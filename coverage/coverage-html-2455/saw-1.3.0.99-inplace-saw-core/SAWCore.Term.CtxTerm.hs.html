<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- |
<span class="lineno">    2 </span>Module      : SAWCore.Term.CtxTerm
<span class="lineno">    3 </span>Copyright   : Galois, Inc. 2018
<span class="lineno">    4 </span>License     : BSD3
<span class="lineno">    5 </span>Stability   : experimental
<span class="lineno">    6 </span>Portability : non-portable (language extensions)
<span class="lineno">    7 </span>-}
<span class="lineno">    8 </span>
<span class="lineno">    9 </span>{-# LANGUAGE FlexibleInstances #-}
<span class="lineno">   10 </span>{-# LANGUAGE GADTs #-}
<span class="lineno">   11 </span>{-# LANGUAGE MultiParamTypeClasses #-}
<span class="lineno">   12 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">   13 </span>{-# LANGUAGE RankNTypes #-}
<span class="lineno">   14 </span>{-# LANGUAGE RecordWildCards #-}
<span class="lineno">   15 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">   16 </span>{-# LANGUAGE UndecidableInstances #-}
<span class="lineno">   17 </span>
<span class="lineno">   18 </span>module SAWCore.Term.CtxTerm
<span class="lineno">   19 </span>  (
<span class="lineno">   20 </span>    -- * Operations on Terms-in-Context
<span class="lineno">   21 </span>    MonadTerm(..)
<span class="lineno">   22 </span>  , ctxLambda, ctxPi, ctxPi1
<span class="lineno">   23 </span>    -- * Constructor Argument Types
<span class="lineno">   24 </span>  , CtorArg(..), CtorArgStruct(..), ctxCtorType
<span class="lineno">   25 </span>    -- * Computing with Eliminators
<span class="lineno">   26 </span>  , mkPRetTp
<span class="lineno">   27 </span>  , ctxCtorElimType, mkCtorElimTypeFun
<span class="lineno">   28 </span>  , ctxReduceRecursor
<span class="lineno">   29 </span>    -- * Parsing and Building Constructor Types
<span class="lineno">   30 </span>  , mkCtorArgStruct
<span class="lineno">   31 </span>  ) where
<span class="lineno">   32 </span>
<span class="lineno">   33 </span>import Control.Monad
<span class="lineno">   34 </span>import Control.Monad.Trans
<span class="lineno">   35 </span>
<span class="lineno">   36 </span>import SAWCore.Name
<span class="lineno">   37 </span>import SAWCore.Recognizer
<span class="lineno">   38 </span>import SAWCore.Term.Functor
<span class="lineno">   39 </span>
<span class="lineno">   40 </span>
<span class="lineno">   41 </span>--
<span class="lineno">   42 </span>-- * Terms In Context
<span class="lineno">   43 </span>--
<span class="lineno">   44 </span>
<span class="lineno">   45 </span>-- | Take a list of terms and match them up with a sequence of bindings,
<span class="lineno">   46 </span>-- returning a structured '[Term]' list.
<span class="lineno">   47 </span>ctxTermsForBindings :: [(LocalName, tp)] -&gt; [Term] -&gt; Maybe [Term]
<span class="lineno">   48 </span><span class="decl"><span class="istickedoff">ctxTermsForBindings bs ts</span>
<span class="lineno">   49 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">length bs == length ts</span> = Just ts</span>
<span class="lineno">   50 </span><span class="spaces">  </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> = <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno">   51 </span>
<span class="lineno">   52 </span>-- | Zip two lists of equal length, but return 'Nothing' if the
<span class="lineno">   53 </span>-- lengths are different.
<span class="lineno">   54 </span>zipSameLength :: [a] -&gt; [b] -&gt; Maybe [(a, b)]
<span class="lineno">   55 </span><span class="decl"><span class="istickedoff">zipSameLength xs ys</span>
<span class="lineno">   56 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">length xs == length ys</span> = Just (zip xs ys)</span>
<span class="lineno">   57 </span><span class="spaces">  </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> = <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno">   58 </span>
<span class="lineno">   59 </span>--
<span class="lineno">   60 </span>-- * Operations on Terms-in-Context
<span class="lineno">   61 </span>--
<span class="lineno">   62 </span>
<span class="lineno">   63 </span>-- | The class of monads that can build terms and substitute into them
<span class="lineno">   64 </span>class Monad m =&gt; MonadTerm m where
<span class="lineno">   65 </span>  mkTermF :: TermF Term -&gt; m Term
<span class="lineno">   66 </span>  liftTerm :: DeBruijnIndex -&gt; DeBruijnIndex -&gt; Term -&gt; m Term
<span class="lineno">   67 </span>  whnfTerm :: Term -&gt; m Term
<span class="lineno">   68 </span>  substTerm :: DeBruijnIndex -&gt; [Term] -&gt; Term -&gt; m Term
<span class="lineno">   69 </span>               -- ^ NOTE: the first term in the list is substituted for the most
<span class="lineno">   70 </span>               -- recently-bound variable, i.e., deBruijn index 0
<span class="lineno">   71 </span>
<span class="lineno">   72 </span>instance (MonadTerm m, MonadTrans t, Monad (t m)) =&gt; MonadTerm (t m) where
<span class="lineno">   73 </span>  <span class="decl"><span class="nottickedoff">mkTermF = lift . mkTermF</span></span>
<span class="lineno">   74 </span>  <span class="decl"><span class="nottickedoff">liftTerm n i t = lift $ liftTerm n i t</span></span>
<span class="lineno">   75 </span>  <span class="decl"><span class="nottickedoff">whnfTerm = lift . whnfTerm</span></span>
<span class="lineno">   76 </span>  <span class="decl"><span class="nottickedoff">substTerm n s t = lift $ substTerm n s t</span></span>
<span class="lineno">   77 </span>
<span class="lineno">   78 </span>-- | Build a 'Term' from a 'FlatTermF' in a 'MonadTerm'
<span class="lineno">   79 </span>mkFlatTermF :: MonadTerm m =&gt; FlatTermF Term -&gt; m Term
<span class="lineno">   80 </span><span class="decl"><span class="istickedoff">mkFlatTermF = mkTermF . FTermF</span></span>
<span class="lineno">   81 </span>
<span class="lineno">   82 </span>-- | Build a free variable as a 'Term'
<span class="lineno">   83 </span>ctxVar :: MonadTerm m =&gt; DeBruijnIndex -&gt; m Term
<span class="lineno">   84 </span><span class="decl"><span class="istickedoff">ctxVar i = mkTermF (LocalVar i)</span></span>
<span class="lineno">   85 </span>
<span class="lineno">   86 </span>-- | Build a list of all the free variables as 'Term's
<span class="lineno">   87 </span>ctxVars :: MonadTerm m =&gt; [(LocalName, tp)] -&gt; m [Term]
<span class="lineno">   88 </span><span class="decl"><span class="istickedoff">ctxVars = helper</span>
<span class="lineno">   89 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">   90 </span><span class="spaces">    </span><span class="istickedoff">helper :: MonadTerm m =&gt; [(LocalName, tp)] -&gt; m [Term]</span>
<span class="lineno">   91 </span><span class="spaces">    </span><span class="istickedoff">helper [] = pure []</span>
<span class="lineno">   92 </span><span class="spaces">    </span><span class="istickedoff">helper (_ : ctx) = (:) &lt;$&gt; ctxVar (length ctx) &lt;*&gt; helper ctx</span></span>
<span class="lineno">   93 </span>
<span class="lineno">   94 </span>-- | Build two lists of the free variables, split at a specific point
<span class="lineno">   95 </span>ctxVars2 :: MonadTerm m =&gt; [(LocalName, tp)] -&gt;
<span class="lineno">   96 </span>            [(LocalName, tp)] -&gt;
<span class="lineno">   97 </span>            m ([Term], [Term])
<span class="lineno">   98 </span><span class="decl"><span class="istickedoff">ctxVars2 vars1 vars2 =</span>
<span class="lineno">   99 </span><span class="spaces">  </span><span class="istickedoff">splitAt (length vars1) &lt;$&gt; ctxVars (vars1 ++ vars2)</span></span>
<span class="lineno">  100 </span>
<span class="lineno">  101 </span>
<span class="lineno">  102 </span>-- | Build a 'Term' for a 'Sort'
<span class="lineno">  103 </span>ctxSort :: MonadTerm m =&gt; Sort -&gt; m Term
<span class="lineno">  104 </span><span class="decl"><span class="istickedoff">ctxSort s = mkFlatTermF (Sort s noFlags)</span></span>
<span class="lineno">  105 </span>
<span class="lineno">  106 </span>-- | Apply two 'Term's
<span class="lineno">  107 </span>ctxApply :: MonadTerm m =&gt; m Term -&gt; m Term -&gt; m Term
<span class="lineno">  108 </span><span class="decl"><span class="istickedoff">ctxApply fm argm =</span>
<span class="lineno">  109 </span><span class="spaces">  </span><span class="istickedoff">do f &lt;- fm</span>
<span class="lineno">  110 </span><span class="spaces">     </span><span class="istickedoff">arg &lt;- argm</span>
<span class="lineno">  111 </span><span class="spaces">     </span><span class="istickedoff">mkTermF (App f arg)</span></span>
<span class="lineno">  112 </span>
<span class="lineno">  113 </span>-- | Apply a 'Term' to a list of arguments
<span class="lineno">  114 </span>ctxApplyMulti :: MonadTerm m =&gt;
<span class="lineno">  115 </span>                 m Term -&gt;
<span class="lineno">  116 </span>                 m [Term] -&gt;
<span class="lineno">  117 </span>                 m Term
<span class="lineno">  118 </span><span class="decl"><span class="istickedoff">ctxApplyMulti fm argsm =</span>
<span class="lineno">  119 </span><span class="spaces">  </span><span class="istickedoff">fm &gt;&gt;= \f -&gt; argsm &gt;&gt;= \args -&gt; helper f args</span>
<span class="lineno">  120 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  121 </span><span class="spaces">    </span><span class="istickedoff">helper :: MonadTerm m =&gt; Term -&gt; [Term] -&gt; m Term</span>
<span class="lineno">  122 </span><span class="spaces">    </span><span class="istickedoff">helper f [] = return f</span>
<span class="lineno">  123 </span><span class="spaces">    </span><span class="istickedoff">helper f (arg : args) =</span>
<span class="lineno">  124 </span><span class="spaces">      </span><span class="istickedoff">do f' &lt;- ctxApply (return f) (return arg)</span>
<span class="lineno">  125 </span><span class="spaces">         </span><span class="istickedoff">helper f' args</span></span>
<span class="lineno">  126 </span>
<span class="lineno">  127 </span>-- | Form a lambda-abstraction as a 'Term'
<span class="lineno">  128 </span>ctxLambda1 :: MonadTerm m =&gt; LocalName -&gt; Term -&gt;
<span class="lineno">  129 </span>              (Term -&gt; m Term) -&gt;
<span class="lineno">  130 </span>              m Term
<span class="lineno">  131 </span><span class="decl"><span class="nottickedoff">ctxLambda1 x tp body_f =</span>
<span class="lineno">  132 </span><span class="spaces">  </span><span class="nottickedoff">do var &lt;- ctxVar 0</span>
<span class="lineno">  133 </span><span class="spaces">     </span><span class="nottickedoff">body &lt;- body_f var</span>
<span class="lineno">  134 </span><span class="spaces">     </span><span class="nottickedoff">mkTermF (Lambda x tp body)</span></span>
<span class="lineno">  135 </span>
<span class="lineno">  136 </span>-- | Form a multi-arity lambda-abstraction as a 'Term'
<span class="lineno">  137 </span>ctxLambda :: MonadTerm m =&gt; [(LocalName, Term)] -&gt;
<span class="lineno">  138 </span>             ([Term] -&gt; m Term) -&gt; m Term
<span class="lineno">  139 </span><span class="decl"><span class="istickedoff">ctxLambda [] body_f = body_f []</span>
<span class="lineno">  140 </span><span class="spaces"></span><span class="istickedoff">ctxLambda ((x, tp) : xs) body_f =</span>
<span class="lineno">  141 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">ctxLambda1 x tp $ \_ -&gt;</span></span>
<span class="lineno">  142 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">ctxLambda xs $ \vars -&gt;</span></span>
<span class="lineno">  143 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">do var &lt;- ctxVar (length xs)</span></span>
<span class="lineno">  144 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">body_f (var : vars)</span></span></span>
<span class="lineno">  145 </span>
<span class="lineno">  146 </span>-- | Form a pi-abstraction as a 'Term'
<span class="lineno">  147 </span>ctxPi1 :: MonadTerm m =&gt; LocalName -&gt; Term -&gt;
<span class="lineno">  148 </span>          (Term -&gt; m Term) -&gt; m Term
<span class="lineno">  149 </span><span class="decl"><span class="istickedoff">ctxPi1 x tp body_f =</span>
<span class="lineno">  150 </span><span class="spaces">  </span><span class="istickedoff">do var &lt;- ctxVar 0</span>
<span class="lineno">  151 </span><span class="spaces">     </span><span class="istickedoff">body &lt;- body_f var</span>
<span class="lineno">  152 </span><span class="spaces">     </span><span class="istickedoff">mkTermF (Pi x tp body)</span></span>
<span class="lineno">  153 </span>
<span class="lineno">  154 </span>-- | Form a multi-arity pi-abstraction as a 'Term'
<span class="lineno">  155 </span>ctxPi :: MonadTerm m =&gt; [(LocalName, Term)] -&gt;
<span class="lineno">  156 </span>         ([Term] -&gt; m Term) -&gt; m Term
<span class="lineno">  157 </span><span class="decl"><span class="istickedoff">ctxPi [] body_f = body_f []</span>
<span class="lineno">  158 </span><span class="spaces"></span><span class="istickedoff">ctxPi ((x, tp) : xs) body_f =</span>
<span class="lineno">  159 </span><span class="spaces">  </span><span class="istickedoff">ctxPi1 x tp $ \_ -&gt;</span>
<span class="lineno">  160 </span><span class="spaces">  </span><span class="istickedoff">ctxPi xs $ \vars -&gt;</span>
<span class="lineno">  161 </span><span class="spaces">  </span><span class="istickedoff">do var &lt;- ctxVar (length xs)</span>
<span class="lineno">  162 </span><span class="spaces">     </span><span class="istickedoff">body_f (var : vars)</span></span>
<span class="lineno">  163 </span>
<span class="lineno">  164 </span>-- | Build an application of a datatype as a 'Term'
<span class="lineno">  165 </span>ctxDataTypeM ::
<span class="lineno">  166 </span>  forall m.
<span class="lineno">  167 </span>  MonadTerm m =&gt;
<span class="lineno">  168 </span>  Name -&gt;
<span class="lineno">  169 </span>  m [Term] -&gt;
<span class="lineno">  170 </span>  m [Term] -&gt;
<span class="lineno">  171 </span>  m Term
<span class="lineno">  172 </span><span class="decl"><span class="istickedoff">ctxDataTypeM d paramsM ixsM =</span>
<span class="lineno">  173 </span><span class="spaces">  </span><span class="istickedoff">ctxApplyMulti (ctxApplyMulti t paramsM) ixsM</span>
<span class="lineno">  174 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  175 </span><span class="spaces">    </span><span class="istickedoff">t :: m Term</span>
<span class="lineno">  176 </span><span class="spaces">    </span><span class="istickedoff">t = mkTermF (Constant d)</span></span>
<span class="lineno">  177 </span>
<span class="lineno">  178 </span>-- | Test if a 'Term' is an application of a specific datatype with the
<span class="lineno">  179 </span>-- supplied context of parameters and indices
<span class="lineno">  180 </span>ctxAsDataTypeApp :: Name -&gt; [(LocalName, tp1)] -&gt;
<span class="lineno">  181 </span>                    [(LocalName, tp2)] -&gt; Term -&gt;
<span class="lineno">  182 </span>                    Maybe ([Term], [Term])
<span class="lineno">  183 </span><span class="decl"><span class="istickedoff">ctxAsDataTypeApp d params ixs t =</span>
<span class="lineno">  184 </span><span class="spaces">  </span><span class="istickedoff">do let (f, args) = asApplyAll t</span>
<span class="lineno">  185 </span><span class="spaces">     </span><span class="istickedoff">d' &lt;- asConstant f</span>
<span class="lineno">  186 </span><span class="spaces">     </span><span class="istickedoff">guard (d == d')</span>
<span class="lineno">  187 </span><span class="spaces">     </span><span class="istickedoff">guard (length args == length params + length ixs)</span>
<span class="lineno">  188 </span><span class="spaces">     </span><span class="istickedoff">let (params', ixs') = splitAt (length params) args</span>
<span class="lineno">  189 </span><span class="spaces">     </span><span class="istickedoff">pure (params', ixs')</span></span>
<span class="lineno">  190 </span>
<span class="lineno">  191 </span>
<span class="lineno">  192 </span>-- | Build an application of a constructor as a 'Term'
<span class="lineno">  193 </span>ctxCtorAppM ::
<span class="lineno">  194 </span>  forall m.
<span class="lineno">  195 </span>  MonadTerm m =&gt;
<span class="lineno">  196 </span>  Name -&gt;
<span class="lineno">  197 </span>  ExtCns Term -&gt;
<span class="lineno">  198 </span>  m [Term] -&gt;
<span class="lineno">  199 </span>  m [Term] -&gt;
<span class="lineno">  200 </span>  m Term
<span class="lineno">  201 </span><span class="decl"><span class="istickedoff">ctxCtorAppM _d c paramsM argsM =</span>
<span class="lineno">  202 </span><span class="spaces">  </span><span class="istickedoff">ctxApplyMulti (ctxApplyMulti t paramsM) argsM</span>
<span class="lineno">  203 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  204 </span><span class="spaces">    </span><span class="istickedoff">t :: m Term</span>
<span class="lineno">  205 </span><span class="spaces">    </span><span class="istickedoff">t = mkTermF (Constant (Name (ecVarIndex c) (ecName c)))</span></span>
<span class="lineno">  206 </span>
<span class="lineno">  207 </span>ctxRecursorAppM :: MonadTerm m =&gt;
<span class="lineno">  208 </span>  m Term -&gt;
<span class="lineno">  209 </span>  m [Term] -&gt;
<span class="lineno">  210 </span>  m Term -&gt;
<span class="lineno">  211 </span>  m Term
<span class="lineno">  212 </span><span class="decl"><span class="istickedoff">ctxRecursorAppM recM ixsM argM =</span>
<span class="lineno">  213 </span><span class="spaces">  </span><span class="istickedoff">do app &lt;- RecursorApp &lt;$&gt; recM &lt;*&gt; ixsM &lt;*&gt; argM</span>
<span class="lineno">  214 </span><span class="spaces">     </span><span class="istickedoff">mkFlatTermF app</span></span>
<span class="lineno">  215 </span>
<span class="lineno">  216 </span>--
<span class="lineno">  217 </span>-- * Generalized Lifting and Substitution
<span class="lineno">  218 </span>--
<span class="lineno">  219 </span>
<span class="lineno">  220 </span>-- | The class of &quot;in-context&quot; types that support lifting and substitution
<span class="lineno">  221 </span>class Monad m =&gt; CtxLiftSubst f m where
<span class="lineno">  222 </span>  -- | Lift an @f@ into an extended context
<span class="lineno">  223 </span>  ctxLift :: DeBruijnIndex -&gt; DeBruijnIndex -&gt; f -&gt; m f
<span class="lineno">  224 </span>  -- | Substitute a list of terms into an @f@
<span class="lineno">  225 </span>  ctxSubst :: [Term] -&gt; DeBruijnIndex -&gt; f -&gt; m f
<span class="lineno">  226 </span>
<span class="lineno">  227 </span>instance MonadTerm m =&gt; CtxLiftSubst Term m where
<span class="lineno">  228 </span>  <span class="decl"><span class="istickedoff">ctxLift i j t = liftTerm i j t</span></span>
<span class="lineno">  229 </span>  <span class="decl"><span class="istickedoff">ctxSubst subst i t =</span>
<span class="lineno">  230 </span><span class="spaces">    </span><span class="istickedoff">-- NOTE: our term lists put the least recently-bound variable first, so we</span>
<span class="lineno">  231 </span><span class="spaces">    </span><span class="istickedoff">-- have to reverse here to call substTerm, which wants the term for the most</span>
<span class="lineno">  232 </span><span class="spaces">    </span><span class="istickedoff">-- recently-bound variable first</span>
<span class="lineno">  233 </span><span class="spaces">    </span><span class="istickedoff">substTerm i (reverse subst) t</span></span>
<span class="lineno">  234 </span>
<span class="lineno">  235 </span>instance MonadTerm m =&gt; CtxLiftSubst [Term] m where
<span class="lineno">  236 </span>  <span class="decl"><span class="istickedoff">ctxLift i j ts = traverse (ctxLift i j) ts</span></span>
<span class="lineno">  237 </span>  <span class="decl"><span class="istickedoff">ctxSubst subst i ts = traverse (ctxSubst subst i) ts</span></span>
<span class="lineno">  238 </span>
<span class="lineno">  239 </span>instance CtxLiftSubst tp m =&gt; CtxLiftSubst [(LocalName, tp)] m where
<span class="lineno">  240 </span>  <span class="decl"><span class="istickedoff">ctxLift _ _ [] = return []</span>
<span class="lineno">  241 </span><span class="spaces">  </span><span class="istickedoff">ctxLift i j ((x, x_tp) : bs) =</span>
<span class="lineno">  242 </span><span class="spaces">    </span><span class="istickedoff">(\t -&gt; (:) (x, t)) &lt;$&gt; ctxLift i j x_tp &lt;*&gt;</span>
<span class="lineno">  243 </span><span class="spaces">    </span><span class="istickedoff">ctxLift (i + 1) j bs</span></span>
<span class="lineno">  244 </span>  <span class="decl"><span class="istickedoff">ctxSubst _ _ [] = return []</span>
<span class="lineno">  245 </span><span class="spaces">  </span><span class="istickedoff">ctxSubst subst i ((x, x_tp) : bs) =</span>
<span class="lineno">  246 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(\t -&gt; (:) (x, t)) &lt;$&gt; ctxSubst subst i x_tp &lt;*&gt;</span></span>
<span class="lineno">  247 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">ctxSubst subst (i + 1) bs</span></span></span>
<span class="lineno">  248 </span>
<span class="lineno">  249 </span>instance MonadTerm m =&gt; CtxLiftSubst CtorArg m where
<span class="lineno">  250 </span>  <span class="decl"><span class="istickedoff">ctxLift i j (ConstArg tp) = ConstArg &lt;$&gt; ctxLift i j tp</span>
<span class="lineno">  251 </span><span class="spaces">  </span><span class="istickedoff">ctxLift i j (RecursiveArg zs ixs) =</span>
<span class="lineno">  252 </span><span class="spaces">    </span><span class="istickedoff">RecursiveArg &lt;$&gt; ctxLift <span class="nottickedoff">i</span> <span class="nottickedoff">j</span> zs &lt;*&gt;</span>
<span class="lineno">  253 </span><span class="spaces">    </span><span class="istickedoff">ctxLift (i + length zs) j ixs</span></span>
<span class="lineno">  254 </span>  <span class="decl"><span class="nottickedoff">ctxSubst subst i (ConstArg tp) = ConstArg &lt;$&gt; ctxSubst subst i tp</span>
<span class="lineno">  255 </span><span class="spaces">  </span><span class="nottickedoff">ctxSubst subst i (RecursiveArg zs ixs) =</span>
<span class="lineno">  256 </span><span class="spaces">    </span><span class="nottickedoff">RecursiveArg &lt;$&gt; ctxSubst subst i zs &lt;*&gt;</span>
<span class="lineno">  257 </span><span class="spaces">    </span><span class="nottickedoff">ctxSubst subst (i + length zs) ixs</span></span>
<span class="lineno">  258 </span>
<span class="lineno">  259 </span>
<span class="lineno">  260 </span>--
<span class="lineno">  261 </span>-- * Constructor Argument Types
<span class="lineno">  262 </span>--
<span class="lineno">  263 </span>
<span class="lineno">  264 </span>-- | A specification of the type of an argument for a constructor of datatype
<span class="lineno">  265 </span>-- @d@, that has a specified list @ixs@ of indices, inside a context @ctx@ of
<span class="lineno">  266 </span>-- parameters and earlier arguments
<span class="lineno">  267 </span>data CtorArg where
<span class="lineno">  268 </span>  -- | A fixed, constant type
<span class="lineno">  269 </span>  ConstArg :: Term -&gt; CtorArg
<span class="lineno">  270 </span>  -- | The construct @'RecursiveArg [(z1,tp1),..,(zn,tpn)] [e1,..,ek]'@
<span class="lineno">  271 </span>  -- specifies a recursive argument type of the form
<span class="lineno">  272 </span>  --
<span class="lineno">  273 </span>  -- &gt; (z1::tp1) -&gt; .. -&gt; (zn::tpn) -&gt; d p1 .. pm e1 .. ek
<span class="lineno">  274 </span>  --
<span class="lineno">  275 </span>  -- where @d@ is the datatype, the @zi::tpi@ are the elements of the Pi
<span class="lineno">  276 </span>  -- context (the first argument to 'RecursiveArgType'), the @pi@ are the
<span class="lineno">  277 </span>  -- parameters of @d@ (not given here), and the @ei@ are the type indices of
<span class="lineno">  278 </span>  -- @d@.
<span class="lineno">  279 </span>  RecursiveArg ::
<span class="lineno">  280 </span>    [(LocalName, Term)] -&gt;
<span class="lineno">  281 </span>    [Term] -&gt;
<span class="lineno">  282 </span>    CtorArg
<span class="lineno">  283 </span>
<span class="lineno">  284 </span>-- | A structure that defines the parameters, arguments, and return type indices
<span class="lineno">  285 </span>-- of a constructor, using 'Term' and friends to get the bindings right
<span class="lineno">  286 </span>data CtorArgStruct =
<span class="lineno">  287 </span>  CtorArgStruct
<span class="lineno">  288 </span>  {
<span class="lineno">  289 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">ctorParams</span></span></span> :: [(LocalName, Term)],
<span class="lineno">  290 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">ctorArgs</span></span></span> :: [(LocalName, CtorArg)],
<span class="lineno">  291 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">ctorIndices</span></span></span> :: [Term],
<span class="lineno">  292 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">dataTypeIndices</span></span></span> :: [(LocalName, Term)]
<span class="lineno">  293 </span>  }
<span class="lineno">  294 </span>
<span class="lineno">  295 </span>
<span class="lineno">  296 </span>-- | Convert a 'CtorArg' into the type that it represents, given a context of
<span class="lineno">  297 </span>-- the parameters and of the previous arguments
<span class="lineno">  298 </span>ctxCtorArgType :: MonadTerm m =&gt; Name -&gt;
<span class="lineno">  299 </span>                  [(LocalName, Term)] -&gt;
<span class="lineno">  300 </span>                  [(LocalName, Term)] -&gt;
<span class="lineno">  301 </span>                  CtorArg -&gt;
<span class="lineno">  302 </span>                  m Term
<span class="lineno">  303 </span><span class="decl"><span class="istickedoff">ctxCtorArgType _ _ _ (ConstArg tp) = return tp</span>
<span class="lineno">  304 </span><span class="spaces"></span><span class="istickedoff">ctxCtorArgType d params prevs (RecursiveArg zs_ctx ixs) =</span>
<span class="lineno">  305 </span><span class="spaces">  </span><span class="istickedoff">ctxPi zs_ctx $ \_ -&gt;</span>
<span class="lineno">  306 </span><span class="spaces">  </span><span class="istickedoff">ctxDataTypeM d ((fst &lt;$&gt; ctxVars2 params prevs) &gt;&gt;= ctxLift <span class="nottickedoff">0</span> (length zs_ctx))</span>
<span class="lineno">  307 </span><span class="spaces">  </span><span class="istickedoff">(return ixs)</span></span>
<span class="lineno">  308 </span>
<span class="lineno">  309 </span>-- | Convert a bindings list of 'CtorArg's to a binding list of types
<span class="lineno">  310 </span>ctxCtorArgBindings :: MonadTerm m =&gt; Name -&gt;
<span class="lineno">  311 </span>                      [(LocalName, Term)] -&gt;
<span class="lineno">  312 </span>                      [(LocalName, Term)] -&gt;
<span class="lineno">  313 </span>                      [(LocalName, CtorArg)] -&gt;
<span class="lineno">  314 </span>                      m [(LocalName, Term)]
<span class="lineno">  315 </span><span class="decl"><span class="istickedoff">ctxCtorArgBindings _ _ _ [] = return []</span>
<span class="lineno">  316 </span><span class="spaces"></span><span class="istickedoff">ctxCtorArgBindings d params prevs ((x, arg) : args) =</span>
<span class="lineno">  317 </span><span class="spaces">  </span><span class="istickedoff">do tp &lt;- ctxCtorArgType d params prevs arg</span>
<span class="lineno">  318 </span><span class="spaces">     </span><span class="istickedoff">rest &lt;- ctxCtorArgBindings d params (prevs ++ [<span class="nottickedoff">(x, tp)</span>]) args</span>
<span class="lineno">  319 </span><span class="spaces">     </span><span class="istickedoff">return ((x, tp) : rest)</span></span>
<span class="lineno">  320 </span>
<span class="lineno">  321 </span>-- | Compute the type of a constructor from the name of its datatype and its
<span class="lineno">  322 </span>-- 'CtorArgStruct'
<span class="lineno">  323 </span>ctxCtorType :: MonadTerm m =&gt; Name -&gt; CtorArgStruct -&gt; m Term
<span class="lineno">  324 </span><span class="decl"><span class="istickedoff">ctxCtorType d (CtorArgStruct{..}) =</span>
<span class="lineno">  325 </span><span class="spaces">  </span><span class="istickedoff">(ctxPi ctorParams $ \params -&gt;</span>
<span class="lineno">  326 </span><span class="spaces">    </span><span class="istickedoff">do bs &lt;-</span>
<span class="lineno">  327 </span><span class="spaces">         </span><span class="istickedoff">ctxCtorArgBindings d ctorParams</span>
<span class="lineno">  328 </span><span class="spaces">         </span><span class="istickedoff">[] ctorArgs</span>
<span class="lineno">  329 </span><span class="spaces">       </span><span class="istickedoff">ctxPi bs $ \_ -&gt;</span>
<span class="lineno">  330 </span><span class="spaces">         </span><span class="istickedoff">ctxDataTypeM d</span>
<span class="lineno">  331 </span><span class="spaces">         </span><span class="istickedoff">(ctxLift 0 (length bs) params)</span>
<span class="lineno">  332 </span><span class="spaces">         </span><span class="istickedoff">(return ctorIndices))</span></span>
<span class="lineno">  333 </span>
<span class="lineno">  334 </span>
<span class="lineno">  335 </span>--
<span class="lineno">  336 </span>-- * Computing with Eliminators
<span class="lineno">  337 </span>--
<span class="lineno">  338 </span>
<span class="lineno">  339 </span>-- | Build the type of the @p_ret@ function, also known as the &quot;motive&quot;
<span class="lineno">  340 </span>-- function, of a recursor on datatype @d@. This type has the form
<span class="lineno">  341 </span>--
<span class="lineno">  342 </span>-- &gt; (i1::ix1) -&gt; .. -&gt; (im::ixm) -&gt; d p1 .. pn i1 .. im -&gt; s
<span class="lineno">  343 </span>--
<span class="lineno">  344 </span>-- where the @pi@ are free variables for the parameters of @d@, the @ixj@
<span class="lineno">  345 </span>-- are the indices of @d@, and @s@ is any sort supplied as an argument.
<span class="lineno">  346 </span>ctxPRetTp :: MonadTerm m =&gt; Name -&gt;
<span class="lineno">  347 </span>             [(LocalName, Term)] -&gt;
<span class="lineno">  348 </span>             [(LocalName, Term)] -&gt; Sort -&gt;
<span class="lineno">  349 </span>             m Term
<span class="lineno">  350 </span><span class="decl"><span class="istickedoff">ctxPRetTp d params ixs s =</span>
<span class="lineno">  351 </span><span class="spaces">  </span><span class="istickedoff">ctxPi ixs $ \ix_vars -&gt;</span>
<span class="lineno">  352 </span><span class="spaces">  </span><span class="istickedoff">do param_vars &lt;- ctxVars params</span>
<span class="lineno">  353 </span><span class="spaces">     </span><span class="istickedoff">dt &lt;- ctxDataTypeM d (ctxLift 0 (length ixs) param_vars)</span>
<span class="lineno">  354 </span><span class="spaces">       </span><span class="istickedoff">(return ix_vars)</span>
<span class="lineno">  355 </span><span class="spaces">     </span><span class="istickedoff">ctxPi1 &quot;_&quot; dt $ \_ -&gt; ctxSort s</span></span>
<span class="lineno">  356 </span>
<span class="lineno">  357 </span>-- | Like 'ctxPRetTp', but also take in a list of parameters and substitute them
<span class="lineno">  358 </span>-- for the parameter variables returned by that function
<span class="lineno">  359 </span>mkPRetTp :: MonadTerm m =&gt;
<span class="lineno">  360 </span>  Name -&gt;
<span class="lineno">  361 </span>  [(LocalName, Term)] -&gt;
<span class="lineno">  362 </span>  [(LocalName, Term)] -&gt;
<span class="lineno">  363 </span>  [Term] -&gt;
<span class="lineno">  364 </span>  Sort -&gt;
<span class="lineno">  365 </span>  m Term
<span class="lineno">  366 </span><span class="decl"><span class="istickedoff">mkPRetTp d untyped_p_ctx untyped_ix_ctx untyped_params s =</span>
<span class="lineno">  367 </span><span class="spaces">  </span><span class="istickedoff">case untyped_p_ctx of</span>
<span class="lineno">  368 </span><span class="spaces">    </span><span class="istickedoff">p_ctx -&gt;</span>
<span class="lineno">  369 </span><span class="spaces">      </span><span class="istickedoff">case (untyped_ix_ctx,</span>
<span class="lineno">  370 </span><span class="spaces">            </span><span class="istickedoff">ctxTermsForBindings p_ctx untyped_params) of</span>
<span class="lineno">  371 </span><span class="spaces">        </span><span class="istickedoff">(ix_ctx, Just params) -&gt;</span>
<span class="lineno">  372 </span><span class="spaces">          </span><span class="istickedoff">do p_ret &lt;- (ctxPRetTp d</span>
<span class="lineno">  373 </span><span class="spaces">                       </span><span class="istickedoff">p_ctx ix_ctx s)</span>
<span class="lineno">  374 </span><span class="spaces">             </span><span class="istickedoff">ctxSubst params 0</span>
<span class="lineno">  375 </span><span class="spaces">               </span><span class="istickedoff">(castPRet <span class="nottickedoff">p_ctx</span> p_ret)</span>
<span class="lineno">  376 </span><span class="spaces">        </span><span class="istickedoff">(_, Nothing) -&gt;</span>
<span class="lineno">  377 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">error &quot;mkPRetTp: incorrect number of parameters&quot;</span></span>
<span class="lineno">  378 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  379 </span><span class="spaces">    </span><span class="istickedoff">castPRet :: [(LocalName, tp)] -&gt; Term -&gt; Term</span>
<span class="lineno">  380 </span><span class="spaces">    </span><span class="istickedoff">castPRet _ctx = id</span></span>
<span class="lineno">  381 </span>
<span class="lineno">  382 </span>
<span class="lineno">  383 </span>-- | Compute the type of an eliminator function for a constructor from the name
<span class="lineno">  384 </span>-- of its datatype, its name, and its 'CtorArgStruct'. This type has, as free
<span class="lineno">  385 </span>-- variables, both the parameters of the datatype and a &quot;motive&quot; function from
<span class="lineno">  386 </span>-- indices of the datatype to a return type. It is of the form
<span class="lineno">  387 </span>--
<span class="lineno">  388 </span>-- &gt; (x1::arg1) -&gt; maybe (rec1::rec_tp1) -&gt; .. -&gt;
<span class="lineno">  389 </span>-- &gt; (xn::argn) -&gt; maybe (recn::rec_tpn) -&gt;
<span class="lineno">  390 </span>-- &gt;   p_ret ix_1 .. ix_k (ctor params x1 .. xn)
<span class="lineno">  391 </span>--
<span class="lineno">  392 </span>-- where the ixs are the type indices of the return type for the constructor,
<span class="lineno">  393 </span>-- the (xi::argi) are the arguments of the constructor, and the @maybe@s
<span class="lineno">  394 </span>-- indicate additional arguments that are present only for arguments of
<span class="lineno">  395 </span>-- recursive type, that is, where @argi@ has the form
<span class="lineno">  396 </span>--
<span class="lineno">  397 </span>-- &gt; (z1::Z1) -&gt; .. -&gt; (zm::Zm) -&gt; d params t1 .. tk
<span class="lineno">  398 </span>--
<span class="lineno">  399 </span>-- In this case, @rec_tpi@ has the form
<span class="lineno">  400 </span>--
<span class="lineno">  401 </span>-- &gt; (z1::Z1) -&gt; .. -&gt; (zm::Zm) -&gt; p_ret t1 .. tk (f z1 .. zm)
<span class="lineno">  402 </span>--
<span class="lineno">  403 </span>-- Note that the output type cannot be expressed in the type of this function,
<span class="lineno">  404 </span>-- since it depends on fields of the 'CtorArgStruct', so, instead, the result is
<span class="lineno">  405 </span>-- just casted to whatever type the caller specifies.
<span class="lineno">  406 </span>ctxCtorElimType :: MonadTerm m =&gt;
<span class="lineno">  407 </span>  Name -&gt;
<span class="lineno">  408 </span>  ExtCns Term -&gt;
<span class="lineno">  409 </span>  CtorArgStruct -&gt;
<span class="lineno">  410 </span>  m Term
<span class="lineno">  411 </span><span class="decl"><span class="istickedoff">ctxCtorElimType d_top c</span>
<span class="lineno">  412 </span><span class="spaces">  </span><span class="istickedoff">(CtorArgStruct{..}) =</span>
<span class="lineno">  413 </span><span class="spaces">  </span><span class="istickedoff">(do let params = ctorParams</span>
<span class="lineno">  414 </span><span class="spaces">      </span><span class="istickedoff">-- NOTE: we use propSort for the type of p_ret just as arbitrary sort, but</span>
<span class="lineno">  415 </span><span class="spaces">      </span><span class="istickedoff">-- it doesn't matter because p_ret_tp is only actually used to form</span>
<span class="lineno">  416 </span><span class="spaces">      </span><span class="istickedoff">-- contexts, and is never actually used directly in the output</span>
<span class="lineno">  417 </span><span class="spaces">      </span><span class="istickedoff">p_ret_tp &lt;- ctxPRetTp d_top params dataTypeIndices propSort</span>
<span class="lineno">  418 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  419 </span><span class="spaces">      </span><span class="istickedoff">-- Lift the argument and return indices into the context of p_ret</span>
<span class="lineno">  420 </span><span class="spaces">      </span><span class="istickedoff">args &lt;- ctxLift 0 1 ctorArgs</span>
<span class="lineno">  421 </span><span class="spaces">      </span><span class="istickedoff">ixs &lt;-</span>
<span class="lineno">  422 </span><span class="spaces">        </span><span class="istickedoff">ctxLift (length ctorArgs) 1</span>
<span class="lineno">  423 </span><span class="spaces">        </span><span class="istickedoff">ctorIndices</span>
<span class="lineno">  424 </span><span class="spaces">      </span><span class="istickedoff">-- Form the context (params ::&gt; p_ret)</span>
<span class="lineno">  425 </span><span class="spaces">      </span><span class="istickedoff">let <span class="nottickedoff">pret = (&quot;_&quot;, p_ret_tp)</span></span>
<span class="lineno">  426 </span><span class="spaces">      </span><span class="istickedoff">-- Call the helper and cast the result to (Typ ret)</span>
<span class="lineno">  427 </span><span class="spaces">      </span><span class="istickedoff">helper d_top params <span class="nottickedoff">pret</span> [] args ixs</span>
<span class="lineno">  428 </span><span class="spaces">  </span><span class="istickedoff">) where</span>
<span class="lineno">  429 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  430 </span><span class="spaces">  </span><span class="istickedoff">-- Iterate through the argument types of the constructor, building up a</span>
<span class="lineno">  431 </span><span class="spaces">  </span><span class="istickedoff">-- function from those arguments to the result type of the p_ret function.</span>
<span class="lineno">  432 </span><span class="spaces">  </span><span class="istickedoff">-- Note that, technically, this function also takes in recursive calls, so has</span>
<span class="lineno">  433 </span><span class="spaces">  </span><span class="istickedoff">-- a slightly richer type, but we are not going to try to compute this richer</span>
<span class="lineno">  434 </span><span class="spaces">  </span><span class="istickedoff">-- type in Haskell land.</span>
<span class="lineno">  435 </span><span class="spaces">  </span><span class="istickedoff">helper :: MonadTerm m =&gt;</span>
<span class="lineno">  436 </span><span class="spaces">    </span><span class="istickedoff">Name -&gt;</span>
<span class="lineno">  437 </span><span class="spaces">    </span><span class="istickedoff">[(LocalName, Term)] -&gt;</span>
<span class="lineno">  438 </span><span class="spaces">    </span><span class="istickedoff">(LocalName, Term) -&gt;</span>
<span class="lineno">  439 </span><span class="spaces">    </span><span class="istickedoff">[(LocalName, Term)] -&gt;</span>
<span class="lineno">  440 </span><span class="spaces">    </span><span class="istickedoff">[(LocalName, CtorArg)] -&gt;</span>
<span class="lineno">  441 </span><span class="spaces">    </span><span class="istickedoff">[Term] -&gt;</span>
<span class="lineno">  442 </span><span class="spaces">    </span><span class="istickedoff">m Term</span>
<span class="lineno">  443 </span><span class="spaces">  </span><span class="istickedoff">helper d params pret prevs [] ret_ixs =</span>
<span class="lineno">  444 </span><span class="spaces">    </span><span class="istickedoff">-- If we are finished with our arguments, construct the final result type</span>
<span class="lineno">  445 </span><span class="spaces">    </span><span class="istickedoff">-- (p_ret ret_ixs (c params prevs))</span>
<span class="lineno">  446 </span><span class="spaces">    </span><span class="istickedoff">do (vars, prev_vars) &lt;- ctxVars2 (params ++ [<span class="nottickedoff">pret</span>]) prevs</span>
<span class="lineno">  447 </span><span class="spaces">       </span><span class="istickedoff">-- note: length vars == length (params ++ [pret])</span>
<span class="lineno">  448 </span><span class="spaces">       </span><span class="istickedoff">let param_terms = init vars</span>
<span class="lineno">  449 </span><span class="spaces">       </span><span class="istickedoff">let p_ret = last vars</span>
<span class="lineno">  450 </span><span class="spaces">       </span><span class="istickedoff">ctxApply (ctxApplyMulti (return p_ret) (return ret_ixs)) $</span>
<span class="lineno">  451 </span><span class="spaces">         </span><span class="istickedoff">ctxCtorAppM <span class="nottickedoff">d</span> c (return param_terms) (return prev_vars)</span>
<span class="lineno">  452 </span><span class="spaces">  </span><span class="istickedoff">helper d params pret prevs ((str, ConstArg tp) : args) ixs =</span>
<span class="lineno">  453 </span><span class="spaces">    </span><span class="istickedoff">-- For a constant argument type, just abstract it and continue</span>
<span class="lineno">  454 </span><span class="spaces">    </span><span class="istickedoff">(ctxPi [(str, tp)] $ \_ -&gt;</span>
<span class="lineno">  455 </span><span class="spaces">      </span><span class="istickedoff">helper d params <span class="nottickedoff">pret</span> (prevs ++ [<span class="nottickedoff">(str, tp)</span>]) args ixs)</span>
<span class="lineno">  456 </span><span class="spaces">  </span><span class="istickedoff">helper d params pret</span>
<span class="lineno">  457 </span><span class="spaces">    </span><span class="istickedoff">prevs ((str, RecursiveArg zs ts) : args) ixs =</span>
<span class="lineno">  458 </span><span class="spaces">    </span><span class="istickedoff">-- For a recursive argument type of the form</span>
<span class="lineno">  459 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno">  460 </span><span class="spaces">    </span><span class="istickedoff">-- (z1::Z1) -&gt; .. -&gt; (zm::Zm) -&gt; d params t1 .. tk</span>
<span class="lineno">  461 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno">  462 </span><span class="spaces">    </span><span class="istickedoff">-- form the type abstraction</span>
<span class="lineno">  463 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno">  464 </span><span class="spaces">    </span><span class="istickedoff">-- (arg:: (z1::Z1) -&gt; .. -&gt; (zm::Zm) -&gt; d params t1 .. tk) -&gt;</span>
<span class="lineno">  465 </span><span class="spaces">    </span><span class="istickedoff">-- (ih :: (z1::Z1) -&gt; .. -&gt; (zm::Zm) -&gt; p_ret t1 .. tk (arg z1 .. zm)) -&gt;</span>
<span class="lineno">  466 </span><span class="spaces">    </span><span class="istickedoff">-- rest</span>
<span class="lineno">  467 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno">  468 </span><span class="spaces">    </span><span class="istickedoff">-- where rest is the result of a recursive call</span>
<span class="lineno">  469 </span><span class="spaces">    </span><span class="istickedoff">do</span>
<span class="lineno">  470 </span><span class="spaces">      </span><span class="istickedoff">-- Build terms for the params and p_ret variables</span>
<span class="lineno">  471 </span><span class="spaces">      </span><span class="istickedoff">vars &lt;- fst &lt;$&gt; ctxVars2 (params ++ [<span class="nottickedoff">pret</span>]) prevs</span>
<span class="lineno">  472 </span><span class="spaces">      </span><span class="istickedoff">-- note: length vars == length (params ++ [pret])</span>
<span class="lineno">  473 </span><span class="spaces">      </span><span class="istickedoff">let param_vars = init vars</span>
<span class="lineno">  474 </span><span class="spaces">      </span><span class="istickedoff">let p_ret = last vars</span>
<span class="lineno">  475 </span><span class="spaces">      </span><span class="istickedoff">-- Build the type of the argument arg</span>
<span class="lineno">  476 </span><span class="spaces">      </span><span class="istickedoff">arg_tp &lt;- ctxPi zs (\_ -&gt; ctxDataTypeM d</span>
<span class="lineno">  477 </span><span class="spaces">                                </span><span class="istickedoff">(ctxLift <span class="nottickedoff">0</span> (length zs) param_vars)</span>
<span class="lineno">  478 </span><span class="spaces">                                </span><span class="istickedoff">(return ts))</span>
<span class="lineno">  479 </span><span class="spaces">      </span><span class="istickedoff">-- Lift zs and ts into the context of arg</span>
<span class="lineno">  480 </span><span class="spaces">      </span><span class="istickedoff">zs' &lt;- ctxLift <span class="nottickedoff">0</span> <span class="nottickedoff">1</span> zs</span>
<span class="lineno">  481 </span><span class="spaces">      </span><span class="istickedoff">ts' &lt;- ctxLift (length zs) 1 ts</span>
<span class="lineno">  482 </span><span class="spaces">      </span><span class="istickedoff">-- Build the pi-abstraction for arg</span>
<span class="lineno">  483 </span><span class="spaces">      </span><span class="istickedoff">ctxPi1 str arg_tp $ \arg -&gt;</span>
<span class="lineno">  484 </span><span class="spaces">        </span><span class="istickedoff">do rest &lt;-</span>
<span class="lineno">  485 </span><span class="spaces">             </span><span class="istickedoff">helper d params <span class="nottickedoff">pret</span> (prevs ++ [<span class="nottickedoff">(str, arg_tp)</span>]) args ixs</span>
<span class="lineno">  486 </span><span class="spaces">           </span><span class="istickedoff">-- Build the type of ih, in the context of arg</span>
<span class="lineno">  487 </span><span class="spaces">           </span><span class="istickedoff">ih_tp &lt;- ctxPi zs' $ \z_vars -&gt;</span>
<span class="lineno">  488 </span><span class="spaces">             </span><span class="istickedoff">ctxApply</span>
<span class="lineno">  489 </span><span class="spaces">             </span><span class="istickedoff">(ctxApplyMulti</span>
<span class="lineno">  490 </span><span class="spaces">              </span><span class="istickedoff">(ctxLift 0 (length zs' + 1) p_ret) (return ts'))</span>
<span class="lineno">  491 </span><span class="spaces">             </span><span class="istickedoff">(ctxApplyMulti (ctxLift <span class="nottickedoff">0</span> (length zs') arg) (return z_vars))</span>
<span class="lineno">  492 </span><span class="spaces">           </span><span class="istickedoff">-- Finally, build the pi-abstraction for ih around the rest</span>
<span class="lineno">  493 </span><span class="spaces">           </span><span class="istickedoff">--</span>
<span class="lineno">  494 </span><span class="spaces">           </span><span class="istickedoff">-- NOTE: we cast away the IH argument, because that is a type that is</span>
<span class="lineno">  495 </span><span class="spaces">           </span><span class="istickedoff">-- computed from the argument structure, and we cannot (well, we</span>
<span class="lineno">  496 </span><span class="spaces">           </span><span class="istickedoff">-- could, but it would be much more work to) express that computation</span>
<span class="lineno">  497 </span><span class="spaces">           </span><span class="istickedoff">-- in the Haskell type system</span>
<span class="lineno">  498 </span><span class="spaces">           </span><span class="istickedoff">(ctxPi1 &quot;_&quot; ih_tp $ \_ -&gt;</span>
<span class="lineno">  499 </span><span class="spaces">               </span><span class="istickedoff">ctxLift 0 1 rest)</span></span>
<span class="lineno">  500 </span>
<span class="lineno">  501 </span>-- | Build a function that substitutes parameters and a @p_ret@ return type
<span class="lineno">  502 </span>-- function into the type of an eliminator, as returned by 'ctxCtorElimType',
<span class="lineno">  503 </span>-- for the given constructor. We return the substitution function in the monad
<span class="lineno">  504 </span>-- so that we only call 'ctxCtorElimType' once but can call the function many
<span class="lineno">  505 </span>-- times, in order to amortize the overhead of 'ctxCtorElimType'.
<span class="lineno">  506 </span>mkCtorElimTypeFun :: MonadTerm m =&gt;
<span class="lineno">  507 </span>  Name {- ^ data type -} -&gt;
<span class="lineno">  508 </span>  ExtCns Term {- ^ constructor type -} -&gt;
<span class="lineno">  509 </span>  CtorArgStruct -&gt;
<span class="lineno">  510 </span>  m ([Term] -&gt; Term -&gt; m Term)
<span class="lineno">  511 </span><span class="decl"><span class="istickedoff">mkCtorElimTypeFun d c argStruct@(CtorArgStruct {..}) =</span>
<span class="lineno">  512 </span><span class="spaces">  </span><span class="istickedoff">do ctxElimType &lt;- ctxCtorElimType d c argStruct</span>
<span class="lineno">  513 </span><span class="spaces">     </span><span class="istickedoff">return $ \params p_ret -&gt;</span>
<span class="lineno">  514 </span><span class="spaces">         </span><span class="istickedoff">whnfTerm =&lt;&lt;</span>
<span class="lineno">  515 </span><span class="spaces">         </span><span class="istickedoff">case ctxTermsForBindings ctorParams params of</span>
<span class="lineno">  516 </span><span class="spaces">           </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">error &quot;ctorElimTypeFun: wrong number of parameters!&quot;</span></span>
<span class="lineno">  517 </span><span class="spaces">           </span><span class="istickedoff">Just paramsCtx -&gt;</span>
<span class="lineno">  518 </span><span class="spaces">             </span><span class="istickedoff">ctxSubst</span>
<span class="lineno">  519 </span><span class="spaces">             </span><span class="istickedoff">(paramsCtx ++ [p_ret])</span>
<span class="lineno">  520 </span><span class="spaces">             </span><span class="istickedoff">0 ctxElimType</span></span>
<span class="lineno">  521 </span>
<span class="lineno">  522 </span>
<span class="lineno">  523 </span>-- | Reduce an application of a recursor to a particular constructor.
<span class="lineno">  524 </span>-- This is known in the Coq literature as an iota reduction. More specifically,
<span class="lineno">  525 </span>-- the call
<span class="lineno">  526 </span>--
<span class="lineno">  527 </span>-- &gt; ctxReduceRecursor rec f_c [x1, .., xk]
<span class="lineno">  528 </span>--
<span class="lineno">  529 </span>-- reduces the term @(RecursorApp rec ixs (CtorApp c ps xs))@ to
<span class="lineno">  530 </span>--
<span class="lineno">  531 </span>-- &gt; f_c x1 (maybe rec_tm_1) .. xk (maybe rec_tm_k)
<span class="lineno">  532 </span>--
<span class="lineno">  533 </span>-- where @f_c@ is the eliminator function associated to the constructor @c@ by the
<span class="lineno">  534 </span>-- recursor value @rec@.  Here @maybe rec_tm_i@ indicates an optional recursive call
<span class="lineno">  535 </span>-- of the recursor on one of the @xi@. These recursive calls only exist for those
<span class="lineno">  536 </span>-- arguments @xi@ that are recursive arguments, i.e., that are specified with
<span class="lineno">  537 </span>-- 'RecursiveArg', and are omitted for non-recursive arguments specified by 'ConstArg'.
<span class="lineno">  538 </span>--
<span class="lineno">  539 </span>-- Specifically, for a @'RecursiveArg' zs ixs@ argument @xi@, which has type
<span class="lineno">  540 </span>-- @\(z1::Z1) -&gt; .. -&gt; d p1 .. pn ix1 .. ixp@, we build the recursive call
<span class="lineno">  541 </span>--
<span class="lineno">  542 </span>-- &gt; \(z1::[xs/args]Z1) -&gt; .. -&gt;
<span class="lineno">  543 </span>-- &gt;   RecursorApp rec [xs/args]ixs (xi z1 ... zn)
<span class="lineno">  544 </span>--
<span class="lineno">  545 </span>-- where @[xs/args]@ substitutes the concrete values for the earlier
<span class="lineno">  546 </span>-- constructor arguments @xs@ for the remaining free variables.
<span class="lineno">  547 </span>
<span class="lineno">  548 </span>ctxReduceRecursor :: forall m.
<span class="lineno">  549 </span>  MonadTerm m =&gt;
<span class="lineno">  550 </span>  Term {- ^ abstracted recursor -} -&gt;
<span class="lineno">  551 </span>  Term {- ^ constructor elimnator function -} -&gt;
<span class="lineno">  552 </span>  [Term] {- ^ constructor arguments -} -&gt;
<span class="lineno">  553 </span>  CtorArgStruct {- ^ constructor formal argument descriptor -} -&gt;
<span class="lineno">  554 </span>  m Term
<span class="lineno">  555 </span><span class="decl"><span class="istickedoff">ctxReduceRecursor rec elimf c_args CtorArgStruct{..} =</span>
<span class="lineno">  556 </span><span class="spaces">  </span><span class="istickedoff">case zipSameLength c_args ctorArgs of</span>
<span class="lineno">  557 </span><span class="spaces">     </span><span class="istickedoff">Just argsCtx_ctorArgs -&gt;</span>
<span class="lineno">  558 </span><span class="spaces">       </span><span class="istickedoff">ctxReduceRecursor_ rec elimf argsCtx_ctorArgs</span>
<span class="lineno">  559 </span><span class="spaces">     </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  560 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">error &quot;ctxReduceRecursorRaw: wrong number of constructor arguments!&quot;</span></span></span>
<span class="lineno">  561 </span>
<span class="lineno">  562 </span>
<span class="lineno">  563 </span>-- | This operation does the real work of building the
<span class="lineno">  564 </span>--   iota reduction for @ctxReduceRecursor@.  We assume
<span class="lineno">  565 </span>--   the input terms we are given live in an ambient
<span class="lineno">  566 </span>--   context @amb@.
<span class="lineno">  567 </span>ctxReduceRecursor_ :: forall m.
<span class="lineno">  568 </span>  MonadTerm m =&gt;
<span class="lineno">  569 </span>  Term     {- ^ recursor value eliminatiting data type d -}-&gt;
<span class="lineno">  570 </span>  Term     {- ^ eliminator function for the constructor -} -&gt;
<span class="lineno">  571 </span>  [(Term, (LocalName, CtorArg))] {- ^ constructor actual arguments plus argument descriptions -} -&gt;
<span class="lineno">  572 </span>  m Term
<span class="lineno">  573 </span><span class="decl"><span class="istickedoff">ctxReduceRecursor_ rec fi args0_argCtx =</span>
<span class="lineno">  574 </span><span class="spaces">  </span><span class="istickedoff">do args &lt;- mk_args [] args0_argCtx</span>
<span class="lineno">  575 </span><span class="spaces">     </span><span class="istickedoff">whnfTerm =&lt;&lt; foldM (\f arg -&gt; mkTermF $ App f arg) fi args</span>
<span class="lineno">  576 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  577 </span><span class="spaces"> </span><span class="istickedoff">where</span>
<span class="lineno">  578 </span><span class="spaces">    </span><span class="istickedoff">mk_args :: [Term] -&gt;  -- already processed parameters/arguments</span>
<span class="lineno">  579 </span><span class="spaces">               </span><span class="istickedoff">[(Term, (LocalName, CtorArg))] -&gt;</span>
<span class="lineno">  580 </span><span class="spaces">                 </span><span class="istickedoff">-- remaining actual arguments to process, with</span>
<span class="lineno">  581 </span><span class="spaces">                 </span><span class="istickedoff">-- telescope for typing the actual arguments</span>
<span class="lineno">  582 </span><span class="spaces">               </span><span class="istickedoff">m [Term]</span>
<span class="lineno">  583 </span><span class="spaces">    </span><span class="istickedoff">-- no more arguments to process</span>
<span class="lineno">  584 </span><span class="spaces">    </span><span class="istickedoff">mk_args _ [] = return []</span>
<span class="lineno">  585 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  586 </span><span class="spaces">    </span><span class="istickedoff">-- process an argument that is not a recursive call</span>
<span class="lineno">  587 </span><span class="spaces">    </span><span class="istickedoff">mk_args pre_xs ((x, (_, ConstArg _)) : xs_args) =</span>
<span class="lineno">  588 </span><span class="spaces">      </span><span class="istickedoff">do tl &lt;- mk_args (pre_xs ++ [x]) xs_args</span>
<span class="lineno">  589 </span><span class="spaces">         </span><span class="istickedoff">pure (x : tl)</span>
<span class="lineno">  590 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  591 </span><span class="spaces">    </span><span class="istickedoff">-- process an argument that is a recursive call</span>
<span class="lineno">  592 </span><span class="spaces">    </span><span class="istickedoff">mk_args pre_xs ((x, (_, RecursiveArg zs ixs)) : xs_args) =</span>
<span class="lineno">  593 </span><span class="spaces">      </span><span class="istickedoff">do zs'  &lt;- ctxSubst <span class="nottickedoff">pre_xs</span> <span class="nottickedoff">0</span> zs</span>
<span class="lineno">  594 </span><span class="spaces">         </span><span class="istickedoff">ixs' &lt;- ctxSubst pre_xs (length zs) ixs</span>
<span class="lineno">  595 </span><span class="spaces">         </span><span class="istickedoff">recx &lt;- mk_rec_arg zs' ixs' x</span>
<span class="lineno">  596 </span><span class="spaces">         </span><span class="istickedoff">tl   &lt;- mk_args (pre_xs ++ [<span class="nottickedoff">x</span>]) xs_args</span>
<span class="lineno">  597 </span><span class="spaces">         </span><span class="istickedoff">pure (x : recx : tl)</span>
<span class="lineno">  598 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  599 </span><span class="spaces">    </span><span class="istickedoff">-- Build an individual recursive call, given the parameters, the bindings</span>
<span class="lineno">  600 </span><span class="spaces">    </span><span class="istickedoff">-- for the RecursiveArg, and the argument we are going to recurse on</span>
<span class="lineno">  601 </span><span class="spaces">    </span><span class="istickedoff">mk_rec_arg ::</span>
<span class="lineno">  602 </span><span class="spaces">      </span><span class="istickedoff">[(LocalName, Term)] -&gt;                -- telescope describing the zs</span>
<span class="lineno">  603 </span><span class="spaces">      </span><span class="istickedoff">[Term] -&gt;                        -- actual values for the indices, shifted under zs</span>
<span class="lineno">  604 </span><span class="spaces">      </span><span class="istickedoff">Term -&gt;                         -- actual value in recursive position</span>
<span class="lineno">  605 </span><span class="spaces">      </span><span class="istickedoff">m Term</span>
<span class="lineno">  606 </span><span class="spaces">    </span><span class="istickedoff">mk_rec_arg zs_ctx ixs x =</span>
<span class="lineno">  607 </span><span class="spaces">      </span><span class="istickedoff">-- eta expand over the zs and apply the RecursorApp form</span>
<span class="lineno">  608 </span><span class="spaces">      </span><span class="istickedoff">ctxLambda zs_ctx (\zs -&gt;</span>
<span class="lineno">  609 </span><span class="spaces">        </span><span class="istickedoff">ctxRecursorAppM</span>
<span class="lineno">  610 </span><span class="spaces">          </span><span class="istickedoff">(ctxLift <span class="nottickedoff">0</span> (length zs_ctx) rec)</span>
<span class="lineno">  611 </span><span class="spaces">          </span><span class="istickedoff">(return ixs)</span>
<span class="lineno">  612 </span><span class="spaces">          </span><span class="istickedoff">(ctxApplyMulti</span>
<span class="lineno">  613 </span><span class="spaces">            </span><span class="istickedoff">(ctxLift <span class="nottickedoff">0</span> (length zs_ctx) x)</span>
<span class="lineno">  614 </span><span class="spaces">            </span><span class="istickedoff">(return zs)))</span></span>
<span class="lineno">  615 </span>
<span class="lineno">  616 </span>
<span class="lineno">  617 </span>--
<span class="lineno">  618 </span>-- * Parsing and Building Constructor Types
<span class="lineno">  619 </span>--
<span class="lineno">  620 </span>
<span class="lineno">  621 </span>-- | Generic method for testing whether a datatype occurs in an object
<span class="lineno">  622 </span>class UsesDataType a where
<span class="lineno">  623 </span>  usesDataType :: Name -&gt; a -&gt; Bool
<span class="lineno">  624 </span>
<span class="lineno">  625 </span>instance UsesDataType (TermF Term) where
<span class="lineno">  626 </span>  <span class="decl"><span class="istickedoff">usesDataType d (Constant d')</span>
<span class="lineno">  627 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">d' == d</span> = <span class="nottickedoff">True</span></span>
<span class="lineno">  628 </span><span class="spaces"></span><span class="istickedoff">--  usesDataType d (FTermF (DataTypeApp d' _ _))</span>
<span class="lineno">  629 </span><span class="spaces"></span><span class="istickedoff">--    | d' == d = True</span>
<span class="lineno">  630 </span><span class="spaces">  </span><span class="istickedoff">usesDataType d (FTermF (RecursorType d' _ _ _))</span>
<span class="lineno">  631 </span><span class="spaces">    </span><span class="istickedoff">| <span class="nottickedoff">d' == d</span> = <span class="nottickedoff">True</span></span>
<span class="lineno">  632 </span><span class="spaces">  </span><span class="istickedoff">usesDataType d (FTermF (Recursor rec))</span>
<span class="lineno">  633 </span><span class="spaces">    </span><span class="istickedoff">| <span class="nottickedoff">recursorDataType rec == d</span> = <span class="nottickedoff">True</span></span>
<span class="lineno">  634 </span><span class="spaces">  </span><span class="istickedoff">usesDataType d tf = any (usesDataType d) tf</span></span>
<span class="lineno">  635 </span>
<span class="lineno">  636 </span>instance UsesDataType Term where
<span class="lineno">  637 </span>  <span class="decl"><span class="istickedoff">usesDataType d = usesDataType d . unwrapTermF</span></span>
<span class="lineno">  638 </span>
<span class="lineno">  639 </span>instance UsesDataType [(LocalName, Term)] where
<span class="lineno">  640 </span>  <span class="decl"><span class="istickedoff">usesDataType _ [] = False</span>
<span class="lineno">  641 </span><span class="spaces">  </span><span class="istickedoff">usesDataType d ((_, tp) : tps) = <span class="nottickedoff">usesDataType d tp || usesDataType d tps</span></span></span>
<span class="lineno">  642 </span>
<span class="lineno">  643 </span>
<span class="lineno">  644 </span>-- | Check that a type is a valid application of datatype @d@ for use in
<span class="lineno">  645 </span>-- specific ways in the type of a constructor for @d@. This requires that this
<span class="lineno">  646 </span>-- application of @d@ be of the form
<span class="lineno">  647 </span>--
<span class="lineno">  648 </span>-- &gt; d p1 .. pn x1 .. xm
<span class="lineno">  649 </span>--
<span class="lineno">  650 </span>-- where the @pi@ are the distinct bound variables bound in the @params@
<span class="lineno">  651 </span>-- context, given as argument, and that the @xj@ have no occurrences of @d@. If
<span class="lineno">  652 </span>-- the given type is of this form, return the @xj@.
<span class="lineno">  653 </span>asCtorDTApp :: Name -&gt; [(LocalName, Term)] -&gt;
<span class="lineno">  654 </span>               [(LocalName, Term)] -&gt;
<span class="lineno">  655 </span>               [(LocalName, tp1)] -&gt;
<span class="lineno">  656 </span>               [(LocalName, tp2)] -&gt;
<span class="lineno">  657 </span>               Term -&gt;
<span class="lineno">  658 </span>               Maybe [Term]
<span class="lineno">  659 </span><span class="decl"><span class="istickedoff">asCtorDTApp d params dt_ixs ctx1 ctx2 (ctxAsDataTypeApp d params dt_ixs -&gt;</span>
<span class="lineno">  660 </span><span class="spaces">                                       </span><span class="istickedoff">Just (param_vars, ixs))</span>
<span class="lineno">  661 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">isVarList params ctx1 ctx2 param_vars &amp;&amp;</span></span>
<span class="lineno">  662 </span><span class="spaces">    </span><span class="istickedoff"><span class="tickonlytrue">not (any (usesDataType d) ixs)</span></span>
<span class="lineno">  663 </span><span class="spaces">  </span><span class="istickedoff">= Just ixs</span>
<span class="lineno">  664 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  665 </span><span class="spaces">    </span><span class="istickedoff">-- Check that the given list of terms is a list of bound variables, one for</span>
<span class="lineno">  666 </span><span class="spaces">    </span><span class="istickedoff">-- each parameter, in the context extended by the given arguments</span>
<span class="lineno">  667 </span><span class="spaces">    </span><span class="istickedoff">isVarList :: [(LocalName, tp1)] -&gt;</span>
<span class="lineno">  668 </span><span class="spaces">                 </span><span class="istickedoff">[(LocalName, tp2)] -&gt;</span>
<span class="lineno">  669 </span><span class="spaces">                 </span><span class="istickedoff">[(LocalName, tp3)] -&gt;</span>
<span class="lineno">  670 </span><span class="spaces">                 </span><span class="istickedoff">[Term] -&gt;</span>
<span class="lineno">  671 </span><span class="spaces">                 </span><span class="istickedoff">Bool</span>
<span class="lineno">  672 </span><span class="spaces">    </span><span class="istickedoff">isVarList _ _ _ [] = True</span>
<span class="lineno">  673 </span><span class="spaces">    </span><span class="istickedoff">isVarList (_ : ps) c1 c2 ((unwrapTermF -&gt; LocalVar i) : ts) =</span>
<span class="lineno">  674 </span><span class="spaces">      </span><span class="istickedoff">i == length ps + length c1 + length c2 &amp;&amp;</span>
<span class="lineno">  675 </span><span class="spaces">      </span><span class="istickedoff">isVarList ps c1 c2 ts</span>
<span class="lineno">  676 </span><span class="spaces">    </span><span class="istickedoff">isVarList _ _ _ _ = <span class="nottickedoff">False</span></span>
<span class="lineno">  677 </span><span class="spaces"></span><span class="istickedoff">asCtorDTApp _ _ _ _ _ _ = Nothing</span></span>
<span class="lineno">  678 </span>
<span class="lineno">  679 </span>
<span class="lineno">  680 </span>-- | Check that an argument for a constructor has one of the allowed forms
<span class="lineno">  681 </span>asCtorArg :: Name -&gt; [(LocalName, Term)] -&gt;
<span class="lineno">  682 </span>             [(LocalName, Term)] -&gt;
<span class="lineno">  683 </span>             [(LocalName, tp)] -&gt;
<span class="lineno">  684 </span>             Term -&gt;
<span class="lineno">  685 </span>             Maybe CtorArg
<span class="lineno">  686 </span><span class="decl"><span class="istickedoff">asCtorArg d params dt_ixs prevs (asPiList -&gt;</span>
<span class="lineno">  687 </span><span class="spaces">                                 </span><span class="istickedoff">(zs,</span>
<span class="lineno">  688 </span><span class="spaces">                                  </span><span class="istickedoff">asCtorDTApp d params dt_ixs prevs zs -&gt;</span>
<span class="lineno">  689 </span><span class="spaces">                                  </span><span class="istickedoff">Just ixs))</span>
<span class="lineno">  690 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">not (usesDataType <span class="nottickedoff">d</span> zs)</span></span>
<span class="lineno">  691 </span><span class="spaces">  </span><span class="istickedoff">= Just (RecursiveArg zs ixs)</span>
<span class="lineno">  692 </span><span class="spaces"></span><span class="istickedoff">asCtorArg d _ _ _ tp</span>
<span class="lineno">  693 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">not (usesDataType d tp)</span></span>
<span class="lineno">  694 </span><span class="spaces">  </span><span class="istickedoff">= Just (ConstArg tp)</span>
<span class="lineno">  695 </span><span class="spaces"></span><span class="istickedoff">asCtorArg _ _ _ _ _ = <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno">  696 </span>
<span class="lineno">  697 </span>-- | Check that a constructor type is a pi-abstraction that takes as input an
<span class="lineno">  698 </span>-- argument of one of the allowed forms described by 'CtorArg'
<span class="lineno">  699 </span>asPiCtorArg :: Name -&gt; [(LocalName, Term)] -&gt;
<span class="lineno">  700 </span>               [(LocalName, Term)] -&gt;
<span class="lineno">  701 </span>               [(LocalName, tp)] -&gt;
<span class="lineno">  702 </span>               Term -&gt;
<span class="lineno">  703 </span>               Maybe (LocalName, CtorArg, Term)
<span class="lineno">  704 </span><span class="decl"><span class="istickedoff">asPiCtorArg d params dt_ixs prevs (asPi -&gt;</span>
<span class="lineno">  705 </span><span class="spaces">                                   </span><span class="istickedoff">Just (x,</span>
<span class="lineno">  706 </span><span class="spaces">                                         </span><span class="istickedoff">asCtorArg d params dt_ixs prevs -&gt;</span>
<span class="lineno">  707 </span><span class="spaces">                                          </span><span class="istickedoff">Just arg, rest)) =</span>
<span class="lineno">  708 </span><span class="spaces">  </span><span class="istickedoff">Just (x, arg, rest)</span>
<span class="lineno">  709 </span><span class="spaces"></span><span class="istickedoff">asPiCtorArg _ _ _ _ _ = Nothing</span></span>
<span class="lineno">  710 </span>
<span class="lineno">  711 </span>-- | Helper function for 'mkCtorArgStruct'
<span class="lineno">  712 </span>mkCtorArgsIxs :: Name -&gt; [(LocalName, Term)] -&gt;
<span class="lineno">  713 </span>                 [(LocalName, Term)] -&gt;
<span class="lineno">  714 </span>                 [(LocalName, CtorArg)] -&gt;
<span class="lineno">  715 </span>                 Term -&gt;
<span class="lineno">  716 </span>                 Maybe ([(LocalName, CtorArg)], [Term])
<span class="lineno">  717 </span><span class="decl"><span class="istickedoff">mkCtorArgsIxs d params dt_ixs prevs (asPiCtorArg d params dt_ixs prevs -&gt;</span>
<span class="lineno">  718 </span><span class="spaces">                                     </span><span class="istickedoff">Just (x, arg, rest)) =</span>
<span class="lineno">  719 </span><span class="spaces">  </span><span class="istickedoff">case mkCtorArgsIxs d params dt_ixs (prevs ++ [<span class="nottickedoff">(x, arg)</span>]) rest of</span>
<span class="lineno">  720 </span><span class="spaces">    </span><span class="istickedoff">Just (args, ixs) -&gt; Just ((x, arg) : args, ixs)</span>
<span class="lineno">  721 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  722 </span><span class="spaces"></span><span class="istickedoff">mkCtorArgsIxs d params dt_ixs prevs (asCtorDTApp d params dt_ixs prevs [] -&gt;</span>
<span class="lineno">  723 </span><span class="spaces">                                     </span><span class="istickedoff">Just ixs) =</span>
<span class="lineno">  724 </span><span class="spaces">  </span><span class="istickedoff">Just ([], ixs)</span>
<span class="lineno">  725 </span><span class="spaces"></span><span class="istickedoff">mkCtorArgsIxs _ _ _ _ _ = <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno">  726 </span>
<span class="lineno">  727 </span>
<span class="lineno">  728 </span>-- | Take in a datatype and bindings lists for its parameters and indices, and
<span class="lineno">  729 </span>-- also a prospective type of a constructor for that datatype, where the
<span class="lineno">  730 </span>-- constructor type is allowed to have the parameters but not the indices free.
<span class="lineno">  731 </span>-- Test that the constructor type is an allowed type for a constructor of this
<span class="lineno">  732 </span>-- datatype, and, if so, build a 'CtorArgStruct' for it.
<span class="lineno">  733 </span>mkCtorArgStruct ::
<span class="lineno">  734 </span>  Name -&gt;
<span class="lineno">  735 </span>  [(LocalName, Term)] -&gt;
<span class="lineno">  736 </span>  [(LocalName, Term)] -&gt;
<span class="lineno">  737 </span>  Term -&gt;
<span class="lineno">  738 </span>  Maybe CtorArgStruct
<span class="lineno">  739 </span><span class="decl"><span class="istickedoff">mkCtorArgStruct d params dt_ixs ctor_tp =</span>
<span class="lineno">  740 </span><span class="spaces">  </span><span class="istickedoff">case mkCtorArgsIxs d params dt_ixs [] ctor_tp of</span>
<span class="lineno">  741 </span><span class="spaces">    </span><span class="istickedoff">Just (args, ctor_ixs) -&gt;</span>
<span class="lineno">  742 </span><span class="spaces">      </span><span class="istickedoff">Just (CtorArgStruct params args ctor_ixs dt_ixs)</span>
<span class="lineno">  743 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">Nothing</span></span></span>

</pre>
</body>
</html>
