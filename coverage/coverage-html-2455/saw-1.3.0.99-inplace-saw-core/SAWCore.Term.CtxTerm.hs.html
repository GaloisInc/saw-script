<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- |
<span class="lineno">    2 </span>Module      : SAWCore.Term.CtxTerm
<span class="lineno">    3 </span>Copyright   : Galois, Inc. 2018
<span class="lineno">    4 </span>License     : BSD3
<span class="lineno">    5 </span>Stability   : experimental
<span class="lineno">    6 </span>Portability : non-portable (language extensions)
<span class="lineno">    7 </span>-}
<span class="lineno">    8 </span>
<span class="lineno">    9 </span>{-# LANGUAGE FlexibleInstances #-}
<span class="lineno">   10 </span>{-# LANGUAGE GADTs #-}
<span class="lineno">   11 </span>{-# LANGUAGE MultiParamTypeClasses #-}
<span class="lineno">   12 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">   13 </span>{-# LANGUAGE RankNTypes #-}
<span class="lineno">   14 </span>{-# LANGUAGE RecordWildCards #-}
<span class="lineno">   15 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">   16 </span>{-# LANGUAGE UndecidableInstances #-}
<span class="lineno">   17 </span>
<span class="lineno">   18 </span>module SAWCore.Term.CtxTerm
<span class="lineno">   19 </span>  (
<span class="lineno">   20 </span>    -- * Contexts and Bindings
<span class="lineno">   21 </span>    bindingsLength, InvBindings(..)
<span class="lineno">   22 </span>  , invAppendBindings, invertBindings
<span class="lineno">   23 </span>    -- * Terms in Context
<span class="lineno">   24 </span>  , ctxTermsForBindings
<span class="lineno">   25 </span>    -- * Operations on Terms-in-Context
<span class="lineno">   26 </span>  , MonadTerm(..)
<span class="lineno">   27 </span>  , ctxLambda, ctxPi, ctxPi1
<span class="lineno">   28 </span>    -- * Generalized Lifting and Substitution
<span class="lineno">   29 </span>  , CtxLiftSubst(..), ctxLiftInBindings
<span class="lineno">   30 </span>  , mkLiftedClosedTerm
<span class="lineno">   31 </span>    -- * Constructor Argument Types
<span class="lineno">   32 </span>  , CtorArg(..), CtorArgStruct(..), ctxCtorArgType, ctxCtorType
<span class="lineno">   33 </span>    -- * Computing with Eliminators
<span class="lineno">   34 </span>  , mkPRetTp
<span class="lineno">   35 </span>  , ctxCtorElimType, mkCtorElimTypeFun
<span class="lineno">   36 </span>  , ctxReduceRecursor
<span class="lineno">   37 </span>    -- * Parsing and Building Constructor Types
<span class="lineno">   38 </span>  , mkCtorArgStruct
<span class="lineno">   39 </span>  ) where
<span class="lineno">   40 </span>
<span class="lineno">   41 </span>import Control.Monad
<span class="lineno">   42 </span>import Control.Monad.Trans
<span class="lineno">   43 </span>
<span class="lineno">   44 </span>import SAWCore.Name
<span class="lineno">   45 </span>import SAWCore.Recognizer
<span class="lineno">   46 </span>import SAWCore.Term.Functor
<span class="lineno">   47 </span>
<span class="lineno">   48 </span>
<span class="lineno">   49 </span>--
<span class="lineno">   50 </span>-- * Contexts and Bindings
<span class="lineno">   51 </span>--
<span class="lineno">   52 </span>
<span class="lineno">   53 </span>-- | Compute the number of bindings in a bindings list
<span class="lineno">   54 </span>bindingsLength :: [(LocalName, tp)] -&gt; Int
<span class="lineno">   55 </span><span class="decl"><span class="istickedoff">bindingsLength = length</span></span>
<span class="lineno">   56 </span>
<span class="lineno">   57 </span>-- | An inverted list of bindings, seen from the &quot;inside out&quot;
<span class="lineno">   58 </span>data InvBindings tp where
<span class="lineno">   59 </span>  InvNoBind :: InvBindings tp
<span class="lineno">   60 </span>  InvBind :: InvBindings tp -&gt; LocalName -&gt; tp -&gt; InvBindings tp
<span class="lineno">   61 </span>
<span class="lineno">   62 </span>-- | Compute the number of bindings in an inverted bindings list
<span class="lineno">   63 </span>invBindingsLength :: InvBindings tp -&gt; Int
<span class="lineno">   64 </span><span class="decl"><span class="istickedoff">invBindingsLength InvNoBind = 0</span>
<span class="lineno">   65 </span><span class="spaces"></span><span class="istickedoff">invBindingsLength (InvBind bs _ _) = 1 + invBindingsLength bs</span></span>
<span class="lineno">   66 </span>
<span class="lineno">   67 </span>-- | Map over all types in an inverted bindings list
<span class="lineno">   68 </span>mapInvBindings :: (f -&gt; g) -&gt; InvBindings f -&gt; InvBindings g
<span class="lineno">   69 </span><span class="decl"><span class="istickedoff">mapInvBindings _ InvNoBind = InvNoBind</span>
<span class="lineno">   70 </span><span class="spaces"></span><span class="istickedoff">mapInvBindings f (InvBind ctx x tp) =</span>
<span class="lineno">   71 </span><span class="spaces">  </span><span class="istickedoff">InvBind (mapInvBindings <span class="nottickedoff">f</span> ctx) <span class="nottickedoff">x</span> <span class="nottickedoff">(f tp)</span></span></span>
<span class="lineno">   72 </span>
<span class="lineno">   73 </span>-- | Append a 'Bindings' list to an inverted 'InvBindings' list, inverting the
<span class="lineno">   74 </span>-- former as we go to yield an inverted 'InvBindings' list. Intuitively, this
<span class="lineno">   75 </span>-- means we are already &quot;inside&quot; the inverted bindings lists, and we are moving
<span class="lineno">   76 </span>-- further &quot;inside&quot; the regular bindings list; at the end we will be &quot;inside&quot;
<span class="lineno">   77 </span>-- both, meaning that we will see the combination &quot;from the inside&quot;.
<span class="lineno">   78 </span>invAppendBindings :: InvBindings tp -&gt;
<span class="lineno">   79 </span>                     [(LocalName, tp)] -&gt;
<span class="lineno">   80 </span>                     InvBindings tp
<span class="lineno">   81 </span><span class="decl"><span class="istickedoff">invAppendBindings as [] = as</span>
<span class="lineno">   82 </span><span class="spaces"></span><span class="istickedoff">invAppendBindings as ((y, y_tp) : bs) =</span>
<span class="lineno">   83 </span><span class="spaces">  </span><span class="istickedoff">(invAppendBindings (InvBind as <span class="nottickedoff">y</span> <span class="nottickedoff">y_tp</span>) bs)</span></span>
<span class="lineno">   84 </span>
<span class="lineno">   85 </span>-- | Invert a 'Bindings' list; i.e., move &quot;inside&quot; those bindings
<span class="lineno">   86 </span>invertBindings :: [(LocalName, tp)] -&gt; InvBindings tp
<span class="lineno">   87 </span><span class="decl"><span class="istickedoff">invertBindings = invAppendBindings InvNoBind</span></span>
<span class="lineno">   88 </span>
<span class="lineno">   89 </span>-- | Append two inverted contexts, where the first one is top-level. This
<span class="lineno">   90 </span>-- restriction allows us to avoid writing a proof of associativity of '(&lt;+&gt;)',
<span class="lineno">   91 </span>-- and instead just using 'ctxAppNilEq'
<span class="lineno">   92 </span>appendTopInvBindings :: InvBindings tp -&gt;
<span class="lineno">   93 </span>                        InvBindings tp -&gt;
<span class="lineno">   94 </span>                        InvBindings tp
<span class="lineno">   95 </span><span class="decl"><span class="istickedoff">appendTopInvBindings ctx1 InvNoBind = ctx1</span>
<span class="lineno">   96 </span><span class="spaces"></span><span class="istickedoff">appendTopInvBindings ctx1 (InvBind ctx2 x tp) =</span>
<span class="lineno">   97 </span><span class="spaces">  </span><span class="istickedoff">let ret = appendTopInvBindings ctx1 ctx2 in</span>
<span class="lineno">   98 </span><span class="spaces">  </span><span class="istickedoff">InvBind ret <span class="nottickedoff">x</span> <span class="nottickedoff">tp</span></span></span>
<span class="lineno">   99 </span>
<span class="lineno">  100 </span>--
<span class="lineno">  101 </span>-- * Terms In Context
<span class="lineno">  102 </span>--
<span class="lineno">  103 </span>
<span class="lineno">  104 </span>-- | Get the head and tail of a non-empty '[Term]' list
<span class="lineno">  105 </span>ctxTermsCtxHeadTail :: [Term] -&gt; ([Term], Term)
<span class="lineno">  106 </span><span class="decl"><span class="istickedoff">ctxTermsCtxHeadTail as = (init as, last as)</span></span>
<span class="lineno">  107 </span>
<span class="lineno">  108 </span>-- | Like 'ctxTermsForBindings' but can return a '[Term]' in an arbitrary
<span class="lineno">  109 </span>-- context. We consider this &quot;unsafe&quot; because it associates an arbitrary context
<span class="lineno">  110 </span>-- with these terms, and so we do not export this function.
<span class="lineno">  111 </span>ctxTermsForBindingsOpen :: [(LocalName, tp)] -&gt; [Term] -&gt; Maybe [Term]
<span class="lineno">  112 </span><span class="decl"><span class="istickedoff">ctxTermsForBindingsOpen [] [] = Just []</span>
<span class="lineno">  113 </span><span class="spaces"></span><span class="istickedoff">ctxTermsForBindingsOpen (_ : bs) (t : ts) =</span>
<span class="lineno">  114 </span><span class="spaces">  </span><span class="istickedoff">(t :) &lt;$&gt; ctxTermsForBindingsOpen bs ts</span>
<span class="lineno">  115 </span><span class="spaces"></span><span class="istickedoff">ctxTermsForBindingsOpen _ _ = <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno">  116 </span>
<span class="lineno">  117 </span>-- | Take a list of terms and match them up with a sequence of bindings,
<span class="lineno">  118 </span>-- returning a structured '[Term]' list. Note that the bindings themselves can
<span class="lineno">  119 </span>-- be in an arbitrary context, but the terms passed in are assumed to be closed,
<span class="lineno">  120 </span>-- i.e., in the empty context.
<span class="lineno">  121 </span>ctxTermsForBindings :: [(LocalName, tp)] -&gt; [Term] -&gt; Maybe [Term]
<span class="lineno">  122 </span><span class="decl"><span class="istickedoff">ctxTermsForBindings [] [] = Just []</span>
<span class="lineno">  123 </span><span class="spaces"></span><span class="istickedoff">ctxTermsForBindings (_ : bs) (t : ts) =</span>
<span class="lineno">  124 </span><span class="spaces">  </span><span class="istickedoff">(t :) &lt;$&gt; ctxTermsForBindings bs ts</span>
<span class="lineno">  125 </span><span class="spaces"></span><span class="istickedoff">ctxTermsForBindings _ _ = <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno">  126 </span>
<span class="lineno">  127 </span>splitCtxTermsCtx :: InvBindings tp -&gt;
<span class="lineno">  128 </span>                    [Term] -&gt;
<span class="lineno">  129 </span>                    ([Term], [Term])
<span class="lineno">  130 </span><span class="decl"><span class="istickedoff">splitCtxTermsCtx ctx terms =</span>
<span class="lineno">  131 </span><span class="spaces">  </span><span class="istickedoff">splitAt (length terms - invBindingsLength ctx) terms</span></span>
<span class="lineno">  132 </span>
<span class="lineno">  133 </span>--
<span class="lineno">  134 </span>-- * Operations on Terms-in-Context
<span class="lineno">  135 </span>--
<span class="lineno">  136 </span>
<span class="lineno">  137 </span>-- | The class of monads that can build terms and substitute into them
<span class="lineno">  138 </span>class Monad m =&gt; MonadTerm m where
<span class="lineno">  139 </span>  mkTermF :: TermF Term -&gt; m Term
<span class="lineno">  140 </span>  liftTerm :: DeBruijnIndex -&gt; DeBruijnIndex -&gt; Term -&gt; m Term
<span class="lineno">  141 </span>  whnfTerm :: Term -&gt; m Term
<span class="lineno">  142 </span>  substTerm :: DeBruijnIndex -&gt; [Term] -&gt; Term -&gt; m Term
<span class="lineno">  143 </span>               -- ^ NOTE: the first term in the list is substituted for the most
<span class="lineno">  144 </span>               -- recently-bound variable, i.e., deBruijn index 0
<span class="lineno">  145 </span>
<span class="lineno">  146 </span>instance (MonadTerm m, MonadTrans t, Monad (t m)) =&gt; MonadTerm (t m) where
<span class="lineno">  147 </span>  <span class="decl"><span class="nottickedoff">mkTermF = lift . mkTermF</span></span>
<span class="lineno">  148 </span>  <span class="decl"><span class="nottickedoff">liftTerm n i t = lift $ liftTerm n i t</span></span>
<span class="lineno">  149 </span>  <span class="decl"><span class="nottickedoff">whnfTerm = lift . whnfTerm</span></span>
<span class="lineno">  150 </span>  <span class="decl"><span class="nottickedoff">substTerm n s t = lift $ substTerm n s t</span></span>
<span class="lineno">  151 </span>
<span class="lineno">  152 </span>-- | Build a 'Term' from a 'FlatTermF' in a 'MonadTerm'
<span class="lineno">  153 </span>mkFlatTermF :: MonadTerm m =&gt; FlatTermF Term -&gt; m Term
<span class="lineno">  154 </span><span class="decl"><span class="istickedoff">mkFlatTermF = mkTermF . FTermF</span></span>
<span class="lineno">  155 </span>
<span class="lineno">  156 </span>-- | Build a free variable as a 'Term'
<span class="lineno">  157 </span>ctxVar :: MonadTerm m =&gt; [(LocalName, tp)] -&gt; m Term
<span class="lineno">  158 </span><span class="decl"><span class="istickedoff">ctxVar ctx = mkTermF (LocalVar $ bindingsLength ctx)</span></span>
<span class="lineno">  159 </span>
<span class="lineno">  160 </span>-- | Build a list of all the free variables as 'Term's
<span class="lineno">  161 </span>ctxVars :: MonadTerm m =&gt; InvBindings tp -&gt; m [Term]
<span class="lineno">  162 </span><span class="decl"><span class="istickedoff">ctxVars ctx_top =</span>
<span class="lineno">  163 </span><span class="spaces">  </span><span class="istickedoff">helper ctx_top []</span>
<span class="lineno">  164 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  165 </span><span class="spaces">        </span><span class="istickedoff">helper :: MonadTerm m =&gt; InvBindings tp -&gt; [(LocalName, tp)] -&gt; m [Term]</span>
<span class="lineno">  166 </span><span class="spaces">        </span><span class="istickedoff">helper InvNoBind _ = return []</span>
<span class="lineno">  167 </span><span class="spaces">        </span><span class="istickedoff">helper (InvBind vars_ctx x tp) ctx =</span>
<span class="lineno">  168 </span><span class="spaces">          </span><span class="istickedoff">snoc &lt;$&gt; helper vars_ctx (<span class="nottickedoff">(x, tp)</span> : ctx) &lt;*&gt; ctxVar ctx</span>
<span class="lineno">  169 </span><span class="spaces">        </span><span class="istickedoff">snoc xs x = xs ++ [x]</span></span>
<span class="lineno">  170 </span>
<span class="lineno">  171 </span>-- | Build two lists of the free variables, split at a specific point
<span class="lineno">  172 </span>--
<span class="lineno">  173 </span>-- FIXME: there should be a nicer way to do this that does not require
<span class="lineno">  174 </span>-- splitCtxTermsCtx and appendTopInvBindings (the latter of which requires
<span class="lineno">  175 </span>-- ctxAppNilEq)
<span class="lineno">  176 </span>ctxVars2 :: MonadTerm m =&gt; InvBindings tp -&gt;
<span class="lineno">  177 </span>            InvBindings tp -&gt;
<span class="lineno">  178 </span>            m ([Term], [Term])
<span class="lineno">  179 </span><span class="decl"><span class="istickedoff">ctxVars2 vars1 vars2 =</span>
<span class="lineno">  180 </span><span class="spaces">  </span><span class="istickedoff">splitCtxTermsCtx vars2 &lt;$&gt; ctxVars (appendTopInvBindings vars1 vars2)</span></span>
<span class="lineno">  181 </span>
<span class="lineno">  182 </span>-- | Build a 'Term' for a 'Sort'
<span class="lineno">  183 </span>ctxSort :: MonadTerm m =&gt; Sort -&gt; m Term
<span class="lineno">  184 </span><span class="decl"><span class="istickedoff">ctxSort s = mkFlatTermF (Sort s noFlags)</span></span>
<span class="lineno">  185 </span>
<span class="lineno">  186 </span>-- | Apply two 'Term's
<span class="lineno">  187 </span>ctxApply :: MonadTerm m =&gt; m Term -&gt; m Term -&gt; m Term
<span class="lineno">  188 </span><span class="decl"><span class="istickedoff">ctxApply fm argm =</span>
<span class="lineno">  189 </span><span class="spaces">  </span><span class="istickedoff">do f &lt;- fm</span>
<span class="lineno">  190 </span><span class="spaces">     </span><span class="istickedoff">arg &lt;- argm</span>
<span class="lineno">  191 </span><span class="spaces">     </span><span class="istickedoff">mkTermF (App f arg)</span></span>
<span class="lineno">  192 </span>
<span class="lineno">  193 </span>-- | Apply a 'Term' to a list of arguments
<span class="lineno">  194 </span>ctxApplyMulti :: MonadTerm m =&gt;
<span class="lineno">  195 </span>                 m Term -&gt;
<span class="lineno">  196 </span>                 m [Term] -&gt;
<span class="lineno">  197 </span>                 m Term
<span class="lineno">  198 </span><span class="decl"><span class="istickedoff">ctxApplyMulti fm argsm =</span>
<span class="lineno">  199 </span><span class="spaces">  </span><span class="istickedoff">fm &gt;&gt;= \f -&gt; argsm &gt;&gt;= \args -&gt; helper f args</span>
<span class="lineno">  200 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  201 </span><span class="spaces">    </span><span class="istickedoff">helper :: MonadTerm m =&gt; Term -&gt; [Term] -&gt; m Term</span>
<span class="lineno">  202 </span><span class="spaces">    </span><span class="istickedoff">helper f [] = return f</span>
<span class="lineno">  203 </span><span class="spaces">    </span><span class="istickedoff">helper f (arg : args) =</span>
<span class="lineno">  204 </span><span class="spaces">      </span><span class="istickedoff">do f' &lt;- ctxApply (return f) (return arg)</span>
<span class="lineno">  205 </span><span class="spaces">         </span><span class="istickedoff">helper f' args</span></span>
<span class="lineno">  206 </span>
<span class="lineno">  207 </span>-- | Form a lambda-abstraction as a 'Term'
<span class="lineno">  208 </span>ctxLambda1 :: MonadTerm m =&gt; LocalName -&gt; Term -&gt;
<span class="lineno">  209 </span>              (Term -&gt; m Term) -&gt;
<span class="lineno">  210 </span>              m Term
<span class="lineno">  211 </span><span class="decl"><span class="nottickedoff">ctxLambda1 x tp body_f =</span>
<span class="lineno">  212 </span><span class="spaces">  </span><span class="nottickedoff">do var &lt;- ctxVar []</span>
<span class="lineno">  213 </span><span class="spaces">     </span><span class="nottickedoff">body &lt;- body_f var</span>
<span class="lineno">  214 </span><span class="spaces">     </span><span class="nottickedoff">mkTermF (Lambda x tp body)</span></span>
<span class="lineno">  215 </span>
<span class="lineno">  216 </span>-- | Form a multi-arity lambda-abstraction as a 'Term'
<span class="lineno">  217 </span>ctxLambda :: MonadTerm m =&gt; [(LocalName, Term)] -&gt;
<span class="lineno">  218 </span>             ([Term] -&gt; m Term) -&gt; m Term
<span class="lineno">  219 </span><span class="decl"><span class="istickedoff">ctxLambda [] body_f = body_f []</span>
<span class="lineno">  220 </span><span class="spaces"></span><span class="istickedoff">ctxLambda ((x, tp) : xs) body_f =</span>
<span class="lineno">  221 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">ctxLambda1 x tp $ \_ -&gt;</span></span>
<span class="lineno">  222 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">ctxLambda xs $ \vars -&gt;</span></span>
<span class="lineno">  223 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">do var &lt;- ctxVar xs</span></span>
<span class="lineno">  224 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">body_f (var : vars)</span></span></span>
<span class="lineno">  225 </span>
<span class="lineno">  226 </span>-- | Form a pi-abstraction as a 'Term'
<span class="lineno">  227 </span>ctxPi1 :: MonadTerm m =&gt; LocalName -&gt; Term -&gt;
<span class="lineno">  228 </span>          (Term -&gt; m Term) -&gt; m Term
<span class="lineno">  229 </span><span class="decl"><span class="istickedoff">ctxPi1 x tp body_f =</span>
<span class="lineno">  230 </span><span class="spaces">  </span><span class="istickedoff">do var &lt;- ctxVar []</span>
<span class="lineno">  231 </span><span class="spaces">     </span><span class="istickedoff">body &lt;- body_f var</span>
<span class="lineno">  232 </span><span class="spaces">     </span><span class="istickedoff">mkTermF (Pi x tp body)</span></span>
<span class="lineno">  233 </span>
<span class="lineno">  234 </span>-- | Form a multi-arity pi-abstraction as a 'Term'
<span class="lineno">  235 </span>ctxPi :: MonadTerm m =&gt; [(LocalName, Term)] -&gt;
<span class="lineno">  236 </span>         ([Term] -&gt; m Term) -&gt; m Term
<span class="lineno">  237 </span><span class="decl"><span class="istickedoff">ctxPi [] body_f = body_f []</span>
<span class="lineno">  238 </span><span class="spaces"></span><span class="istickedoff">ctxPi ((x, tp) : xs) body_f =</span>
<span class="lineno">  239 </span><span class="spaces">  </span><span class="istickedoff">ctxPi1 x tp $ \_ -&gt;</span>
<span class="lineno">  240 </span><span class="spaces">  </span><span class="istickedoff">ctxPi xs $ \vars -&gt;</span>
<span class="lineno">  241 </span><span class="spaces">  </span><span class="istickedoff">do var &lt;- ctxVar xs</span>
<span class="lineno">  242 </span><span class="spaces">     </span><span class="istickedoff">body_f (var : vars)</span></span>
<span class="lineno">  243 </span>
<span class="lineno">  244 </span>-- | Build an application of a datatype as a 'Term'
<span class="lineno">  245 </span>ctxDataTypeM ::
<span class="lineno">  246 </span>  forall m.
<span class="lineno">  247 </span>  MonadTerm m =&gt;
<span class="lineno">  248 </span>  Name -&gt;
<span class="lineno">  249 </span>  m [Term] -&gt;
<span class="lineno">  250 </span>  m [Term] -&gt;
<span class="lineno">  251 </span>  m Term
<span class="lineno">  252 </span><span class="decl"><span class="istickedoff">ctxDataTypeM d paramsM ixsM =</span>
<span class="lineno">  253 </span><span class="spaces">  </span><span class="istickedoff">ctxApplyMulti (ctxApplyMulti t paramsM) ixsM</span>
<span class="lineno">  254 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  255 </span><span class="spaces">    </span><span class="istickedoff">t :: m Term</span>
<span class="lineno">  256 </span><span class="spaces">    </span><span class="istickedoff">t = mkTermF (Constant d)</span></span>
<span class="lineno">  257 </span>
<span class="lineno">  258 </span>-- | Test if a 'Term' is an application of a specific datatype with the
<span class="lineno">  259 </span>-- supplied context of parameters and indices
<span class="lineno">  260 </span>ctxAsDataTypeApp :: Name -&gt; [(LocalName, tp1)] -&gt;
<span class="lineno">  261 </span>                    [(LocalName, tp2)] -&gt; Term -&gt;
<span class="lineno">  262 </span>                    Maybe ([Term], [Term])
<span class="lineno">  263 </span><span class="decl"><span class="istickedoff">ctxAsDataTypeApp d params ixs t =</span>
<span class="lineno">  264 </span><span class="spaces">  </span><span class="istickedoff">do let (f, args) = asApplyAll t</span>
<span class="lineno">  265 </span><span class="spaces">     </span><span class="istickedoff">d' &lt;- asConstant f</span>
<span class="lineno">  266 </span><span class="spaces">     </span><span class="istickedoff">guard (d == d')</span>
<span class="lineno">  267 </span><span class="spaces">     </span><span class="istickedoff">guard (length args == bindingsLength params + bindingsLength ixs)</span>
<span class="lineno">  268 </span><span class="spaces">     </span><span class="istickedoff">let (params', ixs') = splitAt (bindingsLength params) args</span>
<span class="lineno">  269 </span><span class="spaces">     </span><span class="istickedoff">params_ret &lt;- ctxTermsForBindingsOpen params params'</span>
<span class="lineno">  270 </span><span class="spaces">     </span><span class="istickedoff">ixs_ret &lt;- ctxTermsForBindingsOpen ixs ixs'</span>
<span class="lineno">  271 </span><span class="spaces">     </span><span class="istickedoff">pure (params_ret, ixs_ret)</span></span>
<span class="lineno">  272 </span>
<span class="lineno">  273 </span>
<span class="lineno">  274 </span>-- | Build an application of a constructor as a 'Term'
<span class="lineno">  275 </span>ctxCtorAppM ::
<span class="lineno">  276 </span>  forall m.
<span class="lineno">  277 </span>  MonadTerm m =&gt;
<span class="lineno">  278 </span>  Name -&gt;
<span class="lineno">  279 </span>  ExtCns Term -&gt;
<span class="lineno">  280 </span>  m [Term] -&gt;
<span class="lineno">  281 </span>  m [Term] -&gt;
<span class="lineno">  282 </span>  m Term
<span class="lineno">  283 </span><span class="decl"><span class="istickedoff">ctxCtorAppM _d c paramsM argsM =</span>
<span class="lineno">  284 </span><span class="spaces">  </span><span class="istickedoff">ctxApplyMulti (ctxApplyMulti t paramsM) argsM</span>
<span class="lineno">  285 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  286 </span><span class="spaces">    </span><span class="istickedoff">t :: m Term</span>
<span class="lineno">  287 </span><span class="spaces">    </span><span class="istickedoff">t = mkTermF (Constant (Name (ecVarIndex c) (ecName c)))</span></span>
<span class="lineno">  288 </span>
<span class="lineno">  289 </span>ctxRecursorAppM :: MonadTerm m =&gt;
<span class="lineno">  290 </span>  m Term -&gt;
<span class="lineno">  291 </span>  m [Term] -&gt;
<span class="lineno">  292 </span>  m Term -&gt;
<span class="lineno">  293 </span>  m Term
<span class="lineno">  294 </span><span class="decl"><span class="istickedoff">ctxRecursorAppM recM ixsM argM =</span>
<span class="lineno">  295 </span><span class="spaces">  </span><span class="istickedoff">do app &lt;- RecursorApp &lt;$&gt; recM &lt;*&gt; ixsM &lt;*&gt; argM</span>
<span class="lineno">  296 </span><span class="spaces">     </span><span class="istickedoff">mkFlatTermF app</span></span>
<span class="lineno">  297 </span>
<span class="lineno">  298 </span>--
<span class="lineno">  299 </span>-- * Generalized Lifting and Substitution
<span class="lineno">  300 </span>--
<span class="lineno">  301 </span>
<span class="lineno">  302 </span>-- | The class of &quot;in-context&quot; types that support lifting and substitution
<span class="lineno">  303 </span>class Monad m =&gt; CtxLiftSubst f m where
<span class="lineno">  304 </span>  -- | Lift an @f@ into an extended context
<span class="lineno">  305 </span>  ctxLift :: InvBindings tp1 -&gt; [(LocalName, tp2)] -&gt; f -&gt; m f
<span class="lineno">  306 </span>  -- | Substitute a list of terms into an @f@
<span class="lineno">  307 </span>  ctxSubst :: [Term] -&gt; InvBindings tp -&gt; f -&gt; m f
<span class="lineno">  308 </span>
<span class="lineno">  309 </span>-- | Lift an @f@ that is in an extended list of 'Bindings'
<span class="lineno">  310 </span>ctxLiftInBindings :: CtxLiftSubst f m =&gt; InvBindings tp1 -&gt;
<span class="lineno">  311 </span>                     [(LocalName, tp2)] -&gt;
<span class="lineno">  312 </span>                     [(LocalName, tp3)] -&gt;
<span class="lineno">  313 </span>                     f -&gt; m f
<span class="lineno">  314 </span><span class="decl"><span class="istickedoff">ctxLiftInBindings = helper . mapInvBindings <span class="nottickedoff">(Left)</span></span>
<span class="lineno">  315 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  316 </span><span class="spaces">    </span><span class="istickedoff">helper :: CtxLiftSubst f m =&gt; InvBindings (Either tp1 tp2) -&gt;</span>
<span class="lineno">  317 </span><span class="spaces">              </span><span class="istickedoff">[(LocalName, tp2)] -&gt;</span>
<span class="lineno">  318 </span><span class="spaces">              </span><span class="istickedoff">[(LocalName, tp3)] -&gt;</span>
<span class="lineno">  319 </span><span class="spaces">              </span><span class="istickedoff">f -&gt; m f</span>
<span class="lineno">  320 </span><span class="spaces">    </span><span class="istickedoff">helper ctx1 [] as = ctxLift ctx1 as</span>
<span class="lineno">  321 </span><span class="spaces">    </span><span class="istickedoff">helper ctx1 ((str, tp) : ctx2) as =</span>
<span class="lineno">  322 </span><span class="spaces">      </span><span class="istickedoff">helper (InvBind ctx1 <span class="nottickedoff">str</span> <span class="nottickedoff">(Right tp)</span>) ctx2 as</span></span>
<span class="lineno">  323 </span>
<span class="lineno">  324 </span>-- | Substitute into an @f@ that is in an extended list of 'Bindings'
<span class="lineno">  325 </span>ctxSubstInBindings :: CtxLiftSubst f m =&gt; [Term] -&gt;
<span class="lineno">  326 </span>                      InvBindings tp1 -&gt;
<span class="lineno">  327 </span>                      [(LocalName, tp2)] -&gt;
<span class="lineno">  328 </span>                      f -&gt; m f
<span class="lineno">  329 </span><span class="decl"><span class="istickedoff">ctxSubstInBindings subst =</span>
<span class="lineno">  330 </span><span class="spaces">  </span><span class="istickedoff">helper subst . mapInvBindings <span class="nottickedoff">Left</span> where</span>
<span class="lineno">  331 </span><span class="spaces">  </span><span class="istickedoff">helper :: CtxLiftSubst f m =&gt; [Term] -&gt;</span>
<span class="lineno">  332 </span><span class="spaces">            </span><span class="istickedoff">InvBindings (Either tp1 tp2) -&gt;</span>
<span class="lineno">  333 </span><span class="spaces">            </span><span class="istickedoff">[(LocalName, tp2)] -&gt;</span>
<span class="lineno">  334 </span><span class="spaces">            </span><span class="istickedoff">f -&gt; m f</span>
<span class="lineno">  335 </span><span class="spaces">  </span><span class="istickedoff">helper s ctx2 [] f = ctxSubst s ctx2 f</span>
<span class="lineno">  336 </span><span class="spaces">  </span><span class="istickedoff">helper s ctx2 ((x, tp) : ctx3) f =</span>
<span class="lineno">  337 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">helper s (InvBind ctx2 x (Right tp)) ctx3 f</span></span></span>
<span class="lineno">  338 </span>
<span class="lineno">  339 </span>instance MonadTerm m =&gt; CtxLiftSubst Term m where
<span class="lineno">  340 </span>  <span class="decl"><span class="istickedoff">ctxLift ctx1 ctx2 t =</span>
<span class="lineno">  341 </span><span class="spaces">    </span><span class="istickedoff">liftTerm (invBindingsLength ctx1) (bindingsLength ctx2) t</span></span>
<span class="lineno">  342 </span>  <span class="decl"><span class="istickedoff">ctxSubst subst ctx t =</span>
<span class="lineno">  343 </span><span class="spaces">    </span><span class="istickedoff">-- NOTE: our term lists put the least recently-bound variable first, so we</span>
<span class="lineno">  344 </span><span class="spaces">    </span><span class="istickedoff">-- have to reverse here to call substTerm, which wants the term for the most</span>
<span class="lineno">  345 </span><span class="spaces">    </span><span class="istickedoff">-- recently-bound variable first</span>
<span class="lineno">  346 </span><span class="spaces">    </span><span class="istickedoff">substTerm (invBindingsLength ctx) (reverse subst) t</span></span>
<span class="lineno">  347 </span>
<span class="lineno">  348 </span>instance MonadTerm m =&gt; CtxLiftSubst [Term] m where
<span class="lineno">  349 </span>  <span class="decl"><span class="istickedoff">ctxLift _ _ [] = return []</span>
<span class="lineno">  350 </span><span class="spaces">  </span><span class="istickedoff">ctxLift ctx1 ctx2 (t : ts) =</span>
<span class="lineno">  351 </span><span class="spaces">    </span><span class="istickedoff">(:) &lt;$&gt; ctxLift ctx1 ctx2 t &lt;*&gt; ctxLift ctx1 ctx2 ts</span></span>
<span class="lineno">  352 </span>  <span class="decl"><span class="istickedoff">ctxSubst _ _ [] = return []</span>
<span class="lineno">  353 </span><span class="spaces">  </span><span class="istickedoff">ctxSubst subst ctx (t : ts) =</span>
<span class="lineno">  354 </span><span class="spaces">    </span><span class="istickedoff">(:) &lt;$&gt; ctxSubst subst ctx t &lt;*&gt;</span>
<span class="lineno">  355 </span><span class="spaces">    </span><span class="istickedoff">ctxSubst <span class="nottickedoff">subst</span> <span class="nottickedoff">ctx</span> ts</span></span>
<span class="lineno">  356 </span>
<span class="lineno">  357 </span>instance CtxLiftSubst tp m =&gt; CtxLiftSubst [(LocalName, tp)] m where
<span class="lineno">  358 </span>  <span class="decl"><span class="istickedoff">ctxLift _ _ [] = return []</span>
<span class="lineno">  359 </span><span class="spaces">  </span><span class="istickedoff">ctxLift ctx1 ctx2 ((x, x_tp) : bs) =</span>
<span class="lineno">  360 </span><span class="spaces">    </span><span class="istickedoff">(\t -&gt; (:) (x, t)) &lt;$&gt; ctxLift ctx1 ctx2 x_tp &lt;*&gt;</span>
<span class="lineno">  361 </span><span class="spaces">    </span><span class="istickedoff">ctxLift (InvBind ctx1 <span class="nottickedoff">x</span> <span class="nottickedoff">(error &quot;Unused&quot;)</span>) ctx2 bs</span></span>
<span class="lineno">  362 </span>  <span class="decl"><span class="istickedoff">ctxSubst _ _ [] = return []</span>
<span class="lineno">  363 </span><span class="spaces">  </span><span class="istickedoff">ctxSubst subst ctx ((x, x_tp) : bs) =</span>
<span class="lineno">  364 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(\t -&gt; (:) (x, t)) &lt;$&gt; ctxSubst subst ctx x_tp &lt;*&gt;</span></span>
<span class="lineno">  365 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">ctxSubst subst (InvBind ctx x (error &quot;Unused&quot;)) bs</span></span></span>
<span class="lineno">  366 </span>
<span class="lineno">  367 </span>instance MonadTerm m =&gt; CtxLiftSubst CtorArg m where
<span class="lineno">  368 </span>  <span class="decl"><span class="istickedoff">ctxLift ctx1 ctx2 (ConstArg tp) = ConstArg &lt;$&gt; ctxLift ctx1 ctx2 tp</span>
<span class="lineno">  369 </span><span class="spaces">  </span><span class="istickedoff">ctxLift ctx1 ctx2 (RecursiveArg zs ixs) =</span>
<span class="lineno">  370 </span><span class="spaces">    </span><span class="istickedoff">RecursiveArg &lt;$&gt; ctxLift <span class="nottickedoff">ctx1</span> <span class="nottickedoff">ctx2</span> zs &lt;*&gt;</span>
<span class="lineno">  371 </span><span class="spaces">    </span><span class="istickedoff">ctxLiftInBindings ctx1 zs ctx2 ixs</span></span>
<span class="lineno">  372 </span>  <span class="decl"><span class="nottickedoff">ctxSubst subst ctx (ConstArg tp) = ConstArg &lt;$&gt; ctxSubst subst ctx tp</span>
<span class="lineno">  373 </span><span class="spaces">  </span><span class="nottickedoff">ctxSubst subst ctx (RecursiveArg zs ixs) =</span>
<span class="lineno">  374 </span><span class="spaces">    </span><span class="nottickedoff">RecursiveArg &lt;$&gt; ctxSubst subst ctx zs &lt;*&gt;</span>
<span class="lineno">  375 </span><span class="spaces">    </span><span class="nottickedoff">ctxSubstInBindings subst ctx zs ixs</span></span>
<span class="lineno">  376 </span>
<span class="lineno">  377 </span>-- | Make a closed term and then lift it into a context
<span class="lineno">  378 </span>mkLiftedClosedTerm :: MonadTerm m =&gt; [(LocalName, tp)] -&gt; Term -&gt; m Term
<span class="lineno">  379 </span><span class="decl"><span class="nottickedoff">mkLiftedClosedTerm inners t = ctxLift InvNoBind inners t</span></span>
<span class="lineno">  380 </span>
<span class="lineno">  381 </span>
<span class="lineno">  382 </span>--
<span class="lineno">  383 </span>-- * Constructor Argument Types
<span class="lineno">  384 </span>--
<span class="lineno">  385 </span>
<span class="lineno">  386 </span>-- | A specification of the type of an argument for a constructor of datatype
<span class="lineno">  387 </span>-- @d@, that has a specified list @ixs@ of indices, inside a context @ctx@ of
<span class="lineno">  388 </span>-- parameters and earlier arguments
<span class="lineno">  389 </span>data CtorArg where
<span class="lineno">  390 </span>  -- | A fixed, constant type
<span class="lineno">  391 </span>  ConstArg :: Term -&gt; CtorArg
<span class="lineno">  392 </span>  -- | The construct @'RecursiveArg [(z1,tp1),..,(zn,tpn)] [e1,..,ek]'@
<span class="lineno">  393 </span>  -- specifies a recursive argument type of the form
<span class="lineno">  394 </span>  --
<span class="lineno">  395 </span>  -- &gt; (z1::tp1) -&gt; .. -&gt; (zn::tpn) -&gt; d p1 .. pm e1 .. ek
<span class="lineno">  396 </span>  --
<span class="lineno">  397 </span>  -- where @d@ is the datatype, the @zi::tpi@ are the elements of the Pi
<span class="lineno">  398 </span>  -- context (the first argument to 'RecursiveArgType'), the @pi@ are the
<span class="lineno">  399 </span>  -- parameters of @d@ (not given here), and the @ei@ are the type indices of
<span class="lineno">  400 </span>  -- @d@.
<span class="lineno">  401 </span>  RecursiveArg ::
<span class="lineno">  402 </span>    [(LocalName, Term)] -&gt;
<span class="lineno">  403 </span>    [Term] -&gt;
<span class="lineno">  404 </span>    CtorArg
<span class="lineno">  405 </span>
<span class="lineno">  406 </span>-- | A structure that defines the parameters, arguments, and return type indices
<span class="lineno">  407 </span>-- of a constructor, using 'Term' and friends to get the bindings right
<span class="lineno">  408 </span>data CtorArgStruct =
<span class="lineno">  409 </span>  CtorArgStruct
<span class="lineno">  410 </span>  {
<span class="lineno">  411 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">ctorParams</span></span></span> :: [(LocalName, Term)],
<span class="lineno">  412 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">ctorArgs</span></span></span> :: [(LocalName, CtorArg)],
<span class="lineno">  413 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">ctorIndices</span></span></span> :: [Term],
<span class="lineno">  414 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">dataTypeIndices</span></span></span> :: [(LocalName, Term)]
<span class="lineno">  415 </span>  }
<span class="lineno">  416 </span>
<span class="lineno">  417 </span>
<span class="lineno">  418 </span>-- | Convert a 'CtorArg' into the type that it represents, given a context of
<span class="lineno">  419 </span>-- the parameters and of the previous arguments
<span class="lineno">  420 </span>ctxCtorArgType :: MonadTerm m =&gt; Name -&gt;
<span class="lineno">  421 </span>                  InvBindings Term -&gt;
<span class="lineno">  422 </span>                  InvBindings Term -&gt;
<span class="lineno">  423 </span>                  CtorArg -&gt;
<span class="lineno">  424 </span>                  m Term
<span class="lineno">  425 </span><span class="decl"><span class="istickedoff">ctxCtorArgType _ _ _ (ConstArg tp) = return tp</span>
<span class="lineno">  426 </span><span class="spaces"></span><span class="istickedoff">ctxCtorArgType d params prevs (RecursiveArg zs_ctx ixs) =</span>
<span class="lineno">  427 </span><span class="spaces">  </span><span class="istickedoff">ctxPi zs_ctx $ \_ -&gt;</span>
<span class="lineno">  428 </span><span class="spaces">  </span><span class="istickedoff">ctxDataTypeM d ((fst &lt;$&gt; ctxVars2 params prevs) &gt;&gt;= ctxLift <span class="nottickedoff">InvNoBind</span> zs_ctx)</span>
<span class="lineno">  429 </span><span class="spaces">  </span><span class="istickedoff">(return ixs)</span></span>
<span class="lineno">  430 </span>
<span class="lineno">  431 </span>-- | Convert a bindings list of 'CtorArg's to a binding list of types
<span class="lineno">  432 </span>ctxCtorArgBindings :: MonadTerm m =&gt; Name -&gt;
<span class="lineno">  433 </span>                      InvBindings Term -&gt;
<span class="lineno">  434 </span>                      InvBindings Term -&gt;
<span class="lineno">  435 </span>                      [(LocalName, CtorArg)] -&gt;
<span class="lineno">  436 </span>                      m [(LocalName, Term)]
<span class="lineno">  437 </span><span class="decl"><span class="istickedoff">ctxCtorArgBindings _ _ _ [] = return []</span>
<span class="lineno">  438 </span><span class="spaces"></span><span class="istickedoff">ctxCtorArgBindings d params prevs ((x, arg) : args) =</span>
<span class="lineno">  439 </span><span class="spaces">  </span><span class="istickedoff">do tp &lt;- ctxCtorArgType d params prevs arg</span>
<span class="lineno">  440 </span><span class="spaces">     </span><span class="istickedoff">rest &lt;- ctxCtorArgBindings d params (InvBind prevs <span class="nottickedoff">x</span> <span class="nottickedoff">tp</span>) args</span>
<span class="lineno">  441 </span><span class="spaces">     </span><span class="istickedoff">return ((x, tp) : rest)</span></span>
<span class="lineno">  442 </span>
<span class="lineno">  443 </span>-- | Compute the type of a constructor from the name of its datatype and its
<span class="lineno">  444 </span>-- 'CtorArgStruct'
<span class="lineno">  445 </span>ctxCtorType :: MonadTerm m =&gt; Name -&gt; CtorArgStruct -&gt; m Term
<span class="lineno">  446 </span><span class="decl"><span class="istickedoff">ctxCtorType d (CtorArgStruct{..}) =</span>
<span class="lineno">  447 </span><span class="spaces">  </span><span class="istickedoff">(ctxPi ctorParams $ \params -&gt;</span>
<span class="lineno">  448 </span><span class="spaces">    </span><span class="istickedoff">do bs &lt;-</span>
<span class="lineno">  449 </span><span class="spaces">         </span><span class="istickedoff">ctxCtorArgBindings d (invertBindings ctorParams)</span>
<span class="lineno">  450 </span><span class="spaces">         </span><span class="istickedoff">InvNoBind ctorArgs</span>
<span class="lineno">  451 </span><span class="spaces">       </span><span class="istickedoff">ctxPi bs $ \_ -&gt;</span>
<span class="lineno">  452 </span><span class="spaces">         </span><span class="istickedoff">ctxDataTypeM d</span>
<span class="lineno">  453 </span><span class="spaces">         </span><span class="istickedoff">(ctxLift InvNoBind bs params)</span>
<span class="lineno">  454 </span><span class="spaces">         </span><span class="istickedoff">(return ctorIndices))</span></span>
<span class="lineno">  455 </span>
<span class="lineno">  456 </span>
<span class="lineno">  457 </span>--
<span class="lineno">  458 </span>-- * Computing with Eliminators
<span class="lineno">  459 </span>--
<span class="lineno">  460 </span>
<span class="lineno">  461 </span>-- | Build the type of the @p_ret@ function, also known as the &quot;motive&quot;
<span class="lineno">  462 </span>-- function, of a recursor on datatype @d@. This type has the form
<span class="lineno">  463 </span>--
<span class="lineno">  464 </span>-- &gt; (i1::ix1) -&gt; .. -&gt; (im::ixm) -&gt; d p1 .. pn i1 .. im -&gt; s
<span class="lineno">  465 </span>--
<span class="lineno">  466 </span>-- where the @pi@ are free variables for the parameters of @d@, the @ixj@
<span class="lineno">  467 </span>-- are the indices of @d@, and @s@ is any sort supplied as an argument.
<span class="lineno">  468 </span>ctxPRetTp :: MonadTerm m =&gt; Name -&gt;
<span class="lineno">  469 </span>             InvBindings Term -&gt;
<span class="lineno">  470 </span>             [(LocalName, Term)] -&gt; Sort -&gt;
<span class="lineno">  471 </span>             m Term
<span class="lineno">  472 </span><span class="decl"><span class="istickedoff">ctxPRetTp d params ixs s =</span>
<span class="lineno">  473 </span><span class="spaces">  </span><span class="istickedoff">ctxPi ixs $ \ix_vars -&gt;</span>
<span class="lineno">  474 </span><span class="spaces">  </span><span class="istickedoff">do param_vars &lt;- ctxVars params</span>
<span class="lineno">  475 </span><span class="spaces">     </span><span class="istickedoff">dt &lt;- ctxDataTypeM d (ctxLift InvNoBind ixs param_vars)</span>
<span class="lineno">  476 </span><span class="spaces">       </span><span class="istickedoff">(return ix_vars)</span>
<span class="lineno">  477 </span><span class="spaces">     </span><span class="istickedoff">ctxPi1 &quot;_&quot; dt $ \_ -&gt; ctxSort s</span></span>
<span class="lineno">  478 </span>
<span class="lineno">  479 </span>-- | Like 'ctxPRetTp', but also take in a list of parameters and substitute them
<span class="lineno">  480 </span>-- for the parameter variables returned by that function
<span class="lineno">  481 </span>mkPRetTp :: MonadTerm m =&gt;
<span class="lineno">  482 </span>  Name -&gt;
<span class="lineno">  483 </span>  [(LocalName, Term)] -&gt;
<span class="lineno">  484 </span>  [(LocalName, Term)] -&gt;
<span class="lineno">  485 </span>  [Term] -&gt;
<span class="lineno">  486 </span>  Sort -&gt;
<span class="lineno">  487 </span>  m Term
<span class="lineno">  488 </span><span class="decl"><span class="istickedoff">mkPRetTp d untyped_p_ctx untyped_ix_ctx untyped_params s =</span>
<span class="lineno">  489 </span><span class="spaces">  </span><span class="istickedoff">case untyped_p_ctx of</span>
<span class="lineno">  490 </span><span class="spaces">    </span><span class="istickedoff">p_ctx -&gt;</span>
<span class="lineno">  491 </span><span class="spaces">      </span><span class="istickedoff">case (untyped_ix_ctx,</span>
<span class="lineno">  492 </span><span class="spaces">            </span><span class="istickedoff">ctxTermsForBindings p_ctx untyped_params) of</span>
<span class="lineno">  493 </span><span class="spaces">        </span><span class="istickedoff">(ix_ctx, Just params) -&gt;</span>
<span class="lineno">  494 </span><span class="spaces">          </span><span class="istickedoff">do p_ret &lt;- (ctxPRetTp d</span>
<span class="lineno">  495 </span><span class="spaces">                       </span><span class="istickedoff">(invertBindings p_ctx) ix_ctx s)</span>
<span class="lineno">  496 </span><span class="spaces">             </span><span class="istickedoff">ctxSubst params InvNoBind</span>
<span class="lineno">  497 </span><span class="spaces">               </span><span class="istickedoff">(castPRet <span class="nottickedoff">(invertBindings p_ctx)</span> p_ret)</span>
<span class="lineno">  498 </span><span class="spaces">        </span><span class="istickedoff">(_, Nothing) -&gt;</span>
<span class="lineno">  499 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">error &quot;mkPRetTp: incorrect number of parameters&quot;</span></span>
<span class="lineno">  500 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  501 </span><span class="spaces">    </span><span class="istickedoff">castPRet :: InvBindings tp -&gt; Term -&gt; Term</span>
<span class="lineno">  502 </span><span class="spaces">    </span><span class="istickedoff">castPRet _ctx = id</span></span>
<span class="lineno">  503 </span>
<span class="lineno">  504 </span>
<span class="lineno">  505 </span>-- | Compute the type of an eliminator function for a constructor from the name
<span class="lineno">  506 </span>-- of its datatype, its name, and its 'CtorArgStruct'. This type has, as free
<span class="lineno">  507 </span>-- variables, both the parameters of the datatype and a &quot;motive&quot; function from
<span class="lineno">  508 </span>-- indices of the datatype to a return type. It is of the form
<span class="lineno">  509 </span>--
<span class="lineno">  510 </span>-- &gt; (x1::arg1) -&gt; maybe (rec1::rec_tp1) -&gt; .. -&gt;
<span class="lineno">  511 </span>-- &gt; (xn::argn) -&gt; maybe (recn::rec_tpn) -&gt;
<span class="lineno">  512 </span>-- &gt;   p_ret ix_1 .. ix_k (ctor params x1 .. xn)
<span class="lineno">  513 </span>--
<span class="lineno">  514 </span>-- where the ixs are the type indices of the return type for the constructor,
<span class="lineno">  515 </span>-- the (xi::argi) are the arguments of the constructor, and the @maybe@s
<span class="lineno">  516 </span>-- indicate additional arguments that are present only for arguments of
<span class="lineno">  517 </span>-- recursive type, that is, where @argi@ has the form
<span class="lineno">  518 </span>--
<span class="lineno">  519 </span>-- &gt; (z1::Z1) -&gt; .. -&gt; (zm::Zm) -&gt; d params t1 .. tk
<span class="lineno">  520 </span>--
<span class="lineno">  521 </span>-- In this case, @rec_tpi@ has the form
<span class="lineno">  522 </span>--
<span class="lineno">  523 </span>-- &gt; (z1::Z1) -&gt; .. -&gt; (zm::Zm) -&gt; p_ret t1 .. tk (f z1 .. zm)
<span class="lineno">  524 </span>--
<span class="lineno">  525 </span>-- Note that the output type cannot be expressed in the type of this function,
<span class="lineno">  526 </span>-- since it depends on fields of the 'CtorArgStruct', so, instead, the result is
<span class="lineno">  527 </span>-- just casted to whatever type the caller specifies.
<span class="lineno">  528 </span>ctxCtorElimType :: MonadTerm m =&gt;
<span class="lineno">  529 </span>  Name -&gt;
<span class="lineno">  530 </span>  ExtCns Term -&gt;
<span class="lineno">  531 </span>  CtorArgStruct -&gt;
<span class="lineno">  532 </span>  m Term
<span class="lineno">  533 </span><span class="decl"><span class="istickedoff">ctxCtorElimType d_top c</span>
<span class="lineno">  534 </span><span class="spaces">  </span><span class="istickedoff">(CtorArgStruct{..}) =</span>
<span class="lineno">  535 </span><span class="spaces">  </span><span class="istickedoff">(do let params = invertBindings ctorParams</span>
<span class="lineno">  536 </span><span class="spaces">      </span><span class="istickedoff">-- NOTE: we use propSort for the type of p_ret just as arbitrary sort, but</span>
<span class="lineno">  537 </span><span class="spaces">      </span><span class="istickedoff">-- it doesn't matter because p_ret_tp is only actually used to form</span>
<span class="lineno">  538 </span><span class="spaces">      </span><span class="istickedoff">-- contexts, and is never actually used directly in the output</span>
<span class="lineno">  539 </span><span class="spaces">      </span><span class="istickedoff">p_ret_tp &lt;- ctxPRetTp d_top params dataTypeIndices propSort</span>
<span class="lineno">  540 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  541 </span><span class="spaces">      </span><span class="istickedoff">-- Lift the argument and return indices into the context of p_ret</span>
<span class="lineno">  542 </span><span class="spaces">      </span><span class="istickedoff">args &lt;- ctxLift InvNoBind [<span class="nottickedoff">(&quot;_&quot;, p_ret_tp)</span>] ctorArgs</span>
<span class="lineno">  543 </span><span class="spaces">      </span><span class="istickedoff">ixs &lt;-</span>
<span class="lineno">  544 </span><span class="spaces">        </span><span class="istickedoff">ctxLiftInBindings InvNoBind ctorArgs [<span class="nottickedoff">(&quot;_&quot;, p_ret_tp)</span>]</span>
<span class="lineno">  545 </span><span class="spaces">        </span><span class="istickedoff">ctorIndices</span>
<span class="lineno">  546 </span><span class="spaces">      </span><span class="istickedoff">-- Form the context (params ::&gt; p_ret)</span>
<span class="lineno">  547 </span><span class="spaces">      </span><span class="istickedoff">let params_pret = InvBind params <span class="nottickedoff">&quot;_&quot;</span> <span class="nottickedoff">p_ret_tp</span></span>
<span class="lineno">  548 </span><span class="spaces">      </span><span class="istickedoff">-- Call the helper and cast the result to (Typ ret)</span>
<span class="lineno">  549 </span><span class="spaces">      </span><span class="istickedoff">helper d_top params_pret InvNoBind args ixs</span>
<span class="lineno">  550 </span><span class="spaces">  </span><span class="istickedoff">) where</span>
<span class="lineno">  551 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  552 </span><span class="spaces">  </span><span class="istickedoff">-- Iterate through the argument types of the constructor, building up a</span>
<span class="lineno">  553 </span><span class="spaces">  </span><span class="istickedoff">-- function from those arguments to the result type of the p_ret function.</span>
<span class="lineno">  554 </span><span class="spaces">  </span><span class="istickedoff">-- Note that, technically, this function also takes in recursive calls, so has</span>
<span class="lineno">  555 </span><span class="spaces">  </span><span class="istickedoff">-- a slightly richer type, but we are not going to try to compute this richer</span>
<span class="lineno">  556 </span><span class="spaces">  </span><span class="istickedoff">-- type in Haskell land.</span>
<span class="lineno">  557 </span><span class="spaces">  </span><span class="istickedoff">helper :: MonadTerm m =&gt;</span>
<span class="lineno">  558 </span><span class="spaces">    </span><span class="istickedoff">Name -&gt;</span>
<span class="lineno">  559 </span><span class="spaces">    </span><span class="istickedoff">InvBindings Term -&gt;</span>
<span class="lineno">  560 </span><span class="spaces">    </span><span class="istickedoff">InvBindings Term -&gt;</span>
<span class="lineno">  561 </span><span class="spaces">    </span><span class="istickedoff">[(LocalName, CtorArg)] -&gt;</span>
<span class="lineno">  562 </span><span class="spaces">    </span><span class="istickedoff">[Term] -&gt;</span>
<span class="lineno">  563 </span><span class="spaces">    </span><span class="istickedoff">m Term</span>
<span class="lineno">  564 </span><span class="spaces">  </span><span class="istickedoff">helper d params_pret prevs [] ret_ixs =</span>
<span class="lineno">  565 </span><span class="spaces">    </span><span class="istickedoff">-- If we are finished with our arguments, construct the final result type</span>
<span class="lineno">  566 </span><span class="spaces">    </span><span class="istickedoff">-- (p_ret ret_ixs (c params prevs))</span>
<span class="lineno">  567 </span><span class="spaces">    </span><span class="istickedoff">do (vars, prev_vars) &lt;- ctxVars2 params_pret prevs</span>
<span class="lineno">  568 </span><span class="spaces">       </span><span class="istickedoff">let (param_terms, p_ret) = ctxTermsCtxHeadTail vars</span>
<span class="lineno">  569 </span><span class="spaces">       </span><span class="istickedoff">ctxApply (ctxApplyMulti (return p_ret) (return ret_ixs)) $</span>
<span class="lineno">  570 </span><span class="spaces">         </span><span class="istickedoff">ctxCtorAppM <span class="nottickedoff">d</span> c (return param_terms) (return prev_vars)</span>
<span class="lineno">  571 </span><span class="spaces">  </span><span class="istickedoff">helper d params_pret prevs ((str, ConstArg tp) : args) ixs =</span>
<span class="lineno">  572 </span><span class="spaces">    </span><span class="istickedoff">-- For a constant argument type, just abstract it and continue</span>
<span class="lineno">  573 </span><span class="spaces">    </span><span class="istickedoff">(ctxPi [(str, tp)] $ \_ -&gt;</span>
<span class="lineno">  574 </span><span class="spaces">      </span><span class="istickedoff">helper d params_pret (InvBind prevs <span class="nottickedoff">str</span> <span class="nottickedoff">tp</span>) args ixs)</span>
<span class="lineno">  575 </span><span class="spaces">  </span><span class="istickedoff">helper d params_pret</span>
<span class="lineno">  576 </span><span class="spaces">    </span><span class="istickedoff">prevs ((str, RecursiveArg zs ts) : args) ixs =</span>
<span class="lineno">  577 </span><span class="spaces">    </span><span class="istickedoff">-- For a recursive argument type of the form</span>
<span class="lineno">  578 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno">  579 </span><span class="spaces">    </span><span class="istickedoff">-- (z1::Z1) -&gt; .. -&gt; (zm::Zm) -&gt; d params t1 .. tk</span>
<span class="lineno">  580 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno">  581 </span><span class="spaces">    </span><span class="istickedoff">-- form the type abstraction</span>
<span class="lineno">  582 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno">  583 </span><span class="spaces">    </span><span class="istickedoff">-- (arg:: (z1::Z1) -&gt; .. -&gt; (zm::Zm) -&gt; d params t1 .. tk) -&gt;</span>
<span class="lineno">  584 </span><span class="spaces">    </span><span class="istickedoff">-- (ih :: (z1::Z1) -&gt; .. -&gt; (zm::Zm) -&gt; p_ret t1 .. tk (arg z1 .. zm)) -&gt;</span>
<span class="lineno">  585 </span><span class="spaces">    </span><span class="istickedoff">-- rest</span>
<span class="lineno">  586 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno">  587 </span><span class="spaces">    </span><span class="istickedoff">-- where rest is the result of a recursive call</span>
<span class="lineno">  588 </span><span class="spaces">    </span><span class="istickedoff">do</span>
<span class="lineno">  589 </span><span class="spaces">      </span><span class="istickedoff">-- Build terms for the params and p_ret variables</span>
<span class="lineno">  590 </span><span class="spaces">      </span><span class="istickedoff">(param_vars, p_ret) &lt;-</span>
<span class="lineno">  591 </span><span class="spaces">        </span><span class="istickedoff">ctxTermsCtxHeadTail &lt;$&gt; fst &lt;$&gt; ctxVars2 params_pret prevs</span>
<span class="lineno">  592 </span><span class="spaces">      </span><span class="istickedoff">-- Build the type of the argument arg</span>
<span class="lineno">  593 </span><span class="spaces">      </span><span class="istickedoff">arg_tp &lt;- ctxPi zs (\_ -&gt; ctxDataTypeM d</span>
<span class="lineno">  594 </span><span class="spaces">                                </span><span class="istickedoff">(ctxLift <span class="nottickedoff">InvNoBind</span> zs param_vars)</span>
<span class="lineno">  595 </span><span class="spaces">                                </span><span class="istickedoff">(return ts))</span>
<span class="lineno">  596 </span><span class="spaces">      </span><span class="istickedoff">-- Lift zs and ts into the context of arg</span>
<span class="lineno">  597 </span><span class="spaces">      </span><span class="istickedoff">let arg_ctx = [<span class="nottickedoff">(&quot;_&quot;, arg_tp)</span>]</span>
<span class="lineno">  598 </span><span class="spaces">      </span><span class="istickedoff">zs' &lt;- ctxLift <span class="nottickedoff">InvNoBind</span> <span class="nottickedoff">arg_ctx</span> zs</span>
<span class="lineno">  599 </span><span class="spaces">      </span><span class="istickedoff">ts' &lt;- ctxLiftInBindings InvNoBind zs arg_ctx ts</span>
<span class="lineno">  600 </span><span class="spaces">      </span><span class="istickedoff">-- Build the pi-abstraction for arg</span>
<span class="lineno">  601 </span><span class="spaces">      </span><span class="istickedoff">ctxPi1 str arg_tp $ \arg -&gt;</span>
<span class="lineno">  602 </span><span class="spaces">        </span><span class="istickedoff">do rest &lt;-</span>
<span class="lineno">  603 </span><span class="spaces">             </span><span class="istickedoff">helper d params_pret (InvBind prevs <span class="nottickedoff">str</span> <span class="nottickedoff">arg_tp</span>) args ixs</span>
<span class="lineno">  604 </span><span class="spaces">           </span><span class="istickedoff">-- Build the type of ih, in the context of arg</span>
<span class="lineno">  605 </span><span class="spaces">           </span><span class="istickedoff">ih_tp &lt;- ctxPi zs' $ \z_vars -&gt;</span>
<span class="lineno">  606 </span><span class="spaces">             </span><span class="istickedoff">ctxApply</span>
<span class="lineno">  607 </span><span class="spaces">             </span><span class="istickedoff">(ctxApplyMulti</span>
<span class="lineno">  608 </span><span class="spaces">              </span><span class="istickedoff">(ctxLift InvNoBind (<span class="nottickedoff">(&quot;_&quot;, arg_tp)</span> : zs') p_ret) (return ts'))</span>
<span class="lineno">  609 </span><span class="spaces">             </span><span class="istickedoff">(ctxApplyMulti (ctxLift <span class="nottickedoff">InvNoBind</span> zs' arg) (return z_vars))</span>
<span class="lineno">  610 </span><span class="spaces">           </span><span class="istickedoff">-- Finally, build the pi-abstraction for ih around the rest</span>
<span class="lineno">  611 </span><span class="spaces">           </span><span class="istickedoff">--</span>
<span class="lineno">  612 </span><span class="spaces">           </span><span class="istickedoff">-- NOTE: we cast away the IH argument, because that is a type that is</span>
<span class="lineno">  613 </span><span class="spaces">           </span><span class="istickedoff">-- computed from the argument structure, and we cannot (well, we</span>
<span class="lineno">  614 </span><span class="spaces">           </span><span class="istickedoff">-- could, but it would be much more work to) express that computation</span>
<span class="lineno">  615 </span><span class="spaces">           </span><span class="istickedoff">-- in the Haskell type system</span>
<span class="lineno">  616 </span><span class="spaces">           </span><span class="istickedoff">(ctxPi1 &quot;_&quot; ih_tp $ \_ -&gt;</span>
<span class="lineno">  617 </span><span class="spaces">               </span><span class="istickedoff">ctxLift InvNoBind [<span class="nottickedoff">(&quot;_&quot;, ih_tp)</span>] rest)</span></span>
<span class="lineno">  618 </span>
<span class="lineno">  619 </span>-- | Build a function that substitutes parameters and a @p_ret@ return type
<span class="lineno">  620 </span>-- function into the type of an eliminator, as returned by 'ctxCtorElimType',
<span class="lineno">  621 </span>-- for the given constructor. We return the substitution function in the monad
<span class="lineno">  622 </span>-- so that we only call 'ctxCtorElimType' once but can call the function many
<span class="lineno">  623 </span>-- times, in order to amortize the overhead of 'ctxCtorElimType'.
<span class="lineno">  624 </span>mkCtorElimTypeFun :: MonadTerm m =&gt;
<span class="lineno">  625 </span>  Name {- ^ data type -} -&gt;
<span class="lineno">  626 </span>  ExtCns Term {- ^ constructor type -} -&gt;
<span class="lineno">  627 </span>  CtorArgStruct -&gt;
<span class="lineno">  628 </span>  m ([Term] -&gt; Term -&gt; m Term)
<span class="lineno">  629 </span><span class="decl"><span class="istickedoff">mkCtorElimTypeFun d c argStruct@(CtorArgStruct {..}) =</span>
<span class="lineno">  630 </span><span class="spaces">  </span><span class="istickedoff">do ctxElimType &lt;- ctxCtorElimType d c argStruct</span>
<span class="lineno">  631 </span><span class="spaces">     </span><span class="istickedoff">return $ \params p_ret -&gt;</span>
<span class="lineno">  632 </span><span class="spaces">         </span><span class="istickedoff">whnfTerm =&lt;&lt;</span>
<span class="lineno">  633 </span><span class="spaces">         </span><span class="istickedoff">case ctxTermsForBindings ctorParams params of</span>
<span class="lineno">  634 </span><span class="spaces">           </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">error &quot;ctorElimTypeFun: wrong number of parameters!&quot;</span></span>
<span class="lineno">  635 </span><span class="spaces">           </span><span class="istickedoff">Just paramsCtx -&gt;</span>
<span class="lineno">  636 </span><span class="spaces">             </span><span class="istickedoff">ctxSubstInBindings</span>
<span class="lineno">  637 </span><span class="spaces">             </span><span class="istickedoff">(paramsCtx ++ [p_ret])</span>
<span class="lineno">  638 </span><span class="spaces">             </span><span class="istickedoff">InvNoBind [] ctxElimType</span></span>
<span class="lineno">  639 </span>
<span class="lineno">  640 </span>
<span class="lineno">  641 </span>-- | Reduce an application of a recursor to a particular constructor.
<span class="lineno">  642 </span>-- This is known in the Coq literature as an iota reduction. More specifically,
<span class="lineno">  643 </span>-- the call
<span class="lineno">  644 </span>--
<span class="lineno">  645 </span>-- &gt; ctxReduceRecursor rec f_c [x1, .., xk]
<span class="lineno">  646 </span>--
<span class="lineno">  647 </span>-- reduces the term @(RecursorApp rec ixs (CtorApp c ps xs))@ to
<span class="lineno">  648 </span>--
<span class="lineno">  649 </span>-- &gt; f_c x1 (maybe rec_tm_1) .. xk (maybe rec_tm_k)
<span class="lineno">  650 </span>--
<span class="lineno">  651 </span>-- where @f_c@ is the eliminator function associated to the constructor @c@ by the
<span class="lineno">  652 </span>-- recursor value @rec@.  Here @maybe rec_tm_i@ indicates an optional recursive call
<span class="lineno">  653 </span>-- of the recursor on one of the @xi@. These recursive calls only exist for those
<span class="lineno">  654 </span>-- arguments @xi@ that are recursive arguments, i.e., that are specified with
<span class="lineno">  655 </span>-- 'RecursiveArg', and are omitted for non-recursive arguments specified by 'ConstArg'.
<span class="lineno">  656 </span>--
<span class="lineno">  657 </span>-- Specifically, for a @'RecursiveArg' zs ixs@ argument @xi@, which has type
<span class="lineno">  658 </span>-- @\(z1::Z1) -&gt; .. -&gt; d p1 .. pn ix1 .. ixp@, we build the recursive call
<span class="lineno">  659 </span>--
<span class="lineno">  660 </span>-- &gt; \(z1::[xs/args]Z1) -&gt; .. -&gt;
<span class="lineno">  661 </span>-- &gt;   RecursorApp rec [xs/args]ixs (xi z1 ... zn)
<span class="lineno">  662 </span>--
<span class="lineno">  663 </span>-- where @[xs/args]@ substitutes the concrete values for the earlier
<span class="lineno">  664 </span>-- constructor arguments @xs@ for the remaining free variables.
<span class="lineno">  665 </span>
<span class="lineno">  666 </span>ctxReduceRecursor :: forall m.
<span class="lineno">  667 </span>  MonadTerm m =&gt;
<span class="lineno">  668 </span>  Term {- ^ abstracted recursor -} -&gt;
<span class="lineno">  669 </span>  Term {- ^ constructor elimnator function -} -&gt;
<span class="lineno">  670 </span>  [Term] {- ^ constructor arguments -} -&gt;
<span class="lineno">  671 </span>  CtorArgStruct {- ^ constructor formal argument descriptor -} -&gt;
<span class="lineno">  672 </span>  m Term
<span class="lineno">  673 </span><span class="decl"><span class="istickedoff">ctxReduceRecursor rec elimf c_args CtorArgStruct{..} =</span>
<span class="lineno">  674 </span><span class="spaces">  </span><span class="istickedoff">case ctxTermsForBindingsOpen ctorArgs c_args of</span>
<span class="lineno">  675 </span><span class="spaces">     </span><span class="istickedoff">Just argsCtx -&gt;</span>
<span class="lineno">  676 </span><span class="spaces">       </span><span class="istickedoff">ctxReduceRecursor_ rec elimf argsCtx ctorArgs</span>
<span class="lineno">  677 </span><span class="spaces">     </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  678 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">error &quot;ctxReduceRecursorRaw: wrong number of constructor arguments!&quot;</span></span></span>
<span class="lineno">  679 </span>
<span class="lineno">  680 </span>
<span class="lineno">  681 </span>-- | This operation does the real work of building the
<span class="lineno">  682 </span>--   iota reduction for @ctxReduceRecursor@.  We assume
<span class="lineno">  683 </span>--   the input terms we are given live in an ambient
<span class="lineno">  684 </span>--   context @amb@.
<span class="lineno">  685 </span>ctxReduceRecursor_ :: forall m.
<span class="lineno">  686 </span>  MonadTerm m =&gt;
<span class="lineno">  687 </span>  Term     {- ^ recursor value eliminatiting data type d -}-&gt;
<span class="lineno">  688 </span>  Term     {- ^ eliminator function for the constructor -} -&gt;
<span class="lineno">  689 </span>  [Term]    {- ^ constructor actual arguments -} -&gt;
<span class="lineno">  690 </span>  [(LocalName, CtorArg)]
<span class="lineno">  691 </span>    {- ^ telescope describing the constructor arguments -} -&gt;
<span class="lineno">  692 </span>  m Term
<span class="lineno">  693 </span><span class="decl"><span class="istickedoff">ctxReduceRecursor_ rec fi args0 argCtx =</span>
<span class="lineno">  694 </span><span class="spaces">  </span><span class="istickedoff">do args &lt;- mk_args [] args0 argCtx</span>
<span class="lineno">  695 </span><span class="spaces">     </span><span class="istickedoff">whnfTerm =&lt;&lt; foldM (\f arg -&gt; mkTermF $ App f arg) fi args</span>
<span class="lineno">  696 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  697 </span><span class="spaces"> </span><span class="istickedoff">where</span>
<span class="lineno">  698 </span><span class="spaces">    </span><span class="istickedoff">mk_args :: [Term] -&gt;  -- already processed parameters/arguments</span>
<span class="lineno">  699 </span><span class="spaces">               </span><span class="istickedoff">[Term] -&gt;     -- remaining actual arguments to process</span>
<span class="lineno">  700 </span><span class="spaces">               </span><span class="istickedoff">[(LocalName, CtorArg)] -&gt;</span>
<span class="lineno">  701 </span><span class="spaces">                 </span><span class="istickedoff">-- telescope for typing the actual arguments</span>
<span class="lineno">  702 </span><span class="spaces">               </span><span class="istickedoff">m [Term]</span>
<span class="lineno">  703 </span><span class="spaces">    </span><span class="istickedoff">-- no more arguments to process</span>
<span class="lineno">  704 </span><span class="spaces">    </span><span class="istickedoff">mk_args _ _ [] = return []</span>
<span class="lineno">  705 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  706 </span><span class="spaces">    </span><span class="istickedoff">-- process an argument that is not a recursive call</span>
<span class="lineno">  707 </span><span class="spaces">    </span><span class="istickedoff">mk_args pre_xs (x : xs) ((_, ConstArg _) : args) =</span>
<span class="lineno">  708 </span><span class="spaces">      </span><span class="istickedoff">do tl &lt;- mk_args (pre_xs ++ [x]) xs args</span>
<span class="lineno">  709 </span><span class="spaces">         </span><span class="istickedoff">pure (x : tl)</span>
<span class="lineno">  710 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  711 </span><span class="spaces">    </span><span class="istickedoff">-- process an argument that is a recursive call</span>
<span class="lineno">  712 </span><span class="spaces">    </span><span class="istickedoff">mk_args pre_xs (x : xs) ((_, RecursiveArg zs ixs) : args) =</span>
<span class="lineno">  713 </span><span class="spaces">      </span><span class="istickedoff">do zs'  &lt;- ctxSubstInBindings <span class="nottickedoff">pre_xs</span> <span class="nottickedoff">InvNoBind</span> [] zs</span>
<span class="lineno">  714 </span><span class="spaces">         </span><span class="istickedoff">ixs' &lt;- ctxSubstInBindings pre_xs InvNoBind zs ixs</span>
<span class="lineno">  715 </span><span class="spaces">         </span><span class="istickedoff">recx &lt;- mk_rec_arg zs' ixs' x</span>
<span class="lineno">  716 </span><span class="spaces">         </span><span class="istickedoff">tl   &lt;- mk_args (pre_xs ++ [<span class="nottickedoff">x</span>]) xs args</span>
<span class="lineno">  717 </span><span class="spaces">         </span><span class="istickedoff">pure (x : recx : tl)</span>
<span class="lineno">  718 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  719 </span><span class="spaces">    </span><span class="istickedoff">mk_args _ _ _ = <span class="nottickedoff">error &quot;mk_args: impossible&quot;</span></span>
<span class="lineno">  720 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  721 </span><span class="spaces">    </span><span class="istickedoff">-- Build an individual recursive call, given the parameters, the bindings</span>
<span class="lineno">  722 </span><span class="spaces">    </span><span class="istickedoff">-- for the RecursiveArg, and the argument we are going to recurse on</span>
<span class="lineno">  723 </span><span class="spaces">    </span><span class="istickedoff">mk_rec_arg ::</span>
<span class="lineno">  724 </span><span class="spaces">      </span><span class="istickedoff">[(LocalName, Term)] -&gt;                -- telescope describing the zs</span>
<span class="lineno">  725 </span><span class="spaces">      </span><span class="istickedoff">[Term] -&gt;                        -- actual values for the indices, shifted under zs</span>
<span class="lineno">  726 </span><span class="spaces">      </span><span class="istickedoff">Term -&gt;                         -- actual value in recursive position</span>
<span class="lineno">  727 </span><span class="spaces">      </span><span class="istickedoff">m Term</span>
<span class="lineno">  728 </span><span class="spaces">    </span><span class="istickedoff">mk_rec_arg zs_ctx ixs x =</span>
<span class="lineno">  729 </span><span class="spaces">      </span><span class="istickedoff">-- eta expand over the zs and apply the RecursorApp form</span>
<span class="lineno">  730 </span><span class="spaces">      </span><span class="istickedoff">ctxLambda zs_ctx (\zs -&gt;</span>
<span class="lineno">  731 </span><span class="spaces">        </span><span class="istickedoff">ctxRecursorAppM</span>
<span class="lineno">  732 </span><span class="spaces">          </span><span class="istickedoff">(ctxLift <span class="nottickedoff">InvNoBind</span> zs_ctx rec)</span>
<span class="lineno">  733 </span><span class="spaces">          </span><span class="istickedoff">(return ixs)</span>
<span class="lineno">  734 </span><span class="spaces">          </span><span class="istickedoff">(ctxApplyMulti</span>
<span class="lineno">  735 </span><span class="spaces">            </span><span class="istickedoff">(ctxLift <span class="nottickedoff">InvNoBind</span> zs_ctx x)</span>
<span class="lineno">  736 </span><span class="spaces">            </span><span class="istickedoff">(return zs)))</span></span>
<span class="lineno">  737 </span>
<span class="lineno">  738 </span>
<span class="lineno">  739 </span>--
<span class="lineno">  740 </span>-- * Parsing and Building Constructor Types
<span class="lineno">  741 </span>--
<span class="lineno">  742 </span>
<span class="lineno">  743 </span>-- | Generic method for testing whether a datatype occurs in an object
<span class="lineno">  744 </span>class UsesDataType a where
<span class="lineno">  745 </span>  usesDataType :: Name -&gt; a -&gt; Bool
<span class="lineno">  746 </span>
<span class="lineno">  747 </span>instance UsesDataType (TermF Term) where
<span class="lineno">  748 </span>  <span class="decl"><span class="istickedoff">usesDataType d (Constant d')</span>
<span class="lineno">  749 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">d' == d</span> = <span class="nottickedoff">True</span></span>
<span class="lineno">  750 </span><span class="spaces"></span><span class="istickedoff">--  usesDataType d (FTermF (DataTypeApp d' _ _))</span>
<span class="lineno">  751 </span><span class="spaces"></span><span class="istickedoff">--    | d' == d = True</span>
<span class="lineno">  752 </span><span class="spaces">  </span><span class="istickedoff">usesDataType d (FTermF (RecursorType d' _ _ _))</span>
<span class="lineno">  753 </span><span class="spaces">    </span><span class="istickedoff">| <span class="nottickedoff">d' == d</span> = <span class="nottickedoff">True</span></span>
<span class="lineno">  754 </span><span class="spaces">  </span><span class="istickedoff">usesDataType d (FTermF (Recursor rec))</span>
<span class="lineno">  755 </span><span class="spaces">    </span><span class="istickedoff">| <span class="nottickedoff">recursorDataType rec == d</span> = <span class="nottickedoff">True</span></span>
<span class="lineno">  756 </span><span class="spaces">  </span><span class="istickedoff">usesDataType d tf = any (usesDataType d) tf</span></span>
<span class="lineno">  757 </span>
<span class="lineno">  758 </span>instance UsesDataType Term where
<span class="lineno">  759 </span>  <span class="decl"><span class="istickedoff">usesDataType d = usesDataType d . unwrapTermF</span></span>
<span class="lineno">  760 </span>
<span class="lineno">  761 </span>instance UsesDataType [(LocalName, Term)] where
<span class="lineno">  762 </span>  <span class="decl"><span class="istickedoff">usesDataType _ [] = False</span>
<span class="lineno">  763 </span><span class="spaces">  </span><span class="istickedoff">usesDataType d ((_, tp) : tps) = <span class="nottickedoff">usesDataType d tp || usesDataType d tps</span></span></span>
<span class="lineno">  764 </span>
<span class="lineno">  765 </span>
<span class="lineno">  766 </span>-- | Check that a type is a valid application of datatype @d@ for use in
<span class="lineno">  767 </span>-- specific ways in the type of a constructor for @d@. This requires that this
<span class="lineno">  768 </span>-- application of @d@ be of the form
<span class="lineno">  769 </span>--
<span class="lineno">  770 </span>-- &gt; d p1 .. pn x1 .. xm
<span class="lineno">  771 </span>--
<span class="lineno">  772 </span>-- where the @pi@ are the distinct bound variables bound in the @params@
<span class="lineno">  773 </span>-- context, given as argument, and that the @xj@ have no occurrences of @d@. If
<span class="lineno">  774 </span>-- the given type is of this form, return the @xj@.
<span class="lineno">  775 </span>asCtorDTApp :: Name -&gt; [(LocalName, Term)] -&gt;
<span class="lineno">  776 </span>               [(LocalName, Term)] -&gt;
<span class="lineno">  777 </span>               InvBindings tp1 -&gt;
<span class="lineno">  778 </span>               [(LocalName, tp2)] -&gt;
<span class="lineno">  779 </span>               Term -&gt;
<span class="lineno">  780 </span>               Maybe [Term]
<span class="lineno">  781 </span><span class="decl"><span class="istickedoff">asCtorDTApp d params dt_ixs ctx1 ctx2 (ctxAsDataTypeApp d params dt_ixs -&gt;</span>
<span class="lineno">  782 </span><span class="spaces">                                       </span><span class="istickedoff">Just (param_vars, ixs))</span>
<span class="lineno">  783 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">isVarList params ctx1 ctx2 param_vars &amp;&amp;</span></span>
<span class="lineno">  784 </span><span class="spaces">    </span><span class="istickedoff"><span class="tickonlytrue">not (any (usesDataType d) ixs)</span></span>
<span class="lineno">  785 </span><span class="spaces">  </span><span class="istickedoff">= Just ixs</span>
<span class="lineno">  786 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  787 </span><span class="spaces">    </span><span class="istickedoff">-- Check that the given list of terms is a list of bound variables, one for</span>
<span class="lineno">  788 </span><span class="spaces">    </span><span class="istickedoff">-- each parameter, in the context extended by the given arguments</span>
<span class="lineno">  789 </span><span class="spaces">    </span><span class="istickedoff">isVarList :: [(LocalName, tp1)] -&gt;</span>
<span class="lineno">  790 </span><span class="spaces">                 </span><span class="istickedoff">InvBindings tp2 -&gt;</span>
<span class="lineno">  791 </span><span class="spaces">                 </span><span class="istickedoff">[(LocalName, tp3)] -&gt;</span>
<span class="lineno">  792 </span><span class="spaces">                 </span><span class="istickedoff">[Term] -&gt;</span>
<span class="lineno">  793 </span><span class="spaces">                 </span><span class="istickedoff">Bool</span>
<span class="lineno">  794 </span><span class="spaces">    </span><span class="istickedoff">isVarList _ _ _ [] = True</span>
<span class="lineno">  795 </span><span class="spaces">    </span><span class="istickedoff">isVarList (_ : ps) c1 c2 ((unwrapTermF -&gt; LocalVar i) : ts) =</span>
<span class="lineno">  796 </span><span class="spaces">      </span><span class="istickedoff">i == bindingsLength ps + invBindingsLength c1 + bindingsLength c2 &amp;&amp;</span>
<span class="lineno">  797 </span><span class="spaces">      </span><span class="istickedoff">isVarList ps c1 c2 ts</span>
<span class="lineno">  798 </span><span class="spaces">    </span><span class="istickedoff">isVarList _ _ _ _ = <span class="nottickedoff">False</span></span>
<span class="lineno">  799 </span><span class="spaces"></span><span class="istickedoff">asCtorDTApp _ _ _ _ _ _ = Nothing</span></span>
<span class="lineno">  800 </span>
<span class="lineno">  801 </span>
<span class="lineno">  802 </span>-- | Check that an argument for a constructor has one of the allowed forms
<span class="lineno">  803 </span>asCtorArg :: Name -&gt; [(LocalName, Term)] -&gt;
<span class="lineno">  804 </span>             [(LocalName, Term)] -&gt;
<span class="lineno">  805 </span>             InvBindings tp -&gt;
<span class="lineno">  806 </span>             Term -&gt;
<span class="lineno">  807 </span>             Maybe CtorArg
<span class="lineno">  808 </span><span class="decl"><span class="istickedoff">asCtorArg d params dt_ixs prevs (asPiList -&gt;</span>
<span class="lineno">  809 </span><span class="spaces">                                 </span><span class="istickedoff">(zs,</span>
<span class="lineno">  810 </span><span class="spaces">                                  </span><span class="istickedoff">asCtorDTApp d params dt_ixs prevs zs -&gt;</span>
<span class="lineno">  811 </span><span class="spaces">                                  </span><span class="istickedoff">Just ixs))</span>
<span class="lineno">  812 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">not (usesDataType <span class="nottickedoff">d</span> zs)</span></span>
<span class="lineno">  813 </span><span class="spaces">  </span><span class="istickedoff">= Just (RecursiveArg zs ixs)</span>
<span class="lineno">  814 </span><span class="spaces"></span><span class="istickedoff">asCtorArg d _ _ _ tp</span>
<span class="lineno">  815 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">not (usesDataType d tp)</span></span>
<span class="lineno">  816 </span><span class="spaces">  </span><span class="istickedoff">= Just (ConstArg tp)</span>
<span class="lineno">  817 </span><span class="spaces"></span><span class="istickedoff">asCtorArg _ _ _ _ _ = <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno">  818 </span>
<span class="lineno">  819 </span>-- | Check that a constructor type is a pi-abstraction that takes as input an
<span class="lineno">  820 </span>-- argument of one of the allowed forms described by 'CtorArg'
<span class="lineno">  821 </span>asPiCtorArg :: Name -&gt; [(LocalName, Term)] -&gt;
<span class="lineno">  822 </span>               [(LocalName, Term)] -&gt;
<span class="lineno">  823 </span>               InvBindings tp -&gt;
<span class="lineno">  824 </span>               Term -&gt;
<span class="lineno">  825 </span>               Maybe (LocalName, CtorArg, Term)
<span class="lineno">  826 </span><span class="decl"><span class="istickedoff">asPiCtorArg d params dt_ixs prevs (asPi -&gt;</span>
<span class="lineno">  827 </span><span class="spaces">                                   </span><span class="istickedoff">Just (x,</span>
<span class="lineno">  828 </span><span class="spaces">                                         </span><span class="istickedoff">asCtorArg d params dt_ixs prevs -&gt;</span>
<span class="lineno">  829 </span><span class="spaces">                                          </span><span class="istickedoff">Just arg, rest)) =</span>
<span class="lineno">  830 </span><span class="spaces">  </span><span class="istickedoff">Just (x, arg, rest)</span>
<span class="lineno">  831 </span><span class="spaces"></span><span class="istickedoff">asPiCtorArg _ _ _ _ _ = Nothing</span></span>
<span class="lineno">  832 </span>
<span class="lineno">  833 </span>-- | Helper function for 'mkCtorArgStruct'
<span class="lineno">  834 </span>mkCtorArgsIxs :: Name -&gt; [(LocalName, Term)] -&gt;
<span class="lineno">  835 </span>                 [(LocalName, Term)] -&gt;
<span class="lineno">  836 </span>                 InvBindings CtorArg -&gt;
<span class="lineno">  837 </span>                 Term -&gt;
<span class="lineno">  838 </span>                 Maybe ([(LocalName, CtorArg)], [Term])
<span class="lineno">  839 </span><span class="decl"><span class="istickedoff">mkCtorArgsIxs d params dt_ixs prevs (asPiCtorArg d params dt_ixs prevs -&gt;</span>
<span class="lineno">  840 </span><span class="spaces">                                     </span><span class="istickedoff">Just (x, arg, rest)) =</span>
<span class="lineno">  841 </span><span class="spaces">  </span><span class="istickedoff">case mkCtorArgsIxs d params dt_ixs (InvBind prevs <span class="nottickedoff">x</span> <span class="nottickedoff">arg</span>) rest of</span>
<span class="lineno">  842 </span><span class="spaces">    </span><span class="istickedoff">Just (args, ixs) -&gt; Just ((x, arg) : args, ixs)</span>
<span class="lineno">  843 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  844 </span><span class="spaces"></span><span class="istickedoff">mkCtorArgsIxs d params dt_ixs prevs (asCtorDTApp d params dt_ixs prevs [] -&gt;</span>
<span class="lineno">  845 </span><span class="spaces">                                     </span><span class="istickedoff">Just ixs) =</span>
<span class="lineno">  846 </span><span class="spaces">  </span><span class="istickedoff">Just ([], ixs)</span>
<span class="lineno">  847 </span><span class="spaces"></span><span class="istickedoff">mkCtorArgsIxs _ _ _ _ _ = <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno">  848 </span>
<span class="lineno">  849 </span>
<span class="lineno">  850 </span>-- | Take in a datatype and 'Bindings' lists for its parameters and indices, and
<span class="lineno">  851 </span>-- also a prospective type of a constructor for that datatype, where the
<span class="lineno">  852 </span>-- constructor type is allowed to have the parameters but not the indices free.
<span class="lineno">  853 </span>-- Test that the constructor type is an allowed type for a constructor of this
<span class="lineno">  854 </span>-- datatype, and, if so, build a 'CtorArgStruct' for it.
<span class="lineno">  855 </span>mkCtorArgStruct ::
<span class="lineno">  856 </span>  Name -&gt;
<span class="lineno">  857 </span>  [(LocalName, Term)] -&gt;
<span class="lineno">  858 </span>  [(LocalName, Term)] -&gt;
<span class="lineno">  859 </span>  Term -&gt;
<span class="lineno">  860 </span>  Maybe CtorArgStruct
<span class="lineno">  861 </span><span class="decl"><span class="istickedoff">mkCtorArgStruct d params dt_ixs ctor_tp =</span>
<span class="lineno">  862 </span><span class="spaces">  </span><span class="istickedoff">case mkCtorArgsIxs d params dt_ixs InvNoBind ctor_tp of</span>
<span class="lineno">  863 </span><span class="spaces">    </span><span class="istickedoff">Just (args, ctor_ixs) -&gt;</span>
<span class="lineno">  864 </span><span class="spaces">      </span><span class="istickedoff">Just (CtorArgStruct params args ctor_ixs dt_ixs)</span>
<span class="lineno">  865 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">Nothing</span></span></span>

</pre>
</body>
</html>
