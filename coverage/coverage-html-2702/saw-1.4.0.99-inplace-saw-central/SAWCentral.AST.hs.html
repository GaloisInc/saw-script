<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- |
<span class="lineno">    2 </span>Module      : SAWCentral.AST
<span class="lineno">    3 </span>Description : Datatypes representing SAWScript statements, expressions, and types.
<span class="lineno">    4 </span>License     : BSD3
<span class="lineno">    5 </span>Maintainer  : huffman
<span class="lineno">    6 </span>Stability   : provisional
<span class="lineno">    7 </span>-}
<span class="lineno">    8 </span>{-# LANGUAGE DeriveFunctor,DeriveFoldable,DeriveTraversable #-}
<span class="lineno">    9 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">   10 </span>{-# LANGUAGE TypeOperators #-}
<span class="lineno">   11 </span>{-# LANGUAGE FlexibleContexts #-}
<span class="lineno">   12 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">   13 </span>{-# LANGUAGE ViewPatterns #-}
<span class="lineno">   14 </span>{-# LANGUAGE NamedFieldPuns #-}
<span class="lineno">   15 </span>
<span class="lineno">   16 </span>module SAWCentral.AST
<span class="lineno">   17 </span>       ( PrimitiveLifecycle(..)
<span class="lineno">   18 </span>       , everythingAvailable
<span class="lineno">   19 </span>       , defaultAvailable
<span class="lineno">   20 </span>       , Name
<span class="lineno">   21 </span>       , Import(..)
<span class="lineno">   22 </span>       , Expr(..)
<span class="lineno">   23 </span>       , Pattern(..)
<span class="lineno">   24 </span>       , Stmt(..)
<span class="lineno">   25 </span>       , DeclGroup(..)
<span class="lineno">   26 </span>       , Decl(..)
<span class="lineno">   27 </span>       , Context(..)
<span class="lineno">   28 </span>       , Type(..), TypeIndex
<span class="lineno">   29 </span>       , TyCon(..)
<span class="lineno">   30 </span>       , Schema(..)
<span class="lineno">   31 </span>       , SchemaPattern(..)
<span class="lineno">   32 </span>       , NamedType(..)
<span class="lineno">   33 </span>       , tMono, tForall, tUnit, tTuple, tRecord, tArray, tFun
<span class="lineno">   34 </span>       , tString, tTerm, tType, tBool, tInt, tAIG, tCFG
<span class="lineno">   35 </span>       , tJVMSpec, tLLVMSpec, tMIRSpec
<span class="lineno">   36 </span>       , tBlock, tContext, tVar
<span class="lineno">   37 </span>       , isContext
<span class="lineno">   38 </span>
<span class="lineno">   39 </span>       , prettyWholeModule
<span class="lineno">   40 </span>       ) where
<span class="lineno">   41 </span>
<span class="lineno">   42 </span>import qualified SAWSupport.Pretty as PPS (PrettyPrec(..), prettyTypeSig, commaSepAll, replicate)
<span class="lineno">   43 </span>
<span class="lineno">   44 </span>import SAWCentral.Position (Pos(..), Positioned(..), maxSpan)
<span class="lineno">   45 </span>
<span class="lineno">   46 </span>import Data.Text (Text)
<span class="lineno">   47 </span>import Data.Set (Set)
<span class="lineno">   48 </span>import qualified Data.Set as Set
<span class="lineno">   49 </span>import Data.Map (Map)
<span class="lineno">   50 </span>import qualified Data.Map as Map
<span class="lineno">   51 </span>import Data.List (intercalate)
<span class="lineno">   52 </span>
<span class="lineno">   53 </span>import qualified Prettyprinter as PP
<span class="lineno">   54 </span>import           Prettyprinter (Pretty)
<span class="lineno">   55 </span>
<span class="lineno">   56 </span>import qualified Cryptol.Parser.AST as P (ImportSpec(..), ModName)
<span class="lineno">   57 </span>import qualified Cryptol.Utils.Ident as P (identText, modNameChunks)
<span class="lineno">   58 </span>
<span class="lineno">   59 </span>-- Lifecycle / Deprecation {{{
<span class="lineno">   60 </span>
<span class="lineno">   61 </span>-- | Position in the life cycle of a primitive.
<span class="lineno">   62 </span>data PrimitiveLifecycle
<span class="lineno">   63 </span>  = Current         {- ^ Currently available in all modes. -}
<span class="lineno">   64 </span>  | WarnDeprecated  {- ^ Removal planned, available but causes a warning -}
<span class="lineno">   65 </span>  | HideDeprecated  {- ^ Will be removed soon, and available only when
<span class="lineno">   66 </span>                         requested. -}
<span class="lineno">   67 </span>  | Experimental    {- ^ Will be made @Current@ soon, but available only by
<span class="lineno">   68 </span>                         request at the moment. -}
<span class="lineno">   69 </span>  deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Enum</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Bounded</span></span></span></span>)
<span class="lineno">   70 </span>
<span class="lineno">   71 </span>-- | Set of all lifecycle values.
<span class="lineno">   72 </span>everythingAvailable :: Set PrimitiveLifecycle
<span class="lineno">   73 </span><span class="decl"><span class="nottickedoff">everythingAvailable = Set.fromList [minBound .. maxBound]</span></span>
<span class="lineno">   74 </span>
<span class="lineno">   75 </span>-- | Default set of lifecycle values.
<span class="lineno">   76 </span>--   Keep this with its type to make sure it stays current.
<span class="lineno">   77 </span>defaultAvailable :: Set PrimitiveLifecycle
<span class="lineno">   78 </span><span class="decl"><span class="istickedoff">defaultAvailable = Set.fromList [Current, WarnDeprecated]</span></span>
<span class="lineno">   79 </span>
<span class="lineno">   80 </span>-- }}}
<span class="lineno">   81 </span>
<span class="lineno">   82 </span>-- Names {{{
<span class="lineno">   83 </span>
<span class="lineno">   84 </span>type Name = Text
<span class="lineno">   85 </span>
<span class="lineno">   86 </span>-- }}}
<span class="lineno">   87 </span>
<span class="lineno">   88 </span>-- Expr Level {{{
<span class="lineno">   89 </span>
<span class="lineno">   90 </span>data Import = Import
<span class="lineno">   91 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">iIsSubmodule</span></span></span> :: Bool
<span class="lineno">   92 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">iModule</span></span></span>    :: Either FilePath P.ModName
<span class="lineno">   93 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">iAs</span></span></span>        :: Maybe P.ModName
<span class="lineno">   94 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">iSpec</span></span></span>      :: Maybe P.ImportSpec
<span class="lineno">   95 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">iPos</span></span></span>       :: Pos
<span class="lineno">   96 </span>  } deriving <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>
<span class="lineno">   97 </span>
<span class="lineno">   98 </span>instance Positioned Import where
<span class="lineno">   99 </span>  <span class="decl"><span class="istickedoff">getPos = iPos</span></span>
<span class="lineno">  100 </span>
<span class="lineno">  101 </span>data Expr
<span class="lineno">  102 </span>  -- Constants
<span class="lineno">  103 </span>  = Bool Pos Bool
<span class="lineno">  104 </span>  | String Pos Text
<span class="lineno">  105 </span>  | Int Pos Integer
<span class="lineno">  106 </span>  | Code Pos Text
<span class="lineno">  107 </span>  | CType Pos Text
<span class="lineno">  108 </span>  -- Structures
<span class="lineno">  109 </span>  | Array  Pos [Expr]
<span class="lineno">  110 </span>    -- | A do-block, with zero or more statements and a final expression.
<span class="lineno">  111 </span>    --   The body is a pair so it can be carried around as a single object,
<span class="lineno">  112 </span>    --   which is convenient in a few places.
<span class="lineno">  113 </span>  | Block  Pos ([Stmt], Expr)
<span class="lineno">  114 </span>  | Tuple  Pos [Expr]
<span class="lineno">  115 </span>  | Record Pos (Map Name Expr)
<span class="lineno">  116 </span>  -- Accessors
<span class="lineno">  117 </span>  | Index   Pos Expr Expr
<span class="lineno">  118 </span>  | Lookup  Pos Expr Name
<span class="lineno">  119 </span>  | TLookup Pos Expr Integer
<span class="lineno">  120 </span>  -- LC
<span class="lineno">  121 </span>  | Var Pos Name
<span class="lineno">  122 </span>  -- | All functions are handled as lambdas. We hang onto the name
<span class="lineno">  123 </span>  --   from the function declaration (if there was one) for use in
<span class="lineno">  124 </span>  --   stack traces.
<span class="lineno">  125 </span>  | Lambda Pos (Maybe Name) Pattern Expr
<span class="lineno">  126 </span>  | Application Pos Expr Expr
<span class="lineno">  127 </span>  -- Sugar
<span class="lineno">  128 </span>  | Let Pos DeclGroup Expr
<span class="lineno">  129 </span>  | TSig Pos Expr Type
<span class="lineno">  130 </span>  | IfThenElse Pos Expr Expr Expr
<span class="lineno">  131 </span>  deriving <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff">Show</span></span></span></span></span></span>
<span class="lineno">  132 </span>
<span class="lineno">  133 </span>instance Positioned Expr where
<span class="lineno">  134 </span>  <span class="decl"><span class="istickedoff">getPos (Bool pos _) = <span class="nottickedoff">pos</span></span>
<span class="lineno">  135 </span><span class="spaces">  </span><span class="istickedoff">getPos (String pos _) = pos</span>
<span class="lineno">  136 </span><span class="spaces">  </span><span class="istickedoff">getPos (Int pos _) = pos</span>
<span class="lineno">  137 </span><span class="spaces">  </span><span class="istickedoff">getPos (Code pos _) = pos</span>
<span class="lineno">  138 </span><span class="spaces">  </span><span class="istickedoff">getPos (CType pos _) = pos</span>
<span class="lineno">  139 </span><span class="spaces">  </span><span class="istickedoff">getPos (Array pos _) = pos</span>
<span class="lineno">  140 </span><span class="spaces">  </span><span class="istickedoff">getPos (Block pos _) = pos</span>
<span class="lineno">  141 </span><span class="spaces">  </span><span class="istickedoff">getPos (Tuple pos _) = pos</span>
<span class="lineno">  142 </span><span class="spaces">  </span><span class="istickedoff">getPos (Record pos _) = <span class="nottickedoff">pos</span></span>
<span class="lineno">  143 </span><span class="spaces">  </span><span class="istickedoff">getPos (Index pos _ _) = <span class="nottickedoff">pos</span></span>
<span class="lineno">  144 </span><span class="spaces">  </span><span class="istickedoff">getPos (Lookup pos _ _) = <span class="nottickedoff">pos</span></span>
<span class="lineno">  145 </span><span class="spaces">  </span><span class="istickedoff">getPos (TLookup pos _ _) = <span class="nottickedoff">pos</span></span>
<span class="lineno">  146 </span><span class="spaces">  </span><span class="istickedoff">getPos (Var pos _) = pos</span>
<span class="lineno">  147 </span><span class="spaces">  </span><span class="istickedoff">getPos (Lambda pos _ _ _) = <span class="nottickedoff">pos</span></span>
<span class="lineno">  148 </span><span class="spaces">  </span><span class="istickedoff">getPos (Application pos _ _) = pos</span>
<span class="lineno">  149 </span><span class="spaces">  </span><span class="istickedoff">getPos (Let pos _ _) = <span class="nottickedoff">pos</span></span>
<span class="lineno">  150 </span><span class="spaces">  </span><span class="istickedoff">getPos (TSig pos _ _) = <span class="nottickedoff">pos</span></span>
<span class="lineno">  151 </span><span class="spaces">  </span><span class="istickedoff">getPos (IfThenElse pos _ _ _) = pos</span></span>
<span class="lineno">  152 </span>
<span class="lineno">  153 </span>-- | Patterns.
<span class="lineno">  154 </span>--
<span class="lineno">  155 </span>--   In `PVar` the first `Pos` is the position of the whole pattern
<span class="lineno">  156 </span>--   (including any type) and the second is the position of just the
<span class="lineno">  157 </span>--   name itself.
<span class="lineno">  158 </span>data Pattern
<span class="lineno">  159 </span>  = PWild Pos (Maybe Type)
<span class="lineno">  160 </span>  | PVar Pos Pos Name (Maybe Type)
<span class="lineno">  161 </span>  | PTuple Pos [Pattern]
<span class="lineno">  162 </span>  deriving <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff">Show</span></span></span></span></span></span>
<span class="lineno">  163 </span>
<span class="lineno">  164 </span>instance Positioned Pattern where
<span class="lineno">  165 </span>  <span class="decl"><span class="istickedoff">getPos (PWild pos _) = <span class="nottickedoff">pos</span></span>
<span class="lineno">  166 </span><span class="spaces">  </span><span class="istickedoff">getPos (PVar fullpos _namepos _ _) = fullpos</span>
<span class="lineno">  167 </span><span class="spaces">  </span><span class="istickedoff">getPos (PTuple pos _) = pos</span></span>
<span class="lineno">  168 </span>
<span class="lineno">  169 </span>-- | Statements.
<span class="lineno">  170 </span>--
<span class="lineno">  171 </span>--   In `StmtCode` the first `Pos` is the position of the whole
<span class="lineno">  172 </span>--   construct (including the initial &quot;let&quot;) and the second is the
<span class="lineno">  173 </span>--   position of just the Cryptol text.
<span class="lineno">  174 </span>--
<span class="lineno">  175 </span>--   Similarly, in `StmtTypedef` the first `Pos` is the position of
<span class="lineno">  176 </span>--   the whole construct (including the expansion) and the second is
<span class="lineno">  177 </span>--   the position of the name.
<span class="lineno">  178 </span>data Stmt
<span class="lineno">  179 </span>  = StmtBind     Pos Pattern Expr
<span class="lineno">  180 </span>  | StmtLet      Pos DeclGroup
<span class="lineno">  181 </span>  | StmtCode     Pos Pos Text
<span class="lineno">  182 </span>  | StmtImport   Pos Import
<span class="lineno">  183 </span>  | StmtTypedef  Pos Pos Text Type
<span class="lineno">  184 </span>  deriving <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Show</span></span></span></span></span></span>
<span class="lineno">  185 </span>
<span class="lineno">  186 </span>instance Positioned Stmt where
<span class="lineno">  187 </span>  <span class="decl"><span class="istickedoff">getPos (StmtBind pos _ _)  = pos</span>
<span class="lineno">  188 </span><span class="spaces">  </span><span class="istickedoff">getPos (StmtLet pos _)       = <span class="nottickedoff">pos</span></span>
<span class="lineno">  189 </span><span class="spaces">  </span><span class="istickedoff">getPos (StmtCode allpos _spos _str) = <span class="nottickedoff">allpos</span></span>
<span class="lineno">  190 </span><span class="spaces">  </span><span class="istickedoff">getPos (StmtImport pos _)    = <span class="nottickedoff">pos</span></span>
<span class="lineno">  191 </span><span class="spaces">  </span><span class="istickedoff">getPos (StmtTypedef allpos _apos _a _ty) = <span class="nottickedoff">allpos</span></span></span>
<span class="lineno">  192 </span>
<span class="lineno">  193 </span>data DeclGroup
<span class="lineno">  194 </span>  = Recursive [Decl]
<span class="lineno">  195 </span>  | NonRecursive Decl
<span class="lineno">  196 </span>  deriving <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>
<span class="lineno">  197 </span>
<span class="lineno">  198 </span>instance Positioned DeclGroup where
<span class="lineno">  199 </span>  <span class="decl"><span class="nottickedoff">getPos (Recursive ds) = maxSpan ds</span>
<span class="lineno">  200 </span><span class="spaces">  </span><span class="nottickedoff">getPos (NonRecursive d) = getPos d</span></span>
<span class="lineno">  201 </span>
<span class="lineno">  202 </span>data Decl
<span class="lineno">  203 </span>  = Decl { <span class="istickedoff"><span class="decl"><span class="istickedoff">dPos</span></span></span> :: Pos, <span class="istickedoff"><span class="decl"><span class="istickedoff">dPat</span></span></span> :: Pattern, <span class="nottickedoff"><span class="decl"><span class="nottickedoff">dType</span></span></span> :: Maybe Schema, <span class="nottickedoff"><span class="decl"><span class="nottickedoff">dDef</span></span></span> :: Expr }
<span class="lineno">  204 </span>  deriving <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff">Show</span></span></span></span></span></span>
<span class="lineno">  205 </span>
<span class="lineno">  206 </span>instance Positioned Decl where
<span class="lineno">  207 </span>  <span class="decl"><span class="istickedoff">getPos = dPos</span></span>
<span class="lineno">  208 </span>
<span class="lineno">  209 </span>-- }}}
<span class="lineno">  210 </span>
<span class="lineno">  211 </span>-- Type Level {{{
<span class="lineno">  212 </span>
<span class="lineno">  213 </span>data Context
<span class="lineno">  214 </span>  = JavaSetup
<span class="lineno">  215 </span>  | LLVMSetup
<span class="lineno">  216 </span>  | MIRSetup
<span class="lineno">  217 </span>  | ProofScript
<span class="lineno">  218 </span>  | TopLevel
<span class="lineno">  219 </span>  deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  220 </span>
<span class="lineno">  221 </span>-- The position information in a type should be thought of as its
<span class="lineno">  222 </span>-- provenance; for a type annotation in the input it'll be a concrete
<span class="lineno">  223 </span>-- file position. For types we infer, we want the position to record
<span class="lineno">  224 </span>-- not just where but also how the inference happened, so that when we
<span class="lineno">  225 </span>-- report this to the user they can see what's going on. (For example,
<span class="lineno">  226 </span>-- if we infer that a type must be a function because it's applied to
<span class="lineno">  227 </span>-- an argument, we record that it's inferred from context and the
<span class="lineno">  228 </span>-- position of the context is the position of the term that was
<span class="lineno">  229 </span>-- applied.) When the type flows around during type inference it
<span class="lineno">  230 </span>-- carries the position info with it.
<span class="lineno">  231 </span>--
<span class="lineno">  232 </span>-- Note that for a non-primitive type the various layers of the type
<span class="lineno">  233 </span>-- may have totally different provenance. (E.g. we might have List Int
<span class="lineno">  234 </span>-- where List was inferred from a term &quot;[x]&quot; somewhere but Int came
<span class="lineno">  235 </span>-- from an explicit annotation somewhere completely different.) So
<span class="lineno">  236 </span>-- printing this information usefully requires some thought. As of
<span class="lineno">  237 </span>-- this writing most of that thought hasn't been put in yet and we
<span class="lineno">  238 </span>-- just stuff the inference info into the Show instance output. See
<span class="lineno">  239 </span>-- notes in Position.hs.
<span class="lineno">  240 </span>data Type
<span class="lineno">  241 </span>  = TyCon Pos TyCon [Type]
<span class="lineno">  242 </span>  | TyRecord Pos (Map Name Type)
<span class="lineno">  243 </span>  | TyVar Pos Name
<span class="lineno">  244 </span>  | TyUnifyVar Pos TypeIndex       -- ^ For internal typechecker use only
<span class="lineno">  245 </span>  deriving <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff">Show</span></span></span></span></span></span>
<span class="lineno">  246 </span>
<span class="lineno">  247 </span>instance Positioned Type where
<span class="lineno">  248 </span>  <span class="decl"><span class="istickedoff">getPos (TyCon pos _ _) = pos</span>
<span class="lineno">  249 </span><span class="spaces">  </span><span class="istickedoff">getPos (TyRecord pos _) = pos</span>
<span class="lineno">  250 </span><span class="spaces">  </span><span class="istickedoff">getPos (TyVar pos _) = pos</span>
<span class="lineno">  251 </span><span class="spaces">  </span><span class="istickedoff">getPos (TyUnifyVar pos _) = <span class="nottickedoff">pos</span></span></span>
<span class="lineno">  252 </span>
<span class="lineno">  253 </span>type TypeIndex = Integer
<span class="lineno">  254 </span>
<span class="lineno">  255 </span>data TyCon
<span class="lineno">  256 </span>  = TupleCon Integer
<span class="lineno">  257 </span>  | ArrayCon
<span class="lineno">  258 </span>  | FunCon
<span class="lineno">  259 </span>  | StringCon
<span class="lineno">  260 </span>  | TermCon
<span class="lineno">  261 </span>  | TypeCon
<span class="lineno">  262 </span>  | BoolCon
<span class="lineno">  263 </span>  | IntCon
<span class="lineno">  264 </span>  | BlockCon
<span class="lineno">  265 </span>  | AIGCon
<span class="lineno">  266 </span>  | CFGCon
<span class="lineno">  267 </span>  | JVMSpecCon
<span class="lineno">  268 </span>  | LLVMSpecCon
<span class="lineno">  269 </span>  | MIRSpecCon
<span class="lineno">  270 </span>  | ContextCon Context
<span class="lineno">  271 </span>  deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  272 </span>
<span class="lineno">  273 </span>data Schema = Forall [(Pos, Name)] Type
<span class="lineno">  274 </span>  deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>
<span class="lineno">  275 </span>
<span class="lineno">  276 </span>-- | A schema pattern is like a schema but has potentially multiple
<span class="lineno">  277 </span>-- type entries that are meant to match fragments of a complete
<span class="lineno">  278 </span>-- schema. (We don't, for now at least, need a separate type for type
<span class="lineno">  279 </span>-- patterns and can just use Type.)
<span class="lineno">  280 </span>data SchemaPattern = SchemaPattern [(Pos, Name)] [Type]
<span class="lineno">  281 </span>
<span class="lineno">  282 </span>-- | The things a (named) TyVar can refer to by its name.
<span class="lineno">  283 </span>--
<span class="lineno">  284 </span>-- AbstractType is an opaque type whose only semantics are the
<span class="lineno">  285 </span>-- operations available for it, if any. The name identifies it; the
<span class="lineno">  286 </span>-- AbstractType constructor is a placeholder.
<span class="lineno">  287 </span>data NamedType = ConcreteType Type | AbstractType
<span class="lineno">  288 </span>
<span class="lineno">  289 </span>-- }}}
<span class="lineno">  290 </span>
<span class="lineno">  291 </span>-- Pretty Printing {{{
<span class="lineno">  292 </span>
<span class="lineno">  293 </span>prettyWholeModule :: [Stmt] -&gt; PP.Doc ann
<span class="lineno">  294 </span><span class="decl"><span class="istickedoff">prettyWholeModule = (PP.&lt;&gt; PP.line') . vcatWithSemi . map PP.pretty</span></span>
<span class="lineno">  295 </span>
<span class="lineno">  296 </span>vcatWithSemi :: [PP.Doc ann] -&gt; PP.Doc ann
<span class="lineno">  297 </span><span class="decl"><span class="istickedoff">vcatWithSemi = PP.vcat . map (PP.&lt;&gt; PP.semi)</span></span>
<span class="lineno">  298 </span>
<span class="lineno">  299 </span>instance <span class="decl"><span class="nottickedoff">Pretty Expr</span></span> where
<span class="lineno">  300 </span>  <span class="decl"><span class="istickedoff">pretty expr0 = case expr0 of</span>
<span class="lineno">  301 </span><span class="spaces">    </span><span class="istickedoff">Bool _ b   -&gt; <span class="nottickedoff">PP.viaShow b</span></span>
<span class="lineno">  302 </span><span class="spaces">    </span><span class="istickedoff">String _ s -&gt; PP.dquotes (PP.pretty s)</span>
<span class="lineno">  303 </span><span class="spaces">    </span><span class="istickedoff">Int _ i    -&gt; PP.pretty i</span>
<span class="lineno">  304 </span><span class="spaces">    </span><span class="istickedoff">Code _ s   -&gt; PP.braces $ PP.braces $ PP.pretty s</span>
<span class="lineno">  305 </span><span class="spaces">    </span><span class="istickedoff">CType _ s  -&gt; <span class="nottickedoff">PP.braces $ PP.pretty $ &quot;|&quot; &lt;&gt; s &lt;&gt; &quot;|&quot;</span></span>
<span class="lineno">  306 </span><span class="spaces">    </span><span class="istickedoff">Array _ xs -&gt; <span class="nottickedoff">PP.list (map PP.pretty xs)</span></span>
<span class="lineno">  307 </span><span class="spaces">    </span><span class="istickedoff">Block _ (stmts, lastexpr) -&gt;</span>
<span class="lineno">  308 </span><span class="spaces">      </span><span class="istickedoff">let stmts' = map PP.pretty stmts</span>
<span class="lineno">  309 </span><span class="spaces">          </span><span class="istickedoff">lastexpr' = PP.pretty lastexpr</span>
<span class="lineno">  310 </span><span class="spaces">          </span><span class="istickedoff">body = PP.align $ vcatWithSemi (stmts' ++ [lastexpr'])</span>
<span class="lineno">  311 </span><span class="spaces">          </span><span class="istickedoff">body' = PP.indent 3 body</span>
<span class="lineno">  312 </span><span class="spaces">      </span><span class="istickedoff">in</span>
<span class="lineno">  313 </span><span class="spaces">      </span><span class="istickedoff">&quot;do&quot; PP.&lt;+&gt; PP.lbrace PP.&lt;&gt; PP.line' PP.&lt;&gt; body' PP.&lt;&gt; PP.line' PP.&lt;&gt; PP.rbrace</span>
<span class="lineno">  314 </span><span class="spaces">    </span><span class="istickedoff">Tuple _ exprs -&gt; PP.tupled (map PP.pretty exprs)</span>
<span class="lineno">  315 </span><span class="spaces">    </span><span class="istickedoff">Record _ mapping -&gt;</span>
<span class="lineno">  316 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">PP.braces . (PP.space PP.&lt;&gt;) . (PP.&lt;&gt; PP.space) . PP.align . PP.sep . PP.punctuate PP.comma $</span></span>
<span class="lineno">  317 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">map (\(name, value) -&gt; PP.pretty name PP.&lt;+&gt; &quot;=&quot; PP.&lt;+&gt; PP.pretty value)</span></span>
<span class="lineno">  318 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">(Map.assocs mapping)</span></span>
<span class="lineno">  319 </span><span class="spaces">    </span><span class="istickedoff">Index _ _ _ -&gt; <span class="nottickedoff">error &quot;No concrete syntax for AST node 'Index'&quot;</span></span>
<span class="lineno">  320 </span><span class="spaces">    </span><span class="istickedoff">Lookup _ expr name -&gt; <span class="nottickedoff">PP.pretty expr PP.&lt;&gt; PP.dot PP.&lt;&gt; PP.pretty name</span></span>
<span class="lineno">  321 </span><span class="spaces">    </span><span class="istickedoff">TLookup _ expr int -&gt; <span class="nottickedoff">PP.pretty expr PP.&lt;&gt; PP.dot PP.&lt;&gt; PP.pretty int</span></span>
<span class="lineno">  322 </span><span class="spaces">    </span><span class="istickedoff">Var _ name -&gt;</span>
<span class="lineno">  323 </span><span class="spaces">      </span><span class="istickedoff">PP.pretty name</span>
<span class="lineno">  324 </span><span class="spaces">    </span><span class="istickedoff">Lambda _ _mname pat expr -&gt;</span>
<span class="lineno">  325 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">&quot;\\&quot; PP.&lt;+&gt; PP.pretty pat PP.&lt;+&gt; &quot;-&gt;&quot; PP.&lt;+&gt; PP.pretty expr</span></span>
<span class="lineno">  326 </span><span class="spaces">    </span><span class="istickedoff">-- FIXME, use precedence to minimize parentheses</span>
<span class="lineno">  327 </span><span class="spaces">    </span><span class="istickedoff">Application _ f a -&gt; PP.parens (PP.pretty f PP.&lt;+&gt; PP.pretty a)</span>
<span class="lineno">  328 </span><span class="spaces">    </span><span class="istickedoff">Let _ (NonRecursive decl) expr -&gt;</span>
<span class="lineno">  329 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">PP.fillSep</span></span>
<span class="lineno">  330 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">[ &quot;let&quot; PP.&lt;+&gt; prettyDef decl</span></span>
<span class="lineno">  331 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;in&quot; PP.&lt;+&gt; PP.pretty expr</span></span>
<span class="lineno">  332 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  333 </span><span class="spaces">    </span><span class="istickedoff">Let _ (Recursive decls) expr -&gt;</span>
<span class="lineno">  334 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">PP.fillSep</span></span>
<span class="lineno">  335 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">[ &quot;let&quot; PP.&lt;+&gt;</span></span>
<span class="lineno">  336 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">PP.cat (PP.punctuate</span></span>
<span class="lineno">  337 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">(PP.fillSep [PP.emptyDoc, &quot;and&quot; PP.&lt;&gt; PP.space])</span></span>
<span class="lineno">  338 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">(map prettyDef decls))</span></span>
<span class="lineno">  339 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;in&quot; PP.&lt;+&gt; PP.pretty expr</span></span>
<span class="lineno">  340 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  341 </span><span class="spaces">    </span><span class="istickedoff">TSig _ expr typ -&gt; <span class="nottickedoff">PP.parens $ PP.pretty expr PP.&lt;+&gt; PP.colon PP.&lt;+&gt; PPS.prettyPrec 0 typ</span></span>
<span class="lineno">  342 </span><span class="spaces">    </span><span class="istickedoff">IfThenElse _ e1 e2 e3 -&gt;</span>
<span class="lineno">  343 </span><span class="spaces">      </span><span class="istickedoff">&quot;if&quot; PP.&lt;+&gt; PP.pretty e1 PP.&lt;+&gt;</span>
<span class="lineno">  344 </span><span class="spaces">      </span><span class="istickedoff">&quot;then&quot; PP.&lt;+&gt; PP.pretty e2 PP.&lt;+&gt;</span>
<span class="lineno">  345 </span><span class="spaces">      </span><span class="istickedoff">&quot;else&quot; PP.&lt;+&gt; PP.pretty e3</span></span>
<span class="lineno">  346 </span>
<span class="lineno">  347 </span>instance PPS.PrettyPrec Expr where
<span class="lineno">  348 </span>  <span class="decl"><span class="nottickedoff">prettyPrec _ e = PP.pretty e</span></span>
<span class="lineno">  349 </span>
<span class="lineno">  350 </span>instance <span class="decl"><span class="nottickedoff">Pretty Pattern</span></span> where
<span class="lineno">  351 </span>  <span class="decl"><span class="istickedoff">pretty pat = case pat of</span>
<span class="lineno">  352 </span><span class="spaces">    </span><span class="istickedoff">PWild _ mType -&gt;</span>
<span class="lineno">  353 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">prettyMaybeTypedArg (&quot;_&quot;, mType)</span></span>
<span class="lineno">  354 </span><span class="spaces">    </span><span class="istickedoff">PVar _ _ name mType -&gt;</span>
<span class="lineno">  355 </span><span class="spaces">      </span><span class="istickedoff">prettyMaybeTypedArg (name, mType)</span>
<span class="lineno">  356 </span><span class="spaces">    </span><span class="istickedoff">PTuple _ pats -&gt;</span>
<span class="lineno">  357 </span><span class="spaces">      </span><span class="istickedoff">PP.tupled (map PP.pretty pats)</span></span>
<span class="lineno">  358 </span>
<span class="lineno">  359 </span>instance <span class="decl"><span class="nottickedoff">Pretty Stmt</span></span> where
<span class="lineno">  360 </span>   <span class="decl"><span class="istickedoff">pretty = \case</span>
<span class="lineno">  361 </span><span class="spaces">      </span><span class="istickedoff">StmtBind _ (PWild _ _ty) expr -&gt;</span>
<span class="lineno">  362 </span><span class="spaces">         </span><span class="istickedoff">PP.pretty expr</span>
<span class="lineno">  363 </span><span class="spaces">      </span><span class="istickedoff">StmtBind _ pat expr -&gt;</span>
<span class="lineno">  364 </span><span class="spaces">         </span><span class="istickedoff">PP.pretty pat PP.&lt;+&gt; &quot;&lt;-&quot; PP.&lt;+&gt; PP.align (PP.pretty expr)</span>
<span class="lineno">  365 </span><span class="spaces">      </span><span class="istickedoff">StmtLet _ (NonRecursive decl) -&gt;</span>
<span class="lineno">  366 </span><span class="spaces">         </span><span class="istickedoff">&quot;let&quot; PP.&lt;+&gt; prettyDef decl</span>
<span class="lineno">  367 </span><span class="spaces">      </span><span class="istickedoff">StmtLet _ (Recursive decls) -&gt;</span>
<span class="lineno">  368 </span><span class="spaces">         </span><span class="istickedoff">&quot;rec&quot; PP.&lt;+&gt;</span>
<span class="lineno">  369 </span><span class="spaces">         </span><span class="istickedoff">PP.cat (PP.punctuate</span>
<span class="lineno">  370 </span><span class="spaces">            </span><span class="istickedoff">(PP.fillSep [PP.emptyDoc, &quot;and&quot; PP.&lt;&gt; PP.space])</span>
<span class="lineno">  371 </span><span class="spaces">            </span><span class="istickedoff">(map prettyDef decls))</span>
<span class="lineno">  372 </span><span class="spaces">      </span><span class="istickedoff">StmtCode _ _ code -&gt;</span>
<span class="lineno">  373 </span><span class="spaces">         </span><span class="istickedoff">&quot;let&quot; PP.&lt;+&gt;</span>
<span class="lineno">  374 </span><span class="spaces">            </span><span class="istickedoff">(PP.braces . PP.braces $ PP.pretty code)</span>
<span class="lineno">  375 </span><span class="spaces">      </span><span class="istickedoff">StmtImport _ Import{iModule,iAs,iSpec} -&gt;</span>
<span class="lineno">  376 </span><span class="spaces">         </span><span class="istickedoff">&quot;import&quot; PP.&lt;+&gt;</span>
<span class="lineno">  377 </span><span class="spaces">         </span><span class="istickedoff">(case iModule of</span>
<span class="lineno">  378 </span><span class="spaces">            </span><span class="istickedoff">Left filepath -&gt;</span>
<span class="lineno">  379 </span><span class="spaces">               </span><span class="istickedoff">PP.dquotes . PP.pretty $ filepath</span>
<span class="lineno">  380 </span><span class="spaces">            </span><span class="istickedoff">Right modName -&gt;</span>
<span class="lineno">  381 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">ppModName modName</span>) PP.&lt;&gt;</span>
<span class="lineno">  382 </span><span class="spaces">         </span><span class="istickedoff">(case iAs of</span>
<span class="lineno">  383 </span><span class="spaces">            </span><span class="istickedoff">Just modName -&gt;</span>
<span class="lineno">  384 </span><span class="spaces">               </span><span class="istickedoff">PP.space PP.&lt;&gt; &quot;as&quot; PP.&lt;+&gt; ppModName modName</span>
<span class="lineno">  385 </span><span class="spaces">            </span><span class="istickedoff">Nothing -&gt; PP.emptyDoc) PP.&lt;&gt;</span>
<span class="lineno">  386 </span><span class="spaces">         </span><span class="istickedoff">(case iSpec of</span>
<span class="lineno">  387 </span><span class="spaces">            </span><span class="istickedoff">Just (P.Hiding names) -&gt;</span>
<span class="lineno">  388 </span><span class="spaces">               </span><span class="istickedoff">PP.space PP.&lt;&gt; &quot;hiding&quot; PP.&lt;+&gt; PP.tupled (map ppIdent names)</span>
<span class="lineno">  389 </span><span class="spaces">            </span><span class="istickedoff">Just (P.Only names) -&gt;</span>
<span class="lineno">  390 </span><span class="spaces">               </span><span class="istickedoff">PP.space PP.&lt;&gt; PP.tupled (map ppIdent names)</span>
<span class="lineno">  391 </span><span class="spaces">            </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">PP.emptyDoc</span>)</span>
<span class="lineno">  392 </span><span class="spaces">      </span><span class="istickedoff">StmtTypedef _ _ name ty -&gt;</span>
<span class="lineno">  393 </span><span class="spaces">         </span><span class="istickedoff">&quot;typedef&quot; PP.&lt;+&gt; PP.pretty name PP.&lt;+&gt; PPS.prettyPrec <span class="nottickedoff">0</span> ty</span>
<span class="lineno">  394 </span><span class="spaces">      </span><span class="istickedoff">--expr -&gt; PP.cyan . PP.viaShow expr</span>
<span class="lineno">  395 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  396 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  397 </span><span class="spaces">        </span><span class="istickedoff">ppModName mn = PP.pretty (intercalate <span class="nottickedoff">&quot;.&quot;</span> (P.modNameChunks mn))</span>
<span class="lineno">  398 </span><span class="spaces">        </span><span class="istickedoff">ppIdent i = PP.pretty (P.identText i)</span></span>
<span class="lineno">  399 </span>        --ppName n = ppIdent (P.nameIdent n)
<span class="lineno">  400 </span>
<span class="lineno">  401 </span>prettyDef :: Decl -&gt; PP.Doc ann
<span class="lineno">  402 </span><span class="decl"><span class="istickedoff">prettyDef (Decl _ pat0 _ def) =</span>
<span class="lineno">  403 </span><span class="spaces">   </span><span class="istickedoff">let dissectLambda :: Expr -&gt; ([Pattern], Expr)</span>
<span class="lineno">  404 </span><span class="spaces">       </span><span class="istickedoff">dissectLambda = \case</span>
<span class="lineno">  405 </span><span class="spaces">          </span><span class="istickedoff">Lambda _pos _name pat (dissectLambda -&gt; (pats, expr)) -&gt; (pat : pats, expr)</span>
<span class="lineno">  406 </span><span class="spaces">          </span><span class="istickedoff">expr -&gt; ([], expr)</span>
<span class="lineno">  407 </span><span class="spaces">       </span><span class="istickedoff">(args, body) = dissectLambda def</span>
<span class="lineno">  408 </span><span class="spaces">       </span><span class="istickedoff">pat0' = PP.pretty pat0</span>
<span class="lineno">  409 </span><span class="spaces">       </span><span class="istickedoff">args' =</span>
<span class="lineno">  410 </span><span class="spaces">           </span><span class="istickedoff">if not (null args) then</span>
<span class="lineno">  411 </span><span class="spaces">               </span><span class="istickedoff">PP.hsep (map PP.pretty args) PP.&lt;&gt; PP.space</span>
<span class="lineno">  412 </span><span class="spaces">           </span><span class="istickedoff">else</span>
<span class="lineno">  413 </span><span class="spaces">               </span><span class="istickedoff">PP.emptyDoc</span>
<span class="lineno">  414 </span><span class="spaces">       </span><span class="istickedoff">body' = PP.pretty body</span>
<span class="lineno">  415 </span><span class="spaces">   </span><span class="istickedoff">in</span>
<span class="lineno">  416 </span><span class="spaces">   </span><span class="istickedoff">pat0' PP.&lt;+&gt; args' PP.&lt;&gt; &quot;=&quot; PP.&lt;+&gt; body'</span></span>
<span class="lineno">  417 </span>
<span class="lineno">  418 </span>prettyMaybeTypedArg :: (Name, Maybe Type) -&gt; PP.Doc ann
<span class="lineno">  419 </span><span class="decl"><span class="istickedoff">prettyMaybeTypedArg (name,Nothing) =</span>
<span class="lineno">  420 </span><span class="spaces">   </span><span class="istickedoff">PP.pretty name</span>
<span class="lineno">  421 </span><span class="spaces"></span><span class="istickedoff">prettyMaybeTypedArg (name,Just typ) =</span>
<span class="lineno">  422 </span><span class="spaces">   </span><span class="istickedoff">PP.parens $ PP.pretty name PP.&lt;+&gt; PP.colon PP.&lt;+&gt; PPS.prettyPrec <span class="nottickedoff">0</span> typ</span></span>
<span class="lineno">  423 </span>
<span class="lineno">  424 </span>
<span class="lineno">  425 </span>instance PPS.PrettyPrec Schema where
<span class="lineno">  426 </span>  <span class="decl"><span class="istickedoff">prettyPrec _ (Forall ns t) = case ns of</span>
<span class="lineno">  427 </span><span class="spaces">    </span><span class="istickedoff">[] -&gt; PPS.prettyPrec 0 t</span>
<span class="lineno">  428 </span><span class="spaces">    </span><span class="istickedoff">_  -&gt; PP.braces (PPS.commaSepAll $ map PP.pretty ns') PP.&lt;+&gt; PPS.prettyPrec 0 t</span>
<span class="lineno">  429 </span><span class="spaces">          </span><span class="istickedoff">where ns' = map (\(_pos, n) -&gt; n) ns</span></span>
<span class="lineno">  430 </span>
<span class="lineno">  431 </span>instance PPS.PrettyPrec Type where
<span class="lineno">  432 </span>  <span class="decl"><span class="istickedoff">prettyPrec par t@(TyCon _ tc ts) = case (tc,ts) of</span>
<span class="lineno">  433 </span><span class="spaces">    </span><span class="istickedoff">(_,[])                 -&gt; PPS.prettyPrec <span class="nottickedoff">par</span> tc</span>
<span class="lineno">  434 </span><span class="spaces">    </span><span class="istickedoff">(TupleCon _,_)         -&gt; PP.parens $ PPS.commaSepAll $ map (PPS.prettyPrec <span class="nottickedoff">0</span>) ts</span>
<span class="lineno">  435 </span><span class="spaces">    </span><span class="istickedoff">(ArrayCon,[typ])       -&gt; PP.brackets (PPS.prettyPrec <span class="nottickedoff">0</span> typ)</span>
<span class="lineno">  436 </span><span class="spaces">    </span><span class="istickedoff">(FunCon,[f,v])         -&gt; (if par &gt; 0 then PP.parens else id) $</span>
<span class="lineno">  437 </span><span class="spaces">                                </span><span class="istickedoff">PPS.prettyPrec 1 f PP.&lt;+&gt; &quot;-&gt;&quot; PP.&lt;+&gt; PPS.prettyPrec 0 v</span>
<span class="lineno">  438 </span><span class="spaces">    </span><span class="istickedoff">(BlockCon,[cxt,typ])   -&gt; (if <span class="tickonlyfalse">par &gt; 1</span> then <span class="nottickedoff">PP.parens</span> else id) $</span>
<span class="lineno">  439 </span><span class="spaces">                                </span><span class="istickedoff">PPS.prettyPrec <span class="nottickedoff">1</span> cxt PP.&lt;+&gt; PPS.prettyPrec <span class="nottickedoff">2</span> typ</span>
<span class="lineno">  440 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">error $ &quot;malformed TyCon: &quot; ++ show t</span></span>
<span class="lineno">  441 </span><span class="spaces">  </span><span class="istickedoff">prettyPrec _par (TyRecord _ fs) =</span>
<span class="lineno">  442 </span><span class="spaces">      </span><span class="istickedoff">PP.braces</span>
<span class="lineno">  443 </span><span class="spaces">    </span><span class="istickedoff">$ PPS.commaSepAll</span>
<span class="lineno">  444 </span><span class="spaces">    </span><span class="istickedoff">$ map (\(n,t) -&gt; PP.pretty n `PPS.prettyTypeSig` PPS.prettyPrec <span class="nottickedoff">0</span> t)</span>
<span class="lineno">  445 </span><span class="spaces">    </span><span class="istickedoff">$ Map.toList fs</span>
<span class="lineno">  446 </span><span class="spaces">  </span><span class="istickedoff">prettyPrec _par (TyUnifyVar _ i)    = &quot;t.&quot; PP.&lt;&gt; PP.pretty i</span>
<span class="lineno">  447 </span><span class="spaces">  </span><span class="istickedoff">prettyPrec _par (TyVar _ n)         = PP.pretty n</span></span>
<span class="lineno">  448 </span>
<span class="lineno">  449 </span>instance PPS.PrettyPrec TyCon where
<span class="lineno">  450 </span>  <span class="decl"><span class="istickedoff">prettyPrec par tc = case tc of</span>
<span class="lineno">  451 </span><span class="spaces">    </span><span class="istickedoff">TupleCon n     -&gt; PP.parens $ PPS.replicate (n - 1) $ PP.pretty ','</span>
<span class="lineno">  452 </span><span class="spaces">    </span><span class="istickedoff">ArrayCon       -&gt; PP.parens $ PP.brackets $ PP.emptyDoc</span>
<span class="lineno">  453 </span><span class="spaces">    </span><span class="istickedoff">FunCon         -&gt; PP.parens $ &quot;-&gt;&quot;</span>
<span class="lineno">  454 </span><span class="spaces">    </span><span class="istickedoff">StringCon      -&gt; &quot;String&quot;</span>
<span class="lineno">  455 </span><span class="spaces">    </span><span class="istickedoff">TermCon        -&gt; &quot;Term&quot;</span>
<span class="lineno">  456 </span><span class="spaces">    </span><span class="istickedoff">TypeCon        -&gt; <span class="nottickedoff">&quot;Type&quot;</span></span>
<span class="lineno">  457 </span><span class="spaces">    </span><span class="istickedoff">BoolCon        -&gt; &quot;Bool&quot;</span>
<span class="lineno">  458 </span><span class="spaces">    </span><span class="istickedoff">IntCon         -&gt; &quot;Int&quot;</span>
<span class="lineno">  459 </span><span class="spaces">    </span><span class="istickedoff">AIGCon         -&gt; <span class="nottickedoff">&quot;AIG&quot;</span></span>
<span class="lineno">  460 </span><span class="spaces">    </span><span class="istickedoff">CFGCon         -&gt; <span class="nottickedoff">&quot;CFG&quot;</span></span>
<span class="lineno">  461 </span><span class="spaces">    </span><span class="istickedoff">JVMSpecCon     -&gt; &quot;JVMSpec&quot;</span>
<span class="lineno">  462 </span><span class="spaces">    </span><span class="istickedoff">LLVMSpecCon    -&gt; &quot;LLVMSpec&quot;</span>
<span class="lineno">  463 </span><span class="spaces">    </span><span class="istickedoff">MIRSpecCon     -&gt; <span class="nottickedoff">&quot;MIRSpec&quot;</span></span>
<span class="lineno">  464 </span><span class="spaces">    </span><span class="istickedoff">BlockCon       -&gt; &quot;&lt;Block&gt;&quot;</span>
<span class="lineno">  465 </span><span class="spaces">    </span><span class="istickedoff">ContextCon cxt -&gt; PPS.prettyPrec <span class="nottickedoff">par</span> cxt</span></span>
<span class="lineno">  466 </span>
<span class="lineno">  467 </span>instance PPS.PrettyPrec Context where
<span class="lineno">  468 </span>  <span class="decl"><span class="istickedoff">prettyPrec _ c = case c of</span>
<span class="lineno">  469 </span><span class="spaces">    </span><span class="istickedoff">JavaSetup    -&gt; <span class="nottickedoff">&quot;JavaSetup&quot;</span></span>
<span class="lineno">  470 </span><span class="spaces">    </span><span class="istickedoff">LLVMSetup    -&gt; &quot;LLVMSetup&quot;</span>
<span class="lineno">  471 </span><span class="spaces">    </span><span class="istickedoff">MIRSetup     -&gt; <span class="nottickedoff">&quot;MIRSetup&quot;</span></span>
<span class="lineno">  472 </span><span class="spaces">    </span><span class="istickedoff">ProofScript  -&gt; &quot;ProofScript&quot;</span>
<span class="lineno">  473 </span><span class="spaces">    </span><span class="istickedoff">TopLevel     -&gt; &quot;TopLevel&quot;</span></span>
<span class="lineno">  474 </span>
<span class="lineno">  475 </span>instance PPS.PrettyPrec NamedType where
<span class="lineno">  476 </span>  <span class="decl"><span class="nottickedoff">prettyPrec par ty = case ty of</span>
<span class="lineno">  477 </span><span class="spaces">    </span><span class="nottickedoff">ConcreteType ty' -&gt; PPS.prettyPrec par ty'</span>
<span class="lineno">  478 </span><span class="spaces">    </span><span class="nottickedoff">AbstractType -&gt; &quot;&lt;opaque&gt;&quot;</span></span>
<span class="lineno">  479 </span>
<span class="lineno">  480 </span>-- }}}
<span class="lineno">  481 </span>
<span class="lineno">  482 </span>-- Type Constructors {{{
<span class="lineno">  483 </span>
<span class="lineno">  484 </span>tMono :: Type -&gt; Schema
<span class="lineno">  485 </span><span class="decl"><span class="istickedoff">tMono = Forall []</span></span>
<span class="lineno">  486 </span>
<span class="lineno">  487 </span>tForall :: [(Pos, Name)] -&gt; Schema -&gt; Schema
<span class="lineno">  488 </span><span class="decl"><span class="nottickedoff">tForall xs (Forall ys t) = Forall (xs ++ ys) t</span></span>
<span class="lineno">  489 </span>
<span class="lineno">  490 </span>tUnit :: Pos -&gt; Type
<span class="lineno">  491 </span><span class="decl"><span class="nottickedoff">tUnit pos = tTuple pos []</span></span>
<span class="lineno">  492 </span>
<span class="lineno">  493 </span>tTuple :: Pos -&gt; [Type] -&gt; Type
<span class="lineno">  494 </span><span class="decl"><span class="istickedoff">tTuple pos ts = TyCon pos (TupleCon $ fromIntegral $ length ts) ts</span></span>
<span class="lineno">  495 </span>
<span class="lineno">  496 </span>tRecord :: Pos -&gt; [(Name, Type)] -&gt; Type
<span class="lineno">  497 </span><span class="decl"><span class="istickedoff">tRecord pos fields = TyRecord pos (Map.fromList fields)</span></span>
<span class="lineno">  498 </span>
<span class="lineno">  499 </span>tArray :: Pos -&gt; Type -&gt; Type
<span class="lineno">  500 </span><span class="decl"><span class="istickedoff">tArray pos t = TyCon pos ArrayCon [t]</span></span>
<span class="lineno">  501 </span>
<span class="lineno">  502 </span>tFun :: Pos -&gt; Type -&gt; Type -&gt; Type
<span class="lineno">  503 </span><span class="decl"><span class="istickedoff">tFun pos f v = TyCon pos FunCon [f,v]</span></span>
<span class="lineno">  504 </span>
<span class="lineno">  505 </span>tString :: Pos -&gt; Type
<span class="lineno">  506 </span><span class="decl"><span class="istickedoff">tString pos = TyCon pos StringCon []</span></span>
<span class="lineno">  507 </span>
<span class="lineno">  508 </span>tTerm :: Pos -&gt; Type
<span class="lineno">  509 </span><span class="decl"><span class="istickedoff">tTerm pos = TyCon <span class="nottickedoff">pos</span> TermCon []</span></span>
<span class="lineno">  510 </span>
<span class="lineno">  511 </span>tType :: Pos -&gt; Type
<span class="lineno">  512 </span><span class="decl"><span class="istickedoff">tType pos = TyCon <span class="nottickedoff">pos</span> TypeCon []</span></span>
<span class="lineno">  513 </span>
<span class="lineno">  514 </span>tBool :: Pos -&gt; Type
<span class="lineno">  515 </span><span class="decl"><span class="istickedoff">tBool pos = TyCon pos BoolCon []</span></span>
<span class="lineno">  516 </span>
<span class="lineno">  517 </span>tAIG :: Pos -&gt; Type
<span class="lineno">  518 </span><span class="decl"><span class="istickedoff">tAIG pos = TyCon <span class="nottickedoff">pos</span> AIGCon []</span></span>
<span class="lineno">  519 </span>
<span class="lineno">  520 </span>tCFG :: Pos -&gt; Type
<span class="lineno">  521 </span><span class="decl"><span class="istickedoff">tCFG pos = TyCon <span class="nottickedoff">pos</span> CFGCon []</span></span>
<span class="lineno">  522 </span>
<span class="lineno">  523 </span>tInt :: Pos -&gt; Type
<span class="lineno">  524 </span><span class="decl"><span class="istickedoff">tInt pos = TyCon pos IntCon []</span></span>
<span class="lineno">  525 </span>
<span class="lineno">  526 </span>tJVMSpec :: Pos -&gt; Type
<span class="lineno">  527 </span><span class="decl"><span class="istickedoff">tJVMSpec pos = TyCon <span class="nottickedoff">pos</span> JVMSpecCon []</span></span>
<span class="lineno">  528 </span>
<span class="lineno">  529 </span>tLLVMSpec :: Pos -&gt; Type
<span class="lineno">  530 </span><span class="decl"><span class="istickedoff">tLLVMSpec pos = TyCon <span class="nottickedoff">pos</span> LLVMSpecCon []</span></span>
<span class="lineno">  531 </span>
<span class="lineno">  532 </span>tMIRSpec :: Pos -&gt; Type
<span class="lineno">  533 </span><span class="decl"><span class="istickedoff">tMIRSpec pos = TyCon <span class="nottickedoff">pos</span> MIRSpecCon []</span></span>
<span class="lineno">  534 </span>
<span class="lineno">  535 </span>tBlock :: Pos -&gt; Type -&gt; Type -&gt; Type
<span class="lineno">  536 </span><span class="decl"><span class="istickedoff">tBlock pos c t = TyCon pos BlockCon [c,t]</span></span>
<span class="lineno">  537 </span>
<span class="lineno">  538 </span>tContext :: Pos -&gt; Context -&gt; Type
<span class="lineno">  539 </span><span class="decl"><span class="istickedoff">tContext pos c = TyCon pos (ContextCon c) []</span></span>
<span class="lineno">  540 </span>
<span class="lineno">  541 </span>tVar :: Pos -&gt; Name -&gt; Type
<span class="lineno">  542 </span><span class="decl"><span class="istickedoff">tVar pos n = TyVar pos n</span></span>
<span class="lineno">  543 </span>
<span class="lineno">  544 </span>-- }}}
<span class="lineno">  545 </span>
<span class="lineno">  546 </span>-- Type Classifiers {{{
<span class="lineno">  547 </span>
<span class="lineno">  548 </span>-- The idea is that calling these is/should be less messy than direct
<span class="lineno">  549 </span>-- pattern matching, and also help a little to avoid splattering the
<span class="lineno">  550 </span>-- internal representation of types all over the place.
<span class="lineno">  551 </span>
<span class="lineno">  552 </span>-- | Check if type 'ty' is a 'Context' type of context 'c'.
<span class="lineno">  553 </span>isContext ::
<span class="lineno">  554 </span>       Context          -- ^ The context 'c' to look for
<span class="lineno">  555 </span>    -&gt; Type             -- ^ The type 'ty' to inspect
<span class="lineno">  556 </span>    -&gt; Bool
<span class="lineno">  557 </span><span class="decl"><span class="nottickedoff">isContext c ty = case ty of</span>
<span class="lineno">  558 </span><span class="spaces">  </span><span class="nottickedoff">TyCon _pos (ContextCon c') [] | c' == c -&gt; True</span>
<span class="lineno">  559 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt; False</span></span>
<span class="lineno">  560 </span>
<span class="lineno">  561 </span>-- }}}

</pre>
</body>
</html>
