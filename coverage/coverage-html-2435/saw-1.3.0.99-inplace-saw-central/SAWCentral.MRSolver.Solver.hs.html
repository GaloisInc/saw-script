<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE ImplicitParams #-}
<span class="lineno">    2 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">    3 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">    4 </span>{-# LANGUAGE TupleSections #-}
<span class="lineno">    5 </span>{-# LANGUAGE ViewPatterns #-}
<span class="lineno">    6 </span>{-# LANGUAGE RankNTypes #-}
<span class="lineno">    7 </span>
<span class="lineno">    8 </span>-- This is to stop GHC 8.8.4's pattern match checker exceeding its limit when
<span class="lineno">    9 </span>-- checking the pattern match in the 'CompTerm' case of 'normComp'
<span class="lineno">   10 </span>{-# LANGUAGE CPP #-}
<span class="lineno">   11 </span>#if __GLASGOW_HASKELL__ &lt;= 808
<span class="lineno">   12 </span>{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
<span class="lineno">   13 </span>#endif
<span class="lineno">   14 </span>
<span class="lineno">   15 </span>{- |
<span class="lineno">   16 </span>Module      : SAWCentral.MRSolver.Solver
<span class="lineno">   17 </span>Copyright   : Galois, Inc. 2022
<span class="lineno">   18 </span>License     : BSD3
<span class="lineno">   19 </span>Maintainer  : westbrook@galois.com
<span class="lineno">   20 </span>Stability   : experimental
<span class="lineno">   21 </span>Portability : non-portable (language extensions)
<span class="lineno">   22 </span>
<span class="lineno">   23 </span>This module implements a monadic-recursive solver, for proving that one monadic
<span class="lineno">   24 </span>term refines another. The algorithm works on the &quot;monadic normal form&quot; of
<span class="lineno">   25 </span>computations, which uses the following laws to simplify binds, where @either@ is
<span class="lineno">   26 </span>the sum elimination function defined in the SAW core prelude:
<span class="lineno">   27 </span>
<span class="lineno">   28 </span>&gt; retS x &gt;&gt;= k                  = k x
<span class="lineno">   29 </span>&gt; errorS str &gt;&gt;= k              = errorM
<span class="lineno">   30 </span>&gt; (m &gt;&gt;= k1) &gt;&gt;= k2             = m &gt;&gt;= \x -&gt; k1 x &gt;&gt;= k2
<span class="lineno">   31 </span>&gt; (existsS f) &gt;&gt;= k             = existsM (\x -&gt; f x &gt;&gt;= k)
<span class="lineno">   32 </span>&gt; (forallS f) &gt;&gt;= k             = forallM (\x -&gt; f x &gt;&gt;= k)
<span class="lineno">   33 </span>&gt; (assumingS b m) &gt;&gt;= k         = assumingM b (m &gt;&gt;= k)
<span class="lineno">   34 </span>&gt; (assertingS b m) &gt;&gt;= k        = assertingM b (m &gt;&gt;= k)
<span class="lineno">   35 </span>&gt; (orS m1 m2) &gt;&gt;= k             = orM (m1 &gt;&gt;= k) (m2 &gt;&gt;= k)
<span class="lineno">   36 </span>&gt; (if b then m1 else m2) &gt;&gt;= k  = if b then m1 &gt;&gt;= k else m2 &gt;&gt;= k
<span class="lineno">   37 </span>&gt; (either f1 f2 e) &gt;&gt;= k        = either (\x -&gt; f1 x &gt;&gt;= k) (\x -&gt; f2 x &gt;&gt;= k) e
<span class="lineno">   38 </span>
<span class="lineno">   39 </span>The resulting computations are in one of the following forms:
<span class="lineno">   40 </span>
<span class="lineno">   41 </span>&gt; returnM e  |  errorM str  |  existsM f  |  forallM f  |  assumingS b m  |
<span class="lineno">   42 </span>&gt; assertingS b m  |  orM m1 m2  |  if b then m1 else m2  |  either f1 f2 e  |
<span class="lineno">   43 </span>&gt; F e1 ... en  | F e1 ... en &gt;&gt;= k
<span class="lineno">   44 </span>
<span class="lineno">   45 </span>The form @F e1 ... en@ refers to a recursively-defined function or a function
<span class="lineno">   46 </span>variable that has been locally bound by a @FixS@. Either way, monadic
<span class="lineno">   47 </span>normalization does not attempt to normalize these functions.
<span class="lineno">   48 </span>
<span class="lineno">   49 </span>The algorithm maintains a context of three sorts of variables: @FixS@-bound
<span class="lineno">   50 </span>variables, existential variables, and universal variables. Universal variables
<span class="lineno">   51 </span>are represented as free SAW core variables, while the other two forms of
<span class="lineno">   52 </span>variable are represented as SAW core 'ExtCns's terms, which are essentially
<span class="lineno">   53 </span>axioms that have been generated internally. These 'ExtCns's are Skolemized,
<span class="lineno">   54 </span>meaning that they take in as arguments all universal variables that were in
<span class="lineno">   55 </span>scope when they were created. The context also maintains a partial substitution
<span class="lineno">   56 </span>for the existential variables, as they become instantiated with values, and it
<span class="lineno">   57 </span>additionally remembers the bodies / unfoldings of the @FixS@-bound variables.
<span class="lineno">   58 </span>
<span class="lineno">   59 </span>The goal of the solver at any point is of the form @C |- m1 |= m2@, meaning that
<span class="lineno">   60 </span>we are trying to prove @m1@ refines @m2@ in context @C@. This proceeds by cases:
<span class="lineno">   61 </span>
<span class="lineno">   62 </span>&gt; C |- retS e1 |= retS e2: prove C |- e1 = e2
<span class="lineno">   63 </span>&gt;
<span class="lineno">   64 </span>&gt; C |- errorS str1 |= errorS str2: vacuously true
<span class="lineno">   65 </span>&gt;
<span class="lineno">   66 </span>&gt; C |- if b then m1' else m1'' |= m2: prove C,b=true |- m1' |= m2 and
<span class="lineno">   67 </span>&gt; C,b=false |- m1'' |= m2, skipping either case where C,b=X is unsatisfiable;
<span class="lineno">   68 </span>&gt;
<span class="lineno">   69 </span>&gt; C |- m1 |= if b then m2' else m2'': similar to the above
<span class="lineno">   70 </span>&gt;
<span class="lineno">   71 </span>&gt; C |- either T U (SpecM V) f1 f2 e |= m: prove C,x:T,e=inl x |- f1 x |= m and
<span class="lineno">   72 </span>&gt; C,y:U,e=inl y |- f2 y |= m, again skippping any case with unsatisfiable context;
<span class="lineno">   73 </span>&gt;
<span class="lineno">   74 </span>&gt; C |- m |= either T U (SpecM V) f1 f2 e: similar to previous
<span class="lineno">   75 </span>&gt;
<span class="lineno">   76 </span>&gt; C |- m |= forallS f: make a new universal variable x and recurse
<span class="lineno">   77 </span>&gt;
<span class="lineno">   78 </span>&gt; C |- existsS f |= m: make a new universal variable x and recurse (existential
<span class="lineno">   79 </span>&gt; elimination uses universal variables and vice-versa)
<span class="lineno">   80 </span>&gt;
<span class="lineno">   81 </span>&gt; C |- m |= existsS f: make a new existential variable x and recurse
<span class="lineno">   82 </span>&gt;
<span class="lineno">   83 </span>&gt; C |- forallS f |= m: make a new existential variable x and recurse
<span class="lineno">   84 </span>&gt;
<span class="lineno">   85 </span>&gt; C |- m |= orS m1 m2: try to prove C |- m |= m1, and if that fails, backtrack and
<span class="lineno">   86 </span>&gt; prove C |- m |= m2
<span class="lineno">   87 </span>&gt;
<span class="lineno">   88 </span>&gt; C |- orS m1 m2 |= m: prove both C |- m1 |= m and C |- m2 |= m
<span class="lineno">   89 </span>&gt;
<span class="lineno">   90 </span>&gt; C |- FixS fdef args |= m: create a FixS-bound variable F bound to (fdef F) and
<span class="lineno">   91 </span>&gt; recurse on fdef F args |= m
<span class="lineno">   92 </span>&gt;
<span class="lineno">   93 </span>&gt; C |- m |= FixS fdef args: similar to previous case
<span class="lineno">   94 </span>&gt;
<span class="lineno">   95 </span>&gt; C |- F e1 ... en &gt;&gt;= k |= F e1' ... en' &gt;&gt;= k': prove C |- ei = ei' for each i
<span class="lineno">   96 </span>&gt; and then prove k x |= k' x for new universal variable x
<span class="lineno">   97 </span>&gt;
<span class="lineno">   98 </span>&gt; C |- F e1 ... en &gt;&gt;= k |= F' e1' ... em' &gt;&gt;= k':
<span class="lineno">   99 </span>&gt;
<span class="lineno">  100 </span>&gt; * If we have an assumption that forall x1 ... xj, F a1 ... an |= F' a1' .. am',
<span class="lineno">  101 </span>&gt;   prove ei = ai and ei' = ai' and then that C |- k x |= k' x for fresh uvar x
<span class="lineno">  102 </span>&gt;
<span class="lineno">  103 </span>&gt; * If we have an assumption that forall x1, ..., xn, F e1'' ... en'' |= m' for
<span class="lineno">  104 </span>&gt;   some ei'' and m', match the ei'' against the ei by instantiating the xj with
<span class="lineno">  105 </span>&gt;   fresh evars, and if this succeeds then recursively prove C |- m' &gt;&gt;= k |= RHS
<span class="lineno">  106 </span>&gt;
<span class="lineno">  107 </span>&gt; (We don't do this one right now)
<span class="lineno">  108 </span>&gt; * If we have an assumption that forall x1', ..., xn', m |= F e1'' ... en'' for
<span class="lineno">  109 </span>&gt;   some ei'' and m', match the ei'' against the ei by instantiating the xj with
<span class="lineno">  110 </span>&gt;   fresh evars, and if this succeeds then recursively prove C |- LHS |= m' &gt;&gt;= k'
<span class="lineno">  111 </span>&gt;
<span class="lineno">  112 </span>&gt; * If either side is a definition whose unfolding does not contain FixS or any
<span class="lineno">  113 </span>&gt;   related operations, unfold it
<span class="lineno">  114 </span>&gt;
<span class="lineno">  115 </span>&gt; * If F and F' have the same return type, add an assumption forall uvars in scope
<span class="lineno">  116 </span>&gt;   that F e1 ... en |= F' e1' ... em' and unfold both sides, recursively proving
<span class="lineno">  117 </span>&gt;   that F_body e1 ... en |= F_body' e1' ... em'. Then also prove k x |= k' x for
<span class="lineno">  118 </span>&gt;   fresh uvar x.
<span class="lineno">  119 </span>&gt;
<span class="lineno">  120 </span>&gt; * Otherwise we don't know to &quot;split&quot; one of the sides into a bind whose
<span class="lineno">  121 </span>&gt;   components relate to the two components on the other side, so just fail
<span class="lineno">  122 </span>-}
<span class="lineno">  123 </span>
<span class="lineno">  124 </span>module SAWCentral.MRSolver.Solver where
<span class="lineno">  125 </span>
<span class="lineno">  126 </span>import Data.Maybe
<span class="lineno">  127 </span>import qualified Data.Text as T
<span class="lineno">  128 </span>import Data.List (find, findIndices)
<span class="lineno">  129 </span>import Data.Foldable (foldlM)
<span class="lineno">  130 </span>import Data.Bits (shiftL)
<span class="lineno">  131 </span>import Control.Monad (void, foldM, forM, zipWithM, zipWithM_, (&gt;=&gt;))
<span class="lineno">  132 </span>import Control.Monad.Except (MonadError(..))
<span class="lineno">  133 </span>import qualified Data.Map as Map
<span class="lineno">  134 </span>import qualified Data.Text as Text
<span class="lineno">  135 </span>import Data.Set (Set)
<span class="lineno">  136 </span>
<span class="lineno">  137 </span>import SAWCore.Module (Def(..), ResolvedName(..), ctorNumParams, lookupVarIndexInMap)
<span class="lineno">  138 </span>import SAWCore.Name
<span class="lineno">  139 </span>import SAWCore.Term.Functor
<span class="lineno">  140 </span>import SAWCore.SharedTerm
<span class="lineno">  141 </span>import SAWCore.Recognizer
<span class="lineno">  142 </span>
<span class="lineno">  143 </span>import SAWCentral.Panic
<span class="lineno">  144 </span>import SAWCentral.Prover.SolverStats
<span class="lineno">  145 </span>import SAWCentral.Proof (Sequent, SolveResult)
<span class="lineno">  146 </span>import SAWCentral.Value (TopLevel)
<span class="lineno">  147 </span>
<span class="lineno">  148 </span>import SAWCentral.MRSolver.Term
<span class="lineno">  149 </span>import SAWCentral.MRSolver.Evidence
<span class="lineno">  150 </span>import SAWCentral.MRSolver.Monad
<span class="lineno">  151 </span>import SAWCentral.MRSolver.SMT
<span class="lineno">  152 </span>
<span class="lineno">  153 </span>
<span class="lineno">  154 </span>----------------------------------------------------------------------
<span class="lineno">  155 </span>-- * Normalizing and Matching on Terms
<span class="lineno">  156 </span>----------------------------------------------------------------------
<span class="lineno">  157 </span>
<span class="lineno">  158 </span>-- FIXME: move these to Recognizer.hs
<span class="lineno">  159 </span>
<span class="lineno">  160 </span>-- | Recognize an equality proposition over Booleans
<span class="lineno">  161 </span>asBoolEq :: Recognizer Term (Term,Term)
<span class="lineno">  162 </span><span class="decl"><span class="nottickedoff">asBoolEq (asEq -&gt; Just ((asBoolType -&gt; Just ()), e1, e2)) = Just (e1, e2)</span>
<span class="lineno">  163 </span><span class="spaces"></span><span class="nottickedoff">asBoolEq _ = Nothing</span></span>
<span class="lineno">  164 </span>
<span class="lineno">  165 </span>-- | Match a right-nested series of pairs. This is similar to 'asTupleValue'
<span class="lineno">  166 </span>-- except that it expects a unit value to always be at the end.
<span class="lineno">  167 </span>asNestedPairs :: Recognizer Term [Term]
<span class="lineno">  168 </span><span class="decl"><span class="nottickedoff">asNestedPairs (asPairValue -&gt; Just (x, asNestedPairs -&gt; Just xs)) = Just (x:xs)</span>
<span class="lineno">  169 </span><span class="spaces"></span><span class="nottickedoff">asNestedPairs (asFTermF -&gt; Just UnitValue) = Just []</span>
<span class="lineno">  170 </span><span class="spaces"></span><span class="nottickedoff">asNestedPairs _ = Nothing</span></span>
<span class="lineno">  171 </span>
<span class="lineno">  172 </span>-- | Recognize a term of the form @Cons _ x1 (Cons _ x2 (... (Nil _)))@
<span class="lineno">  173 </span>asList :: Recognizer Term [Term]
<span class="lineno">  174 </span><span class="decl"><span class="nottickedoff">asList (asGlobalApply &quot;Prelude.Nil&quot; -&gt; Just [_]) = pure []</span>
<span class="lineno">  175 </span><span class="spaces"></span><span class="nottickedoff">asList (asGlobalApply &quot;Prelude.Cons&quot; -&gt; Just [_, hd, tl]) = (hd:) &lt;$&gt; asList tl</span>
<span class="lineno">  176 </span><span class="spaces"></span><span class="nottickedoff">asList _ = Nothing</span></span>
<span class="lineno">  177 </span>
<span class="lineno">  178 </span>-- | Apply a SAW core term of type @MultiFixBodies@ to a list of monadic
<span class="lineno">  179 </span>-- functions bound for the functions it is defining, and return the bodies for
<span class="lineno">  180 </span>-- those definitions. That is, take a term of the form
<span class="lineno">  181 </span>--
<span class="lineno">  182 </span>-- &gt; \F1 F2 ... Fn -&gt; (f1, (f2, ... (fn, ())))
<span class="lineno">  183 </span>--
<span class="lineno">  184 </span>-- that defines corecursive functions @f1@ through @fn@ using function variables
<span class="lineno">  185 </span>-- @F1@ through @Fn@ to represent recursive calls and apply that term to
<span class="lineno">  186 </span>-- function variables for @F1@ throughh @Fn@, returning @f1@ through @fn@.
<span class="lineno">  187 </span>mrApplyMFixBodies :: Term -&gt; [Term] -&gt; MRM t [Term]
<span class="lineno">  188 </span><span class="decl"><span class="nottickedoff">mrApplyMFixBodies defs_tm fun_tms =</span>
<span class="lineno">  189 </span><span class="spaces">  </span><span class="nottickedoff">do mm &lt;- liftSC0 scGetModuleMap</span>
<span class="lineno">  190 </span><span class="spaces">     </span><span class="nottickedoff">let mbody =</span>
<span class="lineno">  191 </span><span class="spaces">           </span><span class="nottickedoff">case asConstant defs_tm of</span>
<span class="lineno">  192 </span><span class="spaces">             </span><span class="nottickedoff">Nothing -&gt; Nothing</span>
<span class="lineno">  193 </span><span class="spaces">             </span><span class="nottickedoff">Just nm -&gt;</span>
<span class="lineno">  194 </span><span class="spaces">               </span><span class="nottickedoff">case lookupVarIndexInMap (nameIndex nm) mm of</span>
<span class="lineno">  195 </span><span class="spaces">                 </span><span class="nottickedoff">Just (ResolvedDef d) -&gt; defBody d</span>
<span class="lineno">  196 </span><span class="spaces">                 </span><span class="nottickedoff">_ -&gt; Nothing</span>
<span class="lineno">  197 </span><span class="spaces">     </span><span class="nottickedoff">case mbody of</span>
<span class="lineno">  198 </span><span class="spaces">       </span><span class="nottickedoff">Just body -&gt;</span>
<span class="lineno">  199 </span><span class="spaces">         </span><span class="nottickedoff">-- If defs is a constant, unfold it</span>
<span class="lineno">  200 </span><span class="spaces">         </span><span class="nottickedoff">mrApplyMFixBodies body fun_tms</span>
<span class="lineno">  201 </span><span class="spaces">       </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno">  202 </span><span class="spaces">         </span><span class="nottickedoff">do defs_app &lt;- mrApplyAll defs_tm fun_tms</span>
<span class="lineno">  203 </span><span class="spaces">            </span><span class="nottickedoff">case asNestedPairs defs_app of</span>
<span class="lineno">  204 </span><span class="spaces">              </span><span class="nottickedoff">Just defs -&gt; return defs</span>
<span class="lineno">  205 </span><span class="spaces">              </span><span class="nottickedoff">Nothing -&gt; throwMRFailure (MalformedDefs defs_tm)</span></span>
<span class="lineno">  206 </span>
<span class="lineno">  207 </span>-- | Bind fresh function variables for a @LetRecS@ or @MultiFixS@ whose types
<span class="lineno">  208 </span>-- are given in the supplied list (which should all be monadic function types)
<span class="lineno">  209 </span>-- and whose bodies are monadic functions that can corecursively call those same
<span class="lineno">  210 </span>-- fresh function variables. In order to represent this corecursion, the bodies
<span class="lineno">  211 </span>-- are specified by a function that takes in SAW core terms for the newly bound
<span class="lineno">  212 </span>-- functions and returns their bodies.
<span class="lineno">  213 </span>mrFreshCallVars :: [Term] -&gt; ([Term] -&gt; MRM t [Term]) -&gt; MRM t [MRVar]
<span class="lineno">  214 </span><span class="decl"><span class="nottickedoff">mrFreshCallVars fun_tps bodies_f =</span>
<span class="lineno">  215 </span><span class="spaces">  </span><span class="nottickedoff">do</span>
<span class="lineno">  216 </span><span class="spaces">    </span><span class="nottickedoff">-- Bind fresh function variables with the types given by fun_tps</span>
<span class="lineno">  217 </span><span class="spaces">    </span><span class="nottickedoff">fun_vars &lt;- mapM (mrFreshVar &quot;F&quot;) fun_tps</span>
<span class="lineno">  218 </span><span class="spaces">    </span><span class="nottickedoff">fun_tms &lt;- mapM mrVarTerm fun_vars</span>
<span class="lineno">  219 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  220 </span><span class="spaces">    </span><span class="nottickedoff">-- Pass the newly-bound functions to bodies_f to generate the corecursive</span>
<span class="lineno">  221 </span><span class="spaces">    </span><span class="nottickedoff">-- function bodies, and lift them out of the current uvars</span>
<span class="lineno">  222 </span><span class="spaces">    </span><span class="nottickedoff">bodies &lt;- bodies_f fun_tms &gt;&gt;= mapM lambdaUVarsM</span>
<span class="lineno">  223 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  224 </span><span class="spaces">    </span><span class="nottickedoff">-- Remember the body associated with each fresh function constant</span>
<span class="lineno">  225 </span><span class="spaces">    </span><span class="nottickedoff">zipWithM_ (\f body -&gt; mrSetVarInfo f (CallVarInfo body)) fun_vars bodies</span>
<span class="lineno">  226 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  227 </span><span class="spaces">    </span><span class="nottickedoff">-- Finally, return the fresh function variables</span>
<span class="lineno">  228 </span><span class="spaces">    </span><span class="nottickedoff">return fun_vars</span></span>
<span class="lineno">  229 </span>
<span class="lineno">  230 </span>
<span class="lineno">  231 </span>-- | Bind a single fresh function variable for a @FixS@ with a given type (which
<span class="lineno">  232 </span>-- must be a monadic type) and a body that can be corecursive in the function
<span class="lineno">  233 </span>-- variable itself
<span class="lineno">  234 </span>mrFreshCallVar :: Term -&gt; (Term -&gt; MRM t Term) -&gt; MRM t MRVar
<span class="lineno">  235 </span><span class="decl"><span class="nottickedoff">mrFreshCallVar fun_tp body_f =</span>
<span class="lineno">  236 </span><span class="spaces">  </span><span class="nottickedoff">mrFreshCallVars [fun_tp]</span>
<span class="lineno">  237 </span><span class="spaces">  </span><span class="nottickedoff">(\case</span>
<span class="lineno">  238 </span><span class="spaces">      </span><span class="nottickedoff">[v] -&gt; (: []) &lt;$&gt; body_f v</span>
<span class="lineno">  239 </span><span class="spaces">      </span><span class="nottickedoff">_ -&gt; panic &quot;mrFreshCallVar&quot; [&quot;Expected one function variable&quot;]) &gt;&gt;= \case</span>
<span class="lineno">  240 </span><span class="spaces">  </span><span class="nottickedoff">[ret] -&gt; return ret</span>
<span class="lineno">  241 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt; panic &quot;mrFreshCallVar&quot; [&quot;Expected on return variable&quot;]</span></span>
<span class="lineno">  242 </span>
<span class="lineno">  243 </span>
<span class="lineno">  244 </span>-- | Normalize a 'Term' of monadic type to monadic normal form
<span class="lineno">  245 </span>normCompTerm :: Term -&gt; MRM t NormComp
<span class="lineno">  246 </span><span class="decl"><span class="nottickedoff">normCompTerm = normComp . CompTerm</span></span>
<span class="lineno">  247 </span>
<span class="lineno">  248 </span>-- | Normalize a computation to monadic normal form, assuming any 'Term's it
<span class="lineno">  249 </span>-- contains have already been normalized with respect to beta and projections
<span class="lineno">  250 </span>-- (but constants need not be unfolded)
<span class="lineno">  251 </span>normComp :: Comp -&gt; MRM t NormComp
<span class="lineno">  252 </span><span class="decl"><span class="nottickedoff">normComp (CompReturn t) = return $ RetS t</span>
<span class="lineno">  253 </span><span class="spaces"></span><span class="nottickedoff">normComp (CompBind m f) =</span>
<span class="lineno">  254 </span><span class="spaces">  </span><span class="nottickedoff">do norm &lt;- normComp m</span>
<span class="lineno">  255 </span><span class="spaces">     </span><span class="nottickedoff">normBind norm f</span>
<span class="lineno">  256 </span><span class="spaces"></span><span class="nottickedoff">normComp (CompTerm t) =</span>
<span class="lineno">  257 </span><span class="spaces">  </span><span class="nottickedoff">(&gt;&gt;) (mrDebugPPPrefix 3 &quot;normCompTerm:&quot; t) $</span>
<span class="lineno">  258 </span><span class="spaces">  </span><span class="nottickedoff">liftSC0 scGetModuleMap &gt;&gt;= \mm -&gt;</span>
<span class="lineno">  259 </span><span class="spaces">  </span><span class="nottickedoff">let ?mm = mm in</span>
<span class="lineno">  260 </span><span class="spaces">  </span><span class="nottickedoff">withFailureCtx (FailCtxMNF t) $</span>
<span class="lineno">  261 </span><span class="spaces">  </span><span class="nottickedoff">case asApplyAll t of</span>
<span class="lineno">  262 </span><span class="spaces">    </span><span class="nottickedoff">(f@(asLambda -&gt; Just _), args@(_:_)) -&gt;</span>
<span class="lineno">  263 </span><span class="spaces">      </span><span class="nottickedoff">mrApplyAll f args &gt;&gt;= normCompTerm</span>
<span class="lineno">  264 </span><span class="spaces">    </span><span class="nottickedoff">(isGlobalDef &quot;SpecM.retS&quot; -&gt; Just (), [_, _, x]) -&gt;</span>
<span class="lineno">  265 </span><span class="spaces">      </span><span class="nottickedoff">return $ RetS x</span>
<span class="lineno">  266 </span><span class="spaces">    </span><span class="nottickedoff">(isGlobalDef &quot;SpecM.bindS&quot; -&gt; Just (), [ev, _, _, m, f]) -&gt;</span>
<span class="lineno">  267 </span><span class="spaces">      </span><span class="nottickedoff">do norm &lt;- normCompTerm m</span>
<span class="lineno">  268 </span><span class="spaces">         </span><span class="nottickedoff">normBind norm (CompFunTerm (EvTerm ev) f)</span>
<span class="lineno">  269 </span><span class="spaces">    </span><span class="nottickedoff">(isGlobalDef &quot;SpecM.errorS&quot; -&gt; Just (), [_, _, str]) -&gt;</span>
<span class="lineno">  270 </span><span class="spaces">      </span><span class="nottickedoff">return (ErrorS str)</span>
<span class="lineno">  271 </span><span class="spaces">    </span><span class="nottickedoff">(isGlobalDef &quot;Prelude.ite&quot; -&gt; Just (), [_, cond, then_tm, else_tm]) -&gt;</span>
<span class="lineno">  272 </span><span class="spaces">      </span><span class="nottickedoff">return $ Ite cond (CompTerm then_tm) (CompTerm else_tm)</span>
<span class="lineno">  273 </span><span class="spaces">    </span><span class="nottickedoff">(isGlobalDef &quot;Prelude.iteWithProof&quot; -&gt; Just (), [_, cond, then_f, else_f]) -&gt;</span>
<span class="lineno">  274 </span><span class="spaces">      </span><span class="nottickedoff">do bool_tp &lt;- liftSC0 scBoolType</span>
<span class="lineno">  275 </span><span class="spaces">         </span><span class="nottickedoff">then_tm &lt;-</span>
<span class="lineno">  276 </span><span class="spaces">           </span><span class="nottickedoff">(liftSC1 scBool &gt;=&gt; mrEqProp bool_tp cond &gt;=&gt; mrDummyProof &gt;=&gt;</span>
<span class="lineno">  277 </span><span class="spaces">            </span><span class="nottickedoff">liftSC2 scApply then_f) True</span>
<span class="lineno">  278 </span><span class="spaces">         </span><span class="nottickedoff">else_tm &lt;-</span>
<span class="lineno">  279 </span><span class="spaces">           </span><span class="nottickedoff">(liftSC1 scBool &gt;=&gt; mrEqProp bool_tp cond &gt;=&gt; mrDummyProof &gt;=&gt;</span>
<span class="lineno">  280 </span><span class="spaces">            </span><span class="nottickedoff">liftSC2 scApply else_f) False</span>
<span class="lineno">  281 </span><span class="spaces">         </span><span class="nottickedoff">return $ Ite cond (CompTerm then_tm) (CompTerm else_tm)</span>
<span class="lineno">  282 </span><span class="spaces">    </span><span class="nottickedoff">(isGlobalDef &quot;Prelude.either&quot; -&gt; Just (),</span>
<span class="lineno">  283 </span><span class="spaces">     </span><span class="nottickedoff">[ltp, rtp, (asSpecM -&gt; Just (ev, _)), f, g, eith]) -&gt;</span>
<span class="lineno">  284 </span><span class="spaces">      </span><span class="nottickedoff">return $ Eithers [(Type ltp, CompFunTerm ev f),</span>
<span class="lineno">  285 </span><span class="spaces">                        </span><span class="nottickedoff">(Type rtp, CompFunTerm ev g)] eith</span>
<span class="lineno">  286 </span><span class="spaces">    </span><span class="nottickedoff">(isGlobalDef &quot;Prelude.eithers&quot; -&gt; Just (),</span>
<span class="lineno">  287 </span><span class="spaces">     </span><span class="nottickedoff">[_, (matchEitherElims -&gt; Just elims), eith]) -&gt;</span>
<span class="lineno">  288 </span><span class="spaces">      </span><span class="nottickedoff">return $ Eithers elims eith</span>
<span class="lineno">  289 </span><span class="spaces">    </span><span class="nottickedoff">(isGlobalDef &quot;Prelude.maybe&quot; -&gt; Just (),</span>
<span class="lineno">  290 </span><span class="spaces">     </span><span class="nottickedoff">[tp, (asSpecM -&gt; Just (ev, _)), m, f, mayb]) -&gt;</span>
<span class="lineno">  291 </span><span class="spaces">      </span><span class="nottickedoff">do tp' &lt;- case asApplyAll tp of</span>
<span class="lineno">  292 </span><span class="spaces">                  </span><span class="nottickedoff">-- Always unfold: is_bvult, is_bvule</span>
<span class="lineno">  293 </span><span class="spaces">                  </span><span class="nottickedoff">(tpf@(asGlobalDef -&gt; Just ident), args)</span>
<span class="lineno">  294 </span><span class="spaces">                    </span><span class="nottickedoff">| ident `elem` [&quot;Prelude.is_bvult&quot;, &quot;Prelude.is_bvule&quot;]</span>
<span class="lineno">  295 </span><span class="spaces">                    </span><span class="nottickedoff">, Just nm &lt;- asConstant tpf -&gt;</span>
<span class="lineno">  296 </span><span class="spaces">                      </span><span class="nottickedoff">do body &lt;- requireDefBody ident nm</span>
<span class="lineno">  297 </span><span class="spaces">                         </span><span class="nottickedoff">mrApplyAll body args</span>
<span class="lineno">  298 </span><span class="spaces">                  </span><span class="nottickedoff">_ -&gt; return tp</span>
<span class="lineno">  299 </span><span class="spaces">         </span><span class="nottickedoff">return $ MaybeElim (Type tp') (CompTerm m) (CompFunTerm ev f) mayb</span>
<span class="lineno">  300 </span><span class="spaces">    </span><span class="nottickedoff">(isGlobalDef &quot;SpecM.orS&quot; -&gt; Just (), [_, _, m1, m2]) -&gt;</span>
<span class="lineno">  301 </span><span class="spaces">      </span><span class="nottickedoff">return $ OrS (CompTerm m1) (CompTerm m2)</span>
<span class="lineno">  302 </span><span class="spaces">    </span><span class="nottickedoff">(isGlobalDef &quot;SpecM.assertBoolS&quot; -&gt; Just (), [ev, cond]) -&gt;</span>
<span class="lineno">  303 </span><span class="spaces">      </span><span class="nottickedoff">do unit_tp &lt;- mrUnitType</span>
<span class="lineno">  304 </span><span class="spaces">         </span><span class="nottickedoff">return $ AssertBoolBind cond (CompFunReturn (EvTerm ev) unit_tp)</span>
<span class="lineno">  305 </span><span class="spaces">    </span><span class="nottickedoff">(isGlobalDef &quot;SpecM.assumeBoolS&quot; -&gt; Just (), [ev, cond]) -&gt;</span>
<span class="lineno">  306 </span><span class="spaces">      </span><span class="nottickedoff">do unit_tp &lt;- mrUnitType</span>
<span class="lineno">  307 </span><span class="spaces">         </span><span class="nottickedoff">return $ AssumeBoolBind cond (CompFunReturn (EvTerm ev) unit_tp)</span>
<span class="lineno">  308 </span><span class="spaces">    </span><span class="nottickedoff">(isGlobalDef &quot;SpecM.existsS&quot; -&gt; Just (), [ev, tp]) -&gt;</span>
<span class="lineno">  309 </span><span class="spaces">      </span><span class="nottickedoff">do unit_tp &lt;- mrUnitType</span>
<span class="lineno">  310 </span><span class="spaces">         </span><span class="nottickedoff">return $ ExistsBind (Type tp) (CompFunReturn (EvTerm ev) unit_tp)</span>
<span class="lineno">  311 </span><span class="spaces">    </span><span class="nottickedoff">(isGlobalDef &quot;SpecM.forallS&quot; -&gt; Just (), [ev, tp]) -&gt;</span>
<span class="lineno">  312 </span><span class="spaces">      </span><span class="nottickedoff">do unit_tp &lt;- mrUnitType</span>
<span class="lineno">  313 </span><span class="spaces">         </span><span class="nottickedoff">return $ ForallBind (Type tp) (CompFunReturn (EvTerm ev) unit_tp)</span>
<span class="lineno">  314 </span><span class="spaces">    </span><span class="nottickedoff">(isGlobalDef &quot;SpecM.FixS&quot; -&gt; Just (), _ev:_tp_d:body:args) -&gt;</span>
<span class="lineno">  315 </span><span class="spaces">      </span><span class="nottickedoff">do</span>
<span class="lineno">  316 </span><span class="spaces">        </span><span class="nottickedoff">-- Bind a fresh function var for the new recursive function, getting the</span>
<span class="lineno">  317 </span><span class="spaces">        </span><span class="nottickedoff">-- type of the new function as the input type of body, which should have</span>
<span class="lineno">  318 </span><span class="spaces">        </span><span class="nottickedoff">-- type specFun E T -&gt; specFun E T</span>
<span class="lineno">  319 </span><span class="spaces">        </span><span class="nottickedoff">body_tp &lt;- mrTypeOf body</span>
<span class="lineno">  320 </span><span class="spaces">        </span><span class="nottickedoff">fun_tp &lt;- case asPi body_tp of</span>
<span class="lineno">  321 </span><span class="spaces">          </span><span class="nottickedoff">Just (_, tp_in, _) -&gt; return tp_in</span>
<span class="lineno">  322 </span><span class="spaces">          </span><span class="nottickedoff">Nothing -&gt; throwMRFailure (MalformedDefs body)</span>
<span class="lineno">  323 </span><span class="spaces">        </span><span class="nottickedoff">fun_var &lt;- mrFreshCallVar fun_tp (mrApply body)</span>
<span class="lineno">  324 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  325 </span><span class="spaces">        </span><span class="nottickedoff">-- Return the function variable applied to args as a normalized</span>
<span class="lineno">  326 </span><span class="spaces">        </span><span class="nottickedoff">-- computation, noting that it must be applied to all of the uvars as</span>
<span class="lineno">  327 </span><span class="spaces">        </span><span class="nottickedoff">-- well as the args</span>
<span class="lineno">  328 </span><span class="spaces">        </span><span class="nottickedoff">let var = CallSName fun_var</span>
<span class="lineno">  329 </span><span class="spaces">        </span><span class="nottickedoff">all_args &lt;- (++ args) &lt;$&gt; getAllUVarTerms</span>
<span class="lineno">  330 </span><span class="spaces">        </span><span class="nottickedoff">FunBind var all_args &lt;$&gt; mkCompFunReturn &lt;$&gt;</span>
<span class="lineno">  331 </span><span class="spaces">          </span><span class="nottickedoff">mrFunOutType var all_args</span>
<span class="lineno">  332 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  333 </span><span class="spaces">        </span><span class="nottickedoff">{-</span>
<span class="lineno">  334 </span><span class="spaces"></span><span class="nottickedoff">FIXME HERE NOW: match a tuple projection of a MultiFixS</span>
<span class="lineno">  335 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  336 </span><span class="spaces">    </span><span class="nottickedoff">(isGlobalDef &quot;SpecM.MultiFixS&quot; -&gt; Just (), ev:tp_ds:defs:args) -&gt;</span>
<span class="lineno">  337 </span><span class="spaces">      </span><span class="nottickedoff">do</span>
<span class="lineno">  338 </span><span class="spaces">        </span><span class="nottickedoff">-- Bind fresh function vars for the new recursive functions</span>
<span class="lineno">  339 </span><span class="spaces">        </span><span class="nottickedoff">fun_vars &lt;- mrFreshCallVars ev tp_ds defs</span>
<span class="lineno">  340 </span><span class="spaces">        </span><span class="nottickedoff">-- Return the @i@th variable to args as a normalized computation, noting</span>
<span class="lineno">  341 </span><span class="spaces">        </span><span class="nottickedoff">-- that it must be applied to all of the uvars as well as the args</span>
<span class="lineno">  342 </span><span class="spaces">        </span><span class="nottickedoff">let var = CallSName (fun_vars !! (fromIntegral i))</span>
<span class="lineno">  343 </span><span class="spaces">        </span><span class="nottickedoff">all_args &lt;- (++ args) &lt;$&gt; getAllUVarTerms</span>
<span class="lineno">  344 </span><span class="spaces">        </span><span class="nottickedoff">FunBind var all_args &lt;$&gt; mkCompFunReturn &lt;$&gt;</span>
<span class="lineno">  345 </span><span class="spaces">          </span><span class="nottickedoff">mrFunOutType var all_args -}</span>
<span class="lineno">  346 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  347 </span><span class="spaces">    </span><span class="nottickedoff">(isGlobalDef &quot;SpecM.LetRecS&quot; -&gt; Just (), [ev,tp_ds,_,defs,body]) -&gt;</span>
<span class="lineno">  348 </span><span class="spaces">      </span><span class="nottickedoff">do</span>
<span class="lineno">  349 </span><span class="spaces">        </span><span class="nottickedoff">-- First compute the types of the recursive functions being bound by</span>
<span class="lineno">  350 </span><span class="spaces">        </span><span class="nottickedoff">-- mapping @tpElem@ to the type descriptions, and bind functions of</span>
<span class="lineno">  351 </span><span class="spaces">        </span><span class="nottickedoff">-- those types</span>
<span class="lineno">  352 </span><span class="spaces">        </span><span class="nottickedoff">tpElem_fun &lt;- mrGlobalTerm &quot;SpecM.tpElem&quot;</span>
<span class="lineno">  353 </span><span class="spaces">        </span><span class="nottickedoff">fun_tps &lt;- case asList tp_ds of</span>
<span class="lineno">  354 </span><span class="spaces">          </span><span class="nottickedoff">Just ds -&gt; mapM (\d -&gt; mrApplyAll tpElem_fun [ev, d]) ds</span>
<span class="lineno">  355 </span><span class="spaces">          </span><span class="nottickedoff">Nothing -&gt; throwMRFailure (MalformedTpDescList tp_ds)</span>
<span class="lineno">  356 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  357 </span><span class="spaces">        </span><span class="nottickedoff">-- Bind fresh function vars for the new recursive functions</span>
<span class="lineno">  358 </span><span class="spaces">        </span><span class="nottickedoff">fun_vars &lt;- mrFreshCallVars fun_tps (mrApplyMFixBodies defs)</span>
<span class="lineno">  359 </span><span class="spaces">        </span><span class="nottickedoff">fun_tms &lt;- mapM mrVarTerm fun_vars</span>
<span class="lineno">  360 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  361 </span><span class="spaces">        </span><span class="nottickedoff">-- Continue normalizing body applied to those fresh function vars</span>
<span class="lineno">  362 </span><span class="spaces">        </span><span class="nottickedoff">body_app &lt;- mrApplyAll body fun_tms</span>
<span class="lineno">  363 </span><span class="spaces">        </span><span class="nottickedoff">normCompTerm body_app</span>
<span class="lineno">  364 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  365 </span><span class="spaces">    </span><span class="nottickedoff">-- Treat forNatLtThenS like FixS with a body of forNatLtThenSBody</span>
<span class="lineno">  366 </span><span class="spaces">    </span><span class="nottickedoff">(isGlobalDef &quot;SpecM.forNatLtThenS&quot; -&gt; Just (), [ev,st,ret,n,f,k,s0]) -&gt;</span>
<span class="lineno">  367 </span><span class="spaces">      </span><span class="nottickedoff">do</span>
<span class="lineno">  368 </span><span class="spaces">        </span><span class="nottickedoff">-- Bind a fresh function with type Nat -&gt; st -&gt; SpecM E ret</span>
<span class="lineno">  369 </span><span class="spaces">        </span><span class="nottickedoff">type_f &lt;- mrGlobalTermUnfold &quot;SpecM.forNatLtThenSBodyType&quot;</span>
<span class="lineno">  370 </span><span class="spaces">        </span><span class="nottickedoff">fun_tp &lt;- mrApplyAll type_f [ev,st,ret]</span>
<span class="lineno">  371 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  372 </span><span class="spaces">        </span><span class="nottickedoff">-- Build the function for applying forNatLtThenSBody to its arguments to</span>
<span class="lineno">  373 </span><span class="spaces">        </span><span class="nottickedoff">-- define the body of the recursive definition, including the invariant</span>
<span class="lineno">  374 </span><span class="spaces">        </span><span class="nottickedoff">-- argument that is bound to the current assumptions</span>
<span class="lineno">  375 </span><span class="spaces">        </span><span class="nottickedoff">invar &lt;- mrAssumptions</span>
<span class="lineno">  376 </span><span class="spaces">        </span><span class="nottickedoff">body_fun_tm &lt;- mrGlobalTermUnfold &quot;SpecM.forNatLtThenSBody&quot;</span>
<span class="lineno">  377 </span><span class="spaces">        </span><span class="nottickedoff">let body_f rec_fun =</span>
<span class="lineno">  378 </span><span class="spaces">              </span><span class="nottickedoff">mrApplyAll body_fun_tm [ev,st,ret,n,f,k,invar,rec_fun]</span>
<span class="lineno">  379 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  380 </span><span class="spaces">        </span><span class="nottickedoff">-- Bind a fresh function var for the new recursive function</span>
<span class="lineno">  381 </span><span class="spaces">        </span><span class="nottickedoff">fun_var &lt;- mrFreshCallVar fun_tp body_f</span>
<span class="lineno">  382 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  383 </span><span class="spaces">        </span><span class="nottickedoff">-- Return the function variable applied to 0 and s0 as a normalized</span>
<span class="lineno">  384 </span><span class="spaces">        </span><span class="nottickedoff">-- computation, noting that it must be applied to all of the uvars as</span>
<span class="lineno">  385 </span><span class="spaces">        </span><span class="nottickedoff">-- well as the args</span>
<span class="lineno">  386 </span><span class="spaces">        </span><span class="nottickedoff">let var = CallSName fun_var</span>
<span class="lineno">  387 </span><span class="spaces">        </span><span class="nottickedoff">z &lt;- liftSC1 scNat 0</span>
<span class="lineno">  388 </span><span class="spaces">        </span><span class="nottickedoff">all_args &lt;- (++ [z,s0]) &lt;$&gt; getAllUVarTerms</span>
<span class="lineno">  389 </span><span class="spaces">        </span><span class="nottickedoff">FunBind var all_args &lt;$&gt; mkCompFunReturn &lt;$&gt;</span>
<span class="lineno">  390 </span><span class="spaces">          </span><span class="nottickedoff">mrFunOutType var all_args</span>
<span class="lineno">  391 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  392 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  393 </span><span class="spaces">    </span><span class="nottickedoff">-- Convert `vecMapM (bvToNat ...)` into `bvVecMapInvarM`, with the</span>
<span class="lineno">  394 </span><span class="spaces">    </span><span class="nottickedoff">-- invariant being the current set of assumptions</span>
<span class="lineno">  395 </span><span class="spaces">    </span><span class="nottickedoff">(asGlobalDef -&gt; Just &quot;CryptolM.vecMapM&quot;, [_a, _b, (asBvToNat -&gt; Just (_w, _n)),</span>
<span class="lineno">  396 </span><span class="spaces">                                              </span><span class="nottickedoff">_f, _xs]) -&gt;</span>
<span class="lineno">  397 </span><span class="spaces">      </span><span class="nottickedoff">error &quot;FIXME HERE NOW: need SpecM version of vecMapM&quot;</span>
<span class="lineno">  398 </span><span class="spaces">      </span><span class="nottickedoff">{-</span>
<span class="lineno">  399 </span><span class="spaces">      </span><span class="nottickedoff">do invar &lt;- mrAssumptions</span>
<span class="lineno">  400 </span><span class="spaces">         </span><span class="nottickedoff">liftSC2 scGlobalApply &quot;CryptolM.bvVecMapInvarM&quot;</span>
<span class="lineno">  401 </span><span class="spaces">                               </span><span class="nottickedoff">[a, b, w, n, f, xs, invar] &gt;&gt;= normCompTerm</span>
<span class="lineno">  402 </span><span class="spaces">      </span><span class="nottickedoff">-}</span>
<span class="lineno">  403 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  404 </span><span class="spaces">    </span><span class="nottickedoff">-- Convert `atM (bvToNat ...) ... (bvToNat ...)` into the unfolding of</span>
<span class="lineno">  405 </span><span class="spaces">    </span><span class="nottickedoff">-- `bvVecAtM`</span>
<span class="lineno">  406 </span><span class="spaces">    </span><span class="nottickedoff">(asGlobalDef -&gt; Just &quot;CryptolM.atM&quot;, [ev, (asBvToNat -&gt; Just (w, n)),</span>
<span class="lineno">  407 </span><span class="spaces">                                          </span><span class="nottickedoff">a, xs, i_nat]) -&gt;</span>
<span class="lineno">  408 </span><span class="spaces">      </span><span class="nottickedoff">do body &lt;- mrGlobalDefBody &quot;CryptolM.bvVecAtM&quot;</span>
<span class="lineno">  409 </span><span class="spaces">         </span><span class="nottickedoff">liftSC1 scWhnf i_nat &gt;&gt;= mrBvNatInRange w &gt;&gt;= \case</span>
<span class="lineno">  410 </span><span class="spaces">           </span><span class="nottickedoff">Just i -&gt; mrApplyAll body [ev, w, n, a, xs, i]</span>
<span class="lineno">  411 </span><span class="spaces">                       </span><span class="nottickedoff">&gt;&gt;= normCompTerm</span>
<span class="lineno">  412 </span><span class="spaces">           </span><span class="nottickedoff">_ -&gt; throwMRFailure (MalformedComp t)</span>
<span class="lineno">  413 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  414 </span><span class="spaces">    </span><span class="nottickedoff">-- Convert `atM n ... xs (bvToNat ...)` for a constant `n` into the</span>
<span class="lineno">  415 </span><span class="spaces">    </span><span class="nottickedoff">-- unfolding of `bvVecAtM` after converting `n` to a bitvector constant</span>
<span class="lineno">  416 </span><span class="spaces">    </span><span class="nottickedoff">-- and applying `genBVVecFromVec` to `xs`</span>
<span class="lineno">  417 </span><span class="spaces">    </span><span class="nottickedoff">(asGlobalDef -&gt; Just &quot;CryptolM.atM&quot;, [ev, n_tm@(asNat -&gt; Just n),</span>
<span class="lineno">  418 </span><span class="spaces">                                          </span><span class="nottickedoff">a@(asBoolType -&gt; Nothing), xs,</span>
<span class="lineno">  419 </span><span class="spaces">                                          </span><span class="nottickedoff">(asBvToNat -&gt;</span>
<span class="lineno">  420 </span><span class="spaces">                                             </span><span class="nottickedoff">Just (w_tm@(asNat -&gt; Just w),</span>
<span class="lineno">  421 </span><span class="spaces">                                                   </span><span class="nottickedoff">i))]) -&gt;</span>
<span class="lineno">  422 </span><span class="spaces">      </span><span class="nottickedoff">do body &lt;- mrGlobalDefBody &quot;CryptolM.bvVecAtM&quot;</span>
<span class="lineno">  423 </span><span class="spaces">         </span><span class="nottickedoff">if n &lt; 1 `shiftL` fromIntegral w then do</span>
<span class="lineno">  424 </span><span class="spaces">           </span><span class="nottickedoff">n' &lt;- liftSC2 scBvLit w (toInteger n)</span>
<span class="lineno">  425 </span><span class="spaces">           </span><span class="nottickedoff">xs' &lt;- mrGenBVVecFromVec n_tm a xs &quot;normComp (atM)&quot; w_tm n'</span>
<span class="lineno">  426 </span><span class="spaces">           </span><span class="nottickedoff">mrApplyAll body [ev, w_tm, n', a, xs', i] &gt;&gt;= normCompTerm</span>
<span class="lineno">  427 </span><span class="spaces">           </span><span class="nottickedoff">else throwMRFailure (MalformedComp t)</span>
<span class="lineno">  428 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  429 </span><span class="spaces">    </span><span class="nottickedoff">-- Convert `updateM (bvToNat ...) ... (bvToNat ...)` into the unfolding of</span>
<span class="lineno">  430 </span><span class="spaces">    </span><span class="nottickedoff">-- `bvVecUpdateM`</span>
<span class="lineno">  431 </span><span class="spaces">    </span><span class="nottickedoff">(asGlobalDef -&gt; Just &quot;CryptolM.updateM&quot;, [ev, (asBvToNat -&gt; Just (w, n)),</span>
<span class="lineno">  432 </span><span class="spaces">                                              </span><span class="nottickedoff">a, xs, i_nat, x]) -&gt;</span>
<span class="lineno">  433 </span><span class="spaces">      </span><span class="nottickedoff">do body &lt;- mrGlobalDefBody &quot;CryptolM.bvVecUpdateM&quot;</span>
<span class="lineno">  434 </span><span class="spaces">         </span><span class="nottickedoff">liftSC1 scWhnf i_nat &gt;&gt;= mrBvNatInRange w &gt;&gt;= \case</span>
<span class="lineno">  435 </span><span class="spaces">           </span><span class="nottickedoff">Just i -&gt; mrApplyAll body [ev, w, n, a, xs, i, x]</span>
<span class="lineno">  436 </span><span class="spaces">                       </span><span class="nottickedoff">&gt;&gt;= normCompTerm</span>
<span class="lineno">  437 </span><span class="spaces">           </span><span class="nottickedoff">_ -&gt; throwMRFailure (MalformedComp t)</span>
<span class="lineno">  438 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  439 </span><span class="spaces">    </span><span class="nottickedoff">-- Convert `updateM n ... xs (bvToNat ...)` for a constant `n` into the</span>
<span class="lineno">  440 </span><span class="spaces">    </span><span class="nottickedoff">-- unfolding of `bvVecUpdateM` after converting `n` to a bitvector constant</span>
<span class="lineno">  441 </span><span class="spaces">    </span><span class="nottickedoff">-- and applying `genBVVecFromVec` to `xs`</span>
<span class="lineno">  442 </span><span class="spaces">    </span><span class="nottickedoff">(asGlobalDef -&gt; Just &quot;CryptolM.updateM&quot;, [ev, n_tm@(asNat -&gt; Just n),</span>
<span class="lineno">  443 </span><span class="spaces">                                              </span><span class="nottickedoff">a@(asBoolType -&gt; Nothing), xs,</span>
<span class="lineno">  444 </span><span class="spaces">                                              </span><span class="nottickedoff">(asBvToNat -&gt;</span>
<span class="lineno">  445 </span><span class="spaces">                                                 </span><span class="nottickedoff">Just (w_tm@(asNat -&gt; Just w),</span>
<span class="lineno">  446 </span><span class="spaces">                                                       </span><span class="nottickedoff">i)), x]) -&gt;</span>
<span class="lineno">  447 </span><span class="spaces">      </span><span class="nottickedoff">do body &lt;- mrGlobalDefBody &quot;CryptolM.fromBVVecUpdateM&quot;</span>
<span class="lineno">  448 </span><span class="spaces">         </span><span class="nottickedoff">if n &lt; 1 `shiftL` fromIntegral w then do</span>
<span class="lineno">  449 </span><span class="spaces">           </span><span class="nottickedoff">n' &lt;- liftSC2 scBvLit w (toInteger n)</span>
<span class="lineno">  450 </span><span class="spaces">           </span><span class="nottickedoff">xs' &lt;- mrGenBVVecFromVec n_tm a xs &quot;normComp (updateM)&quot; w_tm n'</span>
<span class="lineno">  451 </span><span class="spaces">           </span><span class="nottickedoff">err_tm &lt;- mrErrorTerm a &quot;normComp (updateM)&quot;</span>
<span class="lineno">  452 </span><span class="spaces">           </span><span class="nottickedoff">mrApplyAll body [ev, w_tm, n', a, xs', i, x, err_tm, n_tm]</span>
<span class="lineno">  453 </span><span class="spaces">             </span><span class="nottickedoff">&gt;&gt;= normCompTerm</span>
<span class="lineno">  454 </span><span class="spaces">           </span><span class="nottickedoff">else throwMRFailure (MalformedComp t)</span>
<span class="lineno">  455 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  456 </span><span class="spaces">    </span><span class="nottickedoff">-- Always unfold: sawLet, Num_rec, invariantHint, assumingS, assertingS,</span>
<span class="lineno">  457 </span><span class="spaces">    </span><span class="nottickedoff">-- forNatLtThenSBody, vecMapM, vecMapBindM, seqMapM</span>
<span class="lineno">  458 </span><span class="spaces">    </span><span class="nottickedoff">(f@(asGlobalDef -&gt; Just ident), args)</span>
<span class="lineno">  459 </span><span class="spaces">      </span><span class="nottickedoff">| ident `elem`</span>
<span class="lineno">  460 </span><span class="spaces">        </span><span class="nottickedoff">[&quot;Prelude.sawLet&quot;, &quot;Prelude.ifWithProof&quot;, &quot;Prelude.iteWithProof&quot;,</span>
<span class="lineno">  461 </span><span class="spaces">         </span><span class="nottickedoff">&quot;Cryptol.Num_rec&quot;, &quot;SpecM.invariantHint&quot;,</span>
<span class="lineno">  462 </span><span class="spaces">         </span><span class="nottickedoff">&quot;SpecM.assumingS&quot;, &quot;SpecM.assertingS&quot;, &quot;SpecM.forNatLtThenSBody&quot;,</span>
<span class="lineno">  463 </span><span class="spaces">         </span><span class="nottickedoff">&quot;CryptolM.vecMapM&quot;, &quot;CryptolM.vecMapBindM&quot;, &quot;CryptolM.seqMapM&quot;]</span>
<span class="lineno">  464 </span><span class="spaces">      </span><span class="nottickedoff">, Just nm &lt;- asConstant f -&gt;</span>
<span class="lineno">  465 </span><span class="spaces">        </span><span class="nottickedoff">do body &lt;- requireDefBody ident nm</span>
<span class="lineno">  466 </span><span class="spaces">           </span><span class="nottickedoff">mrApplyAll body args &gt;&gt;= normCompTerm</span>
<span class="lineno">  467 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  468 </span><span class="spaces">    </span><span class="nottickedoff">-- Always unfold recursors applied to constructors</span>
<span class="lineno">  469 </span><span class="spaces">    </span><span class="nottickedoff">(asRecursorApp -&gt; Just (rc, crec, _, arg), args)</span>
<span class="lineno">  470 </span><span class="spaces">      </span><span class="nottickedoff">| (asConstant -&gt; Just c, cargs) &lt;- asApplyAll arg -&gt;</span>
<span class="lineno">  471 </span><span class="spaces">        </span><span class="nottickedoff">do case lookupVarIndexInMap (nameIndex c) mm of</span>
<span class="lineno">  472 </span><span class="spaces">             </span><span class="nottickedoff">Just (ResolvedCtor ctor) -&gt;</span>
<span class="lineno">  473 </span><span class="spaces">               </span><span class="nottickedoff">do let cargs' = drop (ctorNumParams ctor) cargs</span>
<span class="lineno">  474 </span><span class="spaces">                  </span><span class="nottickedoff">hd' &lt;- liftSC4 scReduceRecursor rc crec c cargs'</span>
<span class="lineno">  475 </span><span class="spaces">                         </span><span class="nottickedoff">&gt;&gt;= liftSC1 betaNormalize</span>
<span class="lineno">  476 </span><span class="spaces">                  </span><span class="nottickedoff">t' &lt;- mrApplyAll hd' args</span>
<span class="lineno">  477 </span><span class="spaces">                  </span><span class="nottickedoff">normCompTerm t'</span>
<span class="lineno">  478 </span><span class="spaces">             </span><span class="nottickedoff">_ -&gt; throwMRFailure (MalformedComp t)</span>
<span class="lineno">  479 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  480 </span><span class="spaces">    </span><span class="nottickedoff">-- Always unfold record selectors applied to record values (after scWhnf)</span>
<span class="lineno">  481 </span><span class="spaces">    </span><span class="nottickedoff">(asRecordSelector -&gt; Just (r, fld), args) -&gt;</span>
<span class="lineno">  482 </span><span class="spaces">      </span><span class="nottickedoff">do r' &lt;- liftSC1 scWhnf r</span>
<span class="lineno">  483 </span><span class="spaces">         </span><span class="nottickedoff">case asRecordValue r' of</span>
<span class="lineno">  484 </span><span class="spaces">           </span><span class="nottickedoff">Just (Map.lookup fld -&gt; Just f) -&gt; do t' &lt;- mrApplyAll f args</span>
<span class="lineno">  485 </span><span class="spaces">                                                 </span><span class="nottickedoff">normCompTerm t'</span>
<span class="lineno">  486 </span><span class="spaces">           </span><span class="nottickedoff">_ -&gt; throwMRFailure (MalformedComp t)</span>
<span class="lineno">  487 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  488 </span><span class="spaces">    </span><span class="nottickedoff">-- For a Variable, we have to check what sort of variable it is</span>
<span class="lineno">  489 </span><span class="spaces">    </span><span class="nottickedoff">-- FIXME: substitute for evars if they have been instantiated</span>
<span class="lineno">  490 </span><span class="spaces">    </span><span class="nottickedoff">((asVariable -&gt; Just ec), args) -&gt;</span>
<span class="lineno">  491 </span><span class="spaces">      </span><span class="nottickedoff">do fun_name &lt;- extCnsToFunName ec</span>
<span class="lineno">  492 </span><span class="spaces">         </span><span class="nottickedoff">FunBind fun_name args &lt;$&gt; mkCompFunReturn &lt;$&gt;</span>
<span class="lineno">  493 </span><span class="spaces">           </span><span class="nottickedoff">mrFunOutType fun_name args</span>
<span class="lineno">  494 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  495 </span><span class="spaces">    </span><span class="nottickedoff">((asGlobalFunName -&gt; Just f), args) -&gt;</span>
<span class="lineno">  496 </span><span class="spaces">      </span><span class="nottickedoff">FunBind f args &lt;$&gt; mkCompFunReturn &lt;$&gt; mrFunOutType f args</span>
<span class="lineno">  497 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  498 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; throwMRFailure (MalformedComp t)</span></span>
<span class="lineno">  499 </span>
<span class="lineno">  500 </span>
<span class="lineno">  501 </span>requireDefBody :: Ident -&gt; Name -&gt; MRM t Term
<span class="lineno">  502 </span><span class="decl"><span class="nottickedoff">requireDefBody ident nm =</span>
<span class="lineno">  503 </span><span class="spaces">  </span><span class="nottickedoff">do mm &lt;- liftSC0 scGetModuleMap</span>
<span class="lineno">  504 </span><span class="spaces">     </span><span class="nottickedoff">case lookupVarIndexInMap (nameIndex nm) mm of</span>
<span class="lineno">  505 </span><span class="spaces">       </span><span class="nottickedoff">Just (ResolvedDef (defBody -&gt; Just t)) -&gt; pure t</span>
<span class="lineno">  506 </span><span class="spaces">       </span><span class="nottickedoff">_ -&gt; panic &quot;normComp&quot; [&quot;Missing definition for constant &quot; &lt;&gt; identText ident]</span></span>
<span class="lineno">  507 </span>
<span class="lineno">  508 </span>-- | Bind a computation in whnf with a function, and normalize
<span class="lineno">  509 </span>normBind :: NormComp -&gt; CompFun -&gt; MRM t NormComp
<span class="lineno">  510 </span><span class="decl"><span class="nottickedoff">normBind (RetS t) k = applyNormCompFun k t</span>
<span class="lineno">  511 </span><span class="spaces"></span><span class="nottickedoff">normBind (ErrorS msg) _ = return (ErrorS msg)</span>
<span class="lineno">  512 </span><span class="spaces"></span><span class="nottickedoff">normBind (Ite cond comp1 comp2) k =</span>
<span class="lineno">  513 </span><span class="spaces">  </span><span class="nottickedoff">return $ Ite cond (CompBind comp1 k) (CompBind comp2 k)</span>
<span class="lineno">  514 </span><span class="spaces"></span><span class="nottickedoff">normBind (Eithers elims t) k =</span>
<span class="lineno">  515 </span><span class="spaces">  </span><span class="nottickedoff">return $ Eithers (map (\(tp,f) -&gt; (tp, compFunComp f k)) elims) t</span>
<span class="lineno">  516 </span><span class="spaces"></span><span class="nottickedoff">normBind (MaybeElim tp m f t) k =</span>
<span class="lineno">  517 </span><span class="spaces">  </span><span class="nottickedoff">return $ MaybeElim tp (CompBind m k) (compFunComp f k) t</span>
<span class="lineno">  518 </span><span class="spaces"></span><span class="nottickedoff">normBind (OrS comp1 comp2) k =</span>
<span class="lineno">  519 </span><span class="spaces">  </span><span class="nottickedoff">return $ OrS (CompBind comp1 k) (CompBind comp2 k)</span>
<span class="lineno">  520 </span><span class="spaces"></span><span class="nottickedoff">normBind (AssertBoolBind cond f) k =</span>
<span class="lineno">  521 </span><span class="spaces">  </span><span class="nottickedoff">return $ AssertBoolBind cond (compFunComp f k)</span>
<span class="lineno">  522 </span><span class="spaces"></span><span class="nottickedoff">normBind (AssumeBoolBind cond f) k =</span>
<span class="lineno">  523 </span><span class="spaces">  </span><span class="nottickedoff">return $ AssumeBoolBind cond (compFunComp f k)</span>
<span class="lineno">  524 </span><span class="spaces"></span><span class="nottickedoff">normBind (ExistsBind tp f) k = return $ ExistsBind tp (compFunComp f k)</span>
<span class="lineno">  525 </span><span class="spaces"></span><span class="nottickedoff">normBind (ForallBind tp f) k = return $ ForallBind tp (compFunComp f k)</span>
<span class="lineno">  526 </span><span class="spaces"></span><span class="nottickedoff">normBind (FunBind f args k1) k2</span>
<span class="lineno">  527 </span><span class="spaces">  </span><span class="nottickedoff">-- Turn `bvVecMapInvarM ... &gt;&gt;= k` into `bvVecMapInvarBindM ... k`</span>
<span class="lineno">  528 </span><span class="spaces">  </span><span class="nottickedoff">{-</span>
<span class="lineno">  529 </span><span class="spaces">  </span><span class="nottickedoff">| GlobalName (globalDefString -&gt; &quot;CryptolM.bvVecMapInvarM&quot;) [] &lt;- f</span>
<span class="lineno">  530 </span><span class="spaces">  </span><span class="nottickedoff">, (a:b:args_rest) &lt;- args =</span>
<span class="lineno">  531 </span><span class="spaces">    </span><span class="nottickedoff">do f' &lt;- mrGlobalDef &quot;CryptolM.bvVecMapInvarBindM&quot;</span>
<span class="lineno">  532 </span><span class="spaces">       </span><span class="nottickedoff">cont &lt;- compFunToTerm (compFunComp k1 k2)</span>
<span class="lineno">  533 </span><span class="spaces">       </span><span class="nottickedoff">c &lt;- compFunReturnType k2</span>
<span class="lineno">  534 </span><span class="spaces">       </span><span class="nottickedoff">return $ FunBind f' ((a:b:c:args_rest) ++ [cont])</span>
<span class="lineno">  535 </span><span class="spaces">                           </span><span class="nottickedoff">(CompFunReturn (Type c))</span>
<span class="lineno">  536 </span><span class="spaces">  </span><span class="nottickedoff">-- Turn `bvVecMapInvarBindM ... k1 &gt;&gt;= k2` into</span>
<span class="lineno">  537 </span><span class="spaces">  </span><span class="nottickedoff">-- `bvVecMapInvarBindM ... (composeM ... k1 k2)`</span>
<span class="lineno">  538 </span><span class="spaces">  </span><span class="nottickedoff">| GlobalName (globalDefString -&gt; &quot;CryptolM.bvVecMapInvarBindM&quot;) [] &lt;- f</span>
<span class="lineno">  539 </span><span class="spaces">  </span><span class="nottickedoff">, (args_pre, [cont]) &lt;- splitAt 8 args =</span>
<span class="lineno">  540 </span><span class="spaces">    </span><span class="nottickedoff">do cont' &lt;- compFunToTerm (compFunComp (compFunComp (CompFunTerm cont) k1) k2)</span>
<span class="lineno">  541 </span><span class="spaces">       </span><span class="nottickedoff">c &lt;- compFunReturnType k2</span>
<span class="lineno">  542 </span><span class="spaces">       </span><span class="nottickedoff">return $ FunBind f (args_pre ++ [cont']) (CompFunReturn (Type c))</span>
<span class="lineno">  543 </span><span class="spaces">  </span><span class="nottickedoff">| otherwise -} = return $ FunBind f args (compFunComp k1 k2)</span></span>
<span class="lineno">  544 </span>
<span class="lineno">  545 </span>-- | Bind a 'Term' for a computation with a function and normalize
<span class="lineno">  546 </span>normBindTerm :: Term -&gt; CompFun -&gt; MRM t NormComp
<span class="lineno">  547 </span><span class="decl"><span class="nottickedoff">normBindTerm t f = normCompTerm t &gt;&gt;= \m -&gt; normBind m f</span></span>
<span class="lineno">  548 </span>
<span class="lineno">  549 </span>{-
<span class="lineno">  550 </span>-- | Get the return type of a 'CompFun'
<span class="lineno">  551 </span>compFunReturnType :: CompFun -&gt; MRM t Term
<span class="lineno">  552 </span>compFunReturnType (CompFunTerm _ t) = mrTypeOf t
<span class="lineno">  553 </span>compFunReturnType (CompFunComp _ g) = compFunReturnType g
<span class="lineno">  554 </span>compFunReturnType (CompFunReturn _ _) = error &quot;FIXME&quot;
<span class="lineno">  555 </span>-}
<span class="lineno">  556 </span>
<span class="lineno">  557 </span>-- | Apply a computation function to a term argument to get a computation
<span class="lineno">  558 </span>applyCompFun :: CompFun -&gt; Term -&gt; MRM t Comp
<span class="lineno">  559 </span><span class="decl"><span class="nottickedoff">applyCompFun (CompFunComp f g) t =</span>
<span class="lineno">  560 </span><span class="spaces">  </span><span class="nottickedoff">-- (f &gt;=&gt; g) t == f t &gt;&gt;= g</span>
<span class="lineno">  561 </span><span class="spaces">  </span><span class="nottickedoff">do comp &lt;- applyCompFun f t</span>
<span class="lineno">  562 </span><span class="spaces">     </span><span class="nottickedoff">return $ CompBind comp g</span>
<span class="lineno">  563 </span><span class="spaces"></span><span class="nottickedoff">applyCompFun (CompFunReturn _ _) t =</span>
<span class="lineno">  564 </span><span class="spaces">  </span><span class="nottickedoff">return $ CompReturn t</span>
<span class="lineno">  565 </span><span class="spaces"></span><span class="nottickedoff">applyCompFun (CompFunTerm _ f) t = CompTerm &lt;$&gt; mrApplyAll f [t]</span></span>
<span class="lineno">  566 </span>
<span class="lineno">  567 </span>-- | Convert a 'CompFun' into a 'Term'
<span class="lineno">  568 </span>compFunToTerm :: CompFun -&gt; MRM t Term
<span class="lineno">  569 </span><span class="decl"><span class="nottickedoff">compFunToTerm (CompFunTerm _ t) = return t</span>
<span class="lineno">  570 </span><span class="spaces"></span><span class="nottickedoff">compFunToTerm (CompFunComp f g) =</span>
<span class="lineno">  571 </span><span class="spaces">  </span><span class="nottickedoff">do f' &lt;- compFunToTerm f</span>
<span class="lineno">  572 </span><span class="spaces">     </span><span class="nottickedoff">g' &lt;- compFunToTerm g</span>
<span class="lineno">  573 </span><span class="spaces">     </span><span class="nottickedoff">f_tp &lt;- mrTypeOf f'</span>
<span class="lineno">  574 </span><span class="spaces">     </span><span class="nottickedoff">g_tp &lt;- mrTypeOf g'</span>
<span class="lineno">  575 </span><span class="spaces">     </span><span class="nottickedoff">case (f_tp, g_tp) of</span>
<span class="lineno">  576 </span><span class="spaces">       </span><span class="nottickedoff">(asPi -&gt; Just (_, a, asSpecM -&gt; Just (ev, b)),</span>
<span class="lineno">  577 </span><span class="spaces">        </span><span class="nottickedoff">asPi -&gt; Just (_, _, asSpecM -&gt; Just (_, c))) -&gt;</span>
<span class="lineno">  578 </span><span class="spaces">         </span><span class="nottickedoff">-- we explicitly unfold @SpecM.composeS@ here so @mrApplyAll@ will</span>
<span class="lineno">  579 </span><span class="spaces">         </span><span class="nottickedoff">-- beta-reduce</span>
<span class="lineno">  580 </span><span class="spaces">         </span><span class="nottickedoff">let nm = maybe &quot;ret_val&quot; id (compFunVarName f) in</span>
<span class="lineno">  581 </span><span class="spaces">         </span><span class="nottickedoff">mrLambdaLift1 (nm, a) (b, c, f', g') $ \arg (b', c', f'', g'') -&gt;</span>
<span class="lineno">  582 </span><span class="spaces">           </span><span class="nottickedoff">do app &lt;- mrApplyAll f'' [arg]</span>
<span class="lineno">  583 </span><span class="spaces">              </span><span class="nottickedoff">liftSC2 scGlobalApply &quot;SpecM.bindS&quot; [unEvTerm ev,</span>
<span class="lineno">  584 </span><span class="spaces">                                                   </span><span class="nottickedoff">b', c', app, g'']</span>
<span class="lineno">  585 </span><span class="spaces">       </span><span class="nottickedoff">_ -&gt; error &quot;compFunToTerm: type(s) not of the form: a -&gt; SpecM b&quot;</span>
<span class="lineno">  586 </span><span class="spaces"></span><span class="nottickedoff">compFunToTerm (CompFunReturn ev (Type a)) =</span>
<span class="lineno">  587 </span><span class="spaces">  </span><span class="nottickedoff">mrLambdaLift1 (&quot;ret_val&quot;, a) a $ \ret_val a' -&gt;</span>
<span class="lineno">  588 </span><span class="spaces">    </span><span class="nottickedoff">liftSC2 scGlobalApply &quot;SpecM.retS&quot; [unEvTerm ev, a', ret_val]</span></span>
<span class="lineno">  589 </span>
<span class="lineno">  590 </span>{-
<span class="lineno">  591 </span>-- | Convert a 'Comp' into a 'Term'
<span class="lineno">  592 </span>compToTerm :: Comp -&gt; MRM t Term
<span class="lineno">  593 </span>compToTerm (CompTerm t) = return t
<span class="lineno">  594 </span>compToTerm (CompReturn t) =
<span class="lineno">  595 </span>   do tp &lt;- mrTypeOf t
<span class="lineno">  596 </span>      liftSC2 scGlobalApply &quot;SpecM.retS&quot; [tp, t]
<span class="lineno">  597 </span>compToTerm (CompBind m (CompFunReturn _)) = compToTerm m
<span class="lineno">  598 </span>compToTerm (CompBind m f) =
<span class="lineno">  599 </span>  do m' &lt;- compToTerm m
<span class="lineno">  600 </span>     f' &lt;- compFunToTerm f
<span class="lineno">  601 </span>     mrTypeOf f' &gt;&gt;= \case
<span class="lineno">  602 </span>       (asPi -&gt; Just (_, a, asSpecM -&gt; Just b)) -&gt;
<span class="lineno">  603 </span>         liftSC2 scGlobalApply &quot;SpecM.bindS&quot; [a, b, m', f']
<span class="lineno">  604 </span>       _ -&gt; error &quot;compToTerm: type not of the form: a -&gt; SpecM b&quot;
<span class="lineno">  605 </span>-}
<span class="lineno">  606 </span>
<span class="lineno">  607 </span>-- | Apply a 'CompFun' to a term and normalize the resulting computation
<span class="lineno">  608 </span>applyNormCompFun :: CompFun -&gt; Term -&gt; MRM t NormComp
<span class="lineno">  609 </span><span class="decl"><span class="nottickedoff">applyNormCompFun f arg = applyCompFun f arg &gt;&gt;= normComp</span></span>
<span class="lineno">  610 </span>
<span class="lineno">  611 </span>
<span class="lineno">  612 </span>-- | Convert a 'FunAssumpRHS' to a 'NormComp'
<span class="lineno">  613 </span>mrFunAssumpRHSAsNormComp :: FunAssumpRHS -&gt; MRM t NormComp
<span class="lineno">  614 </span><span class="decl"><span class="nottickedoff">mrFunAssumpRHSAsNormComp (OpaqueFunAssump f args) =</span>
<span class="lineno">  615 </span><span class="spaces">  </span><span class="nottickedoff">FunBind f args &lt;$&gt; mkCompFunReturn &lt;$&gt; mrFunOutType f args</span>
<span class="lineno">  616 </span><span class="spaces"></span><span class="nottickedoff">mrFunAssumpRHSAsNormComp (RewriteFunAssump rhs) = normCompTerm rhs</span></span>
<span class="lineno">  617 </span>
<span class="lineno">  618 </span>
<span class="lineno">  619 </span>-- | Match a term as a static list of eliminators for an Eithers type
<span class="lineno">  620 </span>matchEitherElims :: Term -&gt; Maybe [EitherElim]
<span class="lineno">  621 </span><span class="decl"><span class="nottickedoff">matchEitherElims (asGlobalApply &quot;Prelude.FunsTo_Nil&quot; -&gt; Just [_]) = Just []</span>
<span class="lineno">  622 </span><span class="spaces"></span><span class="nottickedoff">matchEitherElims (asGlobalApply &quot;Prelude.FunsTo_Cons&quot; -&gt; Just [asSpecM -&gt; Just (ev, _), tp, f, rest]) =</span>
<span class="lineno">  623 </span><span class="spaces">  </span><span class="nottickedoff">((Type tp, CompFunTerm ev f):) &lt;$&gt;</span>
<span class="lineno">  624 </span><span class="spaces">  </span><span class="nottickedoff">matchEitherElims rest</span>
<span class="lineno">  625 </span><span class="spaces"></span><span class="nottickedoff">matchEitherElims _ = Nothing</span></span>
<span class="lineno">  626 </span>
<span class="lineno">  627 </span>-- | Construct the type @Eithers tps@ eliminated by a list of 'EitherElim's
<span class="lineno">  628 </span>elimsEithersType :: [EitherElim] -&gt; MRM t Type
<span class="lineno">  629 </span><span class="decl"><span class="nottickedoff">elimsEithersType elims =</span>
<span class="lineno">  630 </span><span class="spaces">  </span><span class="nottickedoff">Type &lt;$&gt;</span>
<span class="lineno">  631 </span><span class="spaces">  </span><span class="nottickedoff">(do f &lt;- mrGlobalTerm &quot;Prelude.Eithers&quot;</span>
<span class="lineno">  632 </span><span class="spaces">      </span><span class="nottickedoff">tps &lt;-</span>
<span class="lineno">  633 </span><span class="spaces">        </span><span class="nottickedoff">foldr</span>
<span class="lineno">  634 </span><span class="spaces">        </span><span class="nottickedoff">(\(Type tp,_) restM -&gt;</span>
<span class="lineno">  635 </span><span class="spaces">          </span><span class="nottickedoff">restM &gt;&gt;= \rest -&gt; mrCtorApp &quot;Prelude.LS_Cons&quot; [tp,rest])</span>
<span class="lineno">  636 </span><span class="spaces">        </span><span class="nottickedoff">(mrCtorApp &quot;Prelude.LS_Nil&quot; [])</span>
<span class="lineno">  637 </span><span class="spaces">        </span><span class="nottickedoff">elims</span>
<span class="lineno">  638 </span><span class="spaces">      </span><span class="nottickedoff">mrApply f tps)</span></span>
<span class="lineno">  639 </span>
<span class="lineno">  640 </span>
<span class="lineno">  641 </span>{- FIXME: do these go away?
<span class="lineno">  642 </span>-- | Lookup the definition of a function or throw a 'CannotLookupFunDef' if this is
<span class="lineno">  643 </span>-- not allowed, either because it is a global function we are treating as opaque
<span class="lineno">  644 </span>-- or because it is a locally-bound function variable
<span class="lineno">  645 </span>mrLookupFunDef :: FunName -&gt; MRM t Term
<span class="lineno">  646 </span>mrLookupFunDef f@(GlobalName _) = throwMRFailure (CannotLookupFunDef f)
<span class="lineno">  647 </span>mrLookupFunDef f@(LocalName var) =
<span class="lineno">  648 </span>  mrVarInfo var &gt;&gt;= \case
<span class="lineno">  649 </span>  Just (FunVarInfo body) -&gt; return body
<span class="lineno">  650 </span>  Just _ -&gt; throwMRFailure (CannotLookupFunDef f)
<span class="lineno">  651 </span>  Nothing -&gt; error &quot;mrLookupFunDef: unknown variable!&quot;
<span class="lineno">  652 </span>
<span class="lineno">  653 </span>-- | Unfold a call to function @f@ in term @f args &gt;&gt;= g@
<span class="lineno">  654 </span>mrUnfoldFunBind :: FunName -&gt; [Term] -&gt; Mark -&gt; CompFun -&gt; MRM t Comp
<span class="lineno">  655 </span>mrUnfoldFunBind f _ mark _ | inMark f mark = throwMRFailure (RecursiveUnfold f)
<span class="lineno">  656 </span>mrUnfoldFunBind f args mark g =
<span class="lineno">  657 </span>  do f_def &lt;- mrLookupFunDef f
<span class="lineno">  658 </span>     CompBind &lt;$&gt;
<span class="lineno">  659 </span>       (CompMark &lt;$&gt; (CompTerm &lt;$&gt; liftSC2 scApplyAll f_def args)
<span class="lineno">  660 </span>        &lt;*&gt; (return $ singleMark f `mappend` mark))
<span class="lineno">  661 </span>       &lt;*&gt; return g
<span class="lineno">  662 </span>-}
<span class="lineno">  663 </span>
<span class="lineno">  664 </span>{-
<span class="lineno">  665 </span>FIXME HERE: maybe each FunName should stipulate whether it is recursive or
<span class="lineno">  666 </span>not, so that mrRefines can unfold the non-recursive ones early but wait on
<span class="lineno">  667 </span>handling the recursive ones
<span class="lineno">  668 </span>-}
<span class="lineno">  669 </span>
<span class="lineno">  670 </span>
<span class="lineno">  671 </span>----------------------------------------------------------------------
<span class="lineno">  672 </span>-- * Handling Coinductive Hypotheses
<span class="lineno">  673 </span>----------------------------------------------------------------------
<span class="lineno">  674 </span>
<span class="lineno">  675 </span>-- | Prove the invariant of a coinductive hypothesis
<span class="lineno">  676 </span>proveCoIndHypInvariant :: CoIndHyp -&gt; MRM t ()
<span class="lineno">  677 </span><span class="decl"><span class="nottickedoff">proveCoIndHypInvariant hyp =</span>
<span class="lineno">  678 </span><span class="spaces">  </span><span class="nottickedoff">do (invar1, invar2) &lt;- applyCoIndHypInvariants hyp</span>
<span class="lineno">  679 </span><span class="spaces">     </span><span class="nottickedoff">invar &lt;- liftSC2 scAnd invar1 invar2</span>
<span class="lineno">  680 </span><span class="spaces">     </span><span class="nottickedoff">success &lt;- mrProvable invar</span>
<span class="lineno">  681 </span><span class="spaces">     </span><span class="nottickedoff">if success then return () else</span>
<span class="lineno">  682 </span><span class="spaces">       </span><span class="nottickedoff">throwMRFailure $</span>
<span class="lineno">  683 </span><span class="spaces">       </span><span class="nottickedoff">InvariantNotProvable (coIndHypLHSFun hyp) (coIndHypRHSFun hyp) invar</span></span>
<span class="lineno">  684 </span>
<span class="lineno">  685 </span>-- | Co-inductively prove the refinement
<span class="lineno">  686 </span>--
<span class="lineno">  687 </span>-- &gt; forall x1, ..., xn. preF y1 ... ym -&gt; preG z1 ... zl -&gt;
<span class="lineno">  688 </span>-- &gt;   F y1 ... ym |= G z1 ... zl@
<span class="lineno">  689 </span>--
<span class="lineno">  690 </span>-- where @F@ and @G@ are the given 'FunName's, @y1, ..., ym@ and @z1, ..., zl@
<span class="lineno">  691 </span>-- are the given argument lists, @x1, ..., xn@ is the current context of uvars,
<span class="lineno">  692 </span>-- and @invarF@ and @invarG@ are the invariants associated with @F@ and @G@,
<span class="lineno">  693 </span>-- respectively. This proof is performed by coinductively assuming the
<span class="lineno">  694 </span>-- refinement holds and proving the refinement with the definitions of @F@ and
<span class="lineno">  695 </span>-- @G@ unfolded to their bodies. Note that this refinement is performed with
<span class="lineno">  696 </span>-- /only/ the invariants @invarF@ and @invarG@ as assumptions; all other
<span class="lineno">  697 </span>-- assumptions are thrown away. If while running the refinement computation a
<span class="lineno">  698 </span>-- 'CoIndHypMismatchWidened' error is reached with the given names, the state is
<span class="lineno">  699 </span>-- restored and the computation is re-run with the widened hypothesis.
<span class="lineno">  700 </span>mrRefinesCoInd :: FunName -&gt; [Term] -&gt; FunName -&gt; [Term] -&gt; MRM t ()
<span class="lineno">  701 </span><span class="decl"><span class="nottickedoff">mrRefinesCoInd f1 args1 f2 args2 =</span>
<span class="lineno">  702 </span><span class="spaces">  </span><span class="nottickedoff">do ctx &lt;- mrUVars</span>
<span class="lineno">  703 </span><span class="spaces">     </span><span class="nottickedoff">preF1 &lt;- mrGetInvariant f1</span>
<span class="lineno">  704 </span><span class="spaces">     </span><span class="nottickedoff">preF2 &lt;- mrGetInvariant f2</span>
<span class="lineno">  705 </span><span class="spaces">     </span><span class="nottickedoff">let hyp = CoIndHyp ctx f1 f2 args1 args2 preF1 preF2</span>
<span class="lineno">  706 </span><span class="spaces">     </span><span class="nottickedoff">proveCoIndHypInvariant hyp</span>
<span class="lineno">  707 </span><span class="spaces">     </span><span class="nottickedoff">proveCoIndHyp [] hyp</span></span>
<span class="lineno">  708 </span>
<span class="lineno">  709 </span>-- | Prove the refinement represented by a 'CoIndHyp' coinductively. This is the
<span class="lineno">  710 </span>-- main loop implementing 'mrRefinesCoInd'. See that function for documentation.
<span class="lineno">  711 </span>proveCoIndHyp :: [[Either Int Int]] -&gt; CoIndHyp -&gt; MRM t ()
<span class="lineno">  712 </span><span class="decl"><span class="nottickedoff">proveCoIndHyp prev_specs hyp = withFailureCtx (FailCtxCoIndHyp hyp) $</span>
<span class="lineno">  713 </span><span class="spaces">  </span><span class="nottickedoff">do let f1 = coIndHypLHSFun hyp</span>
<span class="lineno">  714 </span><span class="spaces">         </span><span class="nottickedoff">f2 = coIndHypRHSFun hyp</span>
<span class="lineno">  715 </span><span class="spaces">         </span><span class="nottickedoff">args1 = coIndHypLHS hyp</span>
<span class="lineno">  716 </span><span class="spaces">         </span><span class="nottickedoff">args2 = coIndHypRHS hyp</span>
<span class="lineno">  717 </span><span class="spaces">     </span><span class="nottickedoff">mrDebugPPInCtxM 1 (prettyWithCtx emptyMRVarCtx $</span>
<span class="lineno">  718 </span><span class="spaces">                        </span><span class="nottickedoff">prettyPrefix &quot;proveCoIndHyp&quot; hyp)</span>
<span class="lineno">  719 </span><span class="spaces">     </span><span class="nottickedoff">lhs &lt;- fromMaybe (error &quot;proveCoIndHyp&quot;) &lt;$&gt; mrFunBody f1 args1</span>
<span class="lineno">  720 </span><span class="spaces">     </span><span class="nottickedoff">rhs &lt;- fromMaybe (error &quot;proveCoIndHyp&quot;) &lt;$&gt; mrFunBody f2 args2</span>
<span class="lineno">  721 </span><span class="spaces">     </span><span class="nottickedoff">(invar1, invar2) &lt;- applyCoIndHypInvariants hyp</span>
<span class="lineno">  722 </span><span class="spaces">     </span><span class="nottickedoff">invar &lt;- liftSC2 scAnd invar1 invar2</span>
<span class="lineno">  723 </span><span class="spaces">     </span><span class="nottickedoff">(withOnlyUVars (coIndHypCtx hyp) $ withOnlyAssumption invar $</span>
<span class="lineno">  724 </span><span class="spaces">      </span><span class="nottickedoff">withCoIndHyp hyp $ mrRefines lhs rhs) `catchError` \case</span>
<span class="lineno">  725 </span><span class="spaces">       </span><span class="nottickedoff">MRExnWiden nm1' nm2' new_vars</span>
<span class="lineno">  726 </span><span class="spaces">         </span><span class="nottickedoff">| f1 == nm1' &amp;&amp; f2 == nm2' &amp;&amp; elem new_vars prev_specs -&gt;</span>
<span class="lineno">  727 </span><span class="spaces">           </span><span class="nottickedoff">-- This should never happen, since it means that generalizing</span>
<span class="lineno">  728 </span><span class="spaces">           </span><span class="nottickedoff">-- new_vars led to the exact same arguments not unifying, but at</span>
<span class="lineno">  729 </span><span class="spaces">           </span><span class="nottickedoff">-- least one more should unify when we generalize</span>
<span class="lineno">  730 </span><span class="spaces">           </span><span class="nottickedoff">panic &quot;proveCoIndHyp&quot; [&quot;Generalization loop detected!&quot;]</span>
<span class="lineno">  731 </span><span class="spaces">         </span><span class="nottickedoff">| f1 == nm1' &amp;&amp; f2 == nm2' -&gt;</span>
<span class="lineno">  732 </span><span class="spaces">           </span><span class="nottickedoff">-- NOTE: the state automatically gets reset here because we defined</span>
<span class="lineno">  733 </span><span class="spaces">           </span><span class="nottickedoff">-- MRM t with ExceptT at a lower level than StateT</span>
<span class="lineno">  734 </span><span class="spaces">           </span><span class="nottickedoff">do mrDebugPPPrefixSep 1 &quot;Widening recursive assumption for&quot; nm1' &quot;|=&quot; nm2'</span>
<span class="lineno">  735 </span><span class="spaces">              </span><span class="nottickedoff">hyp' &lt;- generalizeCoIndHyp hyp new_vars</span>
<span class="lineno">  736 </span><span class="spaces">              </span><span class="nottickedoff">proveCoIndHyp (new_vars:prev_specs) hyp'</span>
<span class="lineno">  737 </span><span class="spaces">       </span><span class="nottickedoff">e -&gt; throwError e</span></span>
<span class="lineno">  738 </span>
<span class="lineno">  739 </span>-- | Test that a coinductive hypothesis for the given function names matches the
<span class="lineno">  740 </span>-- given arguments, otherwise throw an exception saying that widening is needed
<span class="lineno">  741 </span>matchCoIndHyp :: CoIndHyp -&gt; [Term] -&gt; [Term] -&gt; MRM t ()
<span class="lineno">  742 </span><span class="decl"><span class="nottickedoff">matchCoIndHyp hyp args1 args2 =</span>
<span class="lineno">  743 </span><span class="spaces">  </span><span class="nottickedoff">do mrDebugPPPrefix 1 &quot;matchCoIndHyp&quot; hyp</span>
<span class="lineno">  744 </span><span class="spaces">     </span><span class="nottickedoff">(args1', args2') &lt;- instantiateCoIndHyp hyp</span>
<span class="lineno">  745 </span><span class="spaces">     </span><span class="nottickedoff">mrDebugPPPrefixSep 3 &quot;matchCoIndHyp args&quot; args1 &quot;,&quot; args2</span>
<span class="lineno">  746 </span><span class="spaces">     </span><span class="nottickedoff">mrDebugPPPrefixSep 3 &quot;matchCoIndHyp args'&quot; args1' &quot;,&quot; args2'</span>
<span class="lineno">  747 </span><span class="spaces">     </span><span class="nottickedoff">eqs1 &lt;- zipWithM mrProveEqBiRef args1' args1</span>
<span class="lineno">  748 </span><span class="spaces">     </span><span class="nottickedoff">eqs2 &lt;- zipWithM mrProveEqBiRef args2' args2</span>
<span class="lineno">  749 </span><span class="spaces">     </span><span class="nottickedoff">if and (eqs1 ++ eqs2) then return () else</span>
<span class="lineno">  750 </span><span class="spaces">       </span><span class="nottickedoff">throwError $ MRExnWiden (coIndHypLHSFun hyp) (coIndHypRHSFun hyp)</span>
<span class="lineno">  751 </span><span class="spaces">       </span><span class="nottickedoff">(map Left (findIndices not eqs1) ++ map Right (findIndices not eqs2))</span>
<span class="lineno">  752 </span><span class="spaces">     </span><span class="nottickedoff">proveCoIndHypInvariant hyp</span></span>
<span class="lineno">  753 </span>
<span class="lineno">  754 </span>-- | Generalize a coinductive hypothesis of the form
<span class="lineno">  755 </span>--
<span class="lineno">  756 </span>-- &gt; forall x1..xn. f args_l |= g args_r
<span class="lineno">  757 </span>--
<span class="lineno">  758 </span>-- by replacing some of the arguments with fresh variables that are added to the
<span class="lineno">  759 </span>-- coinductive hypothesis, i.e., to the list @x1..xn@ of quantified variables.
<span class="lineno">  760 </span>-- The arguments that need to be generalized are given by index on either the
<span class="lineno">  761 </span>-- left- or right-hand list of arguments. Any of the arguments being generalized
<span class="lineno">  762 </span>-- that are equivalent (in the sense of 'mrProveRel') get generalized to the
<span class="lineno">  763 </span>-- same fresh variable, so we preserve as much equality as we can between
<span class="lineno">  764 </span>-- arguments being generalized. Note that generalized arguments are not unified
<span class="lineno">  765 </span>-- with non-generalized arguments, since they are being generalized because they
<span class="lineno">  766 </span>-- didn't match the non-generalized arguments in some refinement call that the
<span class="lineno">  767 </span>-- solver tried to make and couldn't.
<span class="lineno">  768 </span>generalizeCoIndHyp :: CoIndHyp -&gt; [Either Int Int] -&gt; MRM t CoIndHyp
<span class="lineno">  769 </span><span class="decl"><span class="nottickedoff">generalizeCoIndHyp hyp [] = return hyp</span>
<span class="lineno">  770 </span><span class="spaces"></span><span class="nottickedoff">generalizeCoIndHyp hyp all_specs@(arg_spec_0:arg_specs) =</span>
<span class="lineno">  771 </span><span class="spaces">  </span><span class="nottickedoff">withOnlyUVars (coIndHypCtx hyp) $ do</span>
<span class="lineno">  772 </span><span class="spaces">  </span><span class="nottickedoff">withNoUVars $ mrDebugPPPrefixSep 2 &quot;generalizeCoIndHyp with indices&quot;</span>
<span class="lineno">  773 </span><span class="spaces">                                     </span><span class="nottickedoff">all_specs &quot;on&quot; hyp</span>
<span class="lineno">  774 </span><span class="spaces">  </span><span class="nottickedoff">-- Get the arg and type associated with the first arg_spec and build an</span>
<span class="lineno">  775 </span><span class="spaces">  </span><span class="nottickedoff">-- injective representation for it, keeping track of the representation term</span>
<span class="lineno">  776 </span><span class="spaces">  </span><span class="nottickedoff">-- and type</span>
<span class="lineno">  777 </span><span class="spaces">  </span><span class="nottickedoff">let arg_tm_0 = coIndHypArg hyp arg_spec_0</span>
<span class="lineno">  778 </span><span class="spaces">  </span><span class="nottickedoff">arg_tp_0 &lt;- mrTypeOf arg_tm_0 &gt;&gt;= mrNormOpenTerm</span>
<span class="lineno">  779 </span><span class="spaces">  </span><span class="nottickedoff">(tp_r0, tm_r0, repr0) &lt;- mkInjReprTerm arg_tp_0 arg_tm_0</span>
<span class="lineno">  780 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  781 </span><span class="spaces">  </span><span class="nottickedoff">-- Attempt to unify the representation of arg 0 with each of the arg_specs</span>
<span class="lineno">  782 </span><span class="spaces">  </span><span class="nottickedoff">-- being generalized using injUnifyRepr. When unification succeeds, this could</span>
<span class="lineno">  783 </span><span class="spaces">  </span><span class="nottickedoff">-- result in a more specific representation type, so use injReprRestrict to</span>
<span class="lineno">  784 </span><span class="spaces">  </span><span class="nottickedoff">-- update the representations of all the arguments that have already been</span>
<span class="lineno">  785 </span><span class="spaces">  </span><span class="nottickedoff">-- unified with arg 0</span>
<span class="lineno">  786 </span><span class="spaces">  </span><span class="nottickedoff">(tp_r, _, repr, eq_args, arg_reprs, uneq_args) &lt;-</span>
<span class="lineno">  787 </span><span class="spaces">    </span><span class="nottickedoff">foldM</span>
<span class="lineno">  788 </span><span class="spaces">    </span><span class="nottickedoff">(\(tp_r, tm_r, repr, eq_args, arg_reprs, uneq_args) arg_spec -&gt;</span>
<span class="lineno">  789 </span><span class="spaces">      </span><span class="nottickedoff">do let arg_tm = coIndHypArg hyp arg_spec</span>
<span class="lineno">  790 </span><span class="spaces">         </span><span class="nottickedoff">arg_tp &lt;- mrTypeOf arg_tm &gt;&gt;= mrNormOpenTerm</span>
<span class="lineno">  791 </span><span class="spaces">         </span><span class="nottickedoff">unify_res &lt;- injUnifyRepr tp_r tm_r repr arg_tp arg_tm</span>
<span class="lineno">  792 </span><span class="spaces">         </span><span class="nottickedoff">case unify_res of</span>
<span class="lineno">  793 </span><span class="spaces">           </span><span class="nottickedoff">Just (tp_r',tm_r',repr',arg_repr) -&gt;</span>
<span class="lineno">  794 </span><span class="spaces">             </span><span class="nottickedoff">-- If unification succeeds, add arg to the list of eq_args and add</span>
<span class="lineno">  795 </span><span class="spaces">             </span><span class="nottickedoff">-- its repr to the list of arg_reprs, and restrict the previous</span>
<span class="lineno">  796 </span><span class="spaces">             </span><span class="nottickedoff">-- arg_reprs to use the new representation type tp_r'</span>
<span class="lineno">  797 </span><span class="spaces">             </span><span class="nottickedoff">do arg_reprs' &lt;- mapM (injReprRestrict tp_r' repr' tp_r) arg_reprs</span>
<span class="lineno">  798 </span><span class="spaces">                </span><span class="nottickedoff">return (tp_r', tm_r', repr',</span>
<span class="lineno">  799 </span><span class="spaces">                        </span><span class="nottickedoff">arg_spec:eq_args, arg_repr:arg_reprs', uneq_args)</span>
<span class="lineno">  800 </span><span class="spaces">           </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno">  801 </span><span class="spaces">             </span><span class="nottickedoff">-- If unification fails, add arg_spec to the list of uneq_args</span>
<span class="lineno">  802 </span><span class="spaces">             </span><span class="nottickedoff">return (tp_r, tm_r, repr, eq_args, arg_reprs, arg_spec:uneq_args))</span>
<span class="lineno">  803 </span><span class="spaces">    </span><span class="nottickedoff">(tp_r0, tm_r0, repr0, [], [], [])</span>
<span class="lineno">  804 </span><span class="spaces">    </span><span class="nottickedoff">arg_specs</span>
<span class="lineno">  805 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  806 </span><span class="spaces">  </span><span class="nottickedoff">-- Now we generalize the arguments that unify with arg_spec0 by adding a new</span>
<span class="lineno">  807 </span><span class="spaces">  </span><span class="nottickedoff">-- variable z of type tp_r to hyp and setting each arg in eq_args to the</span>
<span class="lineno">  808 </span><span class="spaces">  </span><span class="nottickedoff">-- result of applying its corresponding repr to z</span>
<span class="lineno">  809 </span><span class="spaces">  </span><span class="nottickedoff">(hyp', var) &lt;- coIndHypWithVar hyp &quot;z&quot; (Type tp_r)</span>
<span class="lineno">  810 </span><span class="spaces">  </span><span class="nottickedoff">arg_reprs' &lt;- liftTermLike 0 1 (repr:arg_reprs)</span>
<span class="lineno">  811 </span><span class="spaces">  </span><span class="nottickedoff">hyp'' &lt;- foldlM (\hyp_i (arg_spec_i, repr_i) -&gt;</span>
<span class="lineno">  812 </span><span class="spaces">                    </span><span class="nottickedoff">coIndHypSetArg hyp_i arg_spec_i &lt;$&gt; mrApplyRepr repr_i var)</span>
<span class="lineno">  813 </span><span class="spaces">                  </span><span class="nottickedoff">hyp' (zip (arg_spec_0:eq_args) arg_reprs')</span>
<span class="lineno">  814 </span><span class="spaces">  </span><span class="nottickedoff">-- We finish by recursing on any remaining arg_specs</span>
<span class="lineno">  815 </span><span class="spaces">  </span><span class="nottickedoff">generalizeCoIndHyp hyp'' uneq_args</span></span>
<span class="lineno">  816 </span>
<span class="lineno">  817 </span>
<span class="lineno">  818 </span>----------------------------------------------------------------------
<span class="lineno">  819 </span>-- * Decidable Propositions
<span class="lineno">  820 </span>----------------------------------------------------------------------
<span class="lineno">  821 </span>
<span class="lineno">  822 </span>-- | A function for assuming a proposition or its negation, that also lifts a
<span class="lineno">  823 </span>-- 'TermLike' argument in the sense of 'withUVarLift'
<span class="lineno">  824 </span>newtype AssumpFun t = AssumpFun { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">appAssumpFun</span></span></span> ::
<span class="lineno">  825 </span>                                    forall tm a. TermLike tm =&gt;
<span class="lineno">  826 </span>                                    Bool -&gt; tm -&gt; (tm -&gt; MRM t a) -&gt; MRM t a }
<span class="lineno">  827 </span>
<span class="lineno">  828 </span>-- | Test if a 'Term' is a propostion that has a corresponding Boolean SAW core
<span class="lineno">  829 </span>-- term that decides it; e.g., IsLtNat n m is a Prop that corresponds to the
<span class="lineno">  830 </span>-- Boolean expression ltNat n m. If so, return the Boolean expression
<span class="lineno">  831 </span>asBoolProp :: Term -&gt; Maybe (MRM t Term)
<span class="lineno">  832 </span><span class="decl"><span class="nottickedoff">asBoolProp (asEq -&gt; Just (asSimpleEq -&gt; Just eqf, e1, e2)) =</span>
<span class="lineno">  833 </span><span class="spaces">  </span><span class="nottickedoff">Just $ liftSC2 eqf e1 e2</span>
<span class="lineno">  834 </span><span class="spaces"></span><span class="nottickedoff">asBoolProp (asApplyAll -&gt; (isGlobalDef &quot;Prelude.IsLtNat&quot; -&gt; Just (), [n,m])) =</span>
<span class="lineno">  835 </span><span class="spaces">  </span><span class="nottickedoff">Just $ liftSC2 scLtNat n m</span>
<span class="lineno">  836 </span><span class="spaces"></span><span class="nottickedoff">asBoolProp _ = Nothing</span></span>
<span class="lineno">  837 </span>
<span class="lineno">  838 </span>-- | Test if a 'Term' is a propostion that MR solver can decide, i.e., test if
<span class="lineno">  839 </span>-- it or its negation holds. If so, return: a function to decide the propostion,
<span class="lineno">  840 </span>-- that returns 'Just' of a Boolean iff the proposition definitely does or does
<span class="lineno">  841 </span>-- not hold; and a function to assume the proposition or its negation in a
<span class="lineno">  842 </span>-- sub-computation. This latter function also takes a 'TermLike' that it will
<span class="lineno">  843 </span>-- lift in the sense of 'withUVarLift' in the sub-computation.
<span class="lineno">  844 </span>asDecProp :: Term -&gt; Maybe (MRM t (Maybe Bool, AssumpFun t))
<span class="lineno">  845 </span><span class="decl"><span class="nottickedoff">asDecProp (asBoolProp -&gt; Just condM) =</span>
<span class="lineno">  846 </span><span class="spaces">  </span><span class="nottickedoff">Just $</span>
<span class="lineno">  847 </span><span class="spaces">  </span><span class="nottickedoff">do cond &lt;- condM</span>
<span class="lineno">  848 </span><span class="spaces">     </span><span class="nottickedoff">not_cond &lt;- liftSC1 scNot cond</span>
<span class="lineno">  849 </span><span class="spaces">     </span><span class="nottickedoff">let assumeM b tm m = withAssumption (if b then cond else not_cond) (m tm)</span>
<span class="lineno">  850 </span><span class="spaces">     </span><span class="nottickedoff">mrProvable cond &gt;&gt;= \case</span>
<span class="lineno">  851 </span><span class="spaces">       </span><span class="nottickedoff">True -&gt; return (Just True, AssumpFun assumeM)</span>
<span class="lineno">  852 </span><span class="spaces">       </span><span class="nottickedoff">False -&gt;</span>
<span class="lineno">  853 </span><span class="spaces">         </span><span class="nottickedoff">mrProvable not_cond &gt;&gt;= \case</span>
<span class="lineno">  854 </span><span class="spaces">         </span><span class="nottickedoff">True -&gt; return (Just False, AssumpFun assumeM)</span>
<span class="lineno">  855 </span><span class="spaces">         </span><span class="nottickedoff">False -&gt; return (Nothing, AssumpFun assumeM)</span>
<span class="lineno">  856 </span><span class="spaces"></span><span class="nottickedoff">asDecProp (asIsFinite -&gt; Just n) =</span>
<span class="lineno">  857 </span><span class="spaces">  </span><span class="nottickedoff">Just $</span>
<span class="lineno">  858 </span><span class="spaces">  </span><span class="nottickedoff">do n_norm &lt;- mrNormOpenTerm n</span>
<span class="lineno">  859 </span><span class="spaces">     </span><span class="nottickedoff">maybe_assump &lt;- mrGetDataTypeAssump n_norm</span>
<span class="lineno">  860 </span><span class="spaces">     </span><span class="nottickedoff">-- The assumption function that requires b == req, in which case it is just</span>
<span class="lineno">  861 </span><span class="spaces">     </span><span class="nottickedoff">-- the identity, and otherwise panics</span>
<span class="lineno">  862 </span><span class="spaces">     </span><span class="nottickedoff">let requireIdAssumeM req b tm m =</span>
<span class="lineno">  863 </span><span class="spaces">           </span><span class="nottickedoff">if req == b then m tm else</span>
<span class="lineno">  864 </span><span class="spaces">             </span><span class="nottickedoff">panic &quot;asDecProp&quot; [&quot;Unexpected inconsistent assumption&quot;]</span>
<span class="lineno">  865 </span><span class="spaces">     </span><span class="nottickedoff">case (maybe_assump, asNum n_norm) of</span>
<span class="lineno">  866 </span><span class="spaces">       </span><span class="nottickedoff">(_, Just (Left _)) -&gt;</span>
<span class="lineno">  867 </span><span class="spaces">         </span><span class="nottickedoff">return (Just True, AssumpFun (requireIdAssumeM True))</span>
<span class="lineno">  868 </span><span class="spaces">       </span><span class="nottickedoff">(_, Just (Right _)) -&gt;</span>
<span class="lineno">  869 </span><span class="spaces">         </span><span class="nottickedoff">return (Just False, AssumpFun (requireIdAssumeM False))</span>
<span class="lineno">  870 </span><span class="spaces">       </span><span class="nottickedoff">(Just (IsNum _), _) -&gt;</span>
<span class="lineno">  871 </span><span class="spaces">         </span><span class="nottickedoff">return (Just True, AssumpFun (requireIdAssumeM True))</span>
<span class="lineno">  872 </span><span class="spaces">       </span><span class="nottickedoff">(Just IsInf, _) -&gt;</span>
<span class="lineno">  873 </span><span class="spaces">         </span><span class="nottickedoff">return (Just False, AssumpFun (requireIdAssumeM False))</span>
<span class="lineno">  874 </span><span class="spaces">       </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno">  875 </span><span class="spaces">         </span><span class="nottickedoff">return (Nothing,</span>
<span class="lineno">  876 </span><span class="spaces">                 </span><span class="nottickedoff">AssumpFun $ \b tm m -&gt;</span>
<span class="lineno">  877 </span><span class="spaces">                  </span><span class="nottickedoff">if b then</span>
<span class="lineno">  878 </span><span class="spaces">                    </span><span class="nottickedoff">(liftSC0 scNatType &gt;&gt;= \nat_tp -&gt;</span>
<span class="lineno">  879 </span><span class="spaces">                      </span><span class="nottickedoff">(withUVarLift &quot;n&quot; (Type nat_tp) (n_norm, tm) $ \n_nat (n', tm') -&gt;</span>
<span class="lineno">  880 </span><span class="spaces">                        </span><span class="nottickedoff">withDataTypeAssump n' (IsNum n_nat) (m tm')))</span>
<span class="lineno">  881 </span><span class="spaces">                  </span><span class="nottickedoff">else</span>
<span class="lineno">  882 </span><span class="spaces">                    </span><span class="nottickedoff">withDataTypeAssump n_norm IsInf (m tm))</span>
<span class="lineno">  883 </span><span class="spaces"></span><span class="nottickedoff">asDecProp _ = Nothing</span></span>
<span class="lineno">  884 </span>
<span class="lineno">  885 </span>
<span class="lineno">  886 </span>----------------------------------------------------------------------
<span class="lineno">  887 </span>-- * Mr Solver Himself (He Identifies as Male)
<span class="lineno">  888 </span>----------------------------------------------------------------------
<span class="lineno">  889 </span>
<span class="lineno">  890 </span>-- | An object that can be converted to a normalized computation
<span class="lineno">  891 </span>class ToNormComp a where
<span class="lineno">  892 </span>  toNormComp :: a -&gt; MRM t NormComp
<span class="lineno">  893 </span>
<span class="lineno">  894 </span>instance ToNormComp NormComp where
<span class="lineno">  895 </span>  <span class="decl"><span class="nottickedoff">toNormComp = return</span></span>
<span class="lineno">  896 </span>instance ToNormComp Comp where
<span class="lineno">  897 </span>  <span class="decl"><span class="nottickedoff">toNormComp = normComp</span></span>
<span class="lineno">  898 </span>instance ToNormComp Term where
<span class="lineno">  899 </span>  <span class="decl"><span class="nottickedoff">toNormComp = normComp . CompTerm</span></span>
<span class="lineno">  900 </span>
<span class="lineno">  901 </span>-- | Prove that the left-hand computation refines the right-hand one. See the
<span class="lineno">  902 </span>-- rules described at the beginning of this module.
<span class="lineno">  903 </span>mrRefines :: (ToNormComp a, ToNormComp b) =&gt; a -&gt; b -&gt; MRM t ()
<span class="lineno">  904 </span><span class="decl"><span class="nottickedoff">mrRefines t1 t2 =</span>
<span class="lineno">  905 </span><span class="spaces">  </span><span class="nottickedoff">do m1 &lt;- toNormComp t1</span>
<span class="lineno">  906 </span><span class="spaces">     </span><span class="nottickedoff">m2 &lt;- toNormComp t2</span>
<span class="lineno">  907 </span><span class="spaces">     </span><span class="nottickedoff">mrDebugPPPrefixSep 1 &quot;mrRefines&quot; m1 &quot;|=&quot; m2</span>
<span class="lineno">  908 </span><span class="spaces">     </span><span class="nottickedoff">-- ctx &lt;- reverse . map (\(a,Type b) -&gt; (a,b)) &lt;$&gt; mrUVars</span>
<span class="lineno">  909 </span><span class="spaces">     </span><span class="nottickedoff">-- mrDebugPPPrefix 2 &quot;in context:&quot; $ ppCtx ctx</span>
<span class="lineno">  910 </span><span class="spaces">     </span><span class="nottickedoff">withFailureCtx (FailCtxRefines m1 m2) $ mrRefines' m1 m2</span></span>
<span class="lineno">  911 </span>
<span class="lineno">  912 </span>-- | Helper function that applies 'mrRefines' to a pair
<span class="lineno">  913 </span>mrRefinesPair :: (ToNormComp a, ToNormComp b) =&gt; (a, b) -&gt; MRM t ()
<span class="lineno">  914 </span><span class="decl"><span class="nottickedoff">mrRefinesPair (a,b) = mrRefines a b</span></span>
<span class="lineno">  915 </span>
<span class="lineno">  916 </span>-- | The main implementation of 'mrRefines'
<span class="lineno">  917 </span>mrRefines' :: NormComp -&gt; NormComp -&gt; MRM t ()
<span class="lineno">  918 </span>
<span class="lineno">  919 </span><span class="decl"><span class="nottickedoff">mrRefines' (RetS e1) (RetS e2) = mrAssertProveEqBiRef e1 e2</span>
<span class="lineno">  920 </span><span class="spaces"></span><span class="nottickedoff">mrRefines' (ErrorS _) (ErrorS _) = return ()</span>
<span class="lineno">  921 </span><span class="spaces"></span><span class="nottickedoff">mrRefines' (RetS e) (ErrorS err) = throwMRFailure (ReturnNotError (Right err) e)</span>
<span class="lineno">  922 </span><span class="spaces"></span><span class="nottickedoff">mrRefines' (ErrorS err) (RetS e) = throwMRFailure (ReturnNotError (Left  err) e)</span>
<span class="lineno">  923 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  924 </span><span class="spaces"></span><span class="nottickedoff">mrRefines' (MaybeElim (Type prop_tp@(asDecProp -&gt; Just decPropM)) m1 f1 _) m2 =</span>
<span class="lineno">  925 </span><span class="spaces">  </span><span class="nottickedoff">decPropM &gt;&gt;= \case</span>
<span class="lineno">  926 </span><span class="spaces">  </span><span class="nottickedoff">(Just True, AssumpFun assumeM) -&gt;</span>
<span class="lineno">  927 </span><span class="spaces">    </span><span class="nottickedoff">do m1' &lt;- mrDummyProof prop_tp &gt;&gt;= applyNormCompFun f1</span>
<span class="lineno">  928 </span><span class="spaces">       </span><span class="nottickedoff">assumeM True (m1',m2) mrRefinesPair</span>
<span class="lineno">  929 </span><span class="spaces">  </span><span class="nottickedoff">(Just False, AssumpFun assumeM) -&gt; assumeM False (m1,m2) mrRefinesPair</span>
<span class="lineno">  930 </span><span class="spaces">  </span><span class="nottickedoff">(Nothing, AssumpFun assumeM) -&gt;</span>
<span class="lineno">  931 </span><span class="spaces">    </span><span class="nottickedoff">do m1' &lt;- mrDummyProof prop_tp &gt;&gt;= applyNormCompFun f1</span>
<span class="lineno">  932 </span><span class="spaces">       </span><span class="nottickedoff">assumeM True (m1',m2) mrRefinesPair</span>
<span class="lineno">  933 </span><span class="spaces">       </span><span class="nottickedoff">assumeM False (m1,m2) mrRefinesPair</span>
<span class="lineno">  934 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  935 </span><span class="spaces"></span><span class="nottickedoff">mrRefines' m1 (MaybeElim (Type prop_tp@(asDecProp -&gt; Just decPropM)) m2 f2 _) =</span>
<span class="lineno">  936 </span><span class="spaces">  </span><span class="nottickedoff">decPropM &gt;&gt;= \case</span>
<span class="lineno">  937 </span><span class="spaces">  </span><span class="nottickedoff">(Just True, AssumpFun assumeM) -&gt;</span>
<span class="lineno">  938 </span><span class="spaces">    </span><span class="nottickedoff">do m2' &lt;- mrDummyProof prop_tp &gt;&gt;= applyNormCompFun f2</span>
<span class="lineno">  939 </span><span class="spaces">       </span><span class="nottickedoff">assumeM True (m1,m2') mrRefinesPair</span>
<span class="lineno">  940 </span><span class="spaces">  </span><span class="nottickedoff">(Just False, AssumpFun assumeM) -&gt; assumeM False (m1,m2) mrRefinesPair</span>
<span class="lineno">  941 </span><span class="spaces">  </span><span class="nottickedoff">(Nothing, AssumpFun assumeM) -&gt;</span>
<span class="lineno">  942 </span><span class="spaces">    </span><span class="nottickedoff">do m2' &lt;- mrDummyProof prop_tp &gt;&gt;= applyNormCompFun f2</span>
<span class="lineno">  943 </span><span class="spaces">       </span><span class="nottickedoff">assumeM True (m1,m2') mrRefinesPair</span>
<span class="lineno">  944 </span><span class="spaces">       </span><span class="nottickedoff">assumeM False (m1,m2) mrRefinesPair</span>
<span class="lineno">  945 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  946 </span><span class="spaces"></span><span class="nottickedoff">mrRefines' (Ite cond1 m1 m1') m2 =</span>
<span class="lineno">  947 </span><span class="spaces">  </span><span class="nottickedoff">liftSC1 scNot cond1 &gt;&gt;= \not_cond1 -&gt;</span>
<span class="lineno">  948 </span><span class="spaces">  </span><span class="nottickedoff">mrProvable cond1 &gt;&gt;= \cond1_true_pv-&gt;</span>
<span class="lineno">  949 </span><span class="spaces">  </span><span class="nottickedoff">mrProvable not_cond1 &gt;&gt;= \cond1_false_pv -&gt;</span>
<span class="lineno">  950 </span><span class="spaces">  </span><span class="nottickedoff">case (cond1_true_pv, cond1_false_pv) of</span>
<span class="lineno">  951 </span><span class="spaces">    </span><span class="nottickedoff">(True, _) -&gt; mrRefines m1 m2</span>
<span class="lineno">  952 </span><span class="spaces">    </span><span class="nottickedoff">(_, True) -&gt; mrRefines m1' m2</span>
<span class="lineno">  953 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; withAssumption cond1 (mrRefines m1 m2) &gt;&gt;</span>
<span class="lineno">  954 </span><span class="spaces">         </span><span class="nottickedoff">withAssumption not_cond1 (mrRefines m1' m2)</span>
<span class="lineno">  955 </span><span class="spaces"></span><span class="nottickedoff">mrRefines' m1 (Ite cond2 m2 m2') =</span>
<span class="lineno">  956 </span><span class="spaces">  </span><span class="nottickedoff">liftSC1 scNot cond2 &gt;&gt;= \not_cond2 -&gt;</span>
<span class="lineno">  957 </span><span class="spaces">  </span><span class="nottickedoff">mrProvable cond2 &gt;&gt;= \cond2_true_pv-&gt;</span>
<span class="lineno">  958 </span><span class="spaces">  </span><span class="nottickedoff">mrProvable not_cond2 &gt;&gt;= \cond2_false_pv -&gt;</span>
<span class="lineno">  959 </span><span class="spaces">  </span><span class="nottickedoff">case (cond2_true_pv, cond2_false_pv) of</span>
<span class="lineno">  960 </span><span class="spaces">    </span><span class="nottickedoff">(True, _) -&gt; mrRefines m1 m2</span>
<span class="lineno">  961 </span><span class="spaces">    </span><span class="nottickedoff">(_, True) -&gt; mrRefines m1 m2'</span>
<span class="lineno">  962 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; withAssumption cond2 (mrRefines m1 m2) &gt;&gt;</span>
<span class="lineno">  963 </span><span class="spaces">         </span><span class="nottickedoff">withAssumption not_cond2 (mrRefines m1 m2')</span>
<span class="lineno">  964 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  965 </span><span class="spaces"></span><span class="nottickedoff">mrRefines' (Eithers [] _) _ = return ()</span>
<span class="lineno">  966 </span><span class="spaces"></span><span class="nottickedoff">mrRefines' _ (Eithers [] _) = return ()</span>
<span class="lineno">  967 </span><span class="spaces"></span><span class="nottickedoff">mrRefines' (Eithers [(_,f)] t1) m2 =</span>
<span class="lineno">  968 </span><span class="spaces">  </span><span class="nottickedoff">applyNormCompFun f t1 &gt;&gt;= \m1 -&gt;</span>
<span class="lineno">  969 </span><span class="spaces">  </span><span class="nottickedoff">mrRefines m1 m2</span>
<span class="lineno">  970 </span><span class="spaces"></span><span class="nottickedoff">mrRefines' m1 (Eithers [(_,f)] t2) =</span>
<span class="lineno">  971 </span><span class="spaces">  </span><span class="nottickedoff">applyNormCompFun f t2 &gt;&gt;= \m2 -&gt;</span>
<span class="lineno">  972 </span><span class="spaces">  </span><span class="nottickedoff">mrRefines m1 m2</span>
<span class="lineno">  973 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  974 </span><span class="spaces"></span><span class="nottickedoff">mrRefines' (Eithers ((tp,f1):elims) t1) m2 =</span>
<span class="lineno">  975 </span><span class="spaces">  </span><span class="nottickedoff">mrNormOpenTerm t1 &gt;&gt;= \t1' -&gt;</span>
<span class="lineno">  976 </span><span class="spaces">  </span><span class="nottickedoff">mrGetDataTypeAssump t1' &gt;&gt;= \mb_assump -&gt;</span>
<span class="lineno">  977 </span><span class="spaces">  </span><span class="nottickedoff">case (mb_assump, asEither t1') of</span>
<span class="lineno">  978 </span><span class="spaces">    </span><span class="nottickedoff">(_, Just (Left  x)) -&gt; applyNormCompFun f1 x &gt;&gt;= flip mrRefines m2</span>
<span class="lineno">  979 </span><span class="spaces">    </span><span class="nottickedoff">(_, Just (Right x)) -&gt; mrRefines (Eithers elims x) m2</span>
<span class="lineno">  980 </span><span class="spaces">    </span><span class="nottickedoff">(Just (IsLeft  x), _) -&gt; applyNormCompFun f1 x &gt;&gt;= flip mrRefines m2</span>
<span class="lineno">  981 </span><span class="spaces">    </span><span class="nottickedoff">(Just (IsRight x), _) -&gt; mrRefines (Eithers elims x) m2</span>
<span class="lineno">  982 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; let lnm = maybe &quot;x_left&quot; id (compFunVarName f1)</span>
<span class="lineno">  983 </span><span class="spaces">             </span><span class="nottickedoff">rnm = &quot;x_right&quot; in</span>
<span class="lineno">  984 </span><span class="spaces">         </span><span class="nottickedoff">elimsEithersType elims &gt;&gt;= \elims_tp -&gt;</span>
<span class="lineno">  985 </span><span class="spaces">         </span><span class="nottickedoff">withUVarLift lnm tp (f1, t1', m2) (\x (f1', t1'', m2') -&gt;</span>
<span class="lineno">  986 </span><span class="spaces">           </span><span class="nottickedoff">applyNormCompFun f1' x &gt;&gt;= withDataTypeAssump t1'' (IsLeft x)</span>
<span class="lineno">  987 </span><span class="spaces">                                      </span><span class="nottickedoff">. flip mrRefines m2') &gt;&gt;</span>
<span class="lineno">  988 </span><span class="spaces">         </span><span class="nottickedoff">withUVarLift rnm elims_tp (elims, t1', m2)</span>
<span class="lineno">  989 </span><span class="spaces">           </span><span class="nottickedoff">(\x (elims', t1'', m2') -&gt;</span>
<span class="lineno">  990 </span><span class="spaces">             </span><span class="nottickedoff">withDataTypeAssump t1'' (IsRight x) (mrRefines (Eithers elims' x) m2'))</span>
<span class="lineno">  991 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  992 </span><span class="spaces"></span><span class="nottickedoff">mrRefines' m1 (Eithers ((tp,f2):elims) t2) =</span>
<span class="lineno">  993 </span><span class="spaces">  </span><span class="nottickedoff">mrNormOpenTerm t2 &gt;&gt;= \t2' -&gt;</span>
<span class="lineno">  994 </span><span class="spaces">  </span><span class="nottickedoff">mrGetDataTypeAssump t2' &gt;&gt;= \mb_assump -&gt;</span>
<span class="lineno">  995 </span><span class="spaces">  </span><span class="nottickedoff">case (mb_assump, asEither t2') of</span>
<span class="lineno">  996 </span><span class="spaces">    </span><span class="nottickedoff">(_, Just (Left  x)) -&gt; applyNormCompFun f2 x &gt;&gt;= mrRefines m1</span>
<span class="lineno">  997 </span><span class="spaces">    </span><span class="nottickedoff">(_, Just (Right x)) -&gt; mrRefines m1 (Eithers elims x)</span>
<span class="lineno">  998 </span><span class="spaces">    </span><span class="nottickedoff">(Just (IsLeft  x), _) -&gt; applyNormCompFun f2 x &gt;&gt;= mrRefines m1</span>
<span class="lineno">  999 </span><span class="spaces">    </span><span class="nottickedoff">(Just (IsRight x), _) -&gt; mrRefines m1 (Eithers elims x)</span>
<span class="lineno"> 1000 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; let lnm = maybe &quot;x_left&quot; id (compFunVarName f2)</span>
<span class="lineno"> 1001 </span><span class="spaces">             </span><span class="nottickedoff">rnm = &quot;x_right&quot; in</span>
<span class="lineno"> 1002 </span><span class="spaces">         </span><span class="nottickedoff">elimsEithersType elims &gt;&gt;= \elims_tp -&gt;</span>
<span class="lineno"> 1003 </span><span class="spaces">         </span><span class="nottickedoff">withUVarLift lnm tp (f2, t2', m1) (\x (f2', t2'', m1') -&gt;</span>
<span class="lineno"> 1004 </span><span class="spaces">           </span><span class="nottickedoff">applyNormCompFun f2' x &gt;&gt;= withDataTypeAssump t2'' (IsLeft x)</span>
<span class="lineno"> 1005 </span><span class="spaces">                                      </span><span class="nottickedoff">. mrRefines m1') &gt;&gt;</span>
<span class="lineno"> 1006 </span><span class="spaces">         </span><span class="nottickedoff">withUVarLift rnm elims_tp (elims, t2', m1)</span>
<span class="lineno"> 1007 </span><span class="spaces">           </span><span class="nottickedoff">(\x (elims', t2'', m1') -&gt;</span>
<span class="lineno"> 1008 </span><span class="spaces">             </span><span class="nottickedoff">withDataTypeAssump t2'' (IsRight x) (mrRefines m1' (Eithers elims' x)))</span>
<span class="lineno"> 1009 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1010 </span><span class="spaces"></span><span class="nottickedoff">mrRefines' m1 (AssumeBoolBind cond2 k2) =</span>
<span class="lineno"> 1011 </span><span class="spaces">  </span><span class="nottickedoff">do m2 &lt;- liftSC0 scUnitValue &gt;&gt;= applyCompFun k2</span>
<span class="lineno"> 1012 </span><span class="spaces">     </span><span class="nottickedoff">not_cond2 &lt;- liftSC1 scNot cond2</span>
<span class="lineno"> 1013 </span><span class="spaces">     </span><span class="nottickedoff">cond2_true_pv &lt;- mrProvable cond2</span>
<span class="lineno"> 1014 </span><span class="spaces">     </span><span class="nottickedoff">cond2_false_pv &lt;- mrProvable not_cond2</span>
<span class="lineno"> 1015 </span><span class="spaces">     </span><span class="nottickedoff">case (cond2_true_pv, cond2_false_pv) of</span>
<span class="lineno"> 1016 </span><span class="spaces">       </span><span class="nottickedoff">(True, _) -&gt; mrRefines m1 m2</span>
<span class="lineno"> 1017 </span><span class="spaces">       </span><span class="nottickedoff">(_, True) -&gt; return ()</span>
<span class="lineno"> 1018 </span><span class="spaces">       </span><span class="nottickedoff">_ -&gt; withAssumption cond2 $ mrRefines m1 m2</span>
<span class="lineno"> 1019 </span><span class="spaces"></span><span class="nottickedoff">mrRefines' (AssertBoolBind cond1 k1) m2 =</span>
<span class="lineno"> 1020 </span><span class="spaces">  </span><span class="nottickedoff">do m1 &lt;- liftSC0 scUnitValue &gt;&gt;= applyCompFun k1</span>
<span class="lineno"> 1021 </span><span class="spaces">     </span><span class="nottickedoff">cond1_str &lt;- mrShowInCtx cond1</span>
<span class="lineno"> 1022 </span><span class="spaces">     </span><span class="nottickedoff">let err_txt = &quot;mrRefines failed assertion: &quot; &lt;&gt; T.pack cond1_str</span>
<span class="lineno"> 1023 </span><span class="spaces">     </span><span class="nottickedoff">m1' &lt;- ErrorS &lt;$&gt; liftSC1 scString err_txt</span>
<span class="lineno"> 1024 </span><span class="spaces">     </span><span class="nottickedoff">not_cond1 &lt;- liftSC1 scNot cond1</span>
<span class="lineno"> 1025 </span><span class="spaces">     </span><span class="nottickedoff">cond1_true_pv &lt;- mrProvable cond1</span>
<span class="lineno"> 1026 </span><span class="spaces">     </span><span class="nottickedoff">cond1_false_pv &lt;- mrProvable not_cond1</span>
<span class="lineno"> 1027 </span><span class="spaces">     </span><span class="nottickedoff">case (cond1_true_pv, cond1_false_pv) of</span>
<span class="lineno"> 1028 </span><span class="spaces">       </span><span class="nottickedoff">(True, _) -&gt; mrRefines m1 m2</span>
<span class="lineno"> 1029 </span><span class="spaces">       </span><span class="nottickedoff">(_, True) -&gt; mrRefines m1' m2</span>
<span class="lineno"> 1030 </span><span class="spaces">       </span><span class="nottickedoff">_ -&gt; withAssumption cond1 $ mrRefines m1 m2</span>
<span class="lineno"> 1031 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1032 </span><span class="spaces"></span><span class="nottickedoff">mrRefines' m1 (ForallBind tp f2) =</span>
<span class="lineno"> 1033 </span><span class="spaces">  </span><span class="nottickedoff">let nm = maybe &quot;x&quot; id (compFunVarName f2) in</span>
<span class="lineno"> 1034 </span><span class="spaces">  </span><span class="nottickedoff">mrNormOpenTerm (typeTm tp) &gt;&gt;= mkInjReprType &gt;&gt;= \(tp', r) -&gt;</span>
<span class="lineno"> 1035 </span><span class="spaces">  </span><span class="nottickedoff">withUVarLift nm (Type tp') (m1,f2) $ \x (m1',f2') -&gt;</span>
<span class="lineno"> 1036 </span><span class="spaces">  </span><span class="nottickedoff">mrApplyRepr r x &gt;&gt;= \x' -&gt;</span>
<span class="lineno"> 1037 </span><span class="spaces">  </span><span class="nottickedoff">applyNormCompFun f2' x' &gt;&gt;= \m2' -&gt;</span>
<span class="lineno"> 1038 </span><span class="spaces">  </span><span class="nottickedoff">mrRefines m1' m2'</span>
<span class="lineno"> 1039 </span><span class="spaces"></span><span class="nottickedoff">mrRefines' (ExistsBind tp f1) m2 =</span>
<span class="lineno"> 1040 </span><span class="spaces">  </span><span class="nottickedoff">let nm = maybe &quot;x&quot; id (compFunVarName f1) in</span>
<span class="lineno"> 1041 </span><span class="spaces">  </span><span class="nottickedoff">mrNormOpenTerm (typeTm tp) &gt;&gt;= mkInjReprType &gt;&gt;= \(tp', r) -&gt;</span>
<span class="lineno"> 1042 </span><span class="spaces">  </span><span class="nottickedoff">withUVarLift nm (Type tp') (f1,m2) $ \x (f1',m2') -&gt;</span>
<span class="lineno"> 1043 </span><span class="spaces">  </span><span class="nottickedoff">mrApplyRepr r x &gt;&gt;= \x' -&gt;</span>
<span class="lineno"> 1044 </span><span class="spaces">  </span><span class="nottickedoff">applyNormCompFun f1' x' &gt;&gt;= \m1' -&gt;</span>
<span class="lineno"> 1045 </span><span class="spaces">  </span><span class="nottickedoff">mrRefines m1' m2'</span>
<span class="lineno"> 1046 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1047 </span><span class="spaces"></span><span class="nottickedoff">mrRefines' m1 (OrS m2 m2') =</span>
<span class="lineno"> 1048 </span><span class="spaces">  </span><span class="nottickedoff">mrOr (mrRefines m1 m2) (mrRefines m1 m2')</span>
<span class="lineno"> 1049 </span><span class="spaces"></span><span class="nottickedoff">mrRefines' (OrS m1 m1') m2 =</span>
<span class="lineno"> 1050 </span><span class="spaces">  </span><span class="nottickedoff">mrRefines m1 m2 &gt;&gt; mrRefines m1' m2</span>
<span class="lineno"> 1051 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1052 </span><span class="spaces"></span><span class="nottickedoff">-- FIXME: the following cases don't work unless we either allow evars to be set</span>
<span class="lineno"> 1053 </span><span class="spaces"></span><span class="nottickedoff">-- to NormComps or we can turn NormComps back into terms</span>
<span class="lineno"> 1054 </span><span class="spaces"></span><span class="nottickedoff">mrRefines' m1@(FunBind (EVarFunName _) _ _) m2 =</span>
<span class="lineno"> 1055 </span><span class="spaces">  </span><span class="nottickedoff">throwMRFailure (CompsDoNotRefine m1 m2)</span>
<span class="lineno"> 1056 </span><span class="spaces"></span><span class="nottickedoff">mrRefines' m1 m2@(FunBind (EVarFunName _) _ _) =</span>
<span class="lineno"> 1057 </span><span class="spaces">  </span><span class="nottickedoff">throwMRFailure (CompsDoNotRefine m1 m2)</span>
<span class="lineno"> 1058 </span><span class="spaces"></span><span class="nottickedoff">{-</span>
<span class="lineno"> 1059 </span><span class="spaces"></span><span class="nottickedoff">mrRefines' (FunBind (EVarFunName evar) args (CompFunReturn _)) m2 =</span>
<span class="lineno"> 1060 </span><span class="spaces">  </span><span class="nottickedoff">mrGetEVar evar &gt;&gt;= \case</span>
<span class="lineno"> 1061 </span><span class="spaces">  </span><span class="nottickedoff">Just f -&gt;</span>
<span class="lineno"> 1062 </span><span class="spaces">    </span><span class="nottickedoff">(mrApplyAll f args &gt;&gt;= normCompTerm) &gt;&gt;= \m1' -&gt;</span>
<span class="lineno"> 1063 </span><span class="spaces">    </span><span class="nottickedoff">mrRefines m1' m2</span>
<span class="lineno"> 1064 </span><span class="spaces">  </span><span class="nottickedoff">Nothing -&gt; mrTrySetAppliedEVar evar args m2</span>
<span class="lineno"> 1065 </span><span class="spaces"></span><span class="nottickedoff">-}</span>
<span class="lineno"> 1066 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1067 </span><span class="spaces"></span><span class="nottickedoff">mrRefines' (FunBind f args1 k1) (FunBind f' args2 k2)</span>
<span class="lineno"> 1068 </span><span class="spaces">  </span><span class="nottickedoff">| f == f' &amp;&amp; length args1 == length args2 =</span>
<span class="lineno"> 1069 </span><span class="spaces">    </span><span class="nottickedoff">zipWithM_ mrAssertProveEqBiRef args1 args2 &gt;&gt;</span>
<span class="lineno"> 1070 </span><span class="spaces">    </span><span class="nottickedoff">mrFunOutType f args1 &gt;&gt;= \(_, tp) -&gt;</span>
<span class="lineno"> 1071 </span><span class="spaces">    </span><span class="nottickedoff">mrRefinesFun tp k1 tp k2</span>
<span class="lineno"> 1072 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1073 </span><span class="spaces"></span><span class="nottickedoff">mrRefines' m1@(FunBind f1 args1 k1)</span>
<span class="lineno"> 1074 </span><span class="spaces">           </span><span class="nottickedoff">m2@(FunBind f2 args2 k2) =</span>
<span class="lineno"> 1075 </span><span class="spaces">  </span><span class="nottickedoff">liftSC0 scGetModuleMap &gt;&gt;= \mm -&gt;</span>
<span class="lineno"> 1076 </span><span class="spaces">  </span><span class="nottickedoff">let ?mm = mm in</span>
<span class="lineno"> 1077 </span><span class="spaces">  </span><span class="nottickedoff">mrFunOutType f1 args1 &gt;&gt;= mapM mrNormOpenTerm &gt;&gt;= \(_, tp1) -&gt;</span>
<span class="lineno"> 1078 </span><span class="spaces">  </span><span class="nottickedoff">mrFunOutType f2 args2 &gt;&gt;= mapM mrNormOpenTerm &gt;&gt;= \(_, tp2) -&gt;</span>
<span class="lineno"> 1079 </span><span class="spaces">  </span><span class="nottickedoff">injUnifyTypes tp1 tp2 &gt;&gt;= \mb_convs -&gt;</span>
<span class="lineno"> 1080 </span><span class="spaces">  </span><span class="nottickedoff">mrFunBodyRecInfo f1 args1 &gt;&gt;= \maybe_f1_body -&gt;</span>
<span class="lineno"> 1081 </span><span class="spaces">  </span><span class="nottickedoff">mrFunBodyRecInfo f2 args2 &gt;&gt;= \maybe_f2_body -&gt;</span>
<span class="lineno"> 1082 </span><span class="spaces">  </span><span class="nottickedoff">mrGetCoIndHyp f1 f2 &gt;&gt;= \maybe_coIndHyp -&gt;</span>
<span class="lineno"> 1083 </span><span class="spaces">  </span><span class="nottickedoff">mrGetFunAssump f1 &gt;&gt;= \maybe_fassump -&gt;</span>
<span class="lineno"> 1084 </span><span class="spaces">  </span><span class="nottickedoff">case (maybe_coIndHyp, maybe_fassump) of</span>
<span class="lineno"> 1085 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1086 </span><span class="spaces">  </span><span class="nottickedoff">-- If we have a co-inductive assumption that f1 args1' |= f2 args2':</span>
<span class="lineno"> 1087 </span><span class="spaces">  </span><span class="nottickedoff">-- * If it is convertible to our goal, continue and prove that k1 |= k2</span>
<span class="lineno"> 1088 </span><span class="spaces">  </span><span class="nottickedoff">-- * If it can be widened with our goal, restart the current proof branch</span>
<span class="lineno"> 1089 </span><span class="spaces">  </span><span class="nottickedoff">--   with the widened hypothesis (done by throwing a</span>
<span class="lineno"> 1090 </span><span class="spaces">  </span><span class="nottickedoff">--   'CoIndHypMismatchWidened' error for 'proveCoIndHyp' to catch)</span>
<span class="lineno"> 1091 </span><span class="spaces">  </span><span class="nottickedoff">-- * Otherwise, throw a 'CoIndHypMismatchFailure' error.</span>
<span class="lineno"> 1092 </span><span class="spaces">  </span><span class="nottickedoff">(Just hyp, _) -&gt;</span>
<span class="lineno"> 1093 </span><span class="spaces">    </span><span class="nottickedoff">matchCoIndHyp hyp args1 args2 &gt;&gt;</span>
<span class="lineno"> 1094 </span><span class="spaces">    </span><span class="nottickedoff">mrRefinesFun tp1 k1 tp2 k2</span>
<span class="lineno"> 1095 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1096 </span><span class="spaces">  </span><span class="nottickedoff">-- If we have an opaque FunAssump that f1 args1' refines f2 args2', then</span>
<span class="lineno"> 1097 </span><span class="spaces">  </span><span class="nottickedoff">-- prove that args1 = args1', args2 = args2', and then that k1 refines k2</span>
<span class="lineno"> 1098 </span><span class="spaces">  </span><span class="nottickedoff">(_, Just fa@(FunAssump ctx _ args1' (OpaqueFunAssump f2' args2') _)) | f2 == f2' -&gt;</span>
<span class="lineno"> 1099 </span><span class="spaces">    </span><span class="nottickedoff">do mrDebugPPInCtxM 2 $ prettyWithCtx ctx $</span>
<span class="lineno"> 1100 </span><span class="spaces">         </span><span class="nottickedoff">prettyAppList [return &quot;mrRefines using opaque FunAssump:&quot;,</span>
<span class="lineno"> 1101 </span><span class="spaces">                        </span><span class="nottickedoff">prettyInCtx ctx, return &quot;.&quot;,</span>
<span class="lineno"> 1102 </span><span class="spaces">                        </span><span class="nottickedoff">prettyTermApp (funNameTerm f1) args1',</span>
<span class="lineno"> 1103 </span><span class="spaces">                        </span><span class="nottickedoff">return &quot;|=&quot;,</span>
<span class="lineno"> 1104 </span><span class="spaces">                        </span><span class="nottickedoff">prettyTermApp (funNameTerm f2) args2']</span>
<span class="lineno"> 1105 </span><span class="spaces">       </span><span class="nottickedoff">evars &lt;- mrFreshEVars ctx</span>
<span class="lineno"> 1106 </span><span class="spaces">       </span><span class="nottickedoff">(args1'', args2'') &lt;- substTermLike 0 evars (args1', args2')</span>
<span class="lineno"> 1107 </span><span class="spaces">       </span><span class="nottickedoff">zipWithM_ mrAssertProveEqBiRef args1'' args1</span>
<span class="lineno"> 1108 </span><span class="spaces">       </span><span class="nottickedoff">zipWithM_ mrAssertProveEqBiRef args2'' args2</span>
<span class="lineno"> 1109 </span><span class="spaces">       </span><span class="nottickedoff">recordUsedFunAssump fa &gt;&gt; mrRefinesFun tp1 k1 tp2 k2</span>
<span class="lineno"> 1110 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1111 </span><span class="spaces">  </span><span class="nottickedoff">-- If we have an opaque FunAssump that f1 refines some f /= f2, and f2</span>
<span class="lineno"> 1112 </span><span class="spaces">  </span><span class="nottickedoff">-- unfolds and is not recursive in itself, unfold f2 and recurse</span>
<span class="lineno"> 1113 </span><span class="spaces">  </span><span class="nottickedoff">(_, Just fa@(FunAssump _ _ _ (OpaqueFunAssump _ _) _))</span>
<span class="lineno"> 1114 </span><span class="spaces">    </span><span class="nottickedoff">| Just (f2_body, False) &lt;- maybe_f2_body -&gt;</span>
<span class="lineno"> 1115 </span><span class="spaces">    </span><span class="nottickedoff">normBindTerm f2_body k2 &gt;&gt;= \m2' -&gt;</span>
<span class="lineno"> 1116 </span><span class="spaces">    </span><span class="nottickedoff">recordUsedFunAssump fa &gt;&gt; mrRefines m1 m2'</span>
<span class="lineno"> 1117 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1118 </span><span class="spaces">  </span><span class="nottickedoff">-- If we have a rewrite FunAssump, or we have an opaque FunAssump that</span>
<span class="lineno"> 1119 </span><span class="spaces">  </span><span class="nottickedoff">-- f1 args1' refines some f args where f /= f2 and f2 does not match the</span>
<span class="lineno"> 1120 </span><span class="spaces">  </span><span class="nottickedoff">-- case above, treat either case like we have a rewrite FunAssump and prove</span>
<span class="lineno"> 1121 </span><span class="spaces">  </span><span class="nottickedoff">-- that args1 = args1' and then that f args refines m2</span>
<span class="lineno"> 1122 </span><span class="spaces">  </span><span class="nottickedoff">(_, Just fa@(FunAssump ctx _ args1' rhs _)) -&gt;</span>
<span class="lineno"> 1123 </span><span class="spaces">    </span><span class="nottickedoff">do let fassump_tp_str = case fassumpRHS fa of</span>
<span class="lineno"> 1124 </span><span class="spaces">                              </span><span class="nottickedoff">OpaqueFunAssump _ _ -&gt; &quot;opaque&quot;</span>
<span class="lineno"> 1125 </span><span class="spaces">                              </span><span class="nottickedoff">RewriteFunAssump _ -&gt; &quot;rewrite&quot;</span>
<span class="lineno"> 1126 </span><span class="spaces">       </span><span class="nottickedoff">mrDebugPPInCtxM 2 $ prettyWithCtx ctx $</span>
<span class="lineno"> 1127 </span><span class="spaces">         </span><span class="nottickedoff">prettyAppList [return (&quot;mrRefines rewriting by &quot; &lt;&gt; fassump_tp_str</span>
<span class="lineno"> 1128 </span><span class="spaces">                                                          </span><span class="nottickedoff">&lt;&gt; &quot; FunAssump:&quot;),</span>
<span class="lineno"> 1129 </span><span class="spaces">                        </span><span class="nottickedoff">prettyInCtx ctx, return &quot;.&quot;,</span>
<span class="lineno"> 1130 </span><span class="spaces">                        </span><span class="nottickedoff">prettyTermApp (funNameTerm f1) args1',</span>
<span class="lineno"> 1131 </span><span class="spaces">                        </span><span class="nottickedoff">return &quot;|=&quot;,</span>
<span class="lineno"> 1132 </span><span class="spaces">                        </span><span class="nottickedoff">case rhs of</span>
<span class="lineno"> 1133 </span><span class="spaces">                          </span><span class="nottickedoff">OpaqueFunAssump f2' args2' -&gt;</span>
<span class="lineno"> 1134 </span><span class="spaces">                            </span><span class="nottickedoff">prettyTermApp (funNameTerm f2') args2'</span>
<span class="lineno"> 1135 </span><span class="spaces">                          </span><span class="nottickedoff">RewriteFunAssump rhs_tm -&gt;</span>
<span class="lineno"> 1136 </span><span class="spaces">                            </span><span class="nottickedoff">prettyInCtx rhs_tm]</span>
<span class="lineno"> 1137 </span><span class="spaces">       </span><span class="nottickedoff">rhs' &lt;- mrFunAssumpRHSAsNormComp rhs</span>
<span class="lineno"> 1138 </span><span class="spaces">       </span><span class="nottickedoff">evars &lt;- mrFreshEVars ctx</span>
<span class="lineno"> 1139 </span><span class="spaces">       </span><span class="nottickedoff">(args1'', rhs'') &lt;- substTermLike 0 evars (args1', rhs')</span>
<span class="lineno"> 1140 </span><span class="spaces">       </span><span class="nottickedoff">zipWithM_ mrAssertProveEqBiRef args1'' args1</span>
<span class="lineno"> 1141 </span><span class="spaces">       </span><span class="nottickedoff">-- It's important to instantiate the evars here so that rhs is well-typed</span>
<span class="lineno"> 1142 </span><span class="spaces">       </span><span class="nottickedoff">-- when bound with k1</span>
<span class="lineno"> 1143 </span><span class="spaces">       </span><span class="nottickedoff">rhs''' &lt;- mapTermLike mrSubstEVars rhs''</span>
<span class="lineno"> 1144 </span><span class="spaces">       </span><span class="nottickedoff">m1' &lt;- normBind rhs''' k1</span>
<span class="lineno"> 1145 </span><span class="spaces">       </span><span class="nottickedoff">recordUsedFunAssump fa &gt;&gt; mrRefines m1' m2</span>
<span class="lineno"> 1146 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1147 </span><span class="spaces">  </span><span class="nottickedoff">-- If f1 unfolds and is not recursive in itself, unfold it and recurse</span>
<span class="lineno"> 1148 </span><span class="spaces">  </span><span class="nottickedoff">_ | Just (f1_body, False) &lt;- maybe_f1_body -&gt;</span>
<span class="lineno"> 1149 </span><span class="spaces">      </span><span class="nottickedoff">normBindTerm f1_body k1 &gt;&gt;= \m1' -&gt; mrRefines m1' m2</span>
<span class="lineno"> 1150 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1151 </span><span class="spaces">  </span><span class="nottickedoff">-- If f2 unfolds and is not recursive in itself, unfold it and recurse</span>
<span class="lineno"> 1152 </span><span class="spaces">  </span><span class="nottickedoff">_ | Just (f2_body, False) &lt;- maybe_f2_body -&gt;</span>
<span class="lineno"> 1153 </span><span class="spaces">      </span><span class="nottickedoff">normBindTerm f2_body k2 &gt;&gt;= \m2' -&gt; mrRefines m1 m2'</span>
<span class="lineno"> 1154 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1155 </span><span class="spaces">  </span><span class="nottickedoff">-- If we don't have a co-inducitve hypothesis for f1 and f2, don't have an</span>
<span class="lineno"> 1156 </span><span class="spaces">  </span><span class="nottickedoff">-- assumption that f1 refines some specification, both f1 and f2 are recursive</span>
<span class="lineno"> 1157 </span><span class="spaces">  </span><span class="nottickedoff">-- and have return types which can be injectively unified, then try to</span>
<span class="lineno"> 1158 </span><span class="spaces">  </span><span class="nottickedoff">-- coinductively prove that f1 args1 |= f2 args2 under the assumption that</span>
<span class="lineno"> 1159 </span><span class="spaces">  </span><span class="nottickedoff">-- f1 args1 |= f2 args2, and then try to prove that k1 |= k2</span>
<span class="lineno"> 1160 </span><span class="spaces">  </span><span class="nottickedoff">_ | Just _ &lt;- maybe_f1_body</span>
<span class="lineno"> 1161 </span><span class="spaces">    </span><span class="nottickedoff">, Just _ &lt;- maybe_f2_body -&gt;</span>
<span class="lineno"> 1162 </span><span class="spaces">      </span><span class="nottickedoff">case mb_convs of</span>
<span class="lineno"> 1163 </span><span class="spaces">        </span><span class="nottickedoff">Just _ -&gt; mrRefinesCoInd f1 args1 f2 args2 &gt;&gt; mrRefinesFun tp1 k1 tp2 k2</span>
<span class="lineno"> 1164 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt; throwMRFailure (BindTypesNotUnifiable (Type tp1) (Type tp2))</span>
<span class="lineno"> 1165 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1166 </span><span class="spaces">  </span><span class="nottickedoff">-- If we cannot line up f1 and f2, then making progress here would require us</span>
<span class="lineno"> 1167 </span><span class="spaces">  </span><span class="nottickedoff">-- to somehow split either m1 or m2 into some bind m' &gt;&gt;= k' such that m' is</span>
<span class="lineno"> 1168 </span><span class="spaces">  </span><span class="nottickedoff">-- related to the function call on the other side and k' is related to the</span>
<span class="lineno"> 1169 </span><span class="spaces">  </span><span class="nottickedoff">-- continuation on the other side, but we don't know how to do that, so give</span>
<span class="lineno"> 1170 </span><span class="spaces">  </span><span class="nottickedoff">-- up</span>
<span class="lineno"> 1171 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt; throwMRFailure (FunNamesDoNotRefine f1 args1 f2 args2)</span>
<span class="lineno"> 1172 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1173 </span><span class="spaces"></span><span class="nottickedoff">mrRefines' m1@(FunBind f1 args1 k1) m2 =</span>
<span class="lineno"> 1174 </span><span class="spaces">  </span><span class="nottickedoff">mrGetFunAssump f1 &gt;&gt;= \case</span>
<span class="lineno"> 1175 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1176 </span><span class="spaces">  </span><span class="nottickedoff">-- If we have an assumption that f1 args' refines some rhs, then prove that</span>
<span class="lineno"> 1177 </span><span class="spaces">  </span><span class="nottickedoff">-- args1 = args' and then that rhs refines m2</span>
<span class="lineno"> 1178 </span><span class="spaces">  </span><span class="nottickedoff">Just fa@(FunAssump ctx _ args1' rhs _) -&gt;</span>
<span class="lineno"> 1179 </span><span class="spaces">    </span><span class="nottickedoff">do rhs' &lt;- mrFunAssumpRHSAsNormComp rhs</span>
<span class="lineno"> 1180 </span><span class="spaces">       </span><span class="nottickedoff">evars &lt;- mrFreshEVars ctx</span>
<span class="lineno"> 1181 </span><span class="spaces">       </span><span class="nottickedoff">(args1'', rhs'') &lt;- substTermLike 0 evars (args1', rhs')</span>
<span class="lineno"> 1182 </span><span class="spaces">       </span><span class="nottickedoff">zipWithM_ mrAssertProveEqBiRef args1'' args1</span>
<span class="lineno"> 1183 </span><span class="spaces">       </span><span class="nottickedoff">-- It's important to instantiate the evars here so that rhs is well-typed</span>
<span class="lineno"> 1184 </span><span class="spaces">       </span><span class="nottickedoff">-- when bound with k1</span>
<span class="lineno"> 1185 </span><span class="spaces">       </span><span class="nottickedoff">rhs''' &lt;- mapTermLike mrSubstEVars rhs''</span>
<span class="lineno"> 1186 </span><span class="spaces">       </span><span class="nottickedoff">m1' &lt;- normBind rhs''' k1</span>
<span class="lineno"> 1187 </span><span class="spaces">       </span><span class="nottickedoff">recordUsedFunAssump fa &gt;&gt; mrRefines m1' m2</span>
<span class="lineno"> 1188 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1189 </span><span class="spaces">  </span><span class="nottickedoff">-- Otherwise, see if we can unfold f1</span>
<span class="lineno"> 1190 </span><span class="spaces">  </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 1191 </span><span class="spaces">    </span><span class="nottickedoff">liftSC0 scGetModuleMap &gt;&gt;= \mm -&gt;</span>
<span class="lineno"> 1192 </span><span class="spaces">    </span><span class="nottickedoff">let ?mm = mm in</span>
<span class="lineno"> 1193 </span><span class="spaces">    </span><span class="nottickedoff">mrFunBodyRecInfo f1 args1 &gt;&gt;= \case</span>
<span class="lineno"> 1194 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1195 </span><span class="spaces">    </span><span class="nottickedoff">-- If f1 unfolds and is not recursive in itself, unfold it and recurse</span>
<span class="lineno"> 1196 </span><span class="spaces">    </span><span class="nottickedoff">Just (f1_body, False) -&gt;</span>
<span class="lineno"> 1197 </span><span class="spaces">      </span><span class="nottickedoff">normBindTerm f1_body k1 &gt;&gt;= \m1' -&gt; mrRefines m1' m2</span>
<span class="lineno"> 1198 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1199 </span><span class="spaces">    </span><span class="nottickedoff">-- Otherwise we would have to somehow split m2 into some computation of the</span>
<span class="lineno"> 1200 </span><span class="spaces">    </span><span class="nottickedoff">-- form m2' &gt;&gt;= k2 where f1 args1 |= m2' and k1 |= k2, but we don't know how</span>
<span class="lineno"> 1201 </span><span class="spaces">    </span><span class="nottickedoff">-- to do this splitting, so give up</span>
<span class="lineno"> 1202 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; mrRefines'' m1 m2</span>
<span class="lineno"> 1203 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1204 </span><span class="spaces"></span><span class="nottickedoff">mrRefines' m1 m2@(FunBind f2 args2 k2) =</span>
<span class="lineno"> 1205 </span><span class="spaces">  </span><span class="nottickedoff">liftSC0 scGetModuleMap &gt;&gt;= \mm -&gt;</span>
<span class="lineno"> 1206 </span><span class="spaces">  </span><span class="nottickedoff">let ?mm = mm in</span>
<span class="lineno"> 1207 </span><span class="spaces">  </span><span class="nottickedoff">mrFunBodyRecInfo f2 args2 &gt;&gt;= \case</span>
<span class="lineno"> 1208 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1209 </span><span class="spaces">  </span><span class="nottickedoff">-- If f2 unfolds and is not recursive in itself, unfold it and recurse</span>
<span class="lineno"> 1210 </span><span class="spaces">  </span><span class="nottickedoff">Just (f2_body, False) -&gt;</span>
<span class="lineno"> 1211 </span><span class="spaces">    </span><span class="nottickedoff">normBindTerm f2_body k2 &gt;&gt;= \m2' -&gt; mrRefines m1 m2'</span>
<span class="lineno"> 1212 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1213 </span><span class="spaces">  </span><span class="nottickedoff">-- If f2 unfolds but is recursive, and k2 is the trivial continuation, meaning</span>
<span class="lineno"> 1214 </span><span class="spaces">  </span><span class="nottickedoff">-- m2 is just f2 args2, use the law of coinduction to prove m1 |= f2 args2 by</span>
<span class="lineno"> 1215 </span><span class="spaces">  </span><span class="nottickedoff">-- proving m1 |= f2_body under the assumption that m1 |= f2 args2</span>
<span class="lineno"> 1216 </span><span class="spaces">  </span><span class="nottickedoff">{- FIXME: implement something like this</span>
<span class="lineno"> 1217 </span><span class="spaces">  </span><span class="nottickedoff">Just (f2_body, True)</span>
<span class="lineno"> 1218 </span><span class="spaces">    </span><span class="nottickedoff">| CompFunReturn _ &lt;- k2 -&gt;</span>
<span class="lineno"> 1219 </span><span class="spaces">      </span><span class="nottickedoff">withFunAssumpR m1 f2 args2 $</span>
<span class="lineno"> 1220 </span><span class="spaces">   </span><span class="nottickedoff">-}</span>
<span class="lineno"> 1221 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1222 </span><span class="spaces">    </span><span class="nottickedoff">-- Otherwise we would have to somehow split m1 into some computation of the</span>
<span class="lineno"> 1223 </span><span class="spaces">    </span><span class="nottickedoff">-- form m1' &gt;&gt;= k1 where m1' |= f2 args2 and k1 |= k2, but we don't know how</span>
<span class="lineno"> 1224 </span><span class="spaces">    </span><span class="nottickedoff">-- to do this splitting, so give up</span>
<span class="lineno"> 1225 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt; mrRefines'' m1 m2</span>
<span class="lineno"> 1226 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1227 </span><span class="spaces"></span><span class="nottickedoff">mrRefines' m1 m2 = mrRefines'' m1 m2</span></span>
<span class="lineno"> 1228 </span>
<span class="lineno"> 1229 </span>-- | The cases of 'mrRefines' which must occur after the ones in 'mrRefines''.
<span class="lineno"> 1230 </span>-- For example, the rules that introduce existential variables need to go last,
<span class="lineno"> 1231 </span>-- so that they can quantify over as many universals as possible
<span class="lineno"> 1232 </span>mrRefines'' :: NormComp -&gt; NormComp -&gt; MRM t ()
<span class="lineno"> 1233 </span>
<span class="lineno"> 1234 </span><span class="decl"><span class="nottickedoff">mrRefines'' m1 (AssertBoolBind cond2 k2) =</span>
<span class="lineno"> 1235 </span><span class="spaces">  </span><span class="nottickedoff">do m2 &lt;- liftSC0 scUnitValue &gt;&gt;= applyCompFun k2</span>
<span class="lineno"> 1236 </span><span class="spaces">     </span><span class="nottickedoff">cond2_pv &lt;- mrProvable cond2</span>
<span class="lineno"> 1237 </span><span class="spaces">     </span><span class="nottickedoff">if cond2_pv then mrRefines m1 m2</span>
<span class="lineno"> 1238 </span><span class="spaces">       </span><span class="nottickedoff">else throwMRFailure (AssertionNotProvable cond2)</span>
<span class="lineno"> 1239 </span><span class="spaces"></span><span class="nottickedoff">mrRefines'' (AssumeBoolBind cond1 k1) m2 =</span>
<span class="lineno"> 1240 </span><span class="spaces">  </span><span class="nottickedoff">do m1 &lt;- liftSC0 scUnitValue &gt;&gt;= applyCompFun k1</span>
<span class="lineno"> 1241 </span><span class="spaces">     </span><span class="nottickedoff">cond1_pv &lt;- mrProvable cond1</span>
<span class="lineno"> 1242 </span><span class="spaces">     </span><span class="nottickedoff">if cond1_pv then mrRefines m1 m2</span>
<span class="lineno"> 1243 </span><span class="spaces">       </span><span class="nottickedoff">else throwMRFailure (AssumptionNotProvable cond1)</span>
<span class="lineno"> 1244 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1245 </span><span class="spaces"></span><span class="nottickedoff">mrRefines'' m1 (ExistsBind tp f2) =</span>
<span class="lineno"> 1246 </span><span class="spaces">  </span><span class="nottickedoff">do let nm = maybe &quot;x&quot; id (compFunVarName f2)</span>
<span class="lineno"> 1247 </span><span class="spaces">     </span><span class="nottickedoff">tp' &lt;- mrNormOpenTerm (typeTm tp)</span>
<span class="lineno"> 1248 </span><span class="spaces">     </span><span class="nottickedoff">evars &lt;- forM (fromMaybe [tp'] (asTupleType tp')) $ \tp_i -&gt;</span>
<span class="lineno"> 1249 </span><span class="spaces">       </span><span class="nottickedoff">mkInjReprType tp_i &gt;&gt;= \(tp_i', r) -&gt;</span>
<span class="lineno"> 1250 </span><span class="spaces">       </span><span class="nottickedoff">mrFreshEVar nm (Type tp_i') &gt;&gt;= mrApplyRepr r</span>
<span class="lineno"> 1251 </span><span class="spaces">     </span><span class="nottickedoff">x &lt;- liftSC1 scTuple evars </span>
<span class="lineno"> 1252 </span><span class="spaces">     </span><span class="nottickedoff">m2' &lt;- applyNormCompFun f2 x</span>
<span class="lineno"> 1253 </span><span class="spaces">     </span><span class="nottickedoff">mrRefines m1 m2'</span>
<span class="lineno"> 1254 </span><span class="spaces"></span><span class="nottickedoff">mrRefines'' (ForallBind tp f1) m2 =</span>
<span class="lineno"> 1255 </span><span class="spaces">  </span><span class="nottickedoff">do let nm = maybe &quot;x&quot; id (compFunVarName f1)</span>
<span class="lineno"> 1256 </span><span class="spaces">     </span><span class="nottickedoff">tp' &lt;- mrNormOpenTerm (typeTm tp)</span>
<span class="lineno"> 1257 </span><span class="spaces">     </span><span class="nottickedoff">evars &lt;- forM (fromMaybe [tp'] (asTupleType tp')) $ \tp_i -&gt;</span>
<span class="lineno"> 1258 </span><span class="spaces">       </span><span class="nottickedoff">mkInjReprType tp_i &gt;&gt;= \(tp_i', r) -&gt;</span>
<span class="lineno"> 1259 </span><span class="spaces">       </span><span class="nottickedoff">mrFreshEVar nm (Type tp_i') &gt;&gt;= mrApplyRepr r</span>
<span class="lineno"> 1260 </span><span class="spaces">     </span><span class="nottickedoff">x &lt;- liftSC1 scTuple evars </span>
<span class="lineno"> 1261 </span><span class="spaces">     </span><span class="nottickedoff">m1' &lt;- applyNormCompFun f1 x</span>
<span class="lineno"> 1262 </span><span class="spaces">     </span><span class="nottickedoff">mrRefines m1' m2</span>
<span class="lineno"> 1263 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1264 </span><span class="spaces"></span><span class="nottickedoff">-- If none of the above cases match, then fail</span>
<span class="lineno"> 1265 </span><span class="spaces"></span><span class="nottickedoff">mrRefines'' m1 m2 = throwMRFailure (CompsDoNotRefine m1 m2)</span></span>
<span class="lineno"> 1266 </span>
<span class="lineno"> 1267 </span>-- | Prove that one function refines another for all inputs
<span class="lineno"> 1268 </span>mrRefinesFun :: Term -&gt; CompFun -&gt; Term -&gt; CompFun -&gt; MRM t ()
<span class="lineno"> 1269 </span><span class="decl"><span class="nottickedoff">mrRefinesFun tp1 f1 tp2 f2 =</span>
<span class="lineno"> 1270 </span><span class="spaces">  </span><span class="nottickedoff">do mrDebugPPPrefixSep 1 &quot;mrRefinesFun on types:&quot; tp1 &quot;,&quot; tp2</span>
<span class="lineno"> 1271 </span><span class="spaces">     </span><span class="nottickedoff">f1' &lt;- compFunToTerm f1 &gt;&gt;= liftSC1 scWhnf</span>
<span class="lineno"> 1272 </span><span class="spaces">     </span><span class="nottickedoff">f2' &lt;- compFunToTerm f2 &gt;&gt;= liftSC1 scWhnf</span>
<span class="lineno"> 1273 </span><span class="spaces">     </span><span class="nottickedoff">mrDebugPPPrefixSep 1 &quot;mrRefinesFun&quot; f1' &quot;|=&quot; f2'</span>
<span class="lineno"> 1274 </span><span class="spaces">     </span><span class="nottickedoff">let nm1 = maybe &quot;call_ret_val&quot; id (compFunVarName f1)</span>
<span class="lineno"> 1275 </span><span class="spaces">         </span><span class="nottickedoff">nm2 = maybe &quot;call_ret_val&quot; id (compFunVarName f2)</span>
<span class="lineno"> 1276 </span><span class="spaces">     </span><span class="nottickedoff">f1'' &lt;- mrLambdaLift1 (nm1, tp1) f1' $ flip mrApply</span>
<span class="lineno"> 1277 </span><span class="spaces">     </span><span class="nottickedoff">f2'' &lt;- mrLambdaLift1 (nm2, tp2) f2' $ flip mrApply</span>
<span class="lineno"> 1278 </span><span class="spaces">     </span><span class="nottickedoff">piTp1 &lt;- mrTypeOf f1'' &gt;&gt;= mrNormOpenTerm</span>
<span class="lineno"> 1279 </span><span class="spaces">     </span><span class="nottickedoff">piTp2 &lt;- mrTypeOf f2'' &gt;&gt;= mrNormOpenTerm</span>
<span class="lineno"> 1280 </span><span class="spaces">     </span><span class="nottickedoff">mrRefinesFunH mrRefines [] piTp1 f1'' piTp2 f2''</span></span>
<span class="lineno"> 1281 </span>
<span class="lineno"> 1282 </span>-- | Prove that two functions both refine another for all inputs
<span class="lineno"> 1283 </span>mrBiRefinesFuns :: MRRel t ()
<span class="lineno"> 1284 </span><span class="decl"><span class="nottickedoff">mrBiRefinesFuns piTp1 f1 piTp2 f2 =</span>
<span class="lineno"> 1285 </span><span class="spaces">  </span><span class="nottickedoff">mrDebugPPPrefixSep 1 &quot;mrBiRefinesFuns&quot; f1 &quot;=|=&quot; f2 &gt;&gt;</span>
<span class="lineno"> 1286 </span><span class="spaces">  </span><span class="nottickedoff">mrNormOpenTerm piTp1 &gt;&gt;= \piTp1' -&gt;</span>
<span class="lineno"> 1287 </span><span class="spaces">  </span><span class="nottickedoff">mrNormOpenTerm piTp2 &gt;&gt;= \piTp2' -&gt;</span>
<span class="lineno"> 1288 </span><span class="spaces">  </span><span class="nottickedoff">mrRefinesFunH mrRefines [] piTp1' f1 piTp2' f2 &gt;&gt;</span>
<span class="lineno"> 1289 </span><span class="spaces">  </span><span class="nottickedoff">mrRefinesFunH mrRefines [] piTp2' f2 piTp1' f1</span></span>
<span class="lineno"> 1290 </span>
<span class="lineno"> 1291 </span>-- | Prove that two terms are related via bi-refinement on terms of SpecFun
<span class="lineno"> 1292 </span>-- type (as in 'isSpecFunType') or via equality otherwise, returning false if
<span class="lineno"> 1293 </span>-- this is not possible and instantiating evars if necessary
<span class="lineno"> 1294 </span>mrProveEqBiRef :: Term -&gt; Term -&gt; MRM t Bool
<span class="lineno"> 1295 </span><span class="decl"><span class="nottickedoff">mrProveEqBiRef = mrProveRel (Just mrBiRefinesFuns)</span></span>
<span class="lineno"> 1296 </span>
<span class="lineno"> 1297 </span>-- | Prove that two terms are related via bi-refinement on terms of SpecFun
<span class="lineno"> 1298 </span>-- type (as in 'isSpecFunType') or via equality otherwise, throwing an error if
<span class="lineno"> 1299 </span>-- this is not possible and instantiating evars if necessary
<span class="lineno"> 1300 </span>mrAssertProveEqBiRef :: Term -&gt; Term -&gt; MRM t ()
<span class="lineno"> 1301 </span><span class="decl"><span class="nottickedoff">mrAssertProveEqBiRef = mrAssertProveRel (Just mrBiRefinesFuns)</span></span>
<span class="lineno"> 1302 </span>
<span class="lineno"> 1303 </span>
<span class="lineno"> 1304 </span>-- | The main loop of 'mrRefinesFun', 'askMRSolver': given a function that
<span class="lineno"> 1305 </span>-- attempts to prove refinement between two computational terms, i.e., terms of
<span class="lineno"> 1306 </span>-- type @SpecM a@ and @SpecM b@ for some types @a@ and @b@, attempt to prove
<span class="lineno"> 1307 </span>-- refinement between two monadic functions. The list of 'Term's argument
<span class="lineno"> 1308 </span>-- contains all the variables that have so far been abstracted by
<span class="lineno"> 1309 </span>-- 'mrRefinesFunH', and the remaining 'Term's are the left-hand type, left-hand
<span class="lineno"> 1310 </span>-- term of that type, right-hand type, and right-hand term of that type for the
<span class="lineno"> 1311 </span>-- refinement we are trying to prove.
<span class="lineno"> 1312 </span>--
<span class="lineno"> 1313 </span>-- This function works by abstracting over arguments of the left- and right-hand
<span class="lineno"> 1314 </span>-- sides, as determined by their types, and applying the functions to these
<span class="lineno"> 1315 </span>-- variables until we get terms of non-functional monadic type, that are passed
<span class="lineno"> 1316 </span>-- to the supplied helper function. Proposition arguments in the form of
<span class="lineno"> 1317 </span>-- equality on Boolean values can occur on either side, and are added as
<span class="lineno"> 1318 </span>-- assumptions to the refinement. Regular non-proof arguments must occur on both
<span class="lineno"> 1319 </span>-- sides, and are added as a single variable that is passed to both sides. This
<span class="lineno"> 1320 </span>-- means that these regular argument types must be either equal or
<span class="lineno"> 1321 </span>-- injectively unifiable with 'injUnifyTypes'.
<span class="lineno"> 1322 </span>mrRefinesFunH :: (Term -&gt; Term -&gt; MRM t a) -&gt; [Term] -&gt; MRRel t a
<span class="lineno"> 1323 </span>
<span class="lineno"> 1324 </span>-- Ignore units on either side
<span class="lineno"> 1325 </span><span class="decl"><span class="nottickedoff">mrRefinesFunH k vars (asPi -&gt; Just (_, asTupleType -&gt; Just [], _)) t1 piTp2 t2 =</span>
<span class="lineno"> 1326 </span><span class="spaces">  </span><span class="nottickedoff">do u &lt;- liftSC0 scUnitValue</span>
<span class="lineno"> 1327 </span><span class="spaces">     </span><span class="nottickedoff">t1' &lt;- mrApplyAll t1 [u]</span>
<span class="lineno"> 1328 </span><span class="spaces">     </span><span class="nottickedoff">piTp1' &lt;- mrTypeOf t1'</span>
<span class="lineno"> 1329 </span><span class="spaces">     </span><span class="nottickedoff">mrRefinesFunH k vars piTp1' t1' piTp2 t2</span>
<span class="lineno"> 1330 </span><span class="spaces"></span><span class="nottickedoff">mrRefinesFunH k vars piTp1 t1 (asPi -&gt; Just (_, asTupleType -&gt; Just [], _)) t2 =</span>
<span class="lineno"> 1331 </span><span class="spaces">  </span><span class="nottickedoff">do u &lt;- liftSC0 scUnitValue</span>
<span class="lineno"> 1332 </span><span class="spaces">     </span><span class="nottickedoff">t2' &lt;- mrApplyAll t2 [u]</span>
<span class="lineno"> 1333 </span><span class="spaces">     </span><span class="nottickedoff">piTp2' &lt;- mrTypeOf t2'</span>
<span class="lineno"> 1334 </span><span class="spaces">     </span><span class="nottickedoff">mrRefinesFunH k vars piTp1 t1 piTp2' t2'</span>
<span class="lineno"> 1335 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1336 </span><span class="spaces"></span><span class="nottickedoff">-- Introduce equalities on either side as assumptions</span>
<span class="lineno"> 1337 </span><span class="spaces"></span><span class="nottickedoff">mrRefinesFunH k vars (asPi -&gt; Just (nm1, tp1@(asBoolEq -&gt;</span>
<span class="lineno"> 1338 </span><span class="spaces">                                              </span><span class="nottickedoff">Just (b1, b2)), _)) t1 piTp2 t2 =</span>
<span class="lineno"> 1339 </span><span class="spaces">  </span><span class="nottickedoff">liftSC2 scBoolEq b1 b2 &gt;&gt;= \eq -&gt;</span>
<span class="lineno"> 1340 </span><span class="spaces">  </span><span class="nottickedoff">withAssumption eq $</span>
<span class="lineno"> 1341 </span><span class="spaces">  </span><span class="nottickedoff">let nm = maybe &quot;p&quot; id $ find ((/=) '_' . Text.head)</span>
<span class="lineno"> 1342 </span><span class="spaces">                        </span><span class="nottickedoff">$ [nm1] ++ catMaybes [ asLambdaName t1 ] in</span>
<span class="lineno"> 1343 </span><span class="spaces">  </span><span class="nottickedoff">withUVarLift nm (Type tp1) (vars,t1,piTp2,t2) $ \var (vars',t1',piTp2',t2') -&gt;</span>
<span class="lineno"> 1344 </span><span class="spaces">  </span><span class="nottickedoff">do t1'' &lt;- mrApplyAll t1' [var]</span>
<span class="lineno"> 1345 </span><span class="spaces">     </span><span class="nottickedoff">piTp1' &lt;- mrTypeOf t1''</span>
<span class="lineno"> 1346 </span><span class="spaces">     </span><span class="nottickedoff">mrRefinesFunH k (var : vars') piTp1' t1'' piTp2' t2'</span>
<span class="lineno"> 1347 </span><span class="spaces"></span><span class="nottickedoff">mrRefinesFunH k vars piTp1 t1 (asPi -&gt; Just (nm2, tp2@(asBoolEq -&gt;</span>
<span class="lineno"> 1348 </span><span class="spaces">                                                       </span><span class="nottickedoff">Just (b1, b2)), _)) t2 =</span>
<span class="lineno"> 1349 </span><span class="spaces">  </span><span class="nottickedoff">liftSC2 scBoolEq b1 b2 &gt;&gt;= \eq -&gt;</span>
<span class="lineno"> 1350 </span><span class="spaces">  </span><span class="nottickedoff">withAssumption eq $</span>
<span class="lineno"> 1351 </span><span class="spaces">  </span><span class="nottickedoff">let nm = maybe &quot;p&quot; id $ find ((/=) '_' . Text.head)</span>
<span class="lineno"> 1352 </span><span class="spaces">                        </span><span class="nottickedoff">$ [nm2] ++ catMaybes [ asLambdaName t2 ] in</span>
<span class="lineno"> 1353 </span><span class="spaces">  </span><span class="nottickedoff">withUVarLift nm (Type tp2) (vars,piTp1,t1,t2) $ \var (vars',piTp1',t1',t2') -&gt;</span>
<span class="lineno"> 1354 </span><span class="spaces">  </span><span class="nottickedoff">do t2'' &lt;- mrApplyAll t2' [var]</span>
<span class="lineno"> 1355 </span><span class="spaces">     </span><span class="nottickedoff">piTp2' &lt;- mrTypeOf t2''</span>
<span class="lineno"> 1356 </span><span class="spaces">     </span><span class="nottickedoff">mrRefinesFunH k (var : vars') piTp1' t1' piTp2' t2''</span>
<span class="lineno"> 1357 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1358 </span><span class="spaces"></span><span class="nottickedoff">-- We always curry pair values before introducing them (NOTE: we do this even</span>
<span class="lineno"> 1359 </span><span class="spaces"></span><span class="nottickedoff">-- when the have the same types to ensure we never have to unify a projection</span>
<span class="lineno"> 1360 </span><span class="spaces"></span><span class="nottickedoff">-- of an evar with a non-projected value, e.g. evar.1 == val)</span>
<span class="lineno"> 1361 </span><span class="spaces"></span><span class="nottickedoff">-- FIXME: Only do this if we have corresponding pairs on both sides?</span>
<span class="lineno"> 1362 </span><span class="spaces"></span><span class="nottickedoff">mrRefinesFunH k vars (asPi -&gt; Just (nm1, asPairType -&gt; Just (tpL1, tpR1), _)) t1</span>
<span class="lineno"> 1363 </span><span class="spaces">                     </span><span class="nottickedoff">(asPi -&gt; Just (nm2, asPairType -&gt; Just (tpL2, tpR2), _)) t2 =</span>
<span class="lineno"> 1364 </span><span class="spaces">  </span><span class="nottickedoff">do t1'' &lt;- mrLambdaLift2 (nm1, tpL1) (nm1, tpR1) t1 $ \prj1 prj2 t1' -&gt;</span>
<span class="lineno"> 1365 </span><span class="spaces">               </span><span class="nottickedoff">liftSC2 scPairValue prj1 prj2 &gt;&gt;= mrApply t1'</span>
<span class="lineno"> 1366 </span><span class="spaces">     </span><span class="nottickedoff">t2'' &lt;- mrLambdaLift2 (nm2, tpL2) (nm2, tpR2) t2 $ \prj1 prj2 t2' -&gt;</span>
<span class="lineno"> 1367 </span><span class="spaces">               </span><span class="nottickedoff">liftSC2 scPairValue prj1 prj2 &gt;&gt;= mrApply t2'</span>
<span class="lineno"> 1368 </span><span class="spaces">     </span><span class="nottickedoff">piTp1' &lt;- mrTypeOf t1''</span>
<span class="lineno"> 1369 </span><span class="spaces">     </span><span class="nottickedoff">piTp2' &lt;- mrTypeOf t2''</span>
<span class="lineno"> 1370 </span><span class="spaces">     </span><span class="nottickedoff">mrRefinesFunH k vars piTp1' t1'' piTp2' t2''</span>
<span class="lineno"> 1371 </span><span class="spaces"></span><span class="nottickedoff">mrRefinesFunH k vars (asPi -&gt; Just (nm1, asPairType -&gt; Just (tpL1, tpR1), _)) t1 tp2 t2 =</span>
<span class="lineno"> 1372 </span><span class="spaces">  </span><span class="nottickedoff">do t1'' &lt;- mrLambdaLift2 (nm1, tpL1) (nm1, tpR1) t1 $ \prj1 prj2 t1' -&gt;</span>
<span class="lineno"> 1373 </span><span class="spaces">               </span><span class="nottickedoff">liftSC2 scPairValue prj1 prj2 &gt;&gt;= mrApply t1'</span>
<span class="lineno"> 1374 </span><span class="spaces">     </span><span class="nottickedoff">piTp1' &lt;- mrTypeOf t1''</span>
<span class="lineno"> 1375 </span><span class="spaces">     </span><span class="nottickedoff">mrRefinesFunH k vars piTp1' t1'' tp2 t2</span>
<span class="lineno"> 1376 </span><span class="spaces"></span><span class="nottickedoff">mrRefinesFunH k vars tp1 t1 (asPi -&gt; Just (nm2, asPairType -&gt; Just (tpL2, tpR2), _)) t2 =</span>
<span class="lineno"> 1377 </span><span class="spaces">  </span><span class="nottickedoff">do t2'' &lt;- mrLambdaLift2 (nm2, tpL2) (nm2, tpR2) t2 $ \prj1 prj2 t2' -&gt;</span>
<span class="lineno"> 1378 </span><span class="spaces">               </span><span class="nottickedoff">liftSC2 scPairValue prj1 prj2 &gt;&gt;= mrApply t2'</span>
<span class="lineno"> 1379 </span><span class="spaces">     </span><span class="nottickedoff">piTp2' &lt;- mrTypeOf t2''</span>
<span class="lineno"> 1380 </span><span class="spaces">     </span><span class="nottickedoff">mrRefinesFunH k vars tp1 t1 piTp2' t2''</span>
<span class="lineno"> 1381 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1382 </span><span class="spaces"></span><span class="nottickedoff">mrRefinesFunH k vars (asPi -&gt; Just (nm1, tp1, _)) t1</span>
<span class="lineno"> 1383 </span><span class="spaces">                     </span><span class="nottickedoff">(asPi -&gt; Just (nm2, tp2, _)) t2 =</span>
<span class="lineno"> 1384 </span><span class="spaces">  </span><span class="nottickedoff">injUnifyTypes tp1 tp2 &gt;&gt;= \case</span>
<span class="lineno"> 1385 </span><span class="spaces">  </span><span class="nottickedoff">-- If we can find injective conversions from from a type @tp@ to @tp1@ and</span>
<span class="lineno"> 1386 </span><span class="spaces">  </span><span class="nottickedoff">-- @tp2@, introduce a variable of type @tp@, apply both conversions to it,</span>
<span class="lineno"> 1387 </span><span class="spaces">  </span><span class="nottickedoff">-- and substitute the results on the left and right sides, respectively</span>
<span class="lineno"> 1388 </span><span class="spaces">  </span><span class="nottickedoff">Just (tp, r1, r2) -&gt;</span>
<span class="lineno"> 1389 </span><span class="spaces">    </span><span class="nottickedoff">mrDebugPPPrefixSep 3 &quot;mrRefinesFunH calling findInjConvs&quot; tp1 &quot;,&quot; tp2 &gt;&gt;</span>
<span class="lineno"> 1390 </span><span class="spaces">    </span><span class="nottickedoff">mrDebugPPPrefix 3 &quot;mrRefinesFunH got type&quot; tp &gt;&gt;</span>
<span class="lineno"> 1391 </span><span class="spaces">    </span><span class="nottickedoff">let nm = maybe &quot;x&quot; id $ find ((/=) '_' . Text.head)</span>
<span class="lineno"> 1392 </span><span class="spaces">                          </span><span class="nottickedoff">$ [nm1, nm2] ++ catMaybes [ asLambdaName t1</span>
<span class="lineno"> 1393 </span><span class="spaces">                                                    </span><span class="nottickedoff">, asLambdaName t2 ] in</span>
<span class="lineno"> 1394 </span><span class="spaces">    </span><span class="nottickedoff">withUVarLift nm (Type tp) (vars,r1,r2,t1,t2) $ \var (vars',r1',r2',t1',t2') -&gt;</span>
<span class="lineno"> 1395 </span><span class="spaces">    </span><span class="nottickedoff">do tm1 &lt;- mrApplyRepr r1' var</span>
<span class="lineno"> 1396 </span><span class="spaces">       </span><span class="nottickedoff">tm2 &lt;- mrApplyRepr r2' var</span>
<span class="lineno"> 1397 </span><span class="spaces">       </span><span class="nottickedoff">t1'' &lt;- mrApplyAll t1' [tm1]</span>
<span class="lineno"> 1398 </span><span class="spaces">       </span><span class="nottickedoff">t2'' &lt;- mrApplyAll t2' [tm2]</span>
<span class="lineno"> 1399 </span><span class="spaces">       </span><span class="nottickedoff">piTp1' &lt;- mrTypeOf t1'' &gt;&gt;= liftSC1 scWhnf</span>
<span class="lineno"> 1400 </span><span class="spaces">       </span><span class="nottickedoff">piTp2' &lt;- mrTypeOf t2'' &gt;&gt;= liftSC1 scWhnf</span>
<span class="lineno"> 1401 </span><span class="spaces">       </span><span class="nottickedoff">mrRefinesFunH k (var : vars') piTp1' t1'' piTp2' t2''</span>
<span class="lineno"> 1402 </span><span class="spaces">  </span><span class="nottickedoff">-- Otherwise, error</span>
<span class="lineno"> 1403 </span><span class="spaces">  </span><span class="nottickedoff">Nothing -&gt; throwMRFailure (TypesNotUnifiable (Type tp1) (Type tp2))</span>
<span class="lineno"> 1404 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1405 </span><span class="spaces"></span><span class="nottickedoff">-- Error if we don't have the same number of arguments on both sides</span>
<span class="lineno"> 1406 </span><span class="spaces"></span><span class="nottickedoff">-- FIXME: Add a specific error for this case</span>
<span class="lineno"> 1407 </span><span class="spaces"></span><span class="nottickedoff">mrRefinesFunH _ _ (asPi -&gt; Just (_,tp1,_)) _ (asPi -&gt; Nothing) _ =</span>
<span class="lineno"> 1408 </span><span class="spaces">  </span><span class="nottickedoff">liftSC0 scUnitType &gt;&gt;= \utp -&gt;</span>
<span class="lineno"> 1409 </span><span class="spaces">  </span><span class="nottickedoff">throwMRFailure (TypesNotEq (Type tp1) (Type utp))</span>
<span class="lineno"> 1410 </span><span class="spaces"></span><span class="nottickedoff">mrRefinesFunH _ _ (asPi -&gt; Nothing) _ (asPi -&gt; Just (_,tp2,_)) _ =</span>
<span class="lineno"> 1411 </span><span class="spaces">  </span><span class="nottickedoff">liftSC0 scUnitType &gt;&gt;= \utp -&gt;</span>
<span class="lineno"> 1412 </span><span class="spaces">  </span><span class="nottickedoff">throwMRFailure (TypesNotEq (Type utp) (Type tp2))</span>
<span class="lineno"> 1413 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1414 </span><span class="spaces"></span><span class="nottickedoff">-- Error if either side's return type is not SpecM</span>
<span class="lineno"> 1415 </span><span class="spaces"></span><span class="nottickedoff">mrRefinesFunH _ _ tp1@(asSpecM -&gt; Nothing) t1 _ _ =</span>
<span class="lineno"> 1416 </span><span class="spaces">  </span><span class="nottickedoff">throwMRFailure (NotCompFunType tp1 t1)</span>
<span class="lineno"> 1417 </span><span class="spaces"></span><span class="nottickedoff">mrRefinesFunH _ _ _ _ tp2@(asSpecM -&gt; Nothing) t2 =</span>
<span class="lineno"> 1418 </span><span class="spaces">  </span><span class="nottickedoff">throwMRFailure (NotCompFunType tp2 t2)</span>
<span class="lineno"> 1419 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1420 </span><span class="spaces"></span><span class="nottickedoff">-- This case means we must be proving refinement on two SpecM computations, so</span>
<span class="lineno"> 1421 </span><span class="spaces"></span><span class="nottickedoff">-- call the helper function k</span>
<span class="lineno"> 1422 </span><span class="spaces"></span><span class="nottickedoff">mrRefinesFunH k _ _ t1 _ t2 = k t1 t2</span></span>
<span class="lineno"> 1423 </span>
<span class="lineno"> 1424 </span>
<span class="lineno"> 1425 </span>----------------------------------------------------------------------
<span class="lineno"> 1426 </span>-- * External Entrypoints
<span class="lineno"> 1427 </span>----------------------------------------------------------------------
<span class="lineno"> 1428 </span>
<span class="lineno"> 1429 </span>-- | The continuation passed to 'mrRefinesFunH' in 'askMRSolver' - normalizes
<span class="lineno"> 1430 </span>-- both resulting terms using 'normCompTerm' then calls the given monadic
<span class="lineno"> 1431 </span>-- function
<span class="lineno"> 1432 </span>askMRSolverH :: (NormComp -&gt; NormComp -&gt; MRM t a) -&gt; Term -&gt; Term -&gt; MRM t a
<span class="lineno"> 1433 </span><span class="decl"><span class="nottickedoff">askMRSolverH f t1 t2 =</span>
<span class="lineno"> 1434 </span><span class="spaces">  </span><span class="nottickedoff">do mrUVars &gt;&gt;= mrDebugPPPrefix 1 &quot;askMRSolverH uvars:&quot;</span>
<span class="lineno"> 1435 </span><span class="spaces">     </span><span class="nottickedoff">m1 &lt;- normCompTerm t1</span>
<span class="lineno"> 1436 </span><span class="spaces">     </span><span class="nottickedoff">m2 &lt;- normCompTerm t2</span>
<span class="lineno"> 1437 </span><span class="spaces">     </span><span class="nottickedoff">f m1 m2</span></span>
<span class="lineno"> 1438 </span>
<span class="lineno"> 1439 </span>-- | Test two monadic, recursive terms for refinement
<span class="lineno"> 1440 </span>askMRSolver ::
<span class="lineno"> 1441 </span>  SharedContext -&gt;
<span class="lineno"> 1442 </span>  MREnv {- ^ The Mr Solver environment -} -&gt;
<span class="lineno"> 1443 </span>  Maybe Integer {- ^ Timeout in milliseconds for each SMT call -} -&gt;
<span class="lineno"> 1444 </span>  (Set VarIndex -&gt; Sequent -&gt; TopLevel (SolverStats, SolveResult))
<span class="lineno"> 1445 </span>    {- ^ The callback to use for making SMT queries -} -&gt;
<span class="lineno"> 1446 </span>  Refnset t {- ^ Any additional refinements to be assumed by Mr Solver -} -&gt;
<span class="lineno"> 1447 </span>  [(LocalName, Term)] {- ^ Any universally quantified variables in scope -} -&gt;
<span class="lineno"> 1448 </span>  Term -&gt; Term -&gt; TopLevel (Either MRFailure (SolverStats, MREvidence t))
<span class="lineno"> 1449 </span><span class="decl"><span class="nottickedoff">askMRSolver sc env timeout askSMT rs args t1 t2 =</span>
<span class="lineno"> 1450 </span><span class="spaces">  </span><span class="nottickedoff">execMRM sc env timeout askSMT rs $</span>
<span class="lineno"> 1451 </span><span class="spaces">  </span><span class="nottickedoff">withUVars (mrVarCtxFromOuterToInner args) $ \_ -&gt;</span>
<span class="lineno"> 1452 </span><span class="spaces">    </span><span class="nottickedoff">do tp1 &lt;- liftSC1 scTypeOf t1 &gt;&gt;= mrNormOpenTerm</span>
<span class="lineno"> 1453 </span><span class="spaces">       </span><span class="nottickedoff">tp2 &lt;- liftSC1 scTypeOf t2 &gt;&gt;= mrNormOpenTerm</span>
<span class="lineno"> 1454 </span><span class="spaces">       </span><span class="nottickedoff">mrDebugPPPrefixSep 1 &quot;mr_solver&quot; t1 &quot;|=&quot; t2</span>
<span class="lineno"> 1455 </span><span class="spaces">       </span><span class="nottickedoff">mrRefinesFunH (askMRSolverH mrRefines) [] tp1 t1 tp2 t2</span></span>
<span class="lineno"> 1456 </span>
<span class="lineno"> 1457 </span>-- | Helper function for 'refinementTerm': returns the proposition stating that
<span class="lineno"> 1458 </span>-- one 'Term' refines another, after quantifying over all current 'mrUVars' with
<span class="lineno"> 1459 </span>-- Pi types. Note that this assumes both terms have the same event types; if
<span class="lineno"> 1460 </span>-- they do not a saw-core typechecking error will be raised.
<span class="lineno"> 1461 </span>refinementTermH :: Term -&gt; Term -&gt; MRM t Term
<span class="lineno"> 1462 </span><span class="decl"><span class="nottickedoff">refinementTermH t1 t2 =</span>
<span class="lineno"> 1463 </span><span class="spaces">  </span><span class="nottickedoff">do (EvTerm ev, tp1) &lt;- fromJust . asSpecM &lt;$&gt; mrTypeOf t1</span>
<span class="lineno"> 1464 </span><span class="spaces">     </span><span class="nottickedoff">(EvTerm  _, tp2) &lt;- fromJust . asSpecM &lt;$&gt; mrTypeOf t2</span>
<span class="lineno"> 1465 </span><span class="spaces">     </span><span class="nottickedoff">-- FIXME: Add a direct way to check that the types are related, instead of</span>
<span class="lineno"> 1466 </span><span class="spaces">     </span><span class="nottickedoff">-- calling 'mrRelTerm' on dummy variables and ignoring the result</span>
<span class="lineno"> 1467 </span><span class="spaces">     </span><span class="nottickedoff">withUVarLift &quot;ret_val&quot; (Type tp1) (tp1,tp2) $ \x1 (tp1',tp2') -&gt;</span>
<span class="lineno"> 1468 </span><span class="spaces">       </span><span class="nottickedoff">withUVarLift &quot;ret_val&quot; (Type tp2') (tp1',tp2',x1) $ \x2 (tp1'',tp2'',x1') -&gt;</span>
<span class="lineno"> 1469 </span><span class="spaces">         </span><span class="nottickedoff">do tp1''' &lt;- mrSubstEVars tp1''</span>
<span class="lineno"> 1470 </span><span class="spaces">            </span><span class="nottickedoff">tp2''' &lt;- mrSubstEVars tp2''</span>
<span class="lineno"> 1471 </span><span class="spaces">            </span><span class="nottickedoff">void $ mrRelTerm Nothing tp1''' x1' tp2''' x2</span>
<span class="lineno"> 1472 </span><span class="spaces">     </span><span class="nottickedoff">rr &lt;- liftSC2 scGlobalApply &quot;SpecM.eqRR&quot; [tp1]</span>
<span class="lineno"> 1473 </span><span class="spaces">     </span><span class="nottickedoff">ref_tm &lt;- liftSC2 scGlobalApply &quot;SpecM.refinesS&quot; [ev, tp1, tp1, rr, t1, t2]</span>
<span class="lineno"> 1474 </span><span class="spaces">     </span><span class="nottickedoff">uvars &lt;- mrUVarsOuterToInner</span>
<span class="lineno"> 1475 </span><span class="spaces">     </span><span class="nottickedoff">liftSC2 scPiList uvars ref_tm</span></span>
<span class="lineno"> 1476 </span>
<span class="lineno"> 1477 </span>-- | Build the proposition stating that one function term refines another, after
<span class="lineno"> 1478 </span>-- quantifying over all the given arguments as well as any additional arguments
<span class="lineno"> 1479 </span>-- needed to fully apply the given terms, and adding any calls to @assertS@ on
<span class="lineno"> 1480 </span>-- the right hand side needed for unifying the arguments generated when fully
<span class="lineno"> 1481 </span>-- applying the given terms
<span class="lineno"> 1482 </span>refinementTerm ::
<span class="lineno"> 1483 </span>  SharedContext -&gt;
<span class="lineno"> 1484 </span>  MREnv {- ^ The Mr Solver environment -} -&gt;
<span class="lineno"> 1485 </span>  Maybe Integer {- ^ Timeout in milliseconds for each SMT call -} -&gt;
<span class="lineno"> 1486 </span>  (Set VarIndex -&gt; Sequent -&gt; TopLevel (SolverStats, SolveResult))
<span class="lineno"> 1487 </span>    {- ^ The callback to use for making SMT queries -} -&gt;
<span class="lineno"> 1488 </span>  Refnset t {- ^ Any additional refinements to be assumed by Mr Solver -} -&gt;
<span class="lineno"> 1489 </span>  [(LocalName, Term)] {- ^ Any universally quantified variables in scope -} -&gt;
<span class="lineno"> 1490 </span>  Term -&gt; Term -&gt; TopLevel (Either MRFailure Term)
<span class="lineno"> 1491 </span><span class="decl"><span class="nottickedoff">refinementTerm sc env timeout askSMT rs args t1 t2 =</span>
<span class="lineno"> 1492 </span><span class="spaces">  </span><span class="nottickedoff">evalMRM sc env timeout askSMT rs $</span>
<span class="lineno"> 1493 </span><span class="spaces">  </span><span class="nottickedoff">withUVars (mrVarCtxFromOuterToInner args) $ \_ -&gt;</span>
<span class="lineno"> 1494 </span><span class="spaces">    </span><span class="nottickedoff">do tp1 &lt;- liftSC1 scTypeOf t1 &gt;&gt;= mrNormOpenTerm</span>
<span class="lineno"> 1495 </span><span class="spaces">       </span><span class="nottickedoff">tp2 &lt;- liftSC1 scTypeOf t2 &gt;&gt;= mrNormOpenTerm</span>
<span class="lineno"> 1496 </span><span class="spaces">       </span><span class="nottickedoff">mrRefinesFunH refinementTermH [] tp1 t1 tp2 t2</span></span>

</pre>
</body>
</html>
