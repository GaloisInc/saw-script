<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE ConstraintKinds #-}
<span class="lineno">    2 </span>{-# LANGUAGE FlexibleContexts #-}
<span class="lineno">    3 </span>{-# LANGUAGE FlexibleInstances #-}
<span class="lineno">    4 </span>{-# LANGUAGE GADTs #-}
<span class="lineno">    5 </span>{-# LANGUAGE GeneralizedNewtypeDeriving #-}
<span class="lineno">    6 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">    7 </span>{-# LANGUAGE MultiParamTypeClasses #-}
<span class="lineno">    8 </span>{-# LANGUAGE MultiWayIf #-}
<span class="lineno">    9 </span>{-# LANGUAGE NamedFieldPuns #-}
<span class="lineno">   10 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">   11 </span>{-# LANGUAGE QuasiQuotes #-}
<span class="lineno">   12 </span>{-# LANGUAGE RankNTypes #-}
<span class="lineno">   13 </span>{-# LANGUAGE RecordWildCards #-}
<span class="lineno">   14 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">   15 </span>{-# LANGUAGE TemplateHaskell #-}
<span class="lineno">   16 </span>{-# LANGUAGE ViewPatterns #-}
<span class="lineno">   17 </span>{-# LANGUAGE TypeApplications #-}
<span class="lineno">   18 </span>{-# LANGUAGE DataKinds #-}
<span class="lineno">   19 </span>{-# LANGUAGE PatternGuards #-}
<span class="lineno">   20 </span>{-# LANGUAGE TupleSections #-}
<span class="lineno">   21 </span>
<span class="lineno">   22 </span>{- |
<span class="lineno">   23 </span>Module      : SAWCoreCoq.Term
<span class="lineno">   24 </span>Copyright   : Galois, Inc. 2018
<span class="lineno">   25 </span>License     : BSD3
<span class="lineno">   26 </span>Maintainer  : atomb@galois.com
<span class="lineno">   27 </span>Stability   : experimental
<span class="lineno">   28 </span>Portability : portable
<span class="lineno">   29 </span>-}
<span class="lineno">   30 </span>
<span class="lineno">   31 </span>module SAWCoreCoq.Term where
<span class="lineno">   32 </span>
<span class="lineno">   33 </span>import           Control.Lens                                  (makeLenses, over, set, to, view)
<span class="lineno">   34 </span>import           Control.Monad                                 (forM)
<span class="lineno">   35 </span>import qualified Control.Monad.Except                          as Except
<span class="lineno">   36 </span>import qualified Control.Monad.Fail                            as Fail
<span class="lineno">   37 </span>import           Control.Monad.Reader                          (MonadReader(ask, local), asks)
<span class="lineno">   38 </span>import           Control.Monad.State                           (MonadState(get), modify)
<span class="lineno">   39 </span>import           Data.Char                                     (isDigit)
<span class="lineno">   40 </span>import           Data.IntMap.Strict (IntMap)
<span class="lineno">   41 </span>import qualified Data.IntMap.Strict                            as IntMap
<span class="lineno">   42 </span>import           Data.List                                     (intersperse, sortOn)
<span class="lineno">   43 </span>import           Data.Maybe                                    (fromMaybe)
<span class="lineno">   44 </span>import qualified Data.Map                                      as Map
<span class="lineno">   45 </span>import qualified Data.Set                                      as Set
<span class="lineno">   46 </span>import qualified Data.Text                                     as Text
<span class="lineno">   47 </span>import           Prelude                                       hiding (fail)
<span class="lineno">   48 </span>import           Prettyprinter
<span class="lineno">   49 </span>
<span class="lineno">   50 </span>import           Data.Parameterized.Pair
<span class="lineno">   51 </span>import           Data.Parameterized.NatRepr
<span class="lineno">   52 </span>import qualified Data.BitVector.Sized                          as BV
<span class="lineno">   53 </span>import qualified Data.Vector                                   as Vector (toList)
<span class="lineno">   54 </span>import qualified Language.Coq.AST                              as Coq
<span class="lineno">   55 </span>import qualified Language.Coq.Pretty                           as Coq
<span class="lineno">   56 </span>import           SAWCore.Module (Def(..), ModuleMap, ResolvedName(..), requireNameInMap, resolvedNameType)
<span class="lineno">   57 </span>import           SAWCore.Name (Name(..), VarName(..))
<span class="lineno">   58 </span>import           SAWCore.Recognizer
<span class="lineno">   59 </span>import           SAWCore.SharedTerm
<span class="lineno">   60 </span>import           SAWCore.Term.Pretty
<span class="lineno">   61 </span>import           SAWCore.Term.Functor
<span class="lineno">   62 </span>import           SAWCoreCoq.Monad
<span class="lineno">   63 </span>import           SAWCoreCoq.SpecialTreatment
<span class="lineno">   64 </span>
<span class="lineno">   65 </span>{-
<span class="lineno">   66 </span>import Debug.Trace
<span class="lineno">   67 </span>traceTerm :: String -&gt; Term -&gt; a -&gt; a
<span class="lineno">   68 </span>traceTerm ctx t a = trace (ctx ++ &quot;: &quot; ++ showTerm t) a
<span class="lineno">   69 </span>-}
<span class="lineno">   70 </span>
<span class="lineno">   71 </span>-- | A Coq identifier used for sharing subterms through let-bindings, annotated
<span class="lineno">   72 </span>-- with a 'Bool' flag indicating whether the shared subterm is closed, i.e., has
<span class="lineno">   73 </span>-- no free variables
<span class="lineno">   74 </span>data SharedName = SharedName { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">sharedNameIdent</span></span></span> :: Coq.Ident,
<span class="lineno">   75 </span>                               <span class="nottickedoff"><span class="decl"><span class="nottickedoff">sharedNameIsClosed</span></span></span> :: Bool }
<span class="lineno">   76 </span>                deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>
<span class="lineno">   77 </span>
<span class="lineno">   78 </span>-- | The read-only state for translating terms
<span class="lineno">   79 </span>data TranslationReader = TranslationReader
<span class="lineno">   80 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_currentModule</span></span></span>  :: Maybe ModuleName
<span class="lineno">   81 </span>    -- ^ The current Coq module for the translation
<span class="lineno">   82 </span>
<span class="lineno">   83 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_localEnvironment</span></span></span>  :: [Coq.Ident]
<span class="lineno">   84 </span>    -- ^ The list of Coq identifiers associated with the current SAW core
<span class="lineno">   85 </span>    -- Bruijn-indexed local variables in scope, innermost (index 0) first
<span class="lineno">   86 </span>
<span class="lineno">   87 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_namedEnvironment</span></span></span>  :: Map.Map VarName Coq.Ident
<span class="lineno">   88 </span>    -- ^ The map of Coq identifiers associated with the SAW core named
<span class="lineno">   89 </span>    -- variables in scope
<span class="lineno">   90 </span>
<span class="lineno">   91 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_unavailableIdents</span></span></span> :: Set.Set Coq.Ident
<span class="lineno">   92 </span>    -- ^ The set of Coq identifiers that are either reserved or already in use.
<span class="lineno">   93 </span>    -- To avoid shadowing, fresh identifiers should be chosen to be disjoint
<span class="lineno">   94 </span>    -- from this set.
<span class="lineno">   95 </span>
<span class="lineno">   96 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_sharedNames</span></span></span> :: IntMap SharedName
<span class="lineno">   97 </span>    -- ^ Index of identifiers for repeated subterms that have been lifted out
<span class="lineno">   98 </span>    -- into a let expression
<span class="lineno">   99 </span>
<span class="lineno">  100 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_nextSharedName</span></span></span> :: Coq.Ident
<span class="lineno">  101 </span>    -- ^ The next available name to be used for a let-bound shared
<span class="lineno">  102 </span>    -- sub-expression
<span class="lineno">  103 </span>
<span class="lineno">  104 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_sawModuleMap</span></span></span> :: ModuleMap
<span class="lineno">  105 </span>    -- ^ The environment of SAW global definitions
<span class="lineno">  106 </span>  }
<span class="lineno">  107 </span>  -- deriving (Show)
<span class="lineno">  108 </span>
<span class="lineno">  109 </span><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">makeLenses ''TranslationReader</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno">  110 </span>
<span class="lineno">  111 </span>data TranslationState = TranslationState
<span class="lineno">  112 </span>
<span class="lineno">  113 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_globalDeclarations</span></span></span> :: [Coq.Ident]
<span class="lineno">  114 </span>    -- ^ Some Cryptol terms seem to capture the name and body of some functions
<span class="lineno">  115 </span>    -- they use (whether from the Cryptol prelude, or previously defined in the
<span class="lineno">  116 </span>    -- same file). We want to translate those exactly once, so we need to keep
<span class="lineno">  117 </span>    -- track of which ones have already been translated.
<span class="lineno">  118 </span>
<span class="lineno">  119 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_topLevelDeclarations</span></span></span> :: [Coq.Decl]
<span class="lineno">  120 </span>    -- ^ Because some terms capture their dependencies, translating one term may
<span class="lineno">  121 </span>    -- result in multiple declarations: one for the term itself, but also zero
<span class="lineno">  122 </span>    -- or many for its dependencies. We store all of those in this, so that a
<span class="lineno">  123 </span>    -- caller of the translation may retrieve all the declarations needed to
<span class="lineno">  124 </span>    -- translate the term. The translation function itself will return only the
<span class="lineno">  125 </span>    -- declaration for the term being translated.
<span class="lineno">  126 </span>
<span class="lineno">  127 </span>  }
<span class="lineno">  128 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  129 </span>
<span class="lineno">  130 </span><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">makeLenses ''TranslationState</span></span></span></span></span>
<span class="lineno">  131 </span>
<span class="lineno">  132 </span>-- | The constraint stating that 'm' can be used for term translation. This
<span class="lineno">  133 </span>-- requires that it have reader effects for 'TranslationReader' and state
<span class="lineno">  134 </span>-- effects for 'TranslationState'.
<span class="lineno">  135 </span>type TermTranslationMonad m =
<span class="lineno">  136 </span>  TranslationMonad TranslationReader TranslationState m
<span class="lineno">  137 </span>
<span class="lineno">  138 </span>-- | Get just the 'TranslationReader' component of the reader value
<span class="lineno">  139 </span>askTR :: TermTranslationMonad m =&gt; m TranslationReader
<span class="lineno">  140 </span><span class="decl"><span class="nottickedoff">askTR = otherConfiguration &lt;$&gt; ask</span></span>
<span class="lineno">  141 </span>
<span class="lineno">  142 </span>-- | Modify just the 'TranslationReader' component of the reader value
<span class="lineno">  143 </span>localTR :: TermTranslationMonad m =&gt;
<span class="lineno">  144 </span>            (TranslationReader -&gt; TranslationReader) -&gt; m a -&gt; m a
<span class="lineno">  145 </span><span class="decl"><span class="nottickedoff">localTR f =</span>
<span class="lineno">  146 </span><span class="spaces">  </span><span class="nottickedoff">local (\r -&gt; r { otherConfiguration = f (otherConfiguration r) })</span></span>
<span class="lineno">  147 </span>
<span class="lineno">  148 </span>-- | Take a Coq identifier that ends in a number (i.e., a sequence of digits)
<span class="lineno">  149 </span>-- and add 1 to that number, viewing an identifier with no trailing number as
<span class="lineno">  150 </span>-- ending in 0
<span class="lineno">  151 </span>nextVariant :: Coq.Ident -&gt; Coq.Ident
<span class="lineno">  152 </span><span class="decl"><span class="nottickedoff">nextVariant (Coq.Ident s) = Coq.Ident (reverse (go (reverse s)))</span>
<span class="lineno">  153 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  154 </span><span class="spaces">    </span><span class="nottickedoff">go :: String -&gt; String</span>
<span class="lineno">  155 </span><span class="spaces">    </span><span class="nottickedoff">go (c : cs)</span>
<span class="lineno">  156 </span><span class="spaces">      </span><span class="nottickedoff">| c == '9'  = '0' : go cs</span>
<span class="lineno">  157 </span><span class="spaces">      </span><span class="nottickedoff">| isDigit c = succ c : cs</span>
<span class="lineno">  158 </span><span class="spaces">    </span><span class="nottickedoff">go cs = '1' : cs</span></span>
<span class="lineno">  159 </span>
<span class="lineno">  160 </span>-- | Find an fresh, as-yet-unused variant of the given Coq identifier
<span class="lineno">  161 </span>freshVariant :: TermTranslationMonad m =&gt; Coq.Ident -&gt; m Coq.Ident
<span class="lineno">  162 </span><span class="decl"><span class="nottickedoff">freshVariant x =</span>
<span class="lineno">  163 </span><span class="spaces">  </span><span class="nottickedoff">do used &lt;- view unavailableIdents &lt;$&gt; askTR</span>
<span class="lineno">  164 </span><span class="spaces">     </span><span class="nottickedoff">let ident0 = x</span>
<span class="lineno">  165 </span><span class="spaces">     </span><span class="nottickedoff">let findVariant i = if Set.member i used then findVariant (nextVariant i) else i</span>
<span class="lineno">  166 </span><span class="spaces">     </span><span class="nottickedoff">return $ findVariant ident0</span></span>
<span class="lineno">  167 </span>
<span class="lineno">  168 </span>-- | Locally mark a Coq identifier as being used in the translation during a
<span class="lineno">  169 </span>-- translation computation, so that computation does not shadow it
<span class="lineno">  170 </span>withUsedCoqIdent :: TermTranslationMonad m =&gt; Coq.Ident -&gt; m a -&gt; m a
<span class="lineno">  171 </span><span class="decl"><span class="nottickedoff">withUsedCoqIdent ident m =</span>
<span class="lineno">  172 </span><span class="spaces">  </span><span class="nottickedoff">localTR (over unavailableIdents (Set.insert ident)) m</span></span>
<span class="lineno">  173 </span>
<span class="lineno">  174 </span>-- | Translate a local name from a saw-core binder into a fresh Coq identifier
<span class="lineno">  175 </span>translateLocalIdent :: TermTranslationMonad m =&gt; LocalName -&gt; m Coq.Ident
<span class="lineno">  176 </span><span class="decl"><span class="nottickedoff">translateLocalIdent x = freshVariant (escapeIdent (Coq.Ident (Text.unpack x)))</span></span>
<span class="lineno">  177 </span>
<span class="lineno">  178 </span>-- | Generate a fresh, unused Coq identifier from a SAW core name and mark it as
<span class="lineno">  179 </span>-- unavailable in the supplied translation computation
<span class="lineno">  180 </span>withFreshIdent :: TermTranslationMonad m =&gt; LocalName -&gt; (Coq.Ident -&gt; m a) -&gt;
<span class="lineno">  181 </span>                  m a
<span class="lineno">  182 </span><span class="decl"><span class="nottickedoff">withFreshIdent n f =</span>
<span class="lineno">  183 </span><span class="spaces">  </span><span class="nottickedoff">do n_coq &lt;- translateLocalIdent n</span>
<span class="lineno">  184 </span><span class="spaces">     </span><span class="nottickedoff">withUsedCoqIdent n_coq $ f n_coq</span></span>
<span class="lineno">  185 </span>
<span class="lineno">  186 </span>-- | Invalidate all shared subterms that are not closed in a translation
<span class="lineno">  187 </span>invalidateOpenSharing :: TermTranslationMonad m =&gt; m a -&gt; m a
<span class="lineno">  188 </span><span class="decl"><span class="nottickedoff">invalidateOpenSharing =</span>
<span class="lineno">  189 </span><span class="spaces">  </span><span class="nottickedoff">localTR (over sharedNames $ IntMap.filter sharedNameIsClosed)</span></span>
<span class="lineno">  190 </span>
<span class="lineno">  191 </span>-- | Run a translation in a context with one more SAW core variable with the
<span class="lineno">  192 </span>-- given name. Pass the corresponding Coq identifier used for this SAW core
<span class="lineno">  193 </span>-- variable to the computation in which it is bound. This invalidates all shared
<span class="lineno">  194 </span>-- terms that are not closed, since these shared terms now correspond to
<span class="lineno">  195 </span>-- different terms (with greater deBruijn indices) that have different
<span class="lineno">  196 </span>-- 'TermIndex'es.
<span class="lineno">  197 </span>withSAWVar :: TermTranslationMonad m =&gt; LocalName -&gt; (Coq.Ident -&gt; m a) -&gt; m a
<span class="lineno">  198 </span><span class="decl"><span class="nottickedoff">withSAWVar n m =</span>
<span class="lineno">  199 </span><span class="spaces">  </span><span class="nottickedoff">invalidateOpenSharing $ withFreshIdent n $ \n_coq -&gt;</span>
<span class="lineno">  200 </span><span class="spaces">  </span><span class="nottickedoff">localTR (over localEnvironment (n_coq :)) $ m n_coq</span></span>
<span class="lineno">  201 </span>
<span class="lineno">  202 </span>-- | Run a translation in a context with one more SAW core variable with the
<span class="lineno">  203 </span>-- given name. Pass the corresponding Coq identifier used for this SAW core
<span class="lineno">  204 </span>-- variable to the computation in which it is bound.
<span class="lineno">  205 </span>withSAWVarEC :: TermTranslationMonad m =&gt; VarName -&gt; (Coq.Ident -&gt; m a) -&gt; m a
<span class="lineno">  206 </span><span class="decl"><span class="nottickedoff">withSAWVarEC n m =</span>
<span class="lineno">  207 </span><span class="spaces">  </span><span class="nottickedoff">withFreshIdent (vnName n) $ \n_coq -&gt;</span>
<span class="lineno">  208 </span><span class="spaces">  </span><span class="nottickedoff">localTR (over namedEnvironment (Map.insert n n_coq)) $ m n_coq</span></span>
<span class="lineno">  209 </span>
<span class="lineno">  210 </span>-- | Find a fresh name generated from 'nextSharedName' to use in place of the
<span class="lineno">  211 </span>-- supplied 'Term' with the supplied index, and associate that index with the
<span class="lineno">  212 </span>-- fresh name in the 'sharedNames' sharing map. Pass the name that was generated
<span class="lineno">  213 </span>-- to the computation.
<span class="lineno">  214 </span>withSharedTerm :: TermTranslationMonad m =&gt; TermIndex -&gt; Term -&gt;
<span class="lineno">  215 </span>                  (Coq.Ident -&gt; m a) -&gt; m a
<span class="lineno">  216 </span><span class="decl"><span class="nottickedoff">withSharedTerm idx t f =</span>
<span class="lineno">  217 </span><span class="spaces">  </span><span class="nottickedoff">do ident &lt;- (view nextSharedName &lt;$&gt; askTR) &gt;&gt;= freshVariant</span>
<span class="lineno">  218 </span><span class="spaces">     </span><span class="nottickedoff">let sh_nm = SharedName ident $ termIsClosed t</span>
<span class="lineno">  219 </span><span class="spaces">     </span><span class="nottickedoff">localTR (set nextSharedName (nextVariant ident) .</span>
<span class="lineno">  220 </span><span class="spaces">              </span><span class="nottickedoff">over sharedNames (IntMap.insert idx sh_nm)) $</span>
<span class="lineno">  221 </span><span class="spaces">       </span><span class="nottickedoff">withUsedCoqIdent ident $ f ident</span></span>
<span class="lineno">  222 </span>
<span class="lineno">  223 </span>-- | Use 'withSharedTerm' to mark a list of terms as being shared
<span class="lineno">  224 </span>withSharedTerms :: TermTranslationMonad m =&gt; [(TermIndex,Term)] -&gt;
<span class="lineno">  225 </span>                   ([Coq.Ident] -&gt; m a) -&gt; m a
<span class="lineno">  226 </span><span class="decl"><span class="nottickedoff">withSharedTerms [] f = f []</span>
<span class="lineno">  227 </span><span class="spaces"></span><span class="nottickedoff">withSharedTerms ((idx,t):ts) f =</span>
<span class="lineno">  228 </span><span class="spaces">  </span><span class="nottickedoff">withSharedTerm idx t $ \n -&gt; withSharedTerms ts $ \ns -&gt; f (n:ns)</span></span>
<span class="lineno">  229 </span>
<span class="lineno">  230 </span>
<span class="lineno">  231 </span>-- | The set of reserved identifiers in Coq, obtained from section
<span class="lineno">  232 </span>-- \&quot;Gallina Specification Language\&quot; of the Coq reference manual.
<span class="lineno">  233 </span>-- &lt;https://coq.inria.fr/refman/language/gallina-specification-language.html&gt;
<span class="lineno">  234 </span>reservedIdents :: Set.Set Coq.Ident
<span class="lineno">  235 </span><span class="decl"><span class="nottickedoff">reservedIdents =</span>
<span class="lineno">  236 </span><span class="spaces">  </span><span class="nottickedoff">Set.fromList $</span>
<span class="lineno">  237 </span><span class="spaces">  </span><span class="nottickedoff">map Coq.Ident $</span>
<span class="lineno">  238 </span><span class="spaces">  </span><span class="nottickedoff">concatMap words $</span>
<span class="lineno">  239 </span><span class="spaces">  </span><span class="nottickedoff">[ &quot;_ Axiom CoFixpoint Definition Fixpoint Hypothesis IF Parameter Prop&quot;</span>
<span class="lineno">  240 </span><span class="spaces">  </span><span class="nottickedoff">, &quot;SProp Set Theorem Type Variable as at by cofix discriminated else&quot;</span>
<span class="lineno">  241 </span><span class="spaces">  </span><span class="nottickedoff">, &quot;end exists exists2 fix for forall fun if in lazymatch let match&quot;</span>
<span class="lineno">  242 </span><span class="spaces">  </span><span class="nottickedoff">, &quot;multimatch return then using where with&quot;</span>
<span class="lineno">  243 </span><span class="spaces">  </span><span class="nottickedoff">]</span></span>
<span class="lineno">  244 </span>
<span class="lineno">  245 </span>-- | Extract the list of names from a list of Coq declarations.  Not all
<span class="lineno">  246 </span>-- declarations have names, e.g. comments and code snippets come without names.
<span class="lineno">  247 </span>namedDecls :: [Coq.Decl] -&gt; [Coq.Ident]
<span class="lineno">  248 </span><span class="decl"><span class="nottickedoff">namedDecls = concatMap filterNamed</span>
<span class="lineno">  249 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  250 </span><span class="spaces">    </span><span class="nottickedoff">filterNamed :: Coq.Decl -&gt; [Coq.Ident]</span>
<span class="lineno">  251 </span><span class="spaces">    </span><span class="nottickedoff">filterNamed (Coq.Axiom n _)                               = [n]</span>
<span class="lineno">  252 </span><span class="spaces">    </span><span class="nottickedoff">filterNamed (Coq.Parameter n _)                           = [n]</span>
<span class="lineno">  253 </span><span class="spaces">    </span><span class="nottickedoff">filterNamed (Coq.Variable n _)                            = [n]</span>
<span class="lineno">  254 </span><span class="spaces">    </span><span class="nottickedoff">filterNamed (Coq.Comment _)                               = []</span>
<span class="lineno">  255 </span><span class="spaces">    </span><span class="nottickedoff">filterNamed (Coq.Definition n _ _ _)                      = [n]</span>
<span class="lineno">  256 </span><span class="spaces">    </span><span class="nottickedoff">filterNamed (Coq.InductiveDecl (Coq.Inductive n _ _ _ _)) = [n]</span>
<span class="lineno">  257 </span><span class="spaces">    </span><span class="nottickedoff">filterNamed (Coq.Snippet _)                               = []</span>
<span class="lineno">  258 </span><span class="spaces">    </span><span class="nottickedoff">filterNamed (Coq.Section _ ds)                            = namedDecls ds</span></span>
<span class="lineno">  259 </span>
<span class="lineno">  260 </span>-- | Retrieve the names of all local and global declarations from the
<span class="lineno">  261 </span>-- translation state.
<span class="lineno">  262 </span>getNamesOfAllDeclarations ::
<span class="lineno">  263 </span>  TermTranslationMonad m =&gt;
<span class="lineno">  264 </span>  m [Coq.Ident]
<span class="lineno">  265 </span><span class="decl"><span class="nottickedoff">getNamesOfAllDeclarations = view allDeclarations &lt;$&gt; get</span>
<span class="lineno">  266 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  267 </span><span class="spaces">    </span><span class="nottickedoff">allDeclarations =</span>
<span class="lineno">  268 </span><span class="spaces">      </span><span class="nottickedoff">to (\ (TranslationState {..}) -&gt; namedDecls _topLevelDeclarations ++ _globalDeclarations)</span></span>
<span class="lineno">  269 </span>
<span class="lineno">  270 </span>-- | Run a term translation computation
<span class="lineno">  271 </span>runTermTranslationMonad ::
<span class="lineno">  272 </span>  TranslationConfiguration -&gt;
<span class="lineno">  273 </span>  Maybe ModuleName -&gt;
<span class="lineno">  274 </span>  ModuleMap -&gt;
<span class="lineno">  275 </span>  [Coq.Ident] -&gt;
<span class="lineno">  276 </span>  [Coq.Ident] -&gt;
<span class="lineno">  277 </span>  (forall m. TermTranslationMonad m =&gt; m a) -&gt;
<span class="lineno">  278 </span>  Either (TranslationError Term) (a, TranslationState)
<span class="lineno">  279 </span><span class="decl"><span class="nottickedoff">runTermTranslationMonad configuration mname mm globalDecls localEnv =</span>
<span class="lineno">  280 </span><span class="spaces">  </span><span class="nottickedoff">runTranslationMonad configuration</span>
<span class="lineno">  281 </span><span class="spaces">  </span><span class="nottickedoff">(TranslationReader {</span>
<span class="lineno">  282 </span><span class="spaces">      </span><span class="nottickedoff">_currentModule = mname</span>
<span class="lineno">  283 </span><span class="spaces">      </span><span class="nottickedoff">, _localEnvironment = localEnv</span>
<span class="lineno">  284 </span><span class="spaces">      </span><span class="nottickedoff">, _namedEnvironment = Map.empty</span>
<span class="lineno">  285 </span><span class="spaces">      </span><span class="nottickedoff">, _unavailableIdents  = Set.union reservedIdents (Set.fromList localEnv)</span>
<span class="lineno">  286 </span><span class="spaces">      </span><span class="nottickedoff">, _sharedNames        = IntMap.empty</span>
<span class="lineno">  287 </span><span class="spaces">      </span><span class="nottickedoff">, _nextSharedName     = &quot;var__0&quot;</span>
<span class="lineno">  288 </span><span class="spaces">      </span><span class="nottickedoff">, _sawModuleMap       = mm })</span>
<span class="lineno">  289 </span><span class="spaces">  </span><span class="nottickedoff">(TranslationState { _globalDeclarations = globalDecls</span>
<span class="lineno">  290 </span><span class="spaces">                    </span><span class="nottickedoff">, _topLevelDeclarations  = []</span>
<span class="lineno">  291 </span><span class="spaces">                    </span><span class="nottickedoff">})</span></span>
<span class="lineno">  292 </span>
<span class="lineno">  293 </span>-- | Return a Coq term for an error computation with the given string message
<span class="lineno">  294 </span>errorTermM :: TermTranslationMonad m =&gt; String -&gt; m Coq.Term
<span class="lineno">  295 </span><span class="decl"><span class="nottickedoff">errorTermM str = return $ Coq.App (Coq.Var &quot;error&quot;) [Coq.StringLit str]</span></span>
<span class="lineno">  296 </span>
<span class="lineno">  297 </span>qualify :: ModuleName -&gt; Coq.Ident -&gt; Coq.Ident
<span class="lineno">  298 </span><span class="decl"><span class="nottickedoff">qualify m (Coq.Ident i) = Coq.Ident (Text.unpack (moduleNameText m) ++ &quot;.&quot; ++ i)</span></span>
<span class="lineno">  299 </span>
<span class="lineno">  300 </span>-- | Translate an 'Ident' with a given list of arguments to a Coq term, using
<span class="lineno">  301 </span>-- any special treatment for that identifier and qualifying it if necessary
<span class="lineno">  302 </span>translateIdentWithArgs :: TermTranslationMonad m =&gt; Ident -&gt; [Term] -&gt; m Coq.Term
<span class="lineno">  303 </span><span class="decl"><span class="nottickedoff">translateIdentWithArgs i args = do</span>
<span class="lineno">  304 </span><span class="spaces">  </span><span class="nottickedoff">currentModuleName &lt;- asks (view currentModule . otherConfiguration)</span>
<span class="lineno">  305 </span><span class="spaces">  </span><span class="nottickedoff">let identToCoq ident =</span>
<span class="lineno">  306 </span><span class="spaces">        </span><span class="nottickedoff">if Just (identModule ident) == currentModuleName</span>
<span class="lineno">  307 </span><span class="spaces">          </span><span class="nottickedoff">then base else qualify (translateModuleName (identModule ident)) base</span>
<span class="lineno">  308 </span><span class="spaces">        </span><span class="nottickedoff">where</span>
<span class="lineno">  309 </span><span class="spaces">          </span><span class="nottickedoff">base = escapeIdent (Coq.Ident (identName ident))</span>
<span class="lineno">  310 </span><span class="spaces">  </span><span class="nottickedoff">specialTreatment &lt;- findSpecialTreatment i</span>
<span class="lineno">  311 </span><span class="spaces">  </span><span class="nottickedoff">applySpecialTreatment identToCoq (atUseSite specialTreatment)</span>
<span class="lineno">  312 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  313 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  314 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  315 </span><span class="spaces">    </span><span class="nottickedoff">applySpecialTreatment identToCoq UsePreserve =</span>
<span class="lineno">  316 </span><span class="spaces">      </span><span class="nottickedoff">Coq.App (Coq.Var $ identToCoq i) &lt;$&gt; mapM translateTerm args</span>
<span class="lineno">  317 </span><span class="spaces">    </span><span class="nottickedoff">applySpecialTreatment _identToCoq (UseRename targetModule targetName expl) =</span>
<span class="lineno">  318 </span><span class="spaces">      </span><span class="nottickedoff">Coq.App</span>
<span class="lineno">  319 </span><span class="spaces">        </span><span class="nottickedoff">((if expl then Coq.ExplVar else Coq.Var) $</span>
<span class="lineno">  320 </span><span class="spaces">          </span><span class="nottickedoff">qualify (fromMaybe (translateModuleName $ identModule i) targetModule)</span>
<span class="lineno">  321 </span><span class="spaces">          </span><span class="nottickedoff">targetName)</span>
<span class="lineno">  322 </span><span class="spaces">          </span><span class="nottickedoff">&lt;$&gt; mapM translateTerm args</span>
<span class="lineno">  323 </span><span class="spaces">    </span><span class="nottickedoff">applySpecialTreatment _identToCoq (UseMacro n macroFun)</span>
<span class="lineno">  324 </span><span class="spaces">      </span><span class="nottickedoff">| length args &gt;= n</span>
<span class="lineno">  325 </span><span class="spaces">      </span><span class="nottickedoff">, (m_args, args') &lt;- splitAt n args =</span>
<span class="lineno">  326 </span><span class="spaces">        </span><span class="nottickedoff">do f &lt;- macroFun &lt;$&gt; mapM translateTerm m_args</span>
<span class="lineno">  327 </span><span class="spaces">           </span><span class="nottickedoff">Coq.App f &lt;$&gt; mapM translateTerm args'</span>
<span class="lineno">  328 </span><span class="spaces">    </span><span class="nottickedoff">applySpecialTreatment _identToCoq (UseMacro n _) =</span>
<span class="lineno">  329 </span><span class="spaces">      </span><span class="nottickedoff">errorTermM (unwords</span>
<span class="lineno">  330 </span><span class="spaces">        </span><span class="nottickedoff">[ &quot;Identifier&quot;</span>
<span class="lineno">  331 </span><span class="spaces">        </span><span class="nottickedoff">, show i</span>
<span class="lineno">  332 </span><span class="spaces">        </span><span class="nottickedoff">, &quot;not applied to required number of args, which is&quot;</span>
<span class="lineno">  333 </span><span class="spaces">        </span><span class="nottickedoff">, show n</span>
<span class="lineno">  334 </span><span class="spaces">        </span><span class="nottickedoff">]</span>
<span class="lineno">  335 </span><span class="spaces">      </span><span class="nottickedoff">)</span></span>
<span class="lineno">  336 </span>
<span class="lineno">  337 </span>-- | Helper for 'translateIdentWithArgs' with no arguments
<span class="lineno">  338 </span>translateIdent :: TermTranslationMonad m =&gt; Ident -&gt; m Coq.Term
<span class="lineno">  339 </span><span class="decl"><span class="nottickedoff">translateIdent i = translateIdentWithArgs i []</span></span>
<span class="lineno">  340 </span>
<span class="lineno">  341 </span>-- | Translate a constant to a Coq term. If the constant is named with
<span class="lineno">  342 </span>-- an 'Ident', then it already has a top-level translation from
<span class="lineno">  343 </span>-- translating the SAW core module containing that 'Ident'. If the
<span class="lineno">  344 </span>-- constant is an 'ImportedName', however, then it might not have a
<span class="lineno">  345 </span>-- Coq definition already, so add a definition of it to the top-level
<span class="lineno">  346 </span>-- translation state.
<span class="lineno">  347 </span>translateConstant :: TermTranslationMonad m =&gt; Name -&gt; m Coq.Term
<span class="lineno">  348 </span><span class="decl"><span class="nottickedoff">translateConstant nm</span>
<span class="lineno">  349 </span><span class="spaces">  </span><span class="nottickedoff">| ModuleIdentifier ident &lt;- nameInfo nm = translateIdent ident</span>
<span class="lineno">  350 </span><span class="spaces"></span><span class="nottickedoff">translateConstant nm =</span>
<span class="lineno">  351 </span><span class="spaces">  </span><span class="nottickedoff">do -- First, apply the constant renaming to get the name for this constant</span>
<span class="lineno">  352 </span><span class="spaces">     </span><span class="nottickedoff">configuration &lt;- asks translationConfiguration</span>
<span class="lineno">  353 </span><span class="spaces">     </span><span class="nottickedoff">-- TODO short name seems wrong</span>
<span class="lineno">  354 </span><span class="spaces">     </span><span class="nottickedoff">let nm_str = Text.unpack $ toShortName $ nameInfo nm</span>
<span class="lineno">  355 </span><span class="spaces">     </span><span class="nottickedoff">let renamed =</span>
<span class="lineno">  356 </span><span class="spaces">           </span><span class="nottickedoff">escapeIdent $ Coq.Ident $ fromMaybe nm_str $</span>
<span class="lineno">  357 </span><span class="spaces">           </span><span class="nottickedoff">lookup nm_str $ constantRenaming configuration</span>
<span class="lineno">  358 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  359 </span><span class="spaces">     </span><span class="nottickedoff">-- Next, test if we should add a definition of this constant</span>
<span class="lineno">  360 </span><span class="spaces">     </span><span class="nottickedoff">alreadyTranslatedDecls &lt;- getNamesOfAllDeclarations</span>
<span class="lineno">  361 </span><span class="spaces">     </span><span class="nottickedoff">let skip_def =</span>
<span class="lineno">  362 </span><span class="spaces">           </span><span class="nottickedoff">elem renamed alreadyTranslatedDecls ||</span>
<span class="lineno">  363 </span><span class="spaces">           </span><span class="nottickedoff">elem nm_str (constantSkips configuration)</span>
<span class="lineno">  364 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  365 </span><span class="spaces">     </span><span class="nottickedoff">-- Add the definition if we aren't skipping it</span>
<span class="lineno">  366 </span><span class="spaces">     </span><span class="nottickedoff">mm &lt;- asks (view sawModuleMap . otherConfiguration)</span>
<span class="lineno">  367 </span><span class="spaces">     </span><span class="nottickedoff">let resolved = requireNameInMap nm mm</span>
<span class="lineno">  368 </span><span class="spaces">     </span><span class="nottickedoff">let maybe_body =</span>
<span class="lineno">  369 </span><span class="spaces">           </span><span class="nottickedoff">case resolved of</span>
<span class="lineno">  370 </span><span class="spaces">             </span><span class="nottickedoff">ResolvedDef d -&gt; defBody d</span>
<span class="lineno">  371 </span><span class="spaces">             </span><span class="nottickedoff">_ -&gt; Nothing</span>
<span class="lineno">  372 </span><span class="spaces">     </span><span class="nottickedoff">case maybe_body of</span>
<span class="lineno">  373 </span><span class="spaces">       </span><span class="nottickedoff">_ | skip_def -&gt; return ()</span>
<span class="lineno">  374 </span><span class="spaces">       </span><span class="nottickedoff">Just body -&gt;</span>
<span class="lineno">  375 </span><span class="spaces">         </span><span class="nottickedoff">-- If the definition has a body, add it as a definition</span>
<span class="lineno">  376 </span><span class="spaces">         </span><span class="nottickedoff">do b &lt;- withTopTranslationState $ translateTermLet body</span>
<span class="lineno">  377 </span><span class="spaces">            </span><span class="nottickedoff">tp &lt;- withTopTranslationState $ translateTermLet (resolvedNameType resolved)</span>
<span class="lineno">  378 </span><span class="spaces">            </span><span class="nottickedoff">modify $ over topLevelDeclarations $ (mkDefinition renamed b tp :)</span>
<span class="lineno">  379 </span><span class="spaces">       </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno">  380 </span><span class="spaces">         </span><span class="nottickedoff">-- If not, add it as a Coq Variable declaration</span>
<span class="lineno">  381 </span><span class="spaces">         </span><span class="nottickedoff">do tp &lt;- withTopTranslationState $ translateTermLet (resolvedNameType resolved)</span>
<span class="lineno">  382 </span><span class="spaces">            </span><span class="nottickedoff">modify (over topLevelDeclarations (Coq.Variable renamed tp :))</span>
<span class="lineno">  383 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  384 </span><span class="spaces">     </span><span class="nottickedoff">-- Finally, return the constant as a Coq variable</span>
<span class="lineno">  385 </span><span class="spaces">     </span><span class="nottickedoff">pure (Coq.Var renamed)</span></span>
<span class="lineno">  386 </span>
<span class="lineno">  387 </span>
<span class="lineno">  388 </span>-- | Translate an 'Ident' and see if the result maps to a special 'Coq.Ident',
<span class="lineno">  389 </span>-- returning the latter 'Coq.Ident' if so
<span class="lineno">  390 </span>translateIdentToIdent :: TermTranslationMonad m =&gt; Ident -&gt; m (Maybe Coq.Ident)
<span class="lineno">  391 </span><span class="decl"><span class="nottickedoff">translateIdentToIdent i =</span>
<span class="lineno">  392 </span><span class="spaces">  </span><span class="nottickedoff">(atUseSite &lt;$&gt; findSpecialTreatment i) &gt;&gt;= \case</span>
<span class="lineno">  393 </span><span class="spaces">    </span><span class="nottickedoff">UsePreserve -&gt; return $ Just (qualify translatedModuleName (Coq.Ident (Text.unpack (identBaseName i))))</span>
<span class="lineno">  394 </span><span class="spaces">    </span><span class="nottickedoff">UseRename   targetModule targetName _ -&gt;</span>
<span class="lineno">  395 </span><span class="spaces">      </span><span class="nottickedoff">return $ Just $ qualify (fromMaybe translatedModuleName targetModule) targetName</span>
<span class="lineno">  396 </span><span class="spaces">    </span><span class="nottickedoff">UseMacro _ _ -&gt; return Nothing</span>
<span class="lineno">  397 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  398 </span><span class="spaces">    </span><span class="nottickedoff">translatedModuleName = translateModuleName (identModule i)</span></span>
<span class="lineno">  399 </span>
<span class="lineno">  400 </span>translateSort :: Sort -&gt; Coq.Sort
<span class="lineno">  401 </span><span class="decl"><span class="nottickedoff">translateSort s = if s == propSort then Coq.Prop else Coq.Type</span></span>
<span class="lineno">  402 </span>
<span class="lineno">  403 </span>flatTermFToExpr ::
<span class="lineno">  404 </span>  TermTranslationMonad m =&gt;
<span class="lineno">  405 </span>  FlatTermF Term -&gt;
<span class="lineno">  406 </span>  m Coq.Term
<span class="lineno">  407 </span><span class="decl"><span class="nottickedoff">flatTermFToExpr tf = -- traceFTermF &quot;flatTermFToExpr&quot; tf $</span>
<span class="lineno">  408 </span><span class="spaces">  </span><span class="nottickedoff">case tf of</span>
<span class="lineno">  409 </span><span class="spaces">    </span><span class="nottickedoff">UnitValue     -&gt; pure (Coq.Var &quot;tt&quot;)</span>
<span class="lineno">  410 </span><span class="spaces">    </span><span class="nottickedoff">UnitType      -&gt;</span>
<span class="lineno">  411 </span><span class="spaces">      </span><span class="nottickedoff">-- We need to explicitly tell Coq that we want unit to be a Type, since</span>
<span class="lineno">  412 </span><span class="spaces">      </span><span class="nottickedoff">-- all SAW core sorts are translated to Types</span>
<span class="lineno">  413 </span><span class="spaces">      </span><span class="nottickedoff">pure (Coq.Ascription (Coq.Var &quot;unit&quot;) (Coq.Sort Coq.Type))</span>
<span class="lineno">  414 </span><span class="spaces">    </span><span class="nottickedoff">PairValue x y -&gt; Coq.App (Coq.Var &quot;pair&quot;) &lt;$&gt; traverse translateTerm [x, y]</span>
<span class="lineno">  415 </span><span class="spaces">    </span><span class="nottickedoff">PairType x y  -&gt; Coq.App (Coq.Var &quot;prod&quot;) &lt;$&gt; traverse translateTerm [x, y]</span>
<span class="lineno">  416 </span><span class="spaces">    </span><span class="nottickedoff">PairLeft t    -&gt;</span>
<span class="lineno">  417 </span><span class="spaces">      </span><span class="nottickedoff">Coq.App &lt;$&gt; pure (Coq.Var &quot;fst&quot;) &lt;*&gt; traverse translateTerm [t]</span>
<span class="lineno">  418 </span><span class="spaces">    </span><span class="nottickedoff">PairRight t   -&gt;</span>
<span class="lineno">  419 </span><span class="spaces">      </span><span class="nottickedoff">Coq.App &lt;$&gt; pure (Coq.Var &quot;snd&quot;) &lt;*&gt; traverse translateTerm [t]</span>
<span class="lineno">  420 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  421 </span><span class="spaces">    </span><span class="nottickedoff">Recursor crec -&gt;</span>
<span class="lineno">  422 </span><span class="spaces">      </span><span class="nottickedoff">do let d = recursorDataType crec</span>
<span class="lineno">  423 </span><span class="spaces">         </span><span class="nottickedoff">maybe_d_trans &lt;-</span>
<span class="lineno">  424 </span><span class="spaces">           </span><span class="nottickedoff">case nameInfo d of</span>
<span class="lineno">  425 </span><span class="spaces">             </span><span class="nottickedoff">ModuleIdentifier ident -&gt; translateIdentToIdent ident</span>
<span class="lineno">  426 </span><span class="spaces">             </span><span class="nottickedoff">ImportedName{} -&gt; pure Nothing</span>
<span class="lineno">  427 </span><span class="spaces">         </span><span class="nottickedoff">case maybe_d_trans of</span>
<span class="lineno">  428 </span><span class="spaces">           </span><span class="nottickedoff">Just (Coq.Ident i) -&gt; return $ Coq.ExplVar (Coq.Ident (i ++ &quot;_rect&quot;))</span>
<span class="lineno">  429 </span><span class="spaces">           </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno">  430 </span><span class="spaces">             </span><span class="nottickedoff">errorTermM (&quot;Recursor for &quot; ++ show d ++</span>
<span class="lineno">  431 </span><span class="spaces">                         </span><span class="nottickedoff">&quot; cannot be translated because the datatype &quot; ++</span>
<span class="lineno">  432 </span><span class="spaces">                         </span><span class="nottickedoff">&quot;is mapped to an arbitrary Coq term&quot;)</span>
<span class="lineno">  433 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  434 </span><span class="spaces">    </span><span class="nottickedoff">Sort s _h -&gt; pure (Coq.Sort (translateSort s))</span>
<span class="lineno">  435 </span><span class="spaces">    </span><span class="nottickedoff">NatLit i -&gt; pure (Coq.NatLit (toInteger i))</span>
<span class="lineno">  436 </span><span class="spaces">    </span><span class="nottickedoff">ArrayValue (asBoolType -&gt; Just ()) (traverse asBool -&gt; Just bits)</span>
<span class="lineno">  437 </span><span class="spaces">      </span><span class="nottickedoff">| Pair w bv &lt;- BV.bitsBE (Vector.toList bits)</span>
<span class="lineno">  438 </span><span class="spaces">      </span><span class="nottickedoff">, Left LeqProof &lt;- decideLeq (knownNat @1) w -&gt; do</span>
<span class="lineno">  439 </span><span class="spaces">          </span><span class="nottickedoff">return (Coq.App (Coq.Var &quot;intToBv&quot;)</span>
<span class="lineno">  440 </span><span class="spaces">                  </span><span class="nottickedoff">[Coq.NatLit (intValue w), Coq.ZLit (BV.asSigned w bv)])</span>
<span class="lineno">  441 </span><span class="spaces">    </span><span class="nottickedoff">ArrayValue _ vec -&gt; do</span>
<span class="lineno">  442 </span><span class="spaces">      </span><span class="nottickedoff">elems &lt;- Vector.toList &lt;$&gt; mapM translateTerm vec</span>
<span class="lineno">  443 </span><span class="spaces">      </span><span class="nottickedoff">-- NOTE: with VectorNotations, this is actually a Coq vector literal</span>
<span class="lineno">  444 </span><span class="spaces">      </span><span class="nottickedoff">return $ Coq.List elems</span>
<span class="lineno">  445 </span><span class="spaces">    </span><span class="nottickedoff">StringLit s -&gt; pure (Coq.Scope (Coq.StringLit (Text.unpack s)) &quot;string&quot;)</span>
<span class="lineno">  446 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  447 </span><span class="spaces">    </span><span class="nottickedoff">-- The translation of a record type {fld1:tp1, ..., fldn:tpn} is</span>
<span class="lineno">  448 </span><span class="spaces">    </span><span class="nottickedoff">-- RecordTypeCons fld1 tp1 (... (RecordTypeCons fldn tpn RecordTypeNil)...).</span>
<span class="lineno">  449 </span><span class="spaces">    </span><span class="nottickedoff">-- Note that SAW core equates record types up to reordering, so we sort our</span>
<span class="lineno">  450 </span><span class="spaces">    </span><span class="nottickedoff">-- record types by field name to canonicalize them.</span>
<span class="lineno">  451 </span><span class="spaces">    </span><span class="nottickedoff">RecordType fs -&gt;</span>
<span class="lineno">  452 </span><span class="spaces">      </span><span class="nottickedoff">foldr (\(name, tp) rest_m -&gt;</span>
<span class="lineno">  453 </span><span class="spaces">              </span><span class="nottickedoff">do rest &lt;- rest_m</span>
<span class="lineno">  454 </span><span class="spaces">                 </span><span class="nottickedoff">tp_trans &lt;- translateTerm tp</span>
<span class="lineno">  455 </span><span class="spaces">                 </span><span class="nottickedoff">return (Coq.App (Coq.Var &quot;RecordTypeCons&quot;)</span>
<span class="lineno">  456 </span><span class="spaces">                         </span><span class="nottickedoff">[Coq.StringLit (Text.unpack name), tp_trans, rest]))</span>
<span class="lineno">  457 </span><span class="spaces">      </span><span class="nottickedoff">(return (Coq.Var &quot;RecordTypeNil&quot;))</span>
<span class="lineno">  458 </span><span class="spaces">      </span><span class="nottickedoff">(sortOn fst fs)</span>
<span class="lineno">  459 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  460 </span><span class="spaces">    </span><span class="nottickedoff">-- The translation of a record value {fld1 = x1, ..., fldn = xn} is</span>
<span class="lineno">  461 </span><span class="spaces">    </span><span class="nottickedoff">-- RecordCons fld1 x1 (... (RecordCons fldn xn RecordNil) ...). Note that</span>
<span class="lineno">  462 </span><span class="spaces">    </span><span class="nottickedoff">-- SAW core equates record values up to reordering, so we sort our record</span>
<span class="lineno">  463 </span><span class="spaces">    </span><span class="nottickedoff">-- values by field name to canonicalize them.</span>
<span class="lineno">  464 </span><span class="spaces">    </span><span class="nottickedoff">RecordValue fs -&gt;</span>
<span class="lineno">  465 </span><span class="spaces">      </span><span class="nottickedoff">foldr (\(name, trm) rest_m -&gt;</span>
<span class="lineno">  466 </span><span class="spaces">              </span><span class="nottickedoff">do rest &lt;- rest_m</span>
<span class="lineno">  467 </span><span class="spaces">                 </span><span class="nottickedoff">trm_trans &lt;- translateTerm trm</span>
<span class="lineno">  468 </span><span class="spaces">                 </span><span class="nottickedoff">return (Coq.App (Coq.Var &quot;RecordCons&quot;)</span>
<span class="lineno">  469 </span><span class="spaces">                         </span><span class="nottickedoff">[Coq.StringLit (Text.unpack name), trm_trans, rest]))</span>
<span class="lineno">  470 </span><span class="spaces">      </span><span class="nottickedoff">(return (Coq.Var &quot;RecordNil&quot;))</span>
<span class="lineno">  471 </span><span class="spaces">      </span><span class="nottickedoff">(sortOn fst fs)</span>
<span class="lineno">  472 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  473 </span><span class="spaces">    </span><span class="nottickedoff">RecordProj r f -&gt; do</span>
<span class="lineno">  474 </span><span class="spaces">      </span><span class="nottickedoff">r_trans &lt;- translateTerm r</span>
<span class="lineno">  475 </span><span class="spaces">      </span><span class="nottickedoff">return (Coq.App (Coq.Var &quot;RecordProj&quot;) [r_trans, Coq.StringLit (Text.unpack f)])</span></span>
<span class="lineno">  476 </span>
<span class="lineno">  477 </span>-- | Recognizes an @App (App &quot;Cryptol.seq&quot; n) x@ and returns @(n, x)@.
<span class="lineno">  478 </span>asSeq :: Recognizer Term (Term, Term)
<span class="lineno">  479 </span><span class="decl"><span class="nottickedoff">asSeq t = do (f, args) &lt;- asApplyAllRecognizer t</span>
<span class="lineno">  480 </span><span class="spaces">             </span><span class="nottickedoff">fid &lt;- asGlobalDef f</span>
<span class="lineno">  481 </span><span class="spaces">             </span><span class="nottickedoff">case (fid, args) of</span>
<span class="lineno">  482 </span><span class="spaces">               </span><span class="nottickedoff">(&quot;Cryptol.seq&quot;, [n, x]) -&gt; return (n,x)</span>
<span class="lineno">  483 </span><span class="spaces">               </span><span class="nottickedoff">_ -&gt; Fail.fail &quot;not a seq&quot;</span></span>
<span class="lineno">  484 </span>
<span class="lineno">  485 </span>asApplyAllRecognizer :: Recognizer Term (Term, [Term])
<span class="lineno">  486 </span><span class="decl"><span class="nottickedoff">asApplyAllRecognizer t = do _ &lt;- asApp t</span>
<span class="lineno">  487 </span><span class="spaces">                            </span><span class="nottickedoff">return $ asApplyAll t</span></span>
<span class="lineno">  488 </span>
<span class="lineno">  489 </span>-- | Run a translation in the top-level translation state with no free SAW
<span class="lineno">  490 </span>-- variables and no bound Coq identifiers
<span class="lineno">  491 </span>withTopTranslationState :: TermTranslationMonad m =&gt; m a -&gt; m a
<span class="lineno">  492 </span><span class="decl"><span class="nottickedoff">withTopTranslationState m =</span>
<span class="lineno">  493 </span><span class="spaces">  </span><span class="nottickedoff">localTR (\r -&gt;</span>
<span class="lineno">  494 </span><span class="spaces">            </span><span class="nottickedoff">TranslationReader {</span>
<span class="lineno">  495 </span><span class="spaces">              </span><span class="nottickedoff">_currentModule     = view currentModule r,</span>
<span class="lineno">  496 </span><span class="spaces">              </span><span class="nottickedoff">_localEnvironment  = [],</span>
<span class="lineno">  497 </span><span class="spaces">              </span><span class="nottickedoff">_namedEnvironment  = Map.empty,</span>
<span class="lineno">  498 </span><span class="spaces">              </span><span class="nottickedoff">_unavailableIdents = reservedIdents,</span>
<span class="lineno">  499 </span><span class="spaces">              </span><span class="nottickedoff">_sharedNames       = IntMap.empty,</span>
<span class="lineno">  500 </span><span class="spaces">              </span><span class="nottickedoff">_nextSharedName    = &quot;var__0&quot; ,</span>
<span class="lineno">  501 </span><span class="spaces">              </span><span class="nottickedoff">_sawModuleMap      = view sawModuleMap r }) m</span></span>
<span class="lineno">  502 </span>
<span class="lineno">  503 </span>-- | Generate a Coq @Definition@ with a given name, body, and type, using the
<span class="lineno">  504 </span>-- lambda-bound variable names for the variables if they are available
<span class="lineno">  505 </span>mkDefinition :: Coq.Ident -&gt; Coq.Term -&gt; Coq.Term -&gt; Coq.Decl
<span class="lineno">  506 </span><span class="decl"><span class="nottickedoff">mkDefinition name (Coq.Lambda bs t) (Coq.Pi bs' tp)</span>
<span class="lineno">  507 </span><span class="spaces">  </span><span class="nottickedoff">| length bs' == length bs =</span>
<span class="lineno">  508 </span><span class="spaces">    </span><span class="nottickedoff">-- NOTE: there are a number of cases where length bs /= length bs', such as</span>
<span class="lineno">  509 </span><span class="spaces">    </span><span class="nottickedoff">-- where the type of a definition is computed from some input (so might not</span>
<span class="lineno">  510 </span><span class="spaces">    </span><span class="nottickedoff">-- have any explicit pi-abstractions), or where the body of a definition is</span>
<span class="lineno">  511 </span><span class="spaces">    </span><span class="nottickedoff">-- a partially applied function (so might not have any lambdas). We could in</span>
<span class="lineno">  512 </span><span class="spaces">    </span><span class="nottickedoff">-- theory try to handle these more complex cases by assigning names to some</span>
<span class="lineno">  513 </span><span class="spaces">    </span><span class="nottickedoff">-- of the arguments, but it's not really necessary for the translation to be</span>
<span class="lineno">  514 </span><span class="spaces">    </span><span class="nottickedoff">-- correct, so we just do the simple thing here.</span>
<span class="lineno">  515 </span><span class="spaces">    </span><span class="nottickedoff">Coq.Definition name bs (Just tp) t</span>
<span class="lineno">  516 </span><span class="spaces"></span><span class="nottickedoff">mkDefinition name t tp = Coq.Definition name [] (Just tp) t</span></span>
<span class="lineno">  517 </span>
<span class="lineno">  518 </span>mkLet :: (Coq.Ident, Coq.Term) -&gt; Coq.Term -&gt; Coq.Term
<span class="lineno">  519 </span><span class="decl"><span class="nottickedoff">mkLet (name, rhs) body = Coq.Let name [] Nothing rhs body</span></span>
<span class="lineno">  520 </span>
<span class="lineno">  521 </span>-- | The result of translating a SAW core variable binding to Coq, including the
<span class="lineno">  522 </span>-- Coq identifier for the variable, the Coq translation of its type, and 0 or
<span class="lineno">  523 </span>-- more implicit Coq arguments that apply to the variable
<span class="lineno">  524 </span>data BindTrans = BindTrans { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">bindTransIdent</span></span></span> :: Coq.Ident,
<span class="lineno">  525 </span>                             <span class="nottickedoff"><span class="decl"><span class="nottickedoff">bindTransType</span></span></span> :: Coq.Type,
<span class="lineno">  526 </span>                             <span class="nottickedoff"><span class="decl"><span class="nottickedoff">bindTransImps</span></span></span> :: [(Coq.Ident,Coq.Type)] }
<span class="lineno">  527 </span>
<span class="lineno">  528 </span>-- | Convert a 'BindTrans' to a list of Coq term-level binders
<span class="lineno">  529 </span>bindTransToBinder :: BindTrans -&gt; [Coq.Binder]
<span class="lineno">  530 </span><span class="decl"><span class="nottickedoff">bindTransToBinder (BindTrans {..}) =</span>
<span class="lineno">  531 </span><span class="spaces">  </span><span class="nottickedoff">Coq.Binder bindTransIdent (Just bindTransType) :</span>
<span class="lineno">  532 </span><span class="spaces">  </span><span class="nottickedoff">map (\(n,ty) -&gt; Coq.ImplicitBinder n (Just ty)) bindTransImps</span></span>
<span class="lineno">  533 </span>
<span class="lineno">  534 </span>-- | Convert a 'BindTrans' to a list of Coq type-level pi-abstraction binders
<span class="lineno">  535 </span>bindTransToPiBinder :: BindTrans -&gt; [Coq.PiBinder]
<span class="lineno">  536 </span><span class="decl"><span class="nottickedoff">bindTransToPiBinder (BindTrans { .. }) =</span>
<span class="lineno">  537 </span><span class="spaces">  </span><span class="nottickedoff">case bindTransImps of</span>
<span class="lineno">  538 </span><span class="spaces">    </span><span class="nottickedoff">[] | bindTransIdent == &quot;_&quot; -&gt; [Coq.PiBinder Nothing bindTransType]</span>
<span class="lineno">  539 </span><span class="spaces">    </span><span class="nottickedoff">[] -&gt; [Coq.PiBinder (Just bindTransIdent) bindTransType]</span>
<span class="lineno">  540 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno">  541 </span><span class="spaces">      </span><span class="nottickedoff">Coq.PiBinder (Just bindTransIdent) bindTransType :</span>
<span class="lineno">  542 </span><span class="spaces">      </span><span class="nottickedoff">map (\(n,ty) -&gt; Coq.PiImplicitBinder (Just n) ty) bindTransImps</span></span>
<span class="lineno">  543 </span>
<span class="lineno">  544 </span>-- | Given a 'LocalName' and its type (as a 'Term'), translate the 'LocalName'
<span class="lineno">  545 </span>-- to a Coq identifier, translate the type to a Coq term, and generate zero or
<span class="lineno">  546 </span>-- more additional 'Ident's and 'Type's representing additonal implicit
<span class="lineno">  547 </span>-- typeclass arguments, added if the given type is @isort@, etc. Pass all of
<span class="lineno">  548 </span>-- this information to the supplied computation, in which the SAW core variable
<span class="lineno">  549 </span>-- is bound to its Coq identifier.
<span class="lineno">  550 </span>translateBinder :: TermTranslationMonad m =&gt; LocalName -&gt; Term -&gt;
<span class="lineno">  551 </span>                   (BindTrans -&gt; m a) -&gt; m a
<span class="lineno">  552 </span><span class="decl"><span class="nottickedoff">translateBinder n ty@(asPiList -&gt; (args, pi_body)) f =</span>
<span class="lineno">  553 </span><span class="spaces">  </span><span class="nottickedoff">do ty' &lt;- translateTerm ty</span>
<span class="lineno">  554 </span><span class="spaces">     </span><span class="nottickedoff">let mb_sort = asSortWithFlags pi_body</span>
<span class="lineno">  555 </span><span class="spaces">         </span><span class="nottickedoff">flagValues = sortFlagsToList $ maybe noFlags snd mb_sort</span>
<span class="lineno">  556 </span><span class="spaces">         </span><span class="nottickedoff">flagLocalNames = [(&quot;Inh&quot;, &quot;SAWCoreScaffolding.Inhabited&quot;),</span>
<span class="lineno">  557 </span><span class="spaces">                           </span><span class="nottickedoff">(&quot;QT&quot;, &quot;QuantType&quot;)]</span>
<span class="lineno">  558 </span><span class="spaces">     </span><span class="nottickedoff">withSAWVar n $ \n' -&gt;</span>
<span class="lineno">  559 </span><span class="spaces">       </span><span class="nottickedoff">helper n' (zip flagValues flagLocalNames) (\imps -&gt;</span>
<span class="lineno">  560 </span><span class="spaces">                                                   </span><span class="nottickedoff">f $ BindTrans n' ty' imps)</span>
<span class="lineno">  561 </span><span class="spaces">       </span><span class="nottickedoff">where</span>
<span class="lineno">  562 </span><span class="spaces">         </span><span class="nottickedoff">helper _ [] g = g []</span>
<span class="lineno">  563 </span><span class="spaces">         </span><span class="nottickedoff">helper n' ((True,(prefix,tc)):rest) g =</span>
<span class="lineno">  564 </span><span class="spaces">           </span><span class="nottickedoff">do nhty &lt;- translateImplicitHyp (Coq.Var tc) args (Coq.Var n')</span>
<span class="lineno">  565 </span><span class="spaces">              </span><span class="nottickedoff">withFreshIdent (prefix &lt;&gt; &quot;_&quot; &lt;&gt; n) $ \nh -&gt;</span>
<span class="lineno">  566 </span><span class="spaces">                </span><span class="nottickedoff">helper n' rest (g . ((nh,nhty) :))</span>
<span class="lineno">  567 </span><span class="spaces">         </span><span class="nottickedoff">helper n' ((False,_):rest) g = helper n' rest g</span></span>
<span class="lineno">  568 </span>
<span class="lineno">  569 </span>-- | Given an 'ExtCns' with its type (as a 'Term'), translate the 'ExtCns'
<span class="lineno">  570 </span>-- to a Coq identifier, translate the type to a Coq term, and generate zero or
<span class="lineno">  571 </span>-- more additional 'Ident's and 'Type's representing additonal implicit
<span class="lineno">  572 </span>-- typeclass arguments, added if the given type is @isort@, etc. Pass all of
<span class="lineno">  573 </span>-- this information to the supplied computation, in which the SAW core variable
<span class="lineno">  574 </span>-- is bound to its Coq identifier.
<span class="lineno">  575 </span>translateBinderEC ::
<span class="lineno">  576 </span>  forall m a. TermTranslationMonad m =&gt; ExtCns Term -&gt; (BindTrans -&gt; m a) -&gt; m a
<span class="lineno">  577 </span><span class="decl"><span class="nottickedoff">translateBinderEC ec f =</span>
<span class="lineno">  578 </span><span class="spaces">  </span><span class="nottickedoff">do ty' &lt;- translateTerm ty</span>
<span class="lineno">  579 </span><span class="spaces">     </span><span class="nottickedoff">let mb_sort = asSortWithFlags pi_body</span>
<span class="lineno">  580 </span><span class="spaces">         </span><span class="nottickedoff">-- NOTE: sortFlagsToList always returns a 2-element list</span>
<span class="lineno">  581 </span><span class="spaces">         </span><span class="nottickedoff">flagValues = sortFlagsToList $ maybe noFlags snd mb_sort</span>
<span class="lineno">  582 </span><span class="spaces">         </span><span class="nottickedoff">flagLocalNames = [(&quot;Inh&quot;, &quot;SAWCoreScaffolding.Inhabited&quot;),</span>
<span class="lineno">  583 </span><span class="spaces">                           </span><span class="nottickedoff">(&quot;QT&quot;, &quot;QuantType&quot;)]</span>
<span class="lineno">  584 </span><span class="spaces">     </span><span class="nottickedoff">withSAWVarEC nm $ \n' -&gt;</span>
<span class="lineno">  585 </span><span class="spaces">       </span><span class="nottickedoff">helper n' (zip flagValues flagLocalNames) (\imps -&gt;</span>
<span class="lineno">  586 </span><span class="spaces">                                                   </span><span class="nottickedoff">f $ BindTrans n' ty' imps)</span>
<span class="lineno">  587 </span><span class="spaces">       </span><span class="nottickedoff">where</span>
<span class="lineno">  588 </span><span class="spaces">         </span><span class="nottickedoff">ty = ecType ec</span>
<span class="lineno">  589 </span><span class="spaces">         </span><span class="nottickedoff">(args, pi_body) = asPiList ty</span>
<span class="lineno">  590 </span><span class="spaces">         </span><span class="nottickedoff">nm = ecName ec</span>
<span class="lineno">  591 </span><span class="spaces">         </span><span class="nottickedoff">n = vnName nm</span>
<span class="lineno">  592 </span><span class="spaces">         </span><span class="nottickedoff">helper ::</span>
<span class="lineno">  593 </span><span class="spaces">           </span><span class="nottickedoff">Coq.Ident -&gt;</span>
<span class="lineno">  594 </span><span class="spaces">           </span><span class="nottickedoff">[(Bool, (LocalName, Coq.Ident))] -&gt;</span>
<span class="lineno">  595 </span><span class="spaces">           </span><span class="nottickedoff">([(Coq.Ident, Coq.Term)] -&gt; m a) -&gt;</span>
<span class="lineno">  596 </span><span class="spaces">           </span><span class="nottickedoff">m a</span>
<span class="lineno">  597 </span><span class="spaces">         </span><span class="nottickedoff">helper _ [] g = g []</span>
<span class="lineno">  598 </span><span class="spaces">         </span><span class="nottickedoff">helper n' ((True,(prefix,tc)):rest) g =</span>
<span class="lineno">  599 </span><span class="spaces">           </span><span class="nottickedoff">do nhty &lt;- translateImplicitHyp (Coq.Var tc) args (Coq.Var n')</span>
<span class="lineno">  600 </span><span class="spaces">              </span><span class="nottickedoff">withFreshIdent (prefix &lt;&gt; &quot;_&quot; &lt;&gt; n) $ \nh -&gt;</span>
<span class="lineno">  601 </span><span class="spaces">                </span><span class="nottickedoff">helper n' rest (g . ((nh,nhty) :))</span>
<span class="lineno">  602 </span><span class="spaces">         </span><span class="nottickedoff">helper n' ((False,_):rest) g = helper n' rest g</span></span>
<span class="lineno">  603 </span>
<span class="lineno">  604 </span>-- | Call 'translateBinder' on a list of SAW core bindings
<span class="lineno">  605 </span>translateBinders :: TermTranslationMonad m =&gt; [(LocalName,Term)] -&gt;
<span class="lineno">  606 </span>                    ([BindTrans] -&gt; m a) -&gt; m a
<span class="lineno">  607 </span><span class="decl"><span class="nottickedoff">translateBinders [] f = f []</span>
<span class="lineno">  608 </span><span class="spaces"></span><span class="nottickedoff">translateBinders ((n,ty):ns_tys) f =</span>
<span class="lineno">  609 </span><span class="spaces">  </span><span class="nottickedoff">translateBinder n ty $ \bnd -&gt;</span>
<span class="lineno">  610 </span><span class="spaces">  </span><span class="nottickedoff">translateBinders ns_tys $ \bnds -&gt; f (bnd : bnds)</span></span>
<span class="lineno">  611 </span>
<span class="lineno">  612 </span>-- | Call 'translateBinder' on a list of SAW core bindings
<span class="lineno">  613 </span>translateBindersEC ::
<span class="lineno">  614 </span>  TermTranslationMonad m =&gt; [ExtCns Term] -&gt; ([BindTrans] -&gt; m a) -&gt; m a
<span class="lineno">  615 </span><span class="decl"><span class="nottickedoff">translateBindersEC [] f = f []</span>
<span class="lineno">  616 </span><span class="spaces"></span><span class="nottickedoff">translateBindersEC (ec : ecs) f =</span>
<span class="lineno">  617 </span><span class="spaces">  </span><span class="nottickedoff">translateBinderEC ec $ \bnd -&gt;</span>
<span class="lineno">  618 </span><span class="spaces">  </span><span class="nottickedoff">translateBindersEC ecs $ \bnds -&gt; f (bnd : bnds)</span></span>
<span class="lineno">  619 </span>
<span class="lineno">  620 </span>-- | Given a typeclass (as a Coq term), a list of 'LocalName's and their
<span class="lineno">  621 </span>-- corresponding types (as 'Term's), and a type-level function with argument
<span class="lineno">  622 </span>-- types given by the prior list, return a 'Pi' of the given arguments, inside
<span class="lineno">  623 </span>-- of which is an 'App' of the typeclass to the fully-applied type-level
<span class="lineno">  624 </span>-- function
<span class="lineno">  625 </span>translateImplicitHyp ::
<span class="lineno">  626 </span>  TermTranslationMonad m =&gt;
<span class="lineno">  627 </span>  Coq.Term -&gt; [(LocalName, Term)] -&gt; Coq.Term -&gt; m Coq.Term
<span class="lineno">  628 </span><span class="decl"><span class="nottickedoff">translateImplicitHyp tc [] tm = return (Coq.App tc [tm])</span>
<span class="lineno">  629 </span><span class="spaces"></span><span class="nottickedoff">translateImplicitHyp tc args tm =</span>
<span class="lineno">  630 </span><span class="spaces">  </span><span class="nottickedoff">translateBinders args $ \args' -&gt;</span>
<span class="lineno">  631 </span><span class="spaces">  </span><span class="nottickedoff">return $ Coq.Pi (concatMap mkPi args') (Coq.App tc [Coq.App tm (map mkArg args')])</span>
<span class="lineno">  632 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  633 </span><span class="spaces">    </span><span class="nottickedoff">mkPi (BindTrans nm ty nhs) =</span>
<span class="lineno">  634 </span><span class="spaces">      </span><span class="nottickedoff">Coq.PiBinder (Just nm) ty :</span>
<span class="lineno">  635 </span><span class="spaces">      </span><span class="nottickedoff">map (\(nh,nhty) -&gt; Coq.PiImplicitBinder (Just nh) nhty) nhs</span>
<span class="lineno">  636 </span><span class="spaces">    </span><span class="nottickedoff">mkArg b = Coq.Var $ bindTransIdent b</span></span>
<span class="lineno">  637 </span>
<span class="lineno">  638 </span>-- | Given a list of 'LocalName's and their corresponding types (as 'Term's),
<span class="lineno">  639 </span>-- return a list of explicit 'Binder's, for use representing the bound variables
<span class="lineno">  640 </span>-- in 'Lambda's, 'Let's, etc.
<span class="lineno">  641 </span>translateParams :: TermTranslationMonad m =&gt; [(LocalName, Term)] -&gt;
<span class="lineno">  642 </span>                   ([Coq.Binder] -&gt; m a) -&gt; m a
<span class="lineno">  643 </span><span class="decl"><span class="nottickedoff">translateParams bs m =</span>
<span class="lineno">  644 </span><span class="spaces">  </span><span class="nottickedoff">translateBinders bs (m . concat . map bindTransToBinder)</span></span>
<span class="lineno">  645 </span>
<span class="lineno">  646 </span>-- | Given a list of 'LocalName's and their corresponding types (as 'Term's),
<span class="lineno">  647 </span>-- return a list of explicit 'Binder's, for use representing the bound variables
<span class="lineno">  648 </span>-- in 'Lambda's, 'Let's, etc.
<span class="lineno">  649 </span>translateParamsEC ::
<span class="lineno">  650 </span>  TermTranslationMonad m =&gt; [ExtCns Term] -&gt; ([Coq.Binder] -&gt; m a) -&gt; m a
<span class="lineno">  651 </span><span class="decl"><span class="nottickedoff">translateParamsEC bs m =</span>
<span class="lineno">  652 </span><span class="spaces">  </span><span class="nottickedoff">translateBindersEC bs (m . concatMap bindTransToBinder)</span></span>
<span class="lineno">  653 </span>
<span class="lineno">  654 </span>
<span class="lineno">  655 </span>-- | Given a list of 'LocalName's and their corresponding types (as 'Term's)
<span class="lineno">  656 </span>-- representing argument types and a 'Term' representing the return type,
<span class="lineno">  657 </span>-- return the resulting 'Pi', with additional implicit arguments added after
<span class="lineno">  658 </span>-- each instance of @isort@, @qsort@, etc.
<span class="lineno">  659 </span>translatePi :: TermTranslationMonad m =&gt; [(LocalName, Term)] -&gt; Term -&gt; m Coq.Term
<span class="lineno">  660 </span><span class="decl"><span class="nottickedoff">translatePi binders body =</span>
<span class="lineno">  661 </span><span class="spaces">  </span><span class="nottickedoff">translatePiBinders binders $ \bindersT -&gt;</span>
<span class="lineno">  662 </span><span class="spaces">  </span><span class="nottickedoff">do bodyT &lt;- translateTermLet body</span>
<span class="lineno">  663 </span><span class="spaces">     </span><span class="nottickedoff">return $ Coq.Pi bindersT bodyT</span></span>
<span class="lineno">  664 </span>
<span class="lineno">  665 </span>-- | Given a 'LocalName' and its type (as a 'Term'), return an explicit
<span class="lineno">  666 </span>-- 'PiBinder' followed by zero or more implicit 'PiBinder's representing
<span class="lineno">  667 </span>-- additonal implicit typeclass arguments, added if the given type is @isort@,
<span class="lineno">  668 </span>-- @qsort@, etc.
<span class="lineno">  669 </span>translatePiBinders :: TermTranslationMonad m =&gt; [(LocalName, Term)] -&gt;
<span class="lineno">  670 </span>                      ([Coq.PiBinder] -&gt; m a) -&gt; m a
<span class="lineno">  671 </span><span class="decl"><span class="nottickedoff">translatePiBinders bs m =</span>
<span class="lineno">  672 </span><span class="spaces">  </span><span class="nottickedoff">translateBinders bs (m . concat . map bindTransToPiBinder)</span></span>
<span class="lineno">  673 </span>
<span class="lineno">  674 </span>-- | Find all subterms of a SAW core term that should be shared, and generate
<span class="lineno">  675 </span>-- let-bindings in Coq to bind them to local variables. Translate SAW core term
<span class="lineno">  676 </span>-- using those let-bindings for the shared subterms.
<span class="lineno">  677 </span>translateTermLet :: TermTranslationMonad m =&gt; Term -&gt; m Coq.Term
<span class="lineno">  678 </span><span class="decl"><span class="nottickedoff">translateTermLet t =</span>
<span class="lineno">  679 </span><span class="spaces">  </span><span class="nottickedoff">let occ_map = scTermCount False t</span>
<span class="lineno">  680 </span><span class="spaces">      </span><span class="nottickedoff">shares = IntMap.assocs $ fmap fst $ IntMap.filter keep occ_map</span>
<span class="lineno">  681 </span><span class="spaces">      </span><span class="nottickedoff">share_tms = map snd shares in</span>
<span class="lineno">  682 </span><span class="spaces">  </span><span class="nottickedoff">-- NOTE: larger terms always have later stAppIndices than their subterms, so</span>
<span class="lineno">  683 </span><span class="spaces">  </span><span class="nottickedoff">-- IntMap.assocs above is guaranteed to return subterms before superterms;</span>
<span class="lineno">  684 </span><span class="spaces">  </span><span class="nottickedoff">-- this ensures that the right-hand sides in our nested let-bindings below</span>
<span class="lineno">  685 </span><span class="spaces">  </span><span class="nottickedoff">-- only refer to variables bound earlier, not later</span>
<span class="lineno">  686 </span><span class="spaces">  </span><span class="nottickedoff">withSharedTerms shares $ \names -&gt;</span>
<span class="lineno">  687 </span><span class="spaces">  </span><span class="nottickedoff">do defs &lt;- traverse translateTermUnshared share_tms</span>
<span class="lineno">  688 </span><span class="spaces">     </span><span class="nottickedoff">body &lt;- translateTerm t</span>
<span class="lineno">  689 </span><span class="spaces">     </span><span class="nottickedoff">pure (foldr mkLet body $ zip names defs)</span>
<span class="lineno">  690 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  691 </span><span class="spaces">    </span><span class="nottickedoff">keep (t', n) = n &gt; 1 &amp;&amp; shouldMemoizeTerm t'</span></span>
<span class="lineno">  692 </span>
<span class="lineno">  693 </span>-- | Translate a SAW core 'Term' to Coq, using let-bound Coq names when they are
<span class="lineno">  694 </span>-- associated with the given term for sharing
<span class="lineno">  695 </span>translateTerm :: TermTranslationMonad m =&gt; Term -&gt; m Coq.Term
<span class="lineno">  696 </span><span class="decl"><span class="nottickedoff">translateTerm t =</span>
<span class="lineno">  697 </span><span class="spaces">  </span><span class="nottickedoff">case t of</span>
<span class="lineno">  698 </span><span class="spaces">    </span><span class="nottickedoff">Unshared {} -&gt; translateTermUnshared t</span>
<span class="lineno">  699 </span><span class="spaces">    </span><span class="nottickedoff">STApp { stAppIndex = i } -&gt;</span>
<span class="lineno">  700 </span><span class="spaces">      </span><span class="nottickedoff">do shared &lt;- view sharedNames &lt;$&gt; askTR</span>
<span class="lineno">  701 </span><span class="spaces">         </span><span class="nottickedoff">case IntMap.lookup i shared of</span>
<span class="lineno">  702 </span><span class="spaces">           </span><span class="nottickedoff">Nothing -&gt; translateTermUnshared t</span>
<span class="lineno">  703 </span><span class="spaces">           </span><span class="nottickedoff">Just sh -&gt; pure (Coq.Var $ sharedNameIdent sh)</span></span>
<span class="lineno">  704 </span>
<span class="lineno">  705 </span>-- | Translate a SAW core 'Term' to Coq without using sharing
<span class="lineno">  706 </span>translateTermUnshared :: TermTranslationMonad m =&gt; Term -&gt; m Coq.Term
<span class="lineno">  707 </span><span class="decl"><span class="nottickedoff">translateTermUnshared t = do</span>
<span class="lineno">  708 </span><span class="spaces">  </span><span class="nottickedoff">-- traceTerm &quot;translateTerm&quot; t $</span>
<span class="lineno">  709 </span><span class="spaces">  </span><span class="nottickedoff">-- NOTE: env is in innermost-first order</span>
<span class="lineno">  710 </span><span class="spaces">  </span><span class="nottickedoff">env &lt;- view localEnvironment &lt;$&gt; askTR</span>
<span class="lineno">  711 </span><span class="spaces">  </span><span class="nottickedoff">-- let t' = trace (&quot;translateTerm: &quot; ++ &quot;env = &quot; ++ show env ++ &quot;, t =&quot; ++ showTerm t) t</span>
<span class="lineno">  712 </span><span class="spaces">  </span><span class="nottickedoff">-- case t' of</span>
<span class="lineno">  713 </span><span class="spaces">  </span><span class="nottickedoff">case unwrapTermF t of</span>
<span class="lineno">  714 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  715 </span><span class="spaces">    </span><span class="nottickedoff">FTermF ftf -&gt; flatTermFToExpr ftf</span>
<span class="lineno">  716 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  717 </span><span class="spaces">    </span><span class="nottickedoff">Pi {} -&gt;</span>
<span class="lineno">  718 </span><span class="spaces">      </span><span class="nottickedoff">let (params, e) = asPiList t in</span>
<span class="lineno">  719 </span><span class="spaces">      </span><span class="nottickedoff">translatePi params e</span>
<span class="lineno">  720 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  721 </span><span class="spaces">    </span><span class="nottickedoff">Lambda {} -&gt;</span>
<span class="lineno">  722 </span><span class="spaces">      </span><span class="nottickedoff">let (params, e) = asLambdaList t in</span>
<span class="lineno">  723 </span><span class="spaces">      </span><span class="nottickedoff">translateParams params $ \paramTerms -&gt;</span>
<span class="lineno">  724 </span><span class="spaces">        </span><span class="nottickedoff">do e' &lt;- translateTermLet e</span>
<span class="lineno">  725 </span><span class="spaces">           </span><span class="nottickedoff">return (Coq.Lambda paramTerms e')</span>
<span class="lineno">  726 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  727 </span><span class="spaces">    </span><span class="nottickedoff">App {} -&gt;</span>
<span class="lineno">  728 </span><span class="spaces">      </span><span class="nottickedoff">-- asApplyAll: innermost argument first</span>
<span class="lineno">  729 </span><span class="spaces">      </span><span class="nottickedoff">let (f, args) = asApplyAll t</span>
<span class="lineno">  730 </span><span class="spaces">      </span><span class="nottickedoff">in</span>
<span class="lineno">  731 </span><span class="spaces">      </span><span class="nottickedoff">case f of</span>
<span class="lineno">  732 </span><span class="spaces">      </span><span class="nottickedoff">(asGlobalDef -&gt; Just i) -&gt;</span>
<span class="lineno">  733 </span><span class="spaces">        </span><span class="nottickedoff">case i of</span>
<span class="lineno">  734 </span><span class="spaces">        </span><span class="nottickedoff">&quot;Prelude.natToInt&quot; -&gt;</span>
<span class="lineno">  735 </span><span class="spaces">          </span><span class="nottickedoff">case args of</span>
<span class="lineno">  736 </span><span class="spaces">          </span><span class="nottickedoff">[n] -&gt; translateTerm n &gt;&gt;= \case</span>
<span class="lineno">  737 </span><span class="spaces">            </span><span class="nottickedoff">Coq.NatLit n' -&gt; pure $ Coq.ZLit n'</span>
<span class="lineno">  738 </span><span class="spaces">            </span><span class="nottickedoff">_ -&gt; translateIdentWithArgs &quot;Prelude.natToInt&quot; [n]</span>
<span class="lineno">  739 </span><span class="spaces">          </span><span class="nottickedoff">_ -&gt; badTerm</span>
<span class="lineno">  740 </span><span class="spaces">        </span><span class="nottickedoff">&quot;Prelude.intNeg&quot; -&gt;</span>
<span class="lineno">  741 </span><span class="spaces">          </span><span class="nottickedoff">case args of</span>
<span class="lineno">  742 </span><span class="spaces">          </span><span class="nottickedoff">[z] -&gt; translateTerm z &gt;&gt;= \case</span>
<span class="lineno">  743 </span><span class="spaces">            </span><span class="nottickedoff">Coq.ZLit z' -&gt; pure $ Coq.ZLit (-z')</span>
<span class="lineno">  744 </span><span class="spaces">            </span><span class="nottickedoff">_ -&gt; translateIdentWithArgs &quot;Prelude.intNeg&quot; [z]</span>
<span class="lineno">  745 </span><span class="spaces">          </span><span class="nottickedoff">_ -&gt; badTerm</span>
<span class="lineno">  746 </span><span class="spaces">        </span><span class="nottickedoff">&quot;Prelude.ite&quot; -&gt;</span>
<span class="lineno">  747 </span><span class="spaces">          </span><span class="nottickedoff">case args of</span>
<span class="lineno">  748 </span><span class="spaces">          </span><span class="nottickedoff">-- `rest` can be non-empty in examples like:</span>
<span class="lineno">  749 </span><span class="spaces">          </span><span class="nottickedoff">-- (if b then f else g) arg1 arg2</span>
<span class="lineno">  750 </span><span class="spaces">          </span><span class="nottickedoff">_ty : c : tt : ft : rest -&gt; do</span>
<span class="lineno">  751 </span><span class="spaces">            </span><span class="nottickedoff">ite &lt;- Coq.If &lt;$&gt; translateTerm c &lt;*&gt; translateTerm tt &lt;*&gt; translateTerm ft</span>
<span class="lineno">  752 </span><span class="spaces">            </span><span class="nottickedoff">case rest of</span>
<span class="lineno">  753 </span><span class="spaces">              </span><span class="nottickedoff">[] -&gt; return ite</span>
<span class="lineno">  754 </span><span class="spaces">              </span><span class="nottickedoff">_  -&gt; Coq.App ite &lt;$&gt; mapM translateTerm rest</span>
<span class="lineno">  755 </span><span class="spaces">          </span><span class="nottickedoff">_ -&gt; badTerm</span>
<span class="lineno">  756 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  757 </span><span class="spaces">        </span><span class="nottickedoff">-- Refuse to translate any recursive value defined using Prelude.fix</span>
<span class="lineno">  758 </span><span class="spaces">        </span><span class="nottickedoff">&quot;Prelude.fix&quot; -&gt; badTerm</span>
<span class="lineno">  759 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  760 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt; translateIdentWithArgs i args</span>
<span class="lineno">  761 </span><span class="spaces">      </span><span class="nottickedoff">_ -&gt; Coq.App &lt;$&gt; translateTerm f &lt;*&gt; traverse translateTerm args</span>
<span class="lineno">  762 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  763 </span><span class="spaces">    </span><span class="nottickedoff">LocalVar n</span>
<span class="lineno">  764 </span><span class="spaces">      </span><span class="nottickedoff">| n &lt; length env -&gt; Coq.Var &lt;$&gt; pure (env !! n)</span>
<span class="lineno">  765 </span><span class="spaces">      </span><span class="nottickedoff">| otherwise -&gt; Except.throwError $ LocalVarOutOfBounds t</span>
<span class="lineno">  766 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  767 </span><span class="spaces">    </span><span class="nottickedoff">-- Constants</span>
<span class="lineno">  768 </span><span class="spaces">    </span><span class="nottickedoff">Constant n -&gt; translateConstant n</span>
<span class="lineno">  769 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  770 </span><span class="spaces">    </span><span class="nottickedoff">Variable ec -&gt;</span>
<span class="lineno">  771 </span><span class="spaces">      </span><span class="nottickedoff">do nenv &lt;- view namedEnvironment &lt;$&gt; askTR</span>
<span class="lineno">  772 </span><span class="spaces">         </span><span class="nottickedoff">let nm = ecName ec</span>
<span class="lineno">  773 </span><span class="spaces">         </span><span class="nottickedoff">case Map.lookup nm nenv of</span>
<span class="lineno">  774 </span><span class="spaces">           </span><span class="nottickedoff">Just ident -&gt; pure (Coq.Var ident)</span>
<span class="lineno">  775 </span><span class="spaces">           </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno">  776 </span><span class="spaces">             </span><span class="nottickedoff">do let nm_str = Text.unpack $ vnName nm</span>
<span class="lineno">  777 </span><span class="spaces">                </span><span class="nottickedoff">let ident = escapeIdent $ Coq.Ident $ nm_str</span>
<span class="lineno">  778 </span><span class="spaces">                </span><span class="nottickedoff">pure (Coq.Var ident)</span>
<span class="lineno">  779 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  780 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  781 </span><span class="spaces">    </span><span class="nottickedoff">badTerm          = Except.throwError $ BadTerm t</span></span>
<span class="lineno">  782 </span>
<span class="lineno">  783 </span>-- | In order to turn fixpoint computations into iterative computations, we need
<span class="lineno">  784 </span>-- to be able to create \&quot;dummy\&quot; values at the type of the computation.
<span class="lineno">  785 </span>defaultTermForType ::
<span class="lineno">  786 </span>  TermTranslationMonad m =&gt;
<span class="lineno">  787 </span>  Term -&gt; m Coq.Term
<span class="lineno">  788 </span><span class="decl"><span class="nottickedoff">defaultTermForType typ = do</span>
<span class="lineno">  789 </span><span class="spaces">  </span><span class="nottickedoff">case typ of</span>
<span class="lineno">  790 </span><span class="spaces">    </span><span class="nottickedoff">(asBoolType -&gt; Just ()) -&gt; translateIdent (mkIdent preludeName &quot;False&quot;)</span>
<span class="lineno">  791 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  792 </span><span class="spaces">    </span><span class="nottickedoff">(isGlobalDef &quot;Prelude.Nat&quot; -&gt; Just ()) -&gt; return $ Coq.NatLit 0</span>
<span class="lineno">  793 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  794 </span><span class="spaces">    </span><span class="nottickedoff">(asIntegerType -&gt; Just ()) -&gt; return $ Coq.ZLit 0</span>
<span class="lineno">  795 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  796 </span><span class="spaces">    </span><span class="nottickedoff">(asSeq -&gt; Just (n, typ')) -&gt; do</span>
<span class="lineno">  797 </span><span class="spaces">      </span><span class="nottickedoff">seqConst &lt;- translateIdent (mkIdent (mkModuleName [&quot;Cryptol&quot;]) &quot;seqConst&quot;)</span>
<span class="lineno">  798 </span><span class="spaces">      </span><span class="nottickedoff">nT       &lt;- translateTerm n</span>
<span class="lineno">  799 </span><span class="spaces">      </span><span class="nottickedoff">typ'T    &lt;- translateTerm typ'</span>
<span class="lineno">  800 </span><span class="spaces">      </span><span class="nottickedoff">defaultT &lt;- defaultTermForType typ'</span>
<span class="lineno">  801 </span><span class="spaces">      </span><span class="nottickedoff">return $ Coq.App seqConst [ nT, typ'T, defaultT ]</span>
<span class="lineno">  802 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  803 </span><span class="spaces">    </span><span class="nottickedoff">(asPairType -&gt; Just (x,y)) -&gt; do</span>
<span class="lineno">  804 </span><span class="spaces">      </span><span class="nottickedoff">x' &lt;- defaultTermForType x</span>
<span class="lineno">  805 </span><span class="spaces">      </span><span class="nottickedoff">y' &lt;- defaultTermForType y</span>
<span class="lineno">  806 </span><span class="spaces">      </span><span class="nottickedoff">return $ Coq.App (Coq.Var &quot;pair&quot;) [x',y']</span>
<span class="lineno">  807 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  808 </span><span class="spaces">    </span><span class="nottickedoff">(asPiList -&gt; (bs,body))</span>
<span class="lineno">  809 </span><span class="spaces">      </span><span class="nottickedoff">| not (null bs)</span>
<span class="lineno">  810 </span><span class="spaces">      </span><span class="nottickedoff">, looseVars body == emptyBitSet -&gt;</span>
<span class="lineno">  811 </span><span class="spaces">      </span><span class="nottickedoff">do bs'   &lt;- forM bs $ \ (_nm, ty) -&gt; Coq.Binder &quot;_&quot; . Just &lt;$&gt; translateTerm ty</span>
<span class="lineno">  812 </span><span class="spaces">         </span><span class="nottickedoff">body' &lt;- defaultTermForType body</span>
<span class="lineno">  813 </span><span class="spaces">         </span><span class="nottickedoff">return $ Coq.Lambda bs' body'</span>
<span class="lineno">  814 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  815 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; Except.throwError $ CannotCreateDefaultValue typ</span></span>
<span class="lineno">  816 </span>
<span class="lineno">  817 </span>-- | Translate a SAW core term along with its type to a Coq term and its Coq
<span class="lineno">  818 </span>-- type, and pass the results to the supplied function
<span class="lineno">  819 </span>translateTermToDocWith ::
<span class="lineno">  820 </span>  TranslationConfiguration -&gt;
<span class="lineno">  821 </span>  Maybe ModuleName -&gt;
<span class="lineno">  822 </span>  ModuleMap -&gt;
<span class="lineno">  823 </span>  [Coq.Ident] -&gt; -- ^ globals that have already been translated
<span class="lineno">  824 </span>  [Coq.Ident] -&gt; -- ^ names of local variables in scope
<span class="lineno">  825 </span>  (Coq.Term -&gt; Coq.Term -&gt; Doc ann) -&gt;
<span class="lineno">  826 </span>  Term -&gt; Term -&gt;
<span class="lineno">  827 </span>  Either (TranslationError Term) (Doc ann)
<span class="lineno">  828 </span><span class="decl"><span class="nottickedoff">translateTermToDocWith configuration r mm globalDecls localEnv f t tp_trm = do</span>
<span class="lineno">  829 </span><span class="spaces">  </span><span class="nottickedoff">((term, tp), state) &lt;-</span>
<span class="lineno">  830 </span><span class="spaces">    </span><span class="nottickedoff">runTermTranslationMonad configuration r mm globalDecls localEnv</span>
<span class="lineno">  831 </span><span class="spaces">    </span><span class="nottickedoff">((,) &lt;$&gt; translateTermLet t &lt;*&gt; translateTermLet tp_trm)</span>
<span class="lineno">  832 </span><span class="spaces">  </span><span class="nottickedoff">let decls = view topLevelDeclarations state</span>
<span class="lineno">  833 </span><span class="spaces">  </span><span class="nottickedoff">return $</span>
<span class="lineno">  834 </span><span class="spaces">    </span><span class="nottickedoff">vcat $</span>
<span class="lineno">  835 </span><span class="spaces">    </span><span class="nottickedoff">[ (vcat . intersperse hardline . map Coq.ppDecl . reverse) decls</span>
<span class="lineno">  836 </span><span class="spaces">    </span><span class="nottickedoff">, if null decls then mempty else hardline</span>
<span class="lineno">  837 </span><span class="spaces">    </span><span class="nottickedoff">, f term tp</span>
<span class="lineno">  838 </span><span class="spaces">    </span><span class="nottickedoff">]</span></span>
<span class="lineno">  839 </span>
<span class="lineno">  840 </span>-- | Translate a SAW core 'Term' and its type (given as a 'Term') to a Coq
<span class="lineno">  841 </span>-- definition with the supplied name
<span class="lineno">  842 </span>translateDefDoc ::
<span class="lineno">  843 </span>  TranslationConfiguration -&gt;
<span class="lineno">  844 </span>  Maybe ModuleName -&gt;
<span class="lineno">  845 </span>  ModuleMap -&gt;
<span class="lineno">  846 </span>  [Coq.Ident] -&gt;
<span class="lineno">  847 </span>  Coq.Ident -&gt; Term -&gt; Term -&gt;
<span class="lineno">  848 </span>  Either (TranslationError Term) (Doc ann)
<span class="lineno">  849 </span><span class="decl"><span class="nottickedoff">translateDefDoc configuration r mm globalDecls name =</span>
<span class="lineno">  850 </span><span class="spaces">  </span><span class="nottickedoff">translateTermToDocWith configuration r mm globalDecls [name]</span>
<span class="lineno">  851 </span><span class="spaces">  </span><span class="nottickedoff">(\ t tp -&gt; Coq.ppDecl $ mkDefinition name t tp)</span></span>

</pre>
</body>
</html>
