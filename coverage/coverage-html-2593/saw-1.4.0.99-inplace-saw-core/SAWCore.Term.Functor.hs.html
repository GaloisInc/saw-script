<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# OPTIONS_GHC -fno-warn-orphans #-}
<span class="lineno">    2 </span>{-# LANGUAGE DeriveGeneric #-}
<span class="lineno">    3 </span>{-# LANGUAGE DeriveLift #-}
<span class="lineno">    4 </span>{-# LANGUAGE DeriveTraversable #-}
<span class="lineno">    5 </span>{-# LANGUAGE FlexibleInstances #-}
<span class="lineno">    6 </span>{-# LANGUAGE RankNTypes #-}
<span class="lineno">    7 </span>{-# LANGUAGE PatternGuards #-}
<span class="lineno">    8 </span>{-# LANGUAGE BangPatterns #-}
<span class="lineno">    9 </span>{-# LANGUAGE TypeOperators #-}
<span class="lineno">   10 </span>
<span class="lineno">   11 </span>{- |
<span class="lineno">   12 </span>Module      : SAWCore.Term.Functor
<span class="lineno">   13 </span>Copyright   : Galois, Inc. 2012-2025
<span class="lineno">   14 </span>License     : BSD3
<span class="lineno">   15 </span>Maintainer  : huffman@galois.com
<span class="lineno">   16 </span>Stability   : experimental
<span class="lineno">   17 </span>Portability : non-portable (language extensions)
<span class="lineno">   18 </span>-}
<span class="lineno">   19 </span>
<span class="lineno">   20 </span>module SAWCore.Term.Functor
<span class="lineno">   21 </span>  ( -- * Module Names
<span class="lineno">   22 </span>    ModuleName, mkModuleName
<span class="lineno">   23 </span>  , preludeName
<span class="lineno">   24 </span>  , moduleNameText
<span class="lineno">   25 </span>  , moduleNamePieces
<span class="lineno">   26 </span>    -- * Identifiers
<span class="lineno">   27 </span>  , Ident(identModule, identBaseName), identName, mkIdent
<span class="lineno">   28 </span>  , parseIdent
<span class="lineno">   29 </span>  , isIdent
<span class="lineno">   30 </span>  , identText
<span class="lineno">   31 </span>  , identPieces
<span class="lineno">   32 </span>    -- * Data types and definitions
<span class="lineno">   33 </span>  , FieldName
<span class="lineno">   34 </span>  , LocalName
<span class="lineno">   35 </span>  , ExtCns(..)
<span class="lineno">   36 </span>  , VarIndex
<span class="lineno">   37 </span>  , NameInfo(..)
<span class="lineno">   38 </span>  , toShortName
<span class="lineno">   39 </span>  , toAbsoluteName
<span class="lineno">   40 </span>  , CompiledRecursor(..)
<span class="lineno">   41 </span>    -- * Terms and associated operations
<span class="lineno">   42 </span>  , TermIndex
<span class="lineno">   43 </span>  , Term(..)
<span class="lineno">   44 </span>  , TermF(..)
<span class="lineno">   45 </span>  , FlatTermF(..)
<span class="lineno">   46 </span>  , zipWithFlatTermF
<span class="lineno">   47 </span>  , unwrapTermF
<span class="lineno">   48 </span>  , termToPat
<span class="lineno">   49 </span>  , alphaEquiv
<span class="lineno">   50 </span>  , alistAllFields
<span class="lineno">   51 </span>    -- * Sorts
<span class="lineno">   52 </span>  , Sort(..), mkSort, propSort, sortOf, maxSort
<span class="lineno">   53 </span>  , SortFlags(..), noFlags, sortFlagsLift2, sortFlagsToList, sortFlagsFromList
<span class="lineno">   54 </span>    -- * Sets of free variables
<span class="lineno">   55 </span>  , freesTermF, freeVars
<span class="lineno">   56 </span>  , closedTerm
<span class="lineno">   57 </span>  ) where
<span class="lineno">   58 </span>
<span class="lineno">   59 </span>import qualified Data.Foldable as Foldable (and, foldl')
<span class="lineno">   60 </span>import Data.Hashable
<span class="lineno">   61 </span>import Data.IntMap (IntMap)
<span class="lineno">   62 </span>import qualified Data.IntMap as IntMap
<span class="lineno">   63 </span>import Data.IntSet (IntSet)
<span class="lineno">   64 </span>import qualified Data.IntSet as IntSet
<span class="lineno">   65 </span>import Data.Text (Text)
<span class="lineno">   66 </span>import qualified Data.Text as Text
<span class="lineno">   67 </span>import Data.Typeable (Typeable)
<span class="lineno">   68 </span>import Data.Vector (Vector)
<span class="lineno">   69 </span>import qualified Data.Vector as V
<span class="lineno">   70 </span>import GHC.Generics (Generic)
<span class="lineno">   71 </span>import Numeric.Natural
<span class="lineno">   72 </span>
<span class="lineno">   73 </span>import qualified Language.Haskell.TH.Syntax as TH
<span class="lineno">   74 </span>import Instances.TH.Lift () -- for instance TH.Lift Text
<span class="lineno">   75 </span>
<span class="lineno">   76 </span>import SAWCore.Name
<span class="lineno">   77 </span>import qualified SAWCore.TermNet as Net
<span class="lineno">   78 </span>
<span class="lineno">   79 </span>type FieldName = Text
<span class="lineno">   80 </span>type LocalName = Text
<span class="lineno">   81 </span>
<span class="lineno">   82 </span>instance <span class="decl"><span class="nottickedoff">Hashable a =&gt; Hashable (Vector a)</span></span> where
<span class="lineno">   83 </span>    <span class="decl"><span class="istickedoff">hashWithSalt x v = hashWithSalt x (V.toList v)</span></span>
<span class="lineno">   84 </span>
<span class="lineno">   85 </span>
<span class="lineno">   86 </span>-- Sorts -----------------------------------------------------------------------
<span class="lineno">   87 </span>
<span class="lineno">   88 </span>-- | The sorts, also known as universes, which can either be a predicative
<span class="lineno">   89 </span>-- universe with level i or the impredicative universe Prop.
<span class="lineno">   90 </span>data Sort
<span class="lineno">   91 </span>  = TypeSort Natural
<span class="lineno">   92 </span>  | PropSort
<span class="lineno">   93 </span>  deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">TH.Lift</span></span></span></span>)
<span class="lineno">   94 </span>
<span class="lineno">   95 </span>-- Prop is the lowest sort
<span class="lineno">   96 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Ord Sort</span></span></span></span></span></span></span></span></span></span></span></span> where
<span class="lineno">   97 </span>  <span class="decl"><span class="istickedoff">PropSort &lt;= _ = True</span>
<span class="lineno">   98 </span><span class="spaces">  </span><span class="istickedoff">(TypeSort _) &lt;= PropSort = <span class="nottickedoff">False</span></span>
<span class="lineno">   99 </span><span class="spaces">  </span><span class="istickedoff">(TypeSort i) &lt;= (TypeSort j) = i &lt;= j</span></span>
<span class="lineno">  100 </span>
<span class="lineno">  101 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Hashable Sort</span></span></span></span> -- automatically derived
<span class="lineno">  102 </span>
<span class="lineno">  103 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Show Sort</span></span></span></span> where
<span class="lineno">  104 </span>  <span class="decl"><span class="istickedoff">showsPrec p (TypeSort i) = showParen (p &gt;= 10) (showString &quot;sort &quot; . shows i)</span>
<span class="lineno">  105 </span><span class="spaces">  </span><span class="istickedoff">showsPrec _ PropSort = showString &quot;Prop&quot;</span></span>
<span class="lineno">  106 </span>
<span class="lineno">  107 </span>-- | Create sort @Type i@ for the given natural number @i@.
<span class="lineno">  108 </span>mkSort :: Natural -&gt; Sort
<span class="lineno">  109 </span><span class="decl"><span class="istickedoff">mkSort i = TypeSort i</span></span>
<span class="lineno">  110 </span>
<span class="lineno">  111 </span>-- | Wrapper around 'PropSort', for export
<span class="lineno">  112 </span>propSort :: Sort
<span class="lineno">  113 </span><span class="decl"><span class="istickedoff">propSort = PropSort</span></span>
<span class="lineno">  114 </span>
<span class="lineno">  115 </span>-- | Returns sort of the given sort.
<span class="lineno">  116 </span>sortOf :: Sort -&gt; Sort
<span class="lineno">  117 </span><span class="decl"><span class="istickedoff">sortOf (TypeSort i) = TypeSort (i + 1)</span>
<span class="lineno">  118 </span><span class="spaces"></span><span class="istickedoff">sortOf PropSort = TypeSort 0</span></span>
<span class="lineno">  119 </span>
<span class="lineno">  120 </span>-- | Get the maximum sort in a list, returning Prop for the empty list
<span class="lineno">  121 </span>maxSort :: [Sort] -&gt; Sort
<span class="lineno">  122 </span><span class="decl"><span class="istickedoff">maxSort [] = propSort</span>
<span class="lineno">  123 </span><span class="spaces"></span><span class="istickedoff">maxSort ss = maximum ss</span></span>
<span class="lineno">  124 </span>
<span class="lineno">  125 </span>-- | This type represents a set of advisory flags for 'Sort's that are mostly
<span class="lineno">  126 </span>-- ignored, but are used in the Coq export process to indicate where various
<span class="lineno">  127 </span>-- typeclass instances are necessary in function definitions. In the concrete
<span class="lineno">  128 </span>-- syntax &quot;isort&quot;, &quot;qsort&quot;, etc. is used to indicate cases where these flags
<span class="lineno">  129 </span>-- are set. Note in particular that these flags do not affect typechecking,
<span class="lineno">  130 </span>-- so missing or overeager &quot;isort&quot;/&quot;qsort&quot; annotations will only be detected
<span class="lineno">  131 </span>-- via the Coq export.
<span class="lineno">  132 </span>--
<span class="lineno">  133 </span>-- * If 'flagInhabited' is 'True', an implicit @Inhabited@ typeclass argument
<span class="lineno">  134 </span>--   will be added during Coq translation. In the concrete syntax, an &quot;i&quot; is
<span class="lineno">  135 </span>--   prepended to the sort (e.g. &quot;isort&quot;).
<span class="lineno">  136 </span>-- * If 'flagQuantType' is 'True', an implicit @QuantType@ typeclass argument
<span class="lineno">  137 </span>--   will be added during Coq translation. In the concrete syntax, an &quot;q&quot; is
<span class="lineno">  138 </span>--   prepended to the sort (e.g. &quot;qsort&quot;, &quot;qisort&quot;).
<span class="lineno">  139 </span>data SortFlags = SortFlags { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">flagInhabited</span></span></span> :: Bool
<span class="lineno">  140 </span>                           , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">flagQuantType</span></span></span> :: Bool }
<span class="lineno">  141 </span>    deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">TH.Lift</span></span></span></span>)
<span class="lineno">  142 </span>
<span class="lineno">  143 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Hashable SortFlags</span></span></span></span> -- automatically derived
<span class="lineno">  144 </span>
<span class="lineno">  145 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Show SortFlags</span></span></span></span> where
<span class="lineno">  146 </span>  <span class="decl"><span class="istickedoff">showsPrec _ (SortFlags i q) = showString $</span>
<span class="lineno">  147 </span><span class="spaces">    </span><span class="istickedoff">concatMap (\(b,s) -&gt; if b then s else &quot;&quot;)</span>
<span class="lineno">  148 </span><span class="spaces">              </span><span class="istickedoff">[(q,<span class="nottickedoff">&quot;q&quot;</span>), (i,&quot;i&quot;)]</span></span>
<span class="lineno">  149 </span>
<span class="lineno">  150 </span>-- | The 'SortFlags' object with no flags set
<span class="lineno">  151 </span>noFlags :: SortFlags
<span class="lineno">  152 </span><span class="decl"><span class="istickedoff">noFlags = SortFlags False False</span></span>
<span class="lineno">  153 </span>
<span class="lineno">  154 </span>-- | Apply a binary operation to corresponding flags of two 'SortFlags'
<span class="lineno">  155 </span>sortFlagsLift2 :: (Bool -&gt; Bool -&gt; Bool) -&gt; SortFlags -&gt; SortFlags -&gt; SortFlags
<span class="lineno">  156 </span><span class="decl"><span class="istickedoff">sortFlagsLift2 f (SortFlags i1 q1) (SortFlags i2 q2) = SortFlags <span class="nottickedoff">(f i1 i2)</span> <span class="nottickedoff">(f q1 q2)</span></span></span>
<span class="lineno">  157 </span>
<span class="lineno">  158 </span>-- | Convert a 'SortFlags' to a list of 'Bool's, indicating which flags are set
<span class="lineno">  159 </span>sortFlagsToList :: SortFlags -&gt; [Bool]
<span class="lineno">  160 </span><span class="decl"><span class="istickedoff">sortFlagsToList (SortFlags i q) = [i, q]</span></span>
<span class="lineno">  161 </span>
<span class="lineno">  162 </span>-- | Build a 'SortFlags' from a list of 'Bool's indicating which flags are set
<span class="lineno">  163 </span>sortFlagsFromList :: [Bool] -&gt; SortFlags
<span class="lineno">  164 </span><span class="decl"><span class="nottickedoff">sortFlagsFromList bs = SortFlags (isSet 0) (isSet 1)</span>
<span class="lineno">  165 </span><span class="spaces">  </span><span class="nottickedoff">where isSet i = i &lt; length bs &amp;&amp; bs !! i</span></span>
<span class="lineno">  166 </span>
<span class="lineno">  167 </span>
<span class="lineno">  168 </span>-- Flat Terms ------------------------------------------------------------------
<span class="lineno">  169 </span>
<span class="lineno">  170 </span>-- | The &quot;flat terms&quot;, which are the built-in atomic constructs of SAW core.
<span class="lineno">  171 </span>--
<span class="lineno">  172 </span>-- NB: If you add constructors to FlatTermF, make sure you update
<span class="lineno">  173 </span>--     zipWithFlatTermF!
<span class="lineno">  174 </span>data FlatTermF e
<span class="lineno">  175 </span>    -- Tuples are represented as nested pairs, grouped to the right,
<span class="lineno">  176 </span>    -- terminated with unit at the end.
<span class="lineno">  177 </span>  = UnitValue
<span class="lineno">  178 </span>  | UnitType
<span class="lineno">  179 </span>  | PairValue e e
<span class="lineno">  180 </span>  | PairType e e
<span class="lineno">  181 </span>  | PairLeft e
<span class="lineno">  182 </span>  | PairRight e
<span class="lineno">  183 </span>
<span class="lineno">  184 </span>    -- | A recursor, which is specified by a 'CompiledRecursor'
<span class="lineno">  185 </span>    -- comprising the datatype name, elimination sort, and other data
<span class="lineno">  186 </span>    -- about the recursor.
<span class="lineno">  187 </span>  | Recursor CompiledRecursor
<span class="lineno">  188 </span>
<span class="lineno">  189 </span>    -- | Non-dependent record types, i.e., N-ary tuple types with named
<span class="lineno">  190 </span>    -- fields. These are considered equal up to reordering of fields. Actual
<span class="lineno">  191 </span>    -- tuple types are represented with field names @&quot;1&quot;@, @&quot;2&quot;@, etc.
<span class="lineno">  192 </span>  | RecordType ![(FieldName, e)]
<span class="lineno">  193 </span>    -- | Non-dependent records, i.e., N-ary tuples with named fields. These are
<span class="lineno">  194 </span>    -- considered equal up to reordering of fields. Actual tuples are
<span class="lineno">  195 </span>    -- represented with field names @&quot;1&quot;@, @&quot;2&quot;@, etc.
<span class="lineno">  196 </span>  | RecordValue ![(FieldName, e)]
<span class="lineno">  197 </span>    -- | Non-dependent record projection
<span class="lineno">  198 </span>  | RecordProj e !FieldName
<span class="lineno">  199 </span>
<span class="lineno">  200 </span>    -- | Sorts, aka universes, are the types of types; i.e., an object is a
<span class="lineno">  201 </span>    -- &quot;type&quot; iff it has type @Sort s@ for some s. See 'SortFlags' for an
<span class="lineno">  202 </span>    -- explanation of the extra argument.
<span class="lineno">  203 </span>  | Sort !Sort !SortFlags
<span class="lineno">  204 </span>
<span class="lineno">  205 </span>    -- Primitive builtin values
<span class="lineno">  206 </span>    -- | Natural number with given value.
<span class="lineno">  207 </span>  | NatLit !Natural
<span class="lineno">  208 </span>    -- | Array value includes type of elements followed by elements.
<span class="lineno">  209 </span>  | ArrayValue e (Vector e)
<span class="lineno">  210 </span>    -- | String literal
<span class="lineno">  211 </span>  | StringLit !Text
<span class="lineno">  212 </span>  deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Functor</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Traversable</span></span></span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>)
<span class="lineno">  213 </span>
<span class="lineno">  214 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Hashable e =&gt; Hashable (FlatTermF e)</span></span></span></span> -- automatically derived
<span class="lineno">  215 </span>
<span class="lineno">  216 </span>-- | A 'CompiledRecursor' comprises the datatype name and elimination
<span class="lineno">  217 </span>-- sort of a recursor, along with some other data derived from details
<span class="lineno">  218 </span>-- of the datatype definition.
<span class="lineno">  219 </span>data CompiledRecursor =
<span class="lineno">  220 </span>  CompiledRecursor
<span class="lineno">  221 </span>  { <span class="istickedoff"><span class="decl"><span class="istickedoff">recursorDataType</span></span></span>  :: Name
<span class="lineno">  222 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">recursorSort</span></span></span>      :: Sort
<span class="lineno">  223 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">recursorNumParams</span></span></span> :: Int
<span class="lineno">  224 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">recursorNumIxs</span></span></span>    :: Int
<span class="lineno">  225 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">recursorCtorOrder</span></span></span> :: [Name]
<span class="lineno">  226 </span>  }
<span class="lineno">  227 </span> deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>)
<span class="lineno">  228 </span>
<span class="lineno">  229 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Hashable CompiledRecursor</span></span></span></span> -- automatically derived
<span class="lineno">  230 </span>
<span class="lineno">  231 </span>-- | Test if the association list used in a 'RecordType' or 'RecordValue' uses
<span class="lineno">  232 </span>-- precisely the given field names and no more. If so, return the values
<span class="lineno">  233 </span>-- associated with those field names, in the order given in the input, and
<span class="lineno">  234 </span>-- otherwise return 'Nothing'
<span class="lineno">  235 </span>alistAllFields :: Eq k =&gt; [k] -&gt; [(k, a)] -&gt; Maybe [a]
<span class="lineno">  236 </span><span class="decl"><span class="istickedoff">alistAllFields [] [] = Just <span class="nottickedoff">[]</span></span>
<span class="lineno">  237 </span><span class="spaces"></span><span class="istickedoff">alistAllFields (fld:flds) alist</span>
<span class="lineno">  238 </span><span class="spaces">  </span><span class="istickedoff">| Just val &lt;- lookup fld alist =</span>
<span class="lineno">  239 </span><span class="spaces">    </span><span class="istickedoff">(val :) &lt;$&gt; alistAllFields flds (deleteField fld alist)</span>
<span class="lineno">  240 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  241 </span><span class="spaces">    </span><span class="istickedoff">deleteField _ [] = <span class="nottickedoff">error &quot;deleteField&quot;</span></span>
<span class="lineno">  242 </span><span class="spaces">    </span><span class="istickedoff">deleteField f ((f',_):rest) | <span class="tickonlytrue">f == f'</span> = rest</span>
<span class="lineno">  243 </span><span class="spaces">    </span><span class="istickedoff">deleteField f (x:rest) = <span class="nottickedoff">x : deleteField f rest</span></span>
<span class="lineno">  244 </span><span class="spaces"></span><span class="istickedoff">alistAllFields _ _ = <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno">  245 </span>
<span class="lineno">  246 </span>zipName :: Name -&gt; Name -&gt; Maybe Name
<span class="lineno">  247 </span><span class="decl"><span class="nottickedoff">zipName x y</span>
<span class="lineno">  248 </span><span class="spaces">  </span><span class="nottickedoff">| x == y = Just x</span>
<span class="lineno">  249 </span><span class="spaces">  </span><span class="nottickedoff">| otherwise = Nothing</span></span>
<span class="lineno">  250 </span>
<span class="lineno">  251 </span>zipRec :: CompiledRecursor -&gt; CompiledRecursor -&gt; Maybe CompiledRecursor
<span class="lineno">  252 </span><span class="decl"><span class="istickedoff">zipRec (CompiledRecursor d1 s1 ps1 n1 ord1) (CompiledRecursor d2 s2 _ n2 ord2)</span>
<span class="lineno">  253 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlyfalse">n1 == n2 &amp;&amp; s1 == s2</span></span>
<span class="lineno">  254 </span><span class="spaces">  </span><span class="istickedoff">= <span class="nottickedoff">do d &lt;- zipName d1 d2</span></span>
<span class="lineno">  255 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">ord &lt;- sequence (zipWith zipName ord1 ord2)</span></span>
<span class="lineno">  256 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">pure $ CompiledRecursor</span></span>
<span class="lineno">  257 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">d</span></span>
<span class="lineno">  258 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">s1</span></span>
<span class="lineno">  259 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">ps1</span></span>
<span class="lineno">  260 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">n1</span></span>
<span class="lineno">  261 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">ord</span></span>
<span class="lineno">  262 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = Nothing</span></span>
<span class="lineno">  263 </span>
<span class="lineno">  264 </span>-- | Zip a binary function @f@ over a pair of 'FlatTermF's by applying @f@
<span class="lineno">  265 </span>-- pointwise to immediate subterms, if the two 'FlatTermF's are the same
<span class="lineno">  266 </span>-- constructor; otherwise, return 'Nothing' if they use different constructors
<span class="lineno">  267 </span>zipWithFlatTermF :: (x -&gt; y -&gt; z) -&gt; FlatTermF x -&gt; FlatTermF y -&gt;
<span class="lineno">  268 </span>                    Maybe (FlatTermF z)
<span class="lineno">  269 </span><span class="decl"><span class="istickedoff">zipWithFlatTermF f = go</span>
<span class="lineno">  270 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  271 </span><span class="spaces">    </span><span class="istickedoff">go UnitValue UnitValue = <span class="nottickedoff">Just UnitValue</span></span>
<span class="lineno">  272 </span><span class="spaces">    </span><span class="istickedoff">go UnitType UnitType = Just UnitType</span>
<span class="lineno">  273 </span><span class="spaces">    </span><span class="istickedoff">go (PairValue x1 x2) (PairValue y1 y2) = Just (PairValue (f x1 y1) (f x2 y2))</span>
<span class="lineno">  274 </span><span class="spaces">    </span><span class="istickedoff">go (PairType x1 x2) (PairType y1 y2) = Just (PairType (f x1 y1) (f x2 y2))</span>
<span class="lineno">  275 </span><span class="spaces">    </span><span class="istickedoff">go (PairLeft x) (PairLeft y) = <span class="nottickedoff">Just (PairLeft (f x y))</span></span>
<span class="lineno">  276 </span><span class="spaces">    </span><span class="istickedoff">go (PairRight x) (PairRight y) = <span class="nottickedoff">Just (PairLeft (f x y))</span></span>
<span class="lineno">  277 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  278 </span><span class="spaces">    </span><span class="istickedoff">go (Recursor rec1) (Recursor rec2) =</span>
<span class="lineno">  279 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">Recursor</span> &lt;$&gt; zipRec rec1 rec2</span>
<span class="lineno">  280 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  281 </span><span class="spaces">    </span><span class="istickedoff">go (RecordType elems1) (RecordType elems2)</span>
<span class="lineno">  282 </span><span class="spaces">      </span><span class="istickedoff">| Just vals2 &lt;- alistAllFields (map fst elems1) elems2 =</span>
<span class="lineno">  283 </span><span class="spaces">        </span><span class="istickedoff">Just $ RecordType $ zipWith (\(fld,x) y -&gt; (<span class="nottickedoff">fld</span>, f x y)) elems1 vals2</span>
<span class="lineno">  284 </span><span class="spaces">    </span><span class="istickedoff">go (RecordValue elems1) (RecordValue elems2)</span>
<span class="lineno">  285 </span><span class="spaces">      </span><span class="istickedoff">| Just vals2 &lt;- <span class="nottickedoff">alistAllFields (map fst elems1) elems2</span> =</span>
<span class="lineno">  286 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">Just $ RecordValue $ zipWith (\(fld,x) y -&gt; (fld, f x y)) elems1 vals2</span></span>
<span class="lineno">  287 </span><span class="spaces">    </span><span class="istickedoff">go (RecordProj e1 fld1) (RecordProj e2 fld2)</span>
<span class="lineno">  288 </span><span class="spaces">      </span><span class="istickedoff">| fld1 == fld2 = Just $ RecordProj (f e1 e2) fld1</span>
<span class="lineno">  289 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  290 </span><span class="spaces">    </span><span class="istickedoff">go (Sort sx hx) (Sort sy hy) | sx == sy = Just (Sort sx (sortFlagsLift2 <span class="nottickedoff">(&amp;&amp;)</span> hx hy))</span>
<span class="lineno">  291 </span><span class="spaces">         </span><span class="istickedoff">-- /\ NB, it's not entirely clear how the flags should be propagated</span>
<span class="lineno">  292 </span><span class="spaces">    </span><span class="istickedoff">go (NatLit i) (NatLit j) | i == j = Just (NatLit i)</span>
<span class="lineno">  293 </span><span class="spaces">    </span><span class="istickedoff">go (StringLit s) (StringLit t) | <span class="nottickedoff">s == t</span> = <span class="nottickedoff">Just (StringLit s)</span></span>
<span class="lineno">  294 </span><span class="spaces">    </span><span class="istickedoff">go (ArrayValue tx vx) (ArrayValue ty vy)</span>
<span class="lineno">  295 </span><span class="spaces">      </span><span class="istickedoff">| V.length vx == V.length vy</span>
<span class="lineno">  296 </span><span class="spaces">      </span><span class="istickedoff">= Just $ ArrayValue (f tx ty) (V.zipWith <span class="nottickedoff">f</span> vx vy)</span>
<span class="lineno">  297 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  298 </span><span class="spaces">    </span><span class="istickedoff">go UnitValue      _ = <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  299 </span><span class="spaces">    </span><span class="istickedoff">go UnitType       _ = <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  300 </span><span class="spaces">    </span><span class="istickedoff">go PairValue{}    _ = Nothing</span>
<span class="lineno">  301 </span><span class="spaces">    </span><span class="istickedoff">go PairType{}     _ = <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  302 </span><span class="spaces">    </span><span class="istickedoff">go PairLeft{}     _ = <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  303 </span><span class="spaces">    </span><span class="istickedoff">go PairRight{}    _ = <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  304 </span><span class="spaces">    </span><span class="istickedoff">go Recursor{}     _ = <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  305 </span><span class="spaces">    </span><span class="istickedoff">go RecordType{}   _ = <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  306 </span><span class="spaces">    </span><span class="istickedoff">go RecordValue{}  _ = <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  307 </span><span class="spaces">    </span><span class="istickedoff">go RecordProj{}   _ = Nothing</span>
<span class="lineno">  308 </span><span class="spaces">    </span><span class="istickedoff">go Sort{}         _ = Nothing</span>
<span class="lineno">  309 </span><span class="spaces">    </span><span class="istickedoff">go NatLit{}       _ = Nothing</span>
<span class="lineno">  310 </span><span class="spaces">    </span><span class="istickedoff">go ArrayValue{}   _ = Nothing</span>
<span class="lineno">  311 </span><span class="spaces">    </span><span class="istickedoff">go StringLit{}    _ = <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno">  312 </span>
<span class="lineno">  313 </span>
<span class="lineno">  314 </span>-- Term Functor ----------------------------------------------------------------
<span class="lineno">  315 </span>
<span class="lineno">  316 </span>-- | A \&quot;knot-tying\&quot; structure for representing terms and term-like things.
<span class="lineno">  317 </span>-- Often, this appears in context as the type \&quot;'TermF' 'Term'\&quot;, in which case
<span class="lineno">  318 </span>-- it represents a full 'Term' AST. The \&quot;F\&quot; stands for 'Functor', or
<span class="lineno">  319 </span>-- occasionally for \&quot;Former\&quot;.
<span class="lineno">  320 </span>data TermF e
<span class="lineno">  321 </span>    = FTermF !(FlatTermF e)
<span class="lineno">  322 </span>      -- ^ The atomic, or builtin, term constructs
<span class="lineno">  323 </span>    | App !e !e
<span class="lineno">  324 </span>      -- ^ Applications of functions
<span class="lineno">  325 </span>    | Lambda !VarName !e !e
<span class="lineno">  326 </span>      -- ^ Function abstractions
<span class="lineno">  327 </span>    | Pi !VarName !e !e
<span class="lineno">  328 </span>      -- ^ The type of a (possibly) dependent function
<span class="lineno">  329 </span>    | Constant !Name
<span class="lineno">  330 </span>      -- ^ A global constant identified by its name.
<span class="lineno">  331 </span>    | Variable !VarName !e
<span class="lineno">  332 </span>      -- ^ A named variable with a type.
<span class="lineno">  333 </span>  deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Functor</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Traversable</span></span></span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>)
<span class="lineno">  334 </span>
<span class="lineno">  335 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Hashable e =&gt; Hashable (TermF e)</span></span></span></span> -- automatically derived
<span class="lineno">  336 </span>
<span class="lineno">  337 </span>
<span class="lineno">  338 </span>-- Term Datatype ---------------------------------------------------------------
<span class="lineno">  339 </span>
<span class="lineno">  340 </span>type TermIndex = Int -- Word64
<span class="lineno">  341 </span>
<span class="lineno">  342 </span>-- | For more information on the semantics of 'Term's, see the
<span class="lineno">  343 </span>-- [manual](https://saw.galois.com/manual.html). 'Term' and 'TermF' are split
<span class="lineno">  344 </span>-- into two structures to facilitate mutual structural recursion (sometimes
<span class="lineno">  345 </span>-- referred to as the [&quot;knot-tying&quot;](https://wiki.haskell.org/Tying_the_Knot)
<span class="lineno">  346 </span>-- pattern, sometimes referred to in terms of [&quot;recursion
<span class="lineno">  347 </span>-- schemes&quot;](https://blog.sumtypeofway.com/posts/introduction-to-recursion-schemes.html))
<span class="lineno">  348 </span>-- and term object reuse via hash-consing.
<span class="lineno">  349 </span>data Term
<span class="lineno">  350 </span>  = STApp
<span class="lineno">  351 </span>    -- ^ This constructor \&quot;wraps\&quot; a 'TermF' 'Term', assigning it a
<span class="lineno">  352 </span>    -- guaranteed-unique integer identifier and caching its likely-unique hash.
<span class="lineno">  353 </span>    -- Most 'Term's are constructed via 'STApp'. When a fresh 'TermF' is evinced
<span class="lineno">  354 </span>    -- in the course of a SAW invocation and needs to be lifted into a 'Term',
<span class="lineno">  355 </span>    -- we can see if we've already created a 'Term' wrapper for an identical
<span class="lineno">  356 </span>    -- 'TermF', and reuse it if so. The implementation of hash-consed 'Term'
<span class="lineno">  357 </span>    -- construction exists in 'SAWCore.SharedTerm', in particular in the
<span class="lineno">  358 </span>    -- 'SAWCore.SharedTerm.scTermF' field of the
<span class="lineno">  359 </span>    -- t'SAWCore.SharedTerm.SharedContext' object.
<span class="lineno">  360 </span>     { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">stAppIndex</span></span></span>    :: {-# UNPACK #-} !TermIndex
<span class="lineno">  361 </span>       -- ^ The UID associated with a 'Term'. It is guaranteed unique across a
<span class="lineno">  362 </span>       -- universe of properly-constructed 'Term's within a single SAW
<span class="lineno">  363 </span>       -- invocation.
<span class="lineno">  364 </span>     , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">stAppHash</span></span></span>     :: {-# UNPACK #-} !Int
<span class="lineno">  365 </span>       -- ^ The hash, according to 'hash', of the 'stAppTermF' field associated
<span class="lineno">  366 </span>       -- with this 'Term'. This should be as unique as a hash can be, but is
<span class="lineno">  367 </span>       -- not guaranteed unique as 'stAppIndex' is.
<span class="lineno">  368 </span>     , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">stAppFreeVars</span></span></span> :: !IntSet
<span class="lineno">  369 </span>       -- ^ A set containing the 'VarIndex' of each of the free named
<span class="lineno">  370 </span>       -- variables from 'Variable' constructors in the term.
<span class="lineno">  371 </span>     , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">stAppTermF</span></span></span>    :: !(TermF Term)
<span class="lineno">  372 </span>       -- ^ The underlying 'TermF' that this 'Term' wraps. This field &quot;ties the
<span class="lineno">  373 </span>       -- knot&quot; of the 'Term'/'TermF' recursion scheme.
<span class="lineno">  374 </span>     }
<span class="lineno">  375 </span>  | Unshared !(TermF Term)
<span class="lineno">  376 </span>    -- ^ Used for constructing 'Term's that don't need to be shared/reused.
<span class="lineno">  377 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, Typeable)
<span class="lineno">  378 </span>
<span class="lineno">  379 </span>instance Hashable Term where
<span class="lineno">  380 </span>  -- The hash of an 'STApp' depends on its not-necessarily-unique
<span class="lineno">  381 </span>  -- 'stAppHash' instead of its necessarily-unique 'stAppIndex'.
<span class="lineno">  382 </span>  -- The reason is that per #1830 (PR) and #1831 (issue), we want to
<span class="lineno">  383 </span>  -- to derive references to terms based solely on their shape.
<span class="lineno">  384 </span>  -- Indices have nothing to do with a term's shape - they're assigned
<span class="lineno">  385 </span>  -- sequentially when building terms, according to the (arbitrary)
<span class="lineno">  386 </span>  -- order in which a term is built.
<span class="lineno">  387 </span>  -- As for uniqueness, though hashing a term based on its subterms'
<span class="lineno">  388 </span>  -- hashes introduces less randomness/freshness, it maintains plenty,
<span class="lineno">  389 </span>  -- and provides benefits as described above.
<span class="lineno">  390 </span>  -- No code should ever rely on total uniqueness of hashes, and terms
<span class="lineno">  391 </span>  -- are no exception.
<span class="lineno">  392 </span>  --
<span class="lineno">  393 </span>  -- Note: Nevertheless, we do take some minor liberties with the
<span class="lineno">  394 </span>  -- contract of 'hashWithSalt'. The contract states that if two
<span class="lineno">  395 </span>  -- values are equal according to '(==)', then they must have the
<span class="lineno">  396 </span>  -- same hash.
<span class="lineno">  397 </span>  -- For terms constructed by/within SAW, this will hold, because
<span class="lineno">  398 </span>  -- SAW's handling of index generation and assignment ensures that
<span class="lineno">  399 </span>  -- equality of indices implies equality of terms and term hashes
<span class="lineno">  400 </span>  -- (see 'SAWCore.SharedTerm.getTerm').
<span class="lineno">  401 </span>  -- However, if terms are constructed outside this standard procedure
<span class="lineno">  402 </span>  -- or in a way that does not respect index uniqueness rules,
<span class="lineno">  403 </span>  -- 'hashWithSalt''s contract could be violated.
<span class="lineno">  404 </span>  <span class="decl"><span class="istickedoff">hash STApp{ stAppHash = h } = h</span>
<span class="lineno">  405 </span><span class="spaces">  </span><span class="istickedoff">hash (Unshared t) = <span class="nottickedoff">hash t</span></span></span>
<span class="lineno">  406 </span>  <span class="decl"><span class="istickedoff">hashWithSalt salt = hashWithSalt salt . hash</span></span>
<span class="lineno">  407 </span>
<span class="lineno">  408 </span>instance <span class="decl"><span class="istickedoff">Eq Term</span></span> where
<span class="lineno">  409 </span>  <span class="decl"><span class="istickedoff">(==) = equalTerm</span></span>
<span class="lineno">  410 </span>
<span class="lineno">  411 </span>equalTerm :: Term -&gt; Term -&gt; Bool
<span class="lineno">  412 </span><span class="decl"><span class="istickedoff">equalTerm (Unshared tf1) (Unshared tf2) = <span class="nottickedoff">tf1 == tf2</span></span>
<span class="lineno">  413 </span><span class="spaces"></span><span class="istickedoff">equalTerm Unshared{} STApp{} = <span class="nottickedoff">False</span></span>
<span class="lineno">  414 </span><span class="spaces"></span><span class="istickedoff">equalTerm STApp{} Unshared{} = <span class="nottickedoff">False</span></span>
<span class="lineno">  415 </span><span class="spaces"></span><span class="istickedoff">equalTerm (STApp{stAppIndex = i1, stAppHash = h1, stAppTermF = tf1})</span>
<span class="lineno">  416 </span><span class="spaces">          </span><span class="istickedoff">(STApp{stAppIndex = i2, stAppHash = h2, stAppTermF = tf2}) =</span>
<span class="lineno">  417 </span><span class="spaces">  </span><span class="istickedoff">i1 == i2 || (h1 == h2 &amp;&amp; tf1 == tf2)</span></span>
<span class="lineno">  418 </span>  -- The hash check (^) is merely an optimization that enables us to
<span class="lineno">  419 </span>  -- quickly return 'False' in most cases. Since we're assuming the
<span class="lineno">  420 </span>  -- contract of 'hashWithSalt' holds, then we know @tf1 == tf2@
<span class="lineno">  421 </span>  -- implies @h1 == h2@. Thus we could safely remove @h1 == h2@ without
<span class="lineno">  422 </span>  -- changing the behavior of this function, but keeping it in enables
<span class="lineno">  423 </span>  -- us to utilize the fact that we save 'STApp' hashes to get away
<span class="lineno">  424 </span>  -- with not traversing the 'stAppTermF' fields in most cases of
<span class="lineno">  425 </span>  -- inequality.
<span class="lineno">  426 </span>
<span class="lineno">  427 </span>-- | Return 'True' iff the given terms are equal modulo alpha equivalence (i.e.
<span class="lineno">  428 </span>-- 'VarName's in 'Lambda' and 'Pi' expressions) and sharing (i.e. 'STApp' vs.
<span class="lineno">  429 </span>-- 'Unshared' expressions).
<span class="lineno">  430 </span>alphaEquiv :: Term -&gt; Term -&gt; Bool
<span class="lineno">  431 </span><span class="decl"><span class="istickedoff">alphaEquiv = term IntMap.empty</span>
<span class="lineno">  432 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  433 </span><span class="spaces">    </span><span class="istickedoff">term :: IntMap VarIndex -&gt; Term -&gt; Term -&gt; Bool</span>
<span class="lineno">  434 </span><span class="spaces">    </span><span class="istickedoff">term vm (Unshared tf1) (Unshared tf2) = <span class="nottickedoff">termf vm tf1 tf2</span></span>
<span class="lineno">  435 </span><span class="spaces">    </span><span class="istickedoff">term vm (Unshared tf1) (STApp{stAppTermF = tf2}) = <span class="nottickedoff">termf vm tf1 tf2</span></span>
<span class="lineno">  436 </span><span class="spaces">    </span><span class="istickedoff">term vm (STApp{stAppTermF = tf1}) (Unshared tf2) = <span class="nottickedoff">termf vm tf1 tf2</span></span>
<span class="lineno">  437 </span><span class="spaces">    </span><span class="istickedoff">term vm</span>
<span class="lineno">  438 </span><span class="spaces">      </span><span class="istickedoff">(STApp{stAppIndex = i1, stAppTermF = tf1, stAppFreeVars = vs1})</span>
<span class="lineno">  439 </span><span class="spaces">      </span><span class="istickedoff">(STApp{stAppIndex = i2, stAppTermF = tf2}) =</span>
<span class="lineno">  440 </span><span class="spaces">      </span><span class="istickedoff">(IntSet.disjoint vs1 (IntMap.keysSet vm) &amp;&amp; i1 == i2) || termf vm tf1 tf2</span>
<span class="lineno">  441 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  442 </span><span class="spaces">    </span><span class="istickedoff">termf :: IntMap VarIndex -&gt; TermF Term -&gt; TermF Term -&gt; Bool</span>
<span class="lineno">  443 </span><span class="spaces">    </span><span class="istickedoff">termf vm (FTermF ftf1) (FTermF ftf2) = ftermf vm ftf1 ftf2</span>
<span class="lineno">  444 </span><span class="spaces">    </span><span class="istickedoff">termf vm (App t1 u1) (App t2 u2) = term vm t1 t2 &amp;&amp; term vm u1 u2</span>
<span class="lineno">  445 </span><span class="spaces">    </span><span class="istickedoff">termf vm (Lambda (vnIndex -&gt; i1) t1 u1) (Lambda (vnIndex -&gt; i2) t2 u2) =</span>
<span class="lineno">  446 </span><span class="spaces">      </span><span class="istickedoff">let vm' = if i1 == i2 then vm else IntMap.insert i1 i2 vm</span>
<span class="lineno">  447 </span><span class="spaces">      </span><span class="istickedoff">in term <span class="nottickedoff">vm</span> t1 t2 &amp;&amp; term vm' u1 u2</span>
<span class="lineno">  448 </span><span class="spaces">    </span><span class="istickedoff">termf vm (Pi (vnIndex -&gt; i1) t1 u1) (Pi (vnIndex -&gt; i2) t2 u2) =</span>
<span class="lineno">  449 </span><span class="spaces">      </span><span class="istickedoff">let vm' = if i1 == i2 then vm else IntMap.insert i1 i2 vm</span>
<span class="lineno">  450 </span><span class="spaces">      </span><span class="istickedoff">in term vm t1 t2 &amp;&amp; term vm' u1 u2</span>
<span class="lineno">  451 </span><span class="spaces">    </span><span class="istickedoff">termf _vm (Constant x1) (Constant x2) = x1 == x2</span>
<span class="lineno">  452 </span><span class="spaces">    </span><span class="istickedoff">termf vm (Variable x1 _t1) (Variable x2 _t2) =</span>
<span class="lineno">  453 </span><span class="spaces">      </span><span class="istickedoff">case IntMap.lookup (vnIndex x1) vm of</span>
<span class="lineno">  454 </span><span class="spaces">        </span><span class="istickedoff">Just i -&gt; vnIndex x2 == i</span>
<span class="lineno">  455 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; x1 == x2</span>
<span class="lineno">  456 </span><span class="spaces">    </span><span class="istickedoff">termf _ FTermF{}   _ = False</span>
<span class="lineno">  457 </span><span class="spaces">    </span><span class="istickedoff">termf _ App{}      _ = False</span>
<span class="lineno">  458 </span><span class="spaces">    </span><span class="istickedoff">termf _ Lambda{}   _ = False</span>
<span class="lineno">  459 </span><span class="spaces">    </span><span class="istickedoff">termf _ Pi{}       _ = False</span>
<span class="lineno">  460 </span><span class="spaces">    </span><span class="istickedoff">termf _ Constant{} _ = False</span>
<span class="lineno">  461 </span><span class="spaces">    </span><span class="istickedoff">termf _ Variable{} _ = False</span>
<span class="lineno">  462 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  463 </span><span class="spaces">    </span><span class="istickedoff">ftermf :: IntMap Int -&gt; FlatTermF Term -&gt; FlatTermF Term -&gt; Bool</span>
<span class="lineno">  464 </span><span class="spaces">    </span><span class="istickedoff">ftermf vm ftf1 ftf2 =</span>
<span class="lineno">  465 </span><span class="spaces">      </span><span class="istickedoff">case zipWithFlatTermF (term vm) ftf1 ftf2 of</span>
<span class="lineno">  466 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; False</span>
<span class="lineno">  467 </span><span class="spaces">        </span><span class="istickedoff">Just ftf3 -&gt; Foldable.and ftf3</span></span>
<span class="lineno">  468 </span>
<span class="lineno">  469 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord Term</span></span></span></span></span></span></span></span></span></span></span></span> where
<span class="lineno">  470 </span>  <span class="decl"><span class="istickedoff">compare (STApp{stAppIndex = i}) (STApp{stAppIndex = j}) | <span class="tickonlytrue">i == j</span> = EQ</span>
<span class="lineno">  471 </span><span class="spaces">  </span><span class="istickedoff">compare STApp{} Unshared{} = <span class="nottickedoff">LT</span> -- matches what we'd get from derived Ord instance</span>
<span class="lineno">  472 </span><span class="spaces">  </span><span class="istickedoff">compare Unshared{} STApp{} = <span class="nottickedoff">GT</span></span>
<span class="lineno">  473 </span><span class="spaces">  </span><span class="istickedoff">compare x y = <span class="nottickedoff">compare (unwrapTermF x) (unwrapTermF y)</span></span></span>
<span class="lineno">  474 </span>
<span class="lineno">  475 </span>instance Net.Pattern Term where
<span class="lineno">  476 </span>  <span class="decl"><span class="istickedoff">toPat = termToPat</span></span>
<span class="lineno">  477 </span>
<span class="lineno">  478 </span>termToPat :: Term -&gt; Net.Pat
<span class="lineno">  479 </span><span class="decl"><span class="istickedoff">termToPat t =</span>
<span class="lineno">  480 </span><span class="spaces">    </span><span class="istickedoff">case unwrapTermF t of</span>
<span class="lineno">  481 </span><span class="spaces">      </span><span class="istickedoff">Constant nm               -&gt; Net.Atom (toShortName (nameInfo nm))</span>
<span class="lineno">  482 </span><span class="spaces">      </span><span class="istickedoff">App t1 t2                 -&gt; Net.App (termToPat t1) (termToPat t2)</span>
<span class="lineno">  483 </span><span class="spaces">      </span><span class="istickedoff">FTermF (Sort s _)         -&gt; Net.Atom (Text.pack ('*' : show s))</span>
<span class="lineno">  484 </span><span class="spaces">      </span><span class="istickedoff">FTermF (NatLit _)         -&gt; Net.Var</span>
<span class="lineno">  485 </span><span class="spaces">      </span><span class="istickedoff">_                         -&gt; Net.Var</span></span>
<span class="lineno">  486 </span>
<span class="lineno">  487 </span>unwrapTermF :: Term -&gt; TermF Term
<span class="lineno">  488 </span><span class="decl"><span class="istickedoff">unwrapTermF STApp{stAppTermF = tf} = tf</span>
<span class="lineno">  489 </span><span class="spaces"></span><span class="istickedoff">unwrapTermF (Unshared tf) = tf</span></span>
<span class="lineno">  490 </span>
<span class="lineno">  491 </span>
<span class="lineno">  492 </span>-- Free Named Variables --------------------------------------------------------
<span class="lineno">  493 </span>
<span class="lineno">  494 </span>-- | Compute an 'IntSet' containing the 'VarIndex' of the free
<span class="lineno">  495 </span>-- variables of a term, given the free variables for its immediate
<span class="lineno">  496 </span>-- subterms.
<span class="lineno">  497 </span>freesTermF :: TermF IntSet -&gt; IntSet
<span class="lineno">  498 </span><span class="decl"><span class="istickedoff">freesTermF tf =</span>
<span class="lineno">  499 </span><span class="spaces">  </span><span class="istickedoff">case tf of</span>
<span class="lineno">  500 </span><span class="spaces">    </span><span class="istickedoff">FTermF ftf -&gt; Foldable.foldl' IntSet.union IntSet.empty ftf</span>
<span class="lineno">  501 </span><span class="spaces">    </span><span class="istickedoff">App l r -&gt; IntSet.union l r</span>
<span class="lineno">  502 </span><span class="spaces">    </span><span class="istickedoff">Lambda nm tp rhs -&gt; IntSet.union tp (IntSet.delete (vnIndex nm) rhs)</span>
<span class="lineno">  503 </span><span class="spaces">    </span><span class="istickedoff">Pi nm lhs rhs -&gt; IntSet.union lhs (IntSet.delete (vnIndex nm) rhs)</span>
<span class="lineno">  504 </span><span class="spaces">    </span><span class="istickedoff">Constant {} -&gt; IntSet.empty</span>
<span class="lineno">  505 </span><span class="spaces">    </span><span class="istickedoff">Variable nm tp -&gt; IntSet.insert (vnIndex nm) tp</span></span>
<span class="lineno">  506 </span>
<span class="lineno">  507 </span>-- | Return an 'IntSet' containing the 'VarIndex' of all free
<span class="lineno">  508 </span>-- variables in the 'Term'.
<span class="lineno">  509 </span>freeVars :: Term -&gt; IntSet
<span class="lineno">  510 </span><span class="decl"><span class="istickedoff">freeVars STApp{ stAppFreeVars = s } = s</span>
<span class="lineno">  511 </span><span class="spaces"></span><span class="istickedoff">freeVars (Unshared tf) = <span class="nottickedoff">freesTermF (fmap freeVars tf)</span></span></span>
<span class="lineno">  512 </span>
<span class="lineno">  513 </span>-- | Test whether a 'Term' is closed, i.e., it has no free variables.
<span class="lineno">  514 </span>closedTerm :: Term -&gt; Bool
<span class="lineno">  515 </span><span class="decl"><span class="istickedoff">closedTerm t = IntSet.null (freeVars t)</span></span>

</pre>
</body>
</html>
