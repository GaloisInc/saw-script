<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- |
<span class="lineno">    2 </span>Module      : SAWCentral.Crucible.JVM.Override
<span class="lineno">    3 </span>Description : Override matching and application for JVM
<span class="lineno">    4 </span>License     : BSD3
<span class="lineno">    5 </span>Maintainer  : atomb
<span class="lineno">    6 </span>Stability   : provisional
<span class="lineno">    7 </span>-}
<span class="lineno">    8 </span>
<span class="lineno">    9 </span>{-# LANGUAGE DataKinds #-}
<span class="lineno">   10 </span>{-# LANGUAGE GADTs #-}
<span class="lineno">   11 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">   12 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">   13 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">   14 </span>{-# LANGUAGE TypeApplications #-}
<span class="lineno">   15 </span>
<span class="lineno">   16 </span>{-# OPTIONS_GHC -Wno-orphans #-} -- Pretty JVMVal
<span class="lineno">   17 </span>
<span class="lineno">   18 </span>module SAWCentral.Crucible.JVM.Override
<span class="lineno">   19 </span>  ( OverrideMatcher
<span class="lineno">   20 </span>  , OverrideMatcher'(..)
<span class="lineno">   21 </span>  , runOverrideMatcher
<span class="lineno">   22 </span>
<span class="lineno">   23 </span>  , setupValueSub
<span class="lineno">   24 </span>  , osAsserts
<span class="lineno">   25 </span>  , termSub
<span class="lineno">   26 </span>
<span class="lineno">   27 </span>  , learnCond
<span class="lineno">   28 </span>  , matchArg
<span class="lineno">   29 </span>  , methodSpecHandler
<span class="lineno">   30 </span>  , valueToSC
<span class="lineno">   31 </span>  , injectJVMVal
<span class="lineno">   32 </span>  , decodeJVMVal
<span class="lineno">   33 </span>
<span class="lineno">   34 </span>  , doEntireArrayStore
<span class="lineno">   35 </span>  , destVecTypedTerm
<span class="lineno">   36 </span>  ) where
<span class="lineno">   37 </span>
<span class="lineno">   38 </span>import           Control.Lens (_2)
<span class="lineno">   39 </span>import           Control.Lens.At
<span class="lineno">   40 </span>import           Control.Lens.Each
<span class="lineno">   41 </span>import           Control.Lens.Fold
<span class="lineno">   42 </span>import           Control.Lens.Getter
<span class="lineno">   43 </span>import           Control.Lens.Lens
<span class="lineno">   44 </span>import           Control.Lens.Setter
<span class="lineno">   45 </span>import           Control.Exception as X
<span class="lineno">   46 </span>import           Control.Monad.IO.Class (liftIO)
<span class="lineno">   47 </span>import           Control.Monad
<span class="lineno">   48 </span>import           Data.Either (partitionEithers)
<span class="lineno">   49 </span>import           Data.Foldable (for_, traverse_)
<span class="lineno">   50 </span>import           Data.IntMap (IntMap)
<span class="lineno">   51 </span>import qualified Data.IntMap as IntMap
<span class="lineno">   52 </span>import           Data.IORef
<span class="lineno">   53 </span>import           Data.List (tails)
<span class="lineno">   54 </span>import           Data.List.NonEmpty (NonEmpty)
<span class="lineno">   55 </span>import qualified Data.List.NonEmpty as NE
<span class="lineno">   56 </span>import qualified Data.Map as Map
<span class="lineno">   57 </span>import qualified Data.Set as Set
<span class="lineno">   58 </span>import qualified Data.Text as Text
<span class="lineno">   59 </span>import           Data.Void (absurd)
<span class="lineno">   60 </span>import qualified Prettyprinter as PP
<span class="lineno">   61 </span>
<span class="lineno">   62 </span>-- cryptol
<span class="lineno">   63 </span>import qualified Cryptol.TypeCheck.AST as Cryptol
<span class="lineno">   64 </span>import qualified Cryptol.Eval.Type as Cryptol (TValue(..), evalType, evalValType)
<span class="lineno">   65 </span>
<span class="lineno">   66 </span>-- what4
<span class="lineno">   67 </span>import qualified What4.BaseTypes as W4
<span class="lineno">   68 </span>import qualified What4.Interface as W4
<span class="lineno">   69 </span>import qualified What4.ProgramLoc as W4
<span class="lineno">   70 </span>import           What4.LabeledPred (labeledPred)
<span class="lineno">   71 </span>
<span class="lineno">   72 </span>-- crucible
<span class="lineno">   73 </span>import qualified Lang.Crucible.Backend as Crucible
<span class="lineno">   74 </span>import qualified Lang.Crucible.CFG.Core as Crucible ( TypeRepr(UnitRepr) )
<span class="lineno">   75 </span>import qualified Lang.Crucible.FunctionHandle as Crucible
<span class="lineno">   76 </span>import qualified Lang.Crucible.Simulator as Crucible
<span class="lineno">   77 </span>
<span class="lineno">   78 </span>-- crucible-jvm
<span class="lineno">   79 </span>import qualified Lang.Crucible.JVM as CJ
<span class="lineno">   80 </span>
<span class="lineno">   81 </span>-- parameterized-utils
<span class="lineno">   82 </span>import           Data.Parameterized.Classes ((:~:)(..), testEquality)
<span class="lineno">   83 </span>import qualified Data.Parameterized.Context as Ctx
<span class="lineno">   84 </span>import           Data.Parameterized.Some (Some(Some))
<span class="lineno">   85 </span>
<span class="lineno">   86 </span>-- saw-core
<span class="lineno">   87 </span>import           SAWCore.Name (VarName(..))
<span class="lineno">   88 </span>import           SAWCore.SharedTerm
<span class="lineno">   89 </span>import           CryptolSAWCore.TypedTerm
<span class="lineno">   90 </span>
<span class="lineno">   91 </span>import           SAWCoreWhat4.ReturnTrip (toSC)
<span class="lineno">   92 </span>
<span class="lineno">   93 </span>-- cryptol-saw-core
<span class="lineno">   94 </span>import qualified CryptolSAWCore.Cryptol as Cryptol
<span class="lineno">   95 </span>
<span class="lineno">   96 </span>import           SAWCentral.Crucible.Common
<span class="lineno">   97 </span>import           SAWCentral.Crucible.Common.MethodSpec (AllocIndex(..), PrePost(..))
<span class="lineno">   98 </span>import           SAWCentral.Crucible.Common.Override hiding (getSymInterface)
<span class="lineno">   99 </span>import qualified SAWCentral.Crucible.Common.Override as Ov (getSymInterface)
<span class="lineno">  100 </span>
<span class="lineno">  101 </span>import qualified SAWCentral.Crucible.Common.MethodSpec as MS
<span class="lineno">  102 </span>import           SAWCentral.Crucible.JVM.MethodSpecIR
<span class="lineno">  103 </span>import           SAWCentral.Crucible.JVM.ResolveSetupValue
<span class="lineno">  104 </span>import           SAWCentral.Crucible.JVM.Setup.Value (jccUninterp)
<span class="lineno">  105 </span>import           SAWCentral.Options
<span class="lineno">  106 </span>import           SAWCentral.Panic
<span class="lineno">  107 </span>import           SAWCentral.Utils (handleException)
<span class="lineno">  108 </span>
<span class="lineno">  109 </span>-- jvm-parser
<span class="lineno">  110 </span>import qualified Language.JVM.Parser as J
<span class="lineno">  111 </span>
<span class="lineno">  112 </span>-- A few convenient synonyms
<span class="lineno">  113 </span>type SetupValue = MS.SetupValue CJ.JVM
<span class="lineno">  114 </span>type CrucibleMethodSpecIR = MS.CrucibleMethodSpecIR CJ.JVM
<span class="lineno">  115 </span>type StateSpec = MS.StateSpec CJ.JVM
<span class="lineno">  116 </span>type SetupCondition = MS.SetupCondition CJ.JVM
<span class="lineno">  117 </span>
<span class="lineno">  118 </span>-- TODO: Improve?
<span class="lineno">  119 </span>ppJVMVal :: JVMVal -&gt; PP.Doc ann
<span class="lineno">  120 </span><span class="decl"><span class="nottickedoff">ppJVMVal = PP.viaShow</span></span>
<span class="lineno">  121 </span>
<span class="lineno">  122 </span>instance <span class="decl"><span class="nottickedoff">PP.Pretty JVMVal</span></span> where
<span class="lineno">  123 </span>  <span class="decl"><span class="nottickedoff">pretty = ppJVMVal</span></span>
<span class="lineno">  124 </span>
<span class="lineno">  125 </span>
<span class="lineno">  126 </span>-- | Try to translate the spec\'s 'SetupValue' into an 'LLVMVal', pretty-print
<span class="lineno">  127 </span>--   the 'LLVMVal'.
<span class="lineno">  128 </span>mkStructuralMismatch ::
<span class="lineno">  129 </span>  Options              {- ^ output/verbosity options -} -&gt;
<span class="lineno">  130 </span>  JVMCrucibleContext -&gt;
<span class="lineno">  131 </span>  SharedContext {- ^ context for constructing SAW terms -} -&gt;
<span class="lineno">  132 </span>  CrucibleMethodSpecIR {- ^ for name and typing environments -} -&gt;
<span class="lineno">  133 </span>  JVMVal {- ^ the value from the simulator -} -&gt;
<span class="lineno">  134 </span>  SetupValue {- ^ the value from the spec -} -&gt;
<span class="lineno">  135 </span>  J.Type     {- ^ the expected type -} -&gt;
<span class="lineno">  136 </span>  OverrideMatcher CJ.JVM w (OverrideFailureReason CJ.JVM)
<span class="lineno">  137 </span><span class="decl"><span class="istickedoff">mkStructuralMismatch opts cc sc spec jvmval setupval jty = do</span>
<span class="lineno">  138 </span><span class="spaces">  </span><span class="istickedoff">setupTy &lt;- typeOfSetupValueJVM <span class="nottickedoff">cc</span> <span class="nottickedoff">spec</span> setupval</span>
<span class="lineno">  139 </span><span class="spaces">  </span><span class="istickedoff">setupJVal &lt;- resolveSetupValueJVM <span class="nottickedoff">opts</span> cc sc <span class="nottickedoff">spec</span> setupval</span>
<span class="lineno">  140 </span><span class="spaces">  </span><span class="istickedoff">pure $ <span class="nottickedoff">StructuralMismatch</span></span>
<span class="lineno">  141 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">(ppJVMVal jvmval)</span></span>
<span class="lineno">  142 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">(ppJVMVal setupJVal)</span></span>
<span class="lineno">  143 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">(Just setupTy)</span></span>
<span class="lineno">  144 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">jty</span></span></span>
<span class="lineno">  145 </span>
<span class="lineno">  146 </span>
<span class="lineno">  147 </span>------------------------------------------------------------------------
<span class="lineno">  148 </span>
<span class="lineno">  149 </span>-- | This function is responsible for implementing the \&quot;override\&quot; behavior
<span class="lineno">  150 </span>--   of method specifications.  The main work done in this function to manage
<span class="lineno">  151 </span>--   the process of selecting between several possible different override
<span class="lineno">  152 </span>--   specifications that could apply.  We want a proof to succeed if /any/
<span class="lineno">  153 </span>--   choice of method spec allows the proof to go through, which is a slightly
<span class="lineno">  154 </span>--   awkward thing to fit into the symbolic simulation framework.
<span class="lineno">  155 </span>--
<span class="lineno">  156 </span>--   The main work of determining the preconditions, postconditions, memory
<span class="lineno">  157 </span>--   updates and return value for a single specification is done by
<span class="lineno">  158 </span>--   the @methodSpecHandler_prestate@ and @methodSpecHandler_poststate@ functions.
<span class="lineno">  159 </span>--
<span class="lineno">  160 </span>--   In a first phase, we attempt to apply the precondition portion of each of
<span class="lineno">  161 </span>--   the given method specifications.  Each of them that might apply generate
<span class="lineno">  162 </span>--   a substitution for the setup variables and a collection of preconditions
<span class="lineno">  163 </span>--   that guard the specification.  We use these preconditions to compute
<span class="lineno">  164 </span>--   a multiway symbolic branch, one for each override which might apply.
<span class="lineno">  165 </span>--
<span class="lineno">  166 </span>--   In the body of each of the individual branches, we compute the postcondition
<span class="lineno">  167 </span>--   actions of the corresponding method specification.  This will update memory
<span class="lineno">  168 </span>--   and compute function return values, in addition to assuming postcondition
<span class="lineno">  169 </span>--   predicates.
<span class="lineno">  170 </span>methodSpecHandler ::
<span class="lineno">  171 </span>  forall rtp args ret.
<span class="lineno">  172 </span>  Options                  {- ^ output/verbosity options                     -} -&gt;
<span class="lineno">  173 </span>  SharedContext            {- ^ context for constructing SAW terms           -} -&gt;
<span class="lineno">  174 </span>  JVMCrucibleContext          {- ^ context for interacting with Crucible        -} -&gt;
<span class="lineno">  175 </span>  W4.ProgramLoc            {- ^ Location of the call site for error reporting-} -&gt;
<span class="lineno">  176 </span>  IORef MetadataMap {- ^ metadata map -} -&gt;
<span class="lineno">  177 </span>  NonEmpty CrucibleMethodSpecIR {- ^ specification for current function override  -} -&gt;
<span class="lineno">  178 </span>  Crucible.FnHandle args ret {- ^ a handle for the function -} -&gt;
<span class="lineno">  179 </span>  Crucible.OverrideSim (SAWCruciblePersonality Sym) Sym CJ.JVM rtp args ret
<span class="lineno">  180 </span>     (Crucible.RegValue Sym ret)
<span class="lineno">  181 </span><span class="decl"><span class="istickedoff">methodSpecHandler opts sc cc top_loc _mdMap css h =</span>
<span class="lineno">  182 </span><span class="spaces">  </span><span class="istickedoff">-- TODO, special case for single-override situations,</span>
<span class="lineno">  183 </span><span class="spaces">  </span><span class="istickedoff">--  and use the mdMap to keep track of obligations arising</span>
<span class="lineno">  184 </span><span class="spaces">  </span><span class="istickedoff">--  from override preconditions.</span>
<span class="lineno">  185 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  186 </span><span class="spaces">  </span><span class="istickedoff">jccWithBackend cc $ \bak -&gt; do</span>
<span class="lineno">  187 </span><span class="spaces">  </span><span class="istickedoff">let sym = backendGetSym bak</span>
<span class="lineno">  188 </span><span class="spaces">  </span><span class="istickedoff">Crucible.RegMap args &lt;- Crucible.getOverrideArgs</span>
<span class="lineno">  189 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  190 </span><span class="spaces">  </span><span class="istickedoff">-- First, run the precondition matcher phase.  Collect together a list of the results.</span>
<span class="lineno">  191 </span><span class="spaces">  </span><span class="istickedoff">-- For each override, this will either be an error message, or a matcher state and</span>
<span class="lineno">  192 </span><span class="spaces">  </span><span class="istickedoff">-- a method spec.</span>
<span class="lineno">  193 </span><span class="spaces">  </span><span class="istickedoff">prestates &lt;-</span>
<span class="lineno">  194 </span><span class="spaces">    </span><span class="istickedoff">do g0 &lt;- Crucible.readGlobals</span>
<span class="lineno">  195 </span><span class="spaces">       </span><span class="istickedoff">forM css $ \cs -&gt; liftIO $</span>
<span class="lineno">  196 </span><span class="spaces">         </span><span class="istickedoff">let initialFree =</span>
<span class="lineno">  197 </span><span class="spaces">               </span><span class="istickedoff">Set.fromList (cs ^.. MS.csPreState. MS.csFreshVars . each . to tvName . to vnIndex)</span>
<span class="lineno">  198 </span><span class="spaces">          </span><span class="istickedoff">in runOverrideMatcher sym g0 Map.empty IntMap.empty initialFree <span class="nottickedoff">(view MS.csLoc cs)</span></span>
<span class="lineno">  199 </span><span class="spaces">                      </span><span class="istickedoff">(do methodSpecHandler_prestate <span class="nottickedoff">opts</span> <span class="nottickedoff">sc</span> cc args cs</span>
<span class="lineno">  200 </span><span class="spaces">                          </span><span class="istickedoff">return cs)</span>
<span class="lineno">  201 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  202 </span><span class="spaces">  </span><span class="istickedoff">-- Print a failure message if all overrides failed to match.  Otherwise, collect</span>
<span class="lineno">  203 </span><span class="spaces">  </span><span class="istickedoff">-- all the override states that might apply, and compute the conjunction of all</span>
<span class="lineno">  204 </span><span class="spaces">  </span><span class="istickedoff">-- the preconditions.  We'll use these to perform symbolic branches between the</span>
<span class="lineno">  205 </span><span class="spaces">  </span><span class="istickedoff">-- various overrides.</span>
<span class="lineno">  206 </span><span class="spaces">  </span><span class="istickedoff">branches &lt;- case partitionEithers (NE.toList prestates) of</span>
<span class="lineno">  207 </span><span class="spaces">                </span><span class="istickedoff">(e, []) -&gt;</span>
<span class="lineno">  208 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">fail $ show $</span></span>
<span class="lineno">  209 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">PP.vcat</span></span>
<span class="lineno">  210 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">[ &quot;All overrides failed during structural matching:&quot;</span></span>
<span class="lineno">  211 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">, PP.vcat (map (\x -&gt; &quot;*&quot; &lt;&gt; PP.indent 2 (ppOverrideFailure x)) e)</span></span>
<span class="lineno">  212 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  213 </span><span class="spaces">                </span><span class="istickedoff">(_, ss) -&gt; liftIO $</span>
<span class="lineno">  214 </span><span class="spaces">                  </span><span class="istickedoff">forM ss $ \(cs,st) -&gt;</span>
<span class="lineno">  215 </span><span class="spaces">                    </span><span class="istickedoff">do precond &lt;- W4.andAllOf sym (folded._2.labeledPred) (st^.osAsserts)</span>
<span class="lineno">  216 </span><span class="spaces">                       </span><span class="istickedoff">return ( precond, cs, st )</span>
<span class="lineno">  217 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  218 </span><span class="spaces">  </span><span class="istickedoff">-- Now use crucible's symbolic branching machinery to select between the branches.</span>
<span class="lineno">  219 </span><span class="spaces">  </span><span class="istickedoff">-- Essentially, we are doing an n-way if statement on the precondition predicates</span>
<span class="lineno">  220 </span><span class="spaces">  </span><span class="istickedoff">-- for each override, and selecting the first one whose preconditions hold.</span>
<span class="lineno">  221 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno">  222 </span><span class="spaces">  </span><span class="istickedoff">-- Then, in the body of the branch, we run the poststate handler to update the</span>
<span class="lineno">  223 </span><span class="spaces">  </span><span class="istickedoff">-- memory state, compute return values and compute postcondition predicates.</span>
<span class="lineno">  224 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno">  225 </span><span class="spaces">  </span><span class="istickedoff">-- For each override branch that doesn't fail outright, we assume the relevant</span>
<span class="lineno">  226 </span><span class="spaces">  </span><span class="istickedoff">-- postconditions, update the crucible global variable state, and return the</span>
<span class="lineno">  227 </span><span class="spaces">  </span><span class="istickedoff">-- computed return value.</span>
<span class="lineno">  228 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno">  229 </span><span class="spaces">  </span><span class="istickedoff">-- We add a final default branch that simply fails unless some previous override</span>
<span class="lineno">  230 </span><span class="spaces">  </span><span class="istickedoff">-- branch has already succeeded.</span>
<span class="lineno">  231 </span><span class="spaces">  </span><span class="istickedoff">let retTy = Crucible.handleReturnType h</span>
<span class="lineno">  232 </span><span class="spaces">  </span><span class="istickedoff">Crucible.regValue &lt;$&gt; Crucible.callOverride h</span>
<span class="lineno">  233 </span><span class="spaces">     </span><span class="istickedoff">(Crucible.mkOverride' &quot;overrideBranches&quot; <span class="nottickedoff">retTy</span></span>
<span class="lineno">  234 </span><span class="spaces">       </span><span class="istickedoff">(Crucible.symbolicBranches Crucible.emptyRegMap $</span>
<span class="lineno">  235 </span><span class="spaces">         </span><span class="istickedoff">[ ( precond</span>
<span class="lineno">  236 </span><span class="spaces">           </span><span class="istickedoff">, do g &lt;- Crucible.readGlobals</span>
<span class="lineno">  237 </span><span class="spaces">                </span><span class="istickedoff">res &lt;- liftIO $ runOverrideMatcher <span class="nottickedoff">sym</span> g</span>
<span class="lineno">  238 </span><span class="spaces">                   </span><span class="istickedoff">(st^.setupValueSub)</span>
<span class="lineno">  239 </span><span class="spaces">                   </span><span class="istickedoff">(st^.termSub)</span>
<span class="lineno">  240 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">(st^.osFree)</span></span>
<span class="lineno">  241 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">(st^.osLocation)</span></span>
<span class="lineno">  242 </span><span class="spaces">                   </span><span class="istickedoff">(methodSpecHandler_poststate opts sc cc retTy cs)</span>
<span class="lineno">  243 </span><span class="spaces">                </span><span class="istickedoff">case res of</span>
<span class="lineno">  244 </span><span class="spaces">                  </span><span class="istickedoff">Left (OF loc rsn)  -&gt;</span>
<span class="lineno">  245 </span><span class="spaces">                    </span><span class="istickedoff">-- TODO, better pretty printing for reasons</span>
<span class="lineno">  246 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">liftIO</span></span>
<span class="lineno">  247 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">$ Crucible.abortExecBecause</span></span>
<span class="lineno">  248 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">$ Crucible.AssertionFailure</span></span>
<span class="lineno">  249 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">$ Crucible.SimError loc</span></span>
<span class="lineno">  250 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">$ Crucible.AssertFailureSimError &quot;assumed false&quot; (show rsn)</span></span>
<span class="lineno">  251 </span><span class="spaces">                  </span><span class="istickedoff">Right (ret,st') -&gt;</span>
<span class="lineno">  252 </span><span class="spaces">                    </span><span class="istickedoff">do liftIO $ forM_ (st'^.osAssumes) $ <span class="nottickedoff">\(_md,asum) -&gt;</span></span>
<span class="lineno">  253 </span><span class="spaces">                         </span><span class="istickedoff"><span class="nottickedoff">Crucible.addAssumption bak</span></span>
<span class="lineno">  254 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">$ Crucible.GenericAssumption (st^.osLocation) &quot;override postcondition&quot; asum</span></span>
<span class="lineno">  255 </span><span class="spaces">                       </span><span class="istickedoff">Crucible.writeGlobals (st'^.overrideGlobals)</span>
<span class="lineno">  256 </span><span class="spaces">                       </span><span class="istickedoff">Crucible.overrideReturn' (Crucible.RegEntry retTy ret)</span>
<span class="lineno">  257 </span><span class="spaces">           </span><span class="istickedoff">, Just (W4.plSourceLoc (cs ^. MS.csLoc))</span>
<span class="lineno">  258 </span><span class="spaces">           </span><span class="istickedoff">)</span>
<span class="lineno">  259 </span><span class="spaces">         </span><span class="istickedoff">| (precond, cs, st) &lt;- branches</span>
<span class="lineno">  260 </span><span class="spaces">         </span><span class="istickedoff">] ++</span>
<span class="lineno">  261 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">[</span></span>
<span class="lineno">  262 </span><span class="spaces"></span><span class="istickedoff"><span class="nottickedoff"></span></span>
<span class="lineno">  263 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">let fnName = case branches of</span></span>
<span class="lineno">  264 </span><span class="spaces">                           </span><span class="istickedoff"><span class="nottickedoff">(_, cs, _) : _  -&gt; cs ^. MS.csMethod . jvmMethodName</span></span>
<span class="lineno">  265 </span><span class="spaces">                           </span><span class="istickedoff"><span class="nottickedoff">_               -&gt; &quot;unknown function&quot;</span></span>
<span class="lineno">  266 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">in</span></span>
<span class="lineno">  267 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">( W4.truePred sym</span></span>
<span class="lineno">  268 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">, liftIO $ Crucible.addFailedAssertion bak (Crucible.GenericSimError $ &quot;no override specification applies for &quot; ++ fnName)</span></span>
<span class="lineno">  269 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">, Just (W4.plSourceLoc top_loc)</span></span>
<span class="lineno">  270 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">)</span></span>
<span class="lineno">  271 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  272 </span><span class="spaces">       </span><span class="istickedoff">))</span>
<span class="lineno">  273 </span><span class="spaces">     </span><span class="istickedoff">(Crucible.RegMap args)</span></span>
<span class="lineno">  274 </span>
<span class="lineno">  275 </span>------------------------------------------------------------------------
<span class="lineno">  276 </span>
<span class="lineno">  277 </span>-- | Use a method spec to override the behavior of a function.
<span class="lineno">  278 </span>--   This function computes the pre-state portion of the override,
<span class="lineno">  279 </span>--   which involves reading values from arguments and memory and computing
<span class="lineno">  280 </span>--   substitutions for the setup value variables, and computing precondition
<span class="lineno">  281 </span>--   predicates.
<span class="lineno">  282 </span>methodSpecHandler_prestate ::
<span class="lineno">  283 </span>  forall ctx w.
<span class="lineno">  284 </span>  Options                  {- ^ output/verbosity options                     -} -&gt;
<span class="lineno">  285 </span>  SharedContext            {- ^ context for constructing SAW terms           -} -&gt;
<span class="lineno">  286 </span>  JVMCrucibleContext          {- ^ context for interacting with Crucible        -} -&gt;
<span class="lineno">  287 </span>  Ctx.Assignment (Crucible.RegEntry Sym) ctx
<span class="lineno">  288 </span>                           {- ^ the arguments to the function -} -&gt;
<span class="lineno">  289 </span>  CrucibleMethodSpecIR     {- ^ specification for current function override  -} -&gt;
<span class="lineno">  290 </span>  OverrideMatcher CJ.JVM w ()
<span class="lineno">  291 </span><span class="decl"><span class="istickedoff">methodSpecHandler_prestate opts sc cc args cs =</span>
<span class="lineno">  292 </span><span class="spaces">  </span><span class="istickedoff">do let expectedArgTypes = Map.elems (cs ^. MS.csArgBindings)</span>
<span class="lineno">  293 </span><span class="spaces">     </span><span class="istickedoff">let aux ::</span>
<span class="lineno">  294 </span><span class="spaces">           </span><span class="istickedoff">(J.Type, SetupValue) -&gt; Crucible.AnyValue Sym -&gt;</span>
<span class="lineno">  295 </span><span class="spaces">           </span><span class="istickedoff">IO (JVMVal, J.Type, SetupValue)</span>
<span class="lineno">  296 </span><span class="spaces">         </span><span class="istickedoff">aux (argTy, setupVal) val =</span>
<span class="lineno">  297 </span><span class="spaces">           </span><span class="istickedoff">case decodeJVMVal argTy val of</span>
<span class="lineno">  298 </span><span class="spaces">             </span><span class="istickedoff">Just val' -&gt; return (val', <span class="nottickedoff">argTy</span>, setupVal)</span>
<span class="lineno">  299 </span><span class="spaces">             </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail &quot;unexpected type&quot;</span></span>
<span class="lineno">  300 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  301 </span><span class="spaces">     </span><span class="istickedoff">-- todo: fail if list lengths mismatch</span>
<span class="lineno">  302 </span><span class="spaces">     </span><span class="istickedoff">xs &lt;- liftIO (zipWithM aux expectedArgTypes (assignmentToList args))</span>
<span class="lineno">  303 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  304 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">md = MS.ConditionMetadata</span></span>
<span class="lineno">  305 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">{ MS.conditionLoc = cs ^. MS.csLoc</span></span>
<span class="lineno">  306 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionTags = mempty</span></span>
<span class="lineno">  307 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionType = &quot;formal argument matching&quot;</span></span>
<span class="lineno">  308 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionContext = &quot;&quot;</span></span>
<span class="lineno">  309 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">}</span></span>
<span class="lineno">  310 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  311 </span><span class="spaces">     </span><span class="istickedoff">sequence_ [ matchArg <span class="nottickedoff">opts</span> <span class="nottickedoff">sc</span> cc <span class="nottickedoff">cs</span> <span class="nottickedoff">PreState</span> <span class="nottickedoff">md</span> x <span class="nottickedoff">y</span> z | (x, y, z) &lt;- xs]</span>
<span class="lineno">  312 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  313 </span><span class="spaces">     </span><span class="istickedoff">learnCond <span class="nottickedoff">opts</span> <span class="nottickedoff">sc</span> cc cs <span class="nottickedoff">PreState</span> (cs ^. MS.csPreState)</span></span>
<span class="lineno">  314 </span>
<span class="lineno">  315 </span>
<span class="lineno">  316 </span>-- | Use a method spec to override the behavior of a function.
<span class="lineno">  317 </span>--   This function computes the post-state portion of the override,
<span class="lineno">  318 </span>--   which involves writing values into memory, computing the return value,
<span class="lineno">  319 </span>--   and computing postcondition predicates.
<span class="lineno">  320 </span>methodSpecHandler_poststate ::
<span class="lineno">  321 </span>  forall ret.
<span class="lineno">  322 </span>  Options                  {- ^ output/verbosity options                     -} -&gt;
<span class="lineno">  323 </span>  SharedContext            {- ^ context for constructing SAW terms           -} -&gt;
<span class="lineno">  324 </span>  JVMCrucibleContext          {- ^ context for interacting with Crucible        -} -&gt;
<span class="lineno">  325 </span>  Crucible.TypeRepr ret    {- ^ type representation of function return value -} -&gt;
<span class="lineno">  326 </span>  CrucibleMethodSpecIR     {- ^ specification for current function override  -} -&gt;
<span class="lineno">  327 </span>  OverrideMatcher CJ.JVM RW (Crucible.RegValue Sym ret)
<span class="lineno">  328 </span><span class="decl"><span class="istickedoff">methodSpecHandler_poststate opts sc cc retTy cs =</span>
<span class="lineno">  329 </span><span class="spaces">  </span><span class="istickedoff">do executeCond opts sc cc <span class="nottickedoff">cs</span> (cs ^. MS.csPostState)</span>
<span class="lineno">  330 </span><span class="spaces">     </span><span class="istickedoff">computeReturnValue <span class="nottickedoff">opts</span> cc sc <span class="nottickedoff">cs</span> retTy (cs ^. MS.csRetValue)</span></span>
<span class="lineno">  331 </span>
<span class="lineno">  332 </span>-- learn pre/post condition
<span class="lineno">  333 </span>learnCond ::
<span class="lineno">  334 </span>  Options -&gt;
<span class="lineno">  335 </span>  SharedContext -&gt;
<span class="lineno">  336 </span>  JVMCrucibleContext -&gt;
<span class="lineno">  337 </span>  CrucibleMethodSpecIR -&gt;
<span class="lineno">  338 </span>  PrePost -&gt;
<span class="lineno">  339 </span>  StateSpec -&gt;
<span class="lineno">  340 </span>  OverrideMatcher CJ.JVM w ()
<span class="lineno">  341 </span><span class="decl"><span class="istickedoff">learnCond opts sc cc cs prepost ss =</span>
<span class="lineno">  342 </span><span class="spaces">  </span><span class="istickedoff">do let loc = cs ^. MS.csLoc</span>
<span class="lineno">  343 </span><span class="spaces">     </span><span class="istickedoff">matchPointsTos <span class="nottickedoff">opts</span> sc cc cs <span class="nottickedoff">prepost</span> (ss ^. MS.csPointsTos)</span>
<span class="lineno">  344 </span><span class="spaces">     </span><span class="istickedoff">traverse_ <span class="nottickedoff">(learnSetupCondition opts sc cc cs prepost)</span> (ss ^. MS.csConditions)</span>
<span class="lineno">  345 </span><span class="spaces">     </span><span class="istickedoff">assertTermEqualities sc cc</span>
<span class="lineno">  346 </span><span class="spaces">     </span><span class="istickedoff">enforceDisjointness cc loc ss</span>
<span class="lineno">  347 </span><span class="spaces">     </span><span class="istickedoff">enforceCompleteSubstitution <span class="nottickedoff">loc</span> ss</span></span>
<span class="lineno">  348 </span>
<span class="lineno">  349 </span>
<span class="lineno">  350 </span>assertTermEqualities ::
<span class="lineno">  351 </span>  SharedContext -&gt;
<span class="lineno">  352 </span>  JVMCrucibleContext -&gt;
<span class="lineno">  353 </span>  OverrideMatcher CJ.JVM md ()
<span class="lineno">  354 </span><span class="decl"><span class="istickedoff">assertTermEqualities sc cc = do</span>
<span class="lineno">  355 </span><span class="spaces">  </span><span class="istickedoff">let sym = cc ^. jccSym</span>
<span class="lineno">  356 </span><span class="spaces">  </span><span class="istickedoff">let assertTermEquality (cond, t, md, e) = do</span>
<span class="lineno">  357 </span><span class="spaces">        </span><span class="istickedoff">p &lt;- instantiateExtResolveSAWPred sc cc t</span>
<span class="lineno">  358 </span><span class="spaces">        </span><span class="istickedoff">p' &lt;- liftIO $ W4.impliesPred sym cond p</span>
<span class="lineno">  359 </span><span class="spaces">        </span><span class="istickedoff">addAssert p' <span class="nottickedoff">md</span> e</span>
<span class="lineno">  360 </span><span class="spaces">  </span><span class="istickedoff">traverse_ assertTermEquality =&lt;&lt; OM (use termEqs)</span></span>
<span class="lineno">  361 </span>
<span class="lineno">  362 </span>
<span class="lineno">  363 </span>-- execute a pre/post condition
<span class="lineno">  364 </span>executeCond ::
<span class="lineno">  365 </span>  Options -&gt;
<span class="lineno">  366 </span>  SharedContext -&gt;
<span class="lineno">  367 </span>  JVMCrucibleContext -&gt;
<span class="lineno">  368 </span>  CrucibleMethodSpecIR -&gt;
<span class="lineno">  369 </span>  StateSpec -&gt;
<span class="lineno">  370 </span>  OverrideMatcher CJ.JVM RW ()
<span class="lineno">  371 </span><span class="decl"><span class="istickedoff">executeCond opts sc cc cs ss =</span>
<span class="lineno">  372 </span><span class="spaces">  </span><span class="istickedoff">do refreshTerms <span class="nottickedoff">sc</span> ss</span>
<span class="lineno">  373 </span><span class="spaces">     </span><span class="istickedoff">traverse_ (executeAllocation opts cc) (Map.assocs (ss ^. MS.csAllocs))</span>
<span class="lineno">  374 </span><span class="spaces">     </span><span class="istickedoff">traverse_ (executePointsTo <span class="nottickedoff">opts</span> sc cc <span class="nottickedoff">cs</span>) (ss ^. MS.csPointsTos)</span>
<span class="lineno">  375 </span><span class="spaces">     </span><span class="istickedoff">traverse_ <span class="nottickedoff">(executeSetupCondition opts sc cc cs)</span> (ss ^. MS.csConditions)</span></span>
<span class="lineno">  376 </span>
<span class="lineno">  377 </span>
<span class="lineno">  378 </span>------------------------------------------------------------------------
<span class="lineno">  379 </span>
<span class="lineno">  380 </span>-- | Generate assertions that all of the memory allocations matched by
<span class="lineno">  381 </span>-- an override's precondition are disjoint.
<span class="lineno">  382 </span>enforceDisjointness ::
<span class="lineno">  383 </span>  JVMCrucibleContext -&gt; W4.ProgramLoc -&gt; StateSpec -&gt; OverrideMatcher CJ.JVM w ()
<span class="lineno">  384 </span><span class="decl"><span class="istickedoff">enforceDisjointness cc loc ss =</span>
<span class="lineno">  385 </span><span class="spaces">  </span><span class="istickedoff">do let sym = cc^.jccSym</span>
<span class="lineno">  386 </span><span class="spaces">     </span><span class="istickedoff">sub &lt;- OM (use setupValueSub)</span>
<span class="lineno">  387 </span><span class="spaces">     </span><span class="istickedoff">let mems = Map.elems $ Map.intersectionWith (,) (view MS.csAllocs ss) sub</span>
<span class="lineno">  388 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  389 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">md = MS.ConditionMetadata</span></span>
<span class="lineno">  390 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">{ MS.conditionLoc = loc</span></span>
<span class="lineno">  391 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionTags = mempty</span></span>
<span class="lineno">  392 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionType = &quot;memory region disjointness&quot;</span></span>
<span class="lineno">  393 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionContext = &quot;&quot;</span></span>
<span class="lineno">  394 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">}</span></span>
<span class="lineno">  395 </span><span class="spaces">     </span><span class="istickedoff">-- Ensure that all regions are disjoint from each other.</span>
<span class="lineno">  396 </span><span class="spaces">     </span><span class="istickedoff">sequence_</span>
<span class="lineno">  397 </span><span class="spaces">        </span><span class="istickedoff">[ do c &lt;- liftIO $ W4.notPred sym =&lt;&lt; CJ.refIsEqual sym p q</span>
<span class="lineno">  398 </span><span class="spaces">             </span><span class="istickedoff">addAssert c <span class="nottickedoff">md</span> a</span>
<span class="lineno">  399 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  400 </span><span class="spaces">        </span><span class="istickedoff">| let a = Crucible.SimError loc $</span>
<span class="lineno">  401 </span><span class="spaces">                    </span><span class="istickedoff">Crucible.AssertFailureSimError &quot;Memory regions not disjoint&quot; &quot;&quot;</span>
<span class="lineno">  402 </span><span class="spaces">        </span><span class="istickedoff">, ((_ploc, _pty), p) : ps &lt;- tails mems</span>
<span class="lineno">  403 </span><span class="spaces">        </span><span class="istickedoff">, ((_qloc, _qty), q)      &lt;- ps</span>
<span class="lineno">  404 </span><span class="spaces">        </span><span class="istickedoff">]</span></span>
<span class="lineno">  405 </span>
<span class="lineno">  406 </span>------------------------------------------------------------------------
<span class="lineno">  407 </span>
<span class="lineno">  408 </span>-- | For each points-to statement read the memory value through the
<span class="lineno">  409 </span>-- given pointer (lhs) and match the value against the given pattern
<span class="lineno">  410 </span>-- (rhs).  Statements are processed in dependency order: a points-to
<span class="lineno">  411 </span>-- statement cannot be executed until bindings for any/all lhs
<span class="lineno">  412 </span>-- variables exist.
<span class="lineno">  413 </span>matchPointsTos ::
<span class="lineno">  414 </span>  Options          {- ^ saw script print out opts -} -&gt;
<span class="lineno">  415 </span>  SharedContext    {- ^ term construction context -} -&gt;
<span class="lineno">  416 </span>  JVMCrucibleContext  {- ^ simulator context     -}     -&gt;
<span class="lineno">  417 </span>  CrucibleMethodSpecIR                               -&gt;
<span class="lineno">  418 </span>  PrePost                                            -&gt;
<span class="lineno">  419 </span>  [JVMPointsTo]       {- ^ points-tos                -} -&gt;
<span class="lineno">  420 </span>  OverrideMatcher CJ.JVM w ()
<span class="lineno">  421 </span><span class="decl"><span class="istickedoff">matchPointsTos opts sc cc spec prepost = go False []</span>
<span class="lineno">  422 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  423 </span><span class="spaces">    </span><span class="istickedoff">go ::</span>
<span class="lineno">  424 </span><span class="spaces">      </span><span class="istickedoff">Bool       {- progress indicator -} -&gt;</span>
<span class="lineno">  425 </span><span class="spaces">      </span><span class="istickedoff">[JVMPointsTo] {- delayed conditions -} -&gt;</span>
<span class="lineno">  426 </span><span class="spaces">      </span><span class="istickedoff">[JVMPointsTo] {- queued conditions  -} -&gt;</span>
<span class="lineno">  427 </span><span class="spaces">      </span><span class="istickedoff">OverrideMatcher CJ.JVM w ()</span>
<span class="lineno">  428 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  429 </span><span class="spaces">    </span><span class="istickedoff">-- all conditions processed, success</span>
<span class="lineno">  430 </span><span class="spaces">    </span><span class="istickedoff">go _ [] [] = return <span class="nottickedoff">()</span></span>
<span class="lineno">  431 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  432 </span><span class="spaces">    </span><span class="istickedoff">-- not all conditions processed, no progress, failure</span>
<span class="lineno">  433 </span><span class="spaces">    </span><span class="istickedoff">go False delayed [] = <span class="nottickedoff">failure (spec ^. MS.csLoc) (AmbiguousPointsTos delayed)</span></span>
<span class="lineno">  434 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  435 </span><span class="spaces">    </span><span class="istickedoff">-- not all conditions processed, progress made, resume delayed conditions</span>
<span class="lineno">  436 </span><span class="spaces">    </span><span class="istickedoff">go True delayed [] = go False [] delayed</span>
<span class="lineno">  437 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  438 </span><span class="spaces">    </span><span class="istickedoff">-- progress the next points-to in the work queue</span>
<span class="lineno">  439 </span><span class="spaces">    </span><span class="istickedoff">go progress delayed (c:cs) =</span>
<span class="lineno">  440 </span><span class="spaces">      </span><span class="istickedoff">do ready &lt;- checkPointsTo c</span>
<span class="lineno">  441 </span><span class="spaces">         </span><span class="istickedoff">if ready then</span>
<span class="lineno">  442 </span><span class="spaces">           </span><span class="istickedoff">do learnPointsTo <span class="nottickedoff">opts</span> sc cc spec <span class="nottickedoff">prepost</span> c</span>
<span class="lineno">  443 </span><span class="spaces">              </span><span class="istickedoff">go True delayed cs</span>
<span class="lineno">  444 </span><span class="spaces">         </span><span class="istickedoff">else</span>
<span class="lineno">  445 </span><span class="spaces">           </span><span class="istickedoff">do go progress (c:delayed) cs</span>
<span class="lineno">  446 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  447 </span><span class="spaces">    </span><span class="istickedoff">-- determine if a precondition is ready to be checked</span>
<span class="lineno">  448 </span><span class="spaces">    </span><span class="istickedoff">checkPointsTo :: JVMPointsTo -&gt; OverrideMatcher CJ.JVM w Bool</span>
<span class="lineno">  449 </span><span class="spaces">    </span><span class="istickedoff">checkPointsTo (JVMPointsToField _loc p _ _) = checkAllocIndex p</span>
<span class="lineno">  450 </span><span class="spaces">    </span><span class="istickedoff">checkPointsTo (JVMPointsToStatic _loc _ _) = pure True</span>
<span class="lineno">  451 </span><span class="spaces">    </span><span class="istickedoff">checkPointsTo (JVMPointsToElem _loc p _ _) = checkAllocIndex p</span>
<span class="lineno">  452 </span><span class="spaces">    </span><span class="istickedoff">checkPointsTo (JVMPointsToArray _loc p _) = checkAllocIndex p</span>
<span class="lineno">  453 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  454 </span><span class="spaces">    </span><span class="istickedoff">checkAllocIndex :: AllocIndex -&gt; OverrideMatcher CJ.JVM w Bool</span>
<span class="lineno">  455 </span><span class="spaces">    </span><span class="istickedoff">checkAllocIndex i =</span>
<span class="lineno">  456 </span><span class="spaces">      </span><span class="istickedoff">do m &lt;- OM (use setupValueSub)</span>
<span class="lineno">  457 </span><span class="spaces">         </span><span class="istickedoff">return (Map.member i m)</span></span>
<span class="lineno">  458 </span>
<span class="lineno">  459 </span>
<span class="lineno">  460 </span>------------------------------------------------------------------------
<span class="lineno">  461 </span>
<span class="lineno">  462 </span>computeReturnValue ::
<span class="lineno">  463 </span>  Options               {- ^ saw script debug and print options     -} -&gt;
<span class="lineno">  464 </span>  JVMCrucibleContext       {- ^ context of the crucible simulation     -} -&gt;
<span class="lineno">  465 </span>  SharedContext         {- ^ context for generating saw terms       -} -&gt;
<span class="lineno">  466 </span>  CrucibleMethodSpecIR  {- ^ method specification                   -} -&gt;
<span class="lineno">  467 </span>  Crucible.TypeRepr ret {- ^ representation of function return type -} -&gt;
<span class="lineno">  468 </span>  Maybe SetupValue      {- ^ optional symbolic return value         -} -&gt;
<span class="lineno">  469 </span>  OverrideMatcher CJ.JVM w (Crucible.RegValue Sym ret)
<span class="lineno">  470 </span>                        {- ^ concrete return value                  -}
<span class="lineno">  471 </span>
<span class="lineno">  472 </span><span class="decl"><span class="istickedoff">computeReturnValue _opts _cc _sc spec ty Nothing =</span>
<span class="lineno">  473 </span><span class="spaces">  </span><span class="istickedoff">case ty of</span>
<span class="lineno">  474 </span><span class="spaces">    </span><span class="istickedoff">Crucible.UnitRepr -&gt; return ()</span>
<span class="lineno">  475 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">failure (spec ^. MS.csLoc) (BadReturnSpecification (Some ty))</span></span>
<span class="lineno">  476 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  477 </span><span class="spaces"></span><span class="istickedoff">computeReturnValue opts cc sc spec ty (Just val) =</span>
<span class="lineno">  478 </span><span class="spaces">  </span><span class="istickedoff">do val' &lt;- resolveSetupValueJVM <span class="nottickedoff">opts</span> cc sc <span class="nottickedoff">spec</span> val</span>
<span class="lineno">  479 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">fail_ = failure (spec ^. MS.csLoc) (BadReturnSpecification (Some ty))</span></span>
<span class="lineno">  480 </span><span class="spaces">     </span><span class="istickedoff">case val' of</span>
<span class="lineno">  481 </span><span class="spaces">       </span><span class="istickedoff">IVal i -&gt;</span>
<span class="lineno">  482 </span><span class="spaces">         </span><span class="istickedoff">case testEquality ty CJ.intRepr of</span>
<span class="lineno">  483 </span><span class="spaces">           </span><span class="istickedoff">Just Refl -&gt; return i</span>
<span class="lineno">  484 </span><span class="spaces">           </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail_</span></span>
<span class="lineno">  485 </span><span class="spaces">       </span><span class="istickedoff">LVal l -&gt;</span>
<span class="lineno">  486 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">case testEquality ty CJ.longRepr of</span></span>
<span class="lineno">  487 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">Just Refl -&gt; return l</span></span>
<span class="lineno">  488 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt; fail_</span></span>
<span class="lineno">  489 </span><span class="spaces">       </span><span class="istickedoff">RVal r -&gt;</span>
<span class="lineno">  490 </span><span class="spaces">         </span><span class="istickedoff">case testEquality ty CJ.refRepr of</span>
<span class="lineno">  491 </span><span class="spaces">           </span><span class="istickedoff">Just Refl -&gt; return r</span>
<span class="lineno">  492 </span><span class="spaces">           </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail_</span></span></span>
<span class="lineno">  493 </span>
<span class="lineno">  494 </span>
<span class="lineno">  495 </span>------------------------------------------------------------------------
<span class="lineno">  496 </span>
<span class="lineno">  497 </span>-- | Assign the given pointer value to the given allocation index in
<span class="lineno">  498 </span>-- the current substitution. If there is already a binding for this
<span class="lineno">  499 </span>-- index, then add a pointer-equality constraint.
<span class="lineno">  500 </span>assignVar ::
<span class="lineno">  501 </span>  JVMCrucibleContext {- ^ context for interacting with Crucible -} -&gt;
<span class="lineno">  502 </span>  MS.ConditionMetadata -&gt;
<span class="lineno">  503 </span>  AllocIndex {- ^ variable index -} -&gt;
<span class="lineno">  504 </span>  JVMRefVal  {- ^ concrete value -} -&gt;
<span class="lineno">  505 </span>  OverrideMatcher CJ.JVM w ()
<span class="lineno">  506 </span>
<span class="lineno">  507 </span><span class="decl"><span class="istickedoff">assignVar cc md var ref =</span>
<span class="lineno">  508 </span><span class="spaces">  </span><span class="istickedoff">do old &lt;- OM (setupValueSub . at var &lt;&lt;.= Just ref)</span>
<span class="lineno">  509 </span><span class="spaces">     </span><span class="istickedoff">let loc = MS.conditionLoc md</span>
<span class="lineno">  510 </span><span class="spaces">     </span><span class="istickedoff">let sym = cc ^. jccSym</span>
<span class="lineno">  511 </span><span class="spaces">     </span><span class="istickedoff">for_ old $ \ref' -&gt;</span>
<span class="lineno">  512 </span><span class="spaces">       </span><span class="istickedoff">do p &lt;- liftIO (CJ.refIsEqual sym ref ref')</span>
<span class="lineno">  513 </span><span class="spaces">          </span><span class="istickedoff">addAssert p <span class="nottickedoff">md</span> (Crucible.SimError loc (Crucible.AssertFailureSimError &quot;equality of aliased pointers&quot; &quot;&quot;))</span></span>
<span class="lineno">  514 </span>
<span class="lineno">  515 </span>------------------------------------------------------------------------
<span class="lineno">  516 </span>
<span class="lineno">  517 </span>-- | Match the value of a function argument with a symbolic 'SetupValue'.
<span class="lineno">  518 </span>matchArg ::
<span class="lineno">  519 </span>  Options          {- ^ saw script print out opts -} -&gt;
<span class="lineno">  520 </span>  SharedContext      {- ^ context for constructing SAW terms    -} -&gt;
<span class="lineno">  521 </span>  JVMCrucibleContext    {- ^ context for interacting with Crucible -} -&gt;
<span class="lineno">  522 </span>  CrucibleMethodSpecIR {- ^ specification for current function override  -} -&gt;
<span class="lineno">  523 </span>  PrePost                                                          -&gt;
<span class="lineno">  524 </span>  MS.ConditionMetadata -&gt;
<span class="lineno">  525 </span>  JVMVal             {- ^ concrete simulation value             -} -&gt;
<span class="lineno">  526 </span>  J.Type             {- ^ expected memory type                  -} -&gt;
<span class="lineno">  527 </span>  SetupValue         {- ^ expected specification value          -} -&gt;
<span class="lineno">  528 </span>  OverrideMatcher CJ.JVM w ()
<span class="lineno">  529 </span>
<span class="lineno">  530 </span><span class="decl"><span class="istickedoff">matchArg opts sc cc cs prepost md actual expectedTy expected@(MS.SetupTerm expectedTT)</span>
<span class="lineno">  531 </span><span class="spaces">  </span><span class="istickedoff">| TypedTermSchema (Cryptol.Forall [] [] tyexpr) &lt;- ttType expectedTT</span>
<span class="lineno">  532 </span><span class="spaces">  </span><span class="istickedoff">, Right tval &lt;- Cryptol.evalType <span class="nottickedoff">mempty</span> tyexpr</span>
<span class="lineno">  533 </span><span class="spaces">  </span><span class="istickedoff">= do sym &lt;- Ov.getSymInterface</span>
<span class="lineno">  534 </span><span class="spaces">       </span><span class="istickedoff">failMsg  &lt;- mkStructuralMismatch <span class="nottickedoff">opts</span> cc sc <span class="nottickedoff">cs</span> <span class="nottickedoff">actual</span> expected <span class="nottickedoff">expectedTy</span></span>
<span class="lineno">  535 </span><span class="spaces">       </span><span class="istickedoff">realTerm &lt;- valueToSC sym <span class="nottickedoff">md</span> <span class="nottickedoff">failMsg</span> tval actual</span>
<span class="lineno">  536 </span><span class="spaces">       </span><span class="istickedoff">matchTerm sc md prepost realTerm (ttTerm expectedTT)</span>
<span class="lineno">  537 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  538 </span><span class="spaces"></span><span class="istickedoff">matchArg opts sc cc cs prepost md actual@(RVal ref) expectedTy setupval =</span>
<span class="lineno">  539 </span><span class="spaces">  </span><span class="istickedoff">case setupval of</span>
<span class="lineno">  540 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupVar var -&gt;</span>
<span class="lineno">  541 </span><span class="spaces">      </span><span class="istickedoff">do assignVar cc md var ref</span>
<span class="lineno">  542 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  543 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupNull () -&gt;</span>
<span class="lineno">  544 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">do sym &lt;- Ov.getSymInterface</span></span>
<span class="lineno">  545 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">p   &lt;- liftIO (CJ.refIsNull sym ref)</span></span>
<span class="lineno">  546 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">addAssert p md (Crucible.SimError (cs ^. MS.csLoc) (Crucible.AssertFailureSimError (&quot;null-equality &quot; ++ MS.stateCond prepost) &quot;&quot;))</span></span>
<span class="lineno">  547 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  548 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupGlobal empty _ -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno">  549 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupEnum   empty   -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno">  550 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupTuple  empty _ -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno">  551 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupSlice  empty   -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno">  552 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  553 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">failure (cs ^. MS.csLoc) =&lt;&lt;</span></span>
<span class="lineno">  554 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">mkStructuralMismatch opts cc sc cs actual setupval expectedTy</span></span>
<span class="lineno">  555 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  556 </span><span class="spaces"></span><span class="istickedoff">matchArg opts sc cc cs _prepost md actual expectedTy expected =</span>
<span class="lineno">  557 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">failure (MS.conditionLoc md) =&lt;&lt;</span></span>
<span class="lineno">  558 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">mkStructuralMismatch opts cc sc cs actual expected expectedTy</span></span></span>
<span class="lineno">  559 </span>
<span class="lineno">  560 </span>------------------------------------------------------------------------
<span class="lineno">  561 </span>
<span class="lineno">  562 </span>valueToSC ::
<span class="lineno">  563 </span>  Sym -&gt;
<span class="lineno">  564 </span>  MS.ConditionMetadata -&gt;
<span class="lineno">  565 </span>  OverrideFailureReason CJ.JVM -&gt;
<span class="lineno">  566 </span>  Cryptol.TValue -&gt;
<span class="lineno">  567 </span>  JVMVal -&gt;
<span class="lineno">  568 </span>  OverrideMatcher CJ.JVM w Term
<span class="lineno">  569 </span><span class="decl"><span class="istickedoff">valueToSC sym _ _ Cryptol.TVBit (IVal x) =</span>
<span class="lineno">  570 </span><span class="spaces">  </span><span class="istickedoff">do b &lt;- liftIO $ W4.bvIsNonzero sym x</span>
<span class="lineno">  571 </span><span class="spaces">      </span><span class="istickedoff">-- TODO: assert that x is 0 or 1</span>
<span class="lineno">  572 </span><span class="spaces">     </span><span class="istickedoff">st &lt;- liftIO (sawCoreState sym)</span>
<span class="lineno">  573 </span><span class="spaces">     </span><span class="istickedoff">liftIO (toSC <span class="nottickedoff">sym</span> st b)</span>
<span class="lineno">  574 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  575 </span><span class="spaces"></span><span class="istickedoff">valueToSC sym _ _ (Cryptol.TVSeq 8 Cryptol.TVBit) (IVal x) =</span>
<span class="lineno">  576 </span><span class="spaces">  </span><span class="istickedoff">do st &lt;- liftIO (sawCoreState sym)</span>
<span class="lineno">  577 </span><span class="spaces">     </span><span class="istickedoff">liftIO (toSC <span class="nottickedoff">sym</span> st =&lt;&lt; W4.bvTrunc sym (W4.knownNat @8) x)</span>
<span class="lineno">  578 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  579 </span><span class="spaces"></span><span class="istickedoff">valueToSC sym _ _ (Cryptol.TVSeq 16 Cryptol.TVBit) (IVal x) =</span>
<span class="lineno">  580 </span><span class="spaces">  </span><span class="istickedoff">do st &lt;- liftIO (sawCoreState sym)</span>
<span class="lineno">  581 </span><span class="spaces">     </span><span class="istickedoff">liftIO (toSC <span class="nottickedoff">sym</span> st =&lt;&lt; W4.bvTrunc sym (W4.knownNat @16) x)</span>
<span class="lineno">  582 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  583 </span><span class="spaces"></span><span class="istickedoff">valueToSC sym _ _ (Cryptol.TVSeq 32 Cryptol.TVBit) (IVal x) =</span>
<span class="lineno">  584 </span><span class="spaces">  </span><span class="istickedoff">do st &lt;- liftIO (sawCoreState sym)</span>
<span class="lineno">  585 </span><span class="spaces">     </span><span class="istickedoff">liftIO (toSC <span class="nottickedoff">sym</span> st x)</span>
<span class="lineno">  586 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  587 </span><span class="spaces"></span><span class="istickedoff">valueToSC sym _ _ (Cryptol.TVSeq 64 Cryptol.TVBit) (LVal x) =</span>
<span class="lineno">  588 </span><span class="spaces">  </span><span class="istickedoff">do st &lt;- liftIO (sawCoreState sym)</span>
<span class="lineno">  589 </span><span class="spaces">     </span><span class="istickedoff">liftIO (toSC <span class="nottickedoff">sym</span> st x)</span>
<span class="lineno">  590 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  591 </span><span class="spaces"></span><span class="istickedoff">valueToSC _sym md failMsg _tval _val =</span>
<span class="lineno">  592 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">failure (MS.conditionLoc md) failMsg</span></span></span>
<span class="lineno">  593 </span>
<span class="lineno">  594 </span>------------------------------------------------------------------------
<span class="lineno">  595 </span>
<span class="lineno">  596 </span>-- | Use the current state to learn about variable assignments based on
<span class="lineno">  597 </span>-- preconditions for a procedure specification.
<span class="lineno">  598 </span>learnSetupCondition ::
<span class="lineno">  599 </span>  Options                    -&gt;
<span class="lineno">  600 </span>  SharedContext              -&gt;
<span class="lineno">  601 </span>  JVMCrucibleContext            -&gt;
<span class="lineno">  602 </span>  CrucibleMethodSpecIR       -&gt;
<span class="lineno">  603 </span>  PrePost                    -&gt;
<span class="lineno">  604 </span>  SetupCondition             -&gt;
<span class="lineno">  605 </span>  OverrideMatcher CJ.JVM w ()
<span class="lineno">  606 </span><span class="decl"><span class="nottickedoff">learnSetupCondition opts sc cc spec prepost cond =</span>
<span class="lineno">  607 </span><span class="spaces">  </span><span class="nottickedoff">case cond of</span>
<span class="lineno">  608 </span><span class="spaces">    </span><span class="nottickedoff">MS.SetupCond_Equal md val1 val2 -&gt; learnEqual opts sc cc spec md prepost val1 val2</span>
<span class="lineno">  609 </span><span class="spaces">    </span><span class="nottickedoff">MS.SetupCond_Pred md tm         -&gt; learnPred sc cc md prepost (ttTerm tm)</span>
<span class="lineno">  610 </span><span class="spaces">    </span><span class="nottickedoff">MS.SetupCond_Ghost md var val   -&gt; learnGhost sc md prepost var val</span></span>
<span class="lineno">  611 </span>
<span class="lineno">  612 </span>------------------------------------------------------------------------
<span class="lineno">  613 </span>
<span class="lineno">  614 </span>-- | Process a &quot;points_to&quot; statement from the precondition section of
<span class="lineno">  615 </span>-- the CrucibleSetup block. First, load the value from the address
<span class="lineno">  616 </span>-- indicated by 'ptr', and then match it against the pattern 'val'.
<span class="lineno">  617 </span>learnPointsTo ::
<span class="lineno">  618 </span>  Options                    -&gt;
<span class="lineno">  619 </span>  SharedContext              -&gt;
<span class="lineno">  620 </span>  JVMCrucibleContext            -&gt;
<span class="lineno">  621 </span>  CrucibleMethodSpecIR       -&gt;
<span class="lineno">  622 </span>  PrePost                    -&gt;
<span class="lineno">  623 </span>  JVMPointsTo                   -&gt;
<span class="lineno">  624 </span>  OverrideMatcher CJ.JVM w ()
<span class="lineno">  625 </span><span class="decl"><span class="istickedoff">learnPointsTo opts sc cc spec prepost pt =</span>
<span class="lineno">  626 </span><span class="spaces">  </span><span class="istickedoff">jccWithBackend cc $ \bak -&gt; do</span>
<span class="lineno">  627 </span><span class="spaces">  </span><span class="istickedoff">let sym = backendGetSym bak</span>
<span class="lineno">  628 </span><span class="spaces">  </span><span class="istickedoff">let tyenv = MS.csAllocations spec</span>
<span class="lineno">  629 </span><span class="spaces">  </span><span class="istickedoff">let <span class="nottickedoff">nameEnv = MS.csTypeNames spec</span></span>
<span class="lineno">  630 </span><span class="spaces">  </span><span class="istickedoff">let jc = cc ^. jccJVMContext</span>
<span class="lineno">  631 </span><span class="spaces">  </span><span class="istickedoff">globals &lt;- OM (use overrideGlobals)</span>
<span class="lineno">  632 </span><span class="spaces">  </span><span class="istickedoff">case pt of</span>
<span class="lineno">  633 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  634 </span><span class="spaces">    </span><span class="istickedoff">JVMPointsToField md ptr fid (Just val) -&gt;</span>
<span class="lineno">  635 </span><span class="spaces">      </span><span class="istickedoff">do ty &lt;- typeOfSetupValue <span class="nottickedoff">cc</span> tyenv <span class="nottickedoff">nameEnv</span> val</span>
<span class="lineno">  636 </span><span class="spaces">         </span><span class="istickedoff">rval &lt;- resolveAllocIndexJVM ptr</span>
<span class="lineno">  637 </span><span class="spaces">         </span><span class="istickedoff">dyn &lt;- liftIO $ CJ.doFieldLoad bak globals rval fid</span>
<span class="lineno">  638 </span><span class="spaces">         </span><span class="istickedoff">v &lt;- liftIO $ projectJVMVal bak ty (&quot;field load &quot; ++ J.fieldIdName fid ++ &quot;, &quot; ++ show (MS.conditionLoc md)) dyn</span>
<span class="lineno">  639 </span><span class="spaces">         </span><span class="istickedoff">matchArg <span class="nottickedoff">opts</span> sc cc <span class="nottickedoff">spec</span> <span class="nottickedoff">prepost</span> md v <span class="nottickedoff">ty</span> val</span>
<span class="lineno">  640 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  641 </span><span class="spaces">    </span><span class="istickedoff">JVMPointsToStatic md fid (Just val) -&gt;</span>
<span class="lineno">  642 </span><span class="spaces">      </span><span class="istickedoff">do ty &lt;- typeOfSetupValue <span class="nottickedoff">cc</span> <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span> val</span>
<span class="lineno">  643 </span><span class="spaces">         </span><span class="istickedoff">dyn &lt;- liftIO $ CJ.doStaticFieldLoad <span class="nottickedoff">bak</span> jc globals fid</span>
<span class="lineno">  644 </span><span class="spaces">         </span><span class="istickedoff">v &lt;- liftIO $ projectJVMVal bak ty (&quot;static field load &quot; ++ J.fieldIdName fid ++ &quot;, &quot; ++ show (MS.conditionLoc md)) dyn</span>
<span class="lineno">  645 </span><span class="spaces">         </span><span class="istickedoff">matchArg <span class="nottickedoff">opts</span> sc cc <span class="nottickedoff">spec</span> <span class="nottickedoff">prepost</span> md v <span class="nottickedoff">ty</span> val</span>
<span class="lineno">  646 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  647 </span><span class="spaces">    </span><span class="istickedoff">JVMPointsToElem md ptr idx (Just val) -&gt;</span>
<span class="lineno">  648 </span><span class="spaces">      </span><span class="istickedoff">do ty &lt;- typeOfSetupValue <span class="nottickedoff">cc</span> <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span> val</span>
<span class="lineno">  649 </span><span class="spaces">         </span><span class="istickedoff">rval &lt;- resolveAllocIndexJVM ptr</span>
<span class="lineno">  650 </span><span class="spaces">         </span><span class="istickedoff">dyn &lt;- liftIO $ CJ.doArrayLoad bak globals rval idx</span>
<span class="lineno">  651 </span><span class="spaces">         </span><span class="istickedoff">v &lt;- liftIO $ projectJVMVal bak ty (&quot;array load &quot; ++ show idx ++ &quot;, &quot; ++ show (MS.conditionLoc md)) dyn</span>
<span class="lineno">  652 </span><span class="spaces">         </span><span class="istickedoff">matchArg <span class="nottickedoff">opts</span> <span class="nottickedoff">sc</span> cc <span class="nottickedoff">spec</span> <span class="nottickedoff">prepost</span> <span class="nottickedoff">md</span> v <span class="nottickedoff">ty</span> val</span>
<span class="lineno">  653 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  654 </span><span class="spaces">    </span><span class="istickedoff">JVMPointsToArray md ptr (Just tt) -&gt;</span>
<span class="lineno">  655 </span><span class="spaces">      </span><span class="istickedoff">do (len, ety) &lt;-</span>
<span class="lineno">  656 </span><span class="spaces">           </span><span class="istickedoff">case ttIsMono (ttType tt) of</span>
<span class="lineno">  657 </span><span class="spaces">             </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail &quot;jvm_array_is: invalid polymorphic value&quot;</span></span>
<span class="lineno">  658 </span><span class="spaces">             </span><span class="istickedoff">Just cty -&gt;</span>
<span class="lineno">  659 </span><span class="spaces">               </span><span class="istickedoff">case Cryptol.tIsSeq cty of</span>
<span class="lineno">  660 </span><span class="spaces">                 </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail &quot;jvm_array_is: expected array type&quot;</span></span>
<span class="lineno">  661 </span><span class="spaces">                 </span><span class="istickedoff">Just (lty, ety) -&gt;</span>
<span class="lineno">  662 </span><span class="spaces">                   </span><span class="istickedoff">case Cryptol.tIsNum lty of</span>
<span class="lineno">  663 </span><span class="spaces">                     </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail &quot;jvm_array_is: expected finite-sized array&quot;</span></span>
<span class="lineno">  664 </span><span class="spaces">                     </span><span class="istickedoff">Just len -&gt; pure (len, ety)</span>
<span class="lineno">  665 </span><span class="spaces">         </span><span class="istickedoff">jty &lt;-</span>
<span class="lineno">  666 </span><span class="spaces">           </span><span class="istickedoff">case toJVMType (Cryptol.evalValType <span class="nottickedoff">mempty</span> ety) of</span>
<span class="lineno">  667 </span><span class="spaces">             </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail &quot;jvm_array_is: invalid element type&quot;</span></span>
<span class="lineno">  668 </span><span class="spaces">             </span><span class="istickedoff">Just jty -&gt; pure jty</span>
<span class="lineno">  669 </span><span class="spaces">         </span><span class="istickedoff">rval &lt;- resolveAllocIndexJVM ptr</span>
<span class="lineno">  670 </span><span class="spaces">         </span><span class="istickedoff">let tval = Cryptol.evalValType <span class="nottickedoff">mempty</span> ety</span>
<span class="lineno">  671 </span><span class="spaces">         </span><span class="istickedoff">let</span>
<span class="lineno">  672 </span><span class="spaces">           </span><span class="istickedoff">load idx =</span>
<span class="lineno">  673 </span><span class="spaces">             </span><span class="istickedoff">do dyn &lt;- liftIO $ CJ.doArrayLoad bak globals rval idx</span>
<span class="lineno">  674 </span><span class="spaces">                </span><span class="istickedoff">let <span class="nottickedoff">msg = &quot;array load &quot; ++ show idx ++ &quot;, &quot; ++ show (MS.conditionLoc md)</span></span>
<span class="lineno">  675 </span><span class="spaces">                </span><span class="istickedoff">jval &lt;- liftIO $ projectJVMVal bak jty <span class="nottickedoff">msg</span> dyn</span>
<span class="lineno">  676 </span><span class="spaces">                </span><span class="istickedoff">let <span class="nottickedoff">failMsg = StructuralMismatch (ppJVMVal jval) mempty (Just jty) jty</span> -- REVISIT</span>
<span class="lineno">  677 </span><span class="spaces">                </span><span class="istickedoff">valueToSC sym <span class="nottickedoff">md</span> <span class="nottickedoff">failMsg</span> tval jval</span>
<span class="lineno">  678 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  679 </span><span class="spaces">         </span><span class="istickedoff">when (len &gt; toInteger (maxBound :: Int)) $ <span class="nottickedoff">fail &quot;jvm_array_is: array length too long&quot;</span></span>
<span class="lineno">  680 </span><span class="spaces">         </span><span class="istickedoff">ety_tm &lt;- liftIO $ Cryptol.importType sc <span class="nottickedoff">Cryptol.emptyEnv</span> ety</span>
<span class="lineno">  681 </span><span class="spaces">         </span><span class="istickedoff">ts &lt;- traverse load [0 .. fromInteger len - 1]</span>
<span class="lineno">  682 </span><span class="spaces">         </span><span class="istickedoff">realTerm &lt;- liftIO $ scVector sc ety_tm ts</span>
<span class="lineno">  683 </span><span class="spaces">         </span><span class="istickedoff">matchTerm sc md <span class="nottickedoff">prepost</span> realTerm (ttTerm tt)</span>
<span class="lineno">  684 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  685 </span><span class="spaces">    </span><span class="istickedoff">-- If the right-hand-side is 'Nothing', this is indicates a &quot;modifies&quot; declaration,</span>
<span class="lineno">  686 </span><span class="spaces">    </span><span class="istickedoff">-- which should probably not appear in the pre-state section, and has no effect.</span>
<span class="lineno">  687 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; pure <span class="nottickedoff">()</span></span></span>
<span class="lineno">  688 </span>
<span class="lineno">  689 </span>------------------------------------------------------------------------
<span class="lineno">  690 </span>
<span class="lineno">  691 </span>-- | Process a &quot;crucible_equal&quot; statement from the precondition
<span class="lineno">  692 </span>-- section of the CrucibleSetup block.
<span class="lineno">  693 </span>learnEqual ::
<span class="lineno">  694 </span>  Options                                          -&gt;
<span class="lineno">  695 </span>  SharedContext                                    -&gt;
<span class="lineno">  696 </span>  JVMCrucibleContext                                  -&gt;
<span class="lineno">  697 </span>  CrucibleMethodSpecIR                             -&gt;
<span class="lineno">  698 </span>  MS.ConditionMetadata                             -&gt;
<span class="lineno">  699 </span>  PrePost                                          -&gt;
<span class="lineno">  700 </span>  SetupValue       {- ^ first value to compare  -} -&gt;
<span class="lineno">  701 </span>  SetupValue       {- ^ second value to compare -} -&gt;
<span class="lineno">  702 </span>  OverrideMatcher CJ.JVM w ()
<span class="lineno">  703 </span><span class="decl"><span class="nottickedoff">learnEqual opts sc cc spec md prepost v1 v2 =</span>
<span class="lineno">  704 </span><span class="spaces">  </span><span class="nottickedoff">do val1 &lt;- resolveSetupValueJVM opts cc sc spec v1</span>
<span class="lineno">  705 </span><span class="spaces">     </span><span class="nottickedoff">val2 &lt;- resolveSetupValueJVM opts cc sc spec v2</span>
<span class="lineno">  706 </span><span class="spaces">     </span><span class="nottickedoff">p &lt;- liftIO (equalValsPred cc val1 val2)</span>
<span class="lineno">  707 </span><span class="spaces">     </span><span class="nottickedoff">let name = &quot;equality &quot; ++ MS.stateCond prepost</span>
<span class="lineno">  708 </span><span class="spaces">     </span><span class="nottickedoff">let loc = MS.conditionLoc md</span>
<span class="lineno">  709 </span><span class="spaces">     </span><span class="nottickedoff">addAssert p md (Crucible.SimError loc (Crucible.AssertFailureSimError name &quot;&quot;))</span></span>
<span class="lineno">  710 </span>
<span class="lineno">  711 </span>-- | Process a &quot;crucible_precond&quot; statement from the precondition
<span class="lineno">  712 </span>-- section of the CrucibleSetup block.
<span class="lineno">  713 </span>learnPred ::
<span class="lineno">  714 </span>  SharedContext                                                       -&gt;
<span class="lineno">  715 </span>  JVMCrucibleContext                                                     -&gt;
<span class="lineno">  716 </span>  MS.ConditionMetadata                                                -&gt;
<span class="lineno">  717 </span>  PrePost                                                             -&gt;
<span class="lineno">  718 </span>  Term             {- ^ the precondition to learn                  -} -&gt;
<span class="lineno">  719 </span>  OverrideMatcher CJ.JVM w ()
<span class="lineno">  720 </span><span class="decl"><span class="nottickedoff">learnPred sc cc md prepost t =</span>
<span class="lineno">  721 </span><span class="spaces">  </span><span class="nottickedoff">do s &lt;- OM (use termSub)</span>
<span class="lineno">  722 </span><span class="spaces">     </span><span class="nottickedoff">u &lt;- liftIO $ scInstantiate sc s t</span>
<span class="lineno">  723 </span><span class="spaces">     </span><span class="nottickedoff">p &lt;- liftIO $ resolveBoolTerm (cc ^. jccSym) (cc ^. jccUninterp) u</span>
<span class="lineno">  724 </span><span class="spaces">     </span><span class="nottickedoff">let loc = MS.conditionLoc md</span>
<span class="lineno">  725 </span><span class="spaces">     </span><span class="nottickedoff">addAssert p md (Crucible.SimError loc (Crucible.AssertFailureSimError (MS.stateCond prepost) &quot;&quot;))</span></span>
<span class="lineno">  726 </span>
<span class="lineno">  727 </span>instantiateExtResolveSAWPred ::
<span class="lineno">  728 </span>  SharedContext -&gt;
<span class="lineno">  729 </span>  JVMCrucibleContext -&gt;
<span class="lineno">  730 </span>  Term -&gt;
<span class="lineno">  731 </span>  OverrideMatcher CJ.JVM md (W4.Pred Sym)
<span class="lineno">  732 </span><span class="decl"><span class="istickedoff">instantiateExtResolveSAWPred sc cc cond = do</span>
<span class="lineno">  733 </span><span class="spaces">  </span><span class="istickedoff">sub &lt;- OM (use termSub)</span>
<span class="lineno">  734 </span><span class="spaces">  </span><span class="istickedoff">liftIO $ resolveSAWPred cc =&lt;&lt; scInstantiate sc sub cond</span></span>
<span class="lineno">  735 </span>
<span class="lineno">  736 </span>------------------------------------------------------------------------
<span class="lineno">  737 </span>
<span class="lineno">  738 </span>-- TODO: replace (W4.ProgramLoc, J.Type) by some allocation datatype
<span class="lineno">  739 </span>-- that includes constructors for object allocations and array
<span class="lineno">  740 </span>-- allocations (with length).
<span class="lineno">  741 </span>
<span class="lineno">  742 </span>-- | Perform an allocation as indicated by a 'crucible_alloc'
<span class="lineno">  743 </span>-- statement from the postcondition section.
<span class="lineno">  744 </span>executeAllocation ::
<span class="lineno">  745 </span>  Options                        -&gt;
<span class="lineno">  746 </span>  JVMCrucibleContext                -&gt;
<span class="lineno">  747 </span>  (AllocIndex, (MS.ConditionMetadata, Allocation)) -&gt;
<span class="lineno">  748 </span>  OverrideMatcher CJ.JVM w ()
<span class="lineno">  749 </span><span class="decl"><span class="istickedoff">executeAllocation opts cc (var, (md, alloc)) =</span>
<span class="lineno">  750 </span><span class="spaces">  </span><span class="istickedoff">jccWithBackend cc $ \bak -&gt;</span>
<span class="lineno">  751 </span><span class="spaces">  </span><span class="istickedoff">do liftIO $ printOutLn opts Debug $ <span class="nottickedoff">unwords [&quot;executeAllocation:&quot;, show var, show alloc]</span></span>
<span class="lineno">  752 </span><span class="spaces">     </span><span class="istickedoff">let jc = cc^.jccJVMContext</span>
<span class="lineno">  753 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">halloc = cc^.jccHandleAllocator</span></span>
<span class="lineno">  754 </span><span class="spaces">     </span><span class="istickedoff">globals &lt;- OM (use overrideGlobals)</span>
<span class="lineno">  755 </span><span class="spaces">     </span><span class="istickedoff">let mut = True -- allocate objects/arrays from post-state as mutable</span>
<span class="lineno">  756 </span><span class="spaces">     </span><span class="istickedoff">(ptr, globals') &lt;-</span>
<span class="lineno">  757 </span><span class="spaces">       </span><span class="istickedoff">case alloc of</span>
<span class="lineno">  758 </span><span class="spaces">         </span><span class="istickedoff">AllocObject cname -&gt;</span>
<span class="lineno">  759 </span><span class="spaces">           </span><span class="istickedoff">liftIO $ CJ.doAllocateObject bak <span class="nottickedoff">halloc</span> jc cname (const mut) globals</span>
<span class="lineno">  760 </span><span class="spaces">         </span><span class="istickedoff">AllocArray len elemTy -&gt;</span>
<span class="lineno">  761 </span><span class="spaces">           </span><span class="istickedoff">liftIO $ CJ.doAllocateArray bak <span class="nottickedoff">halloc</span> <span class="nottickedoff">jc</span> len elemTy <span class="nottickedoff">(const mut)</span> globals</span>
<span class="lineno">  762 </span><span class="spaces">     </span><span class="istickedoff">OM (overrideGlobals .= globals')</span>
<span class="lineno">  763 </span><span class="spaces">     </span><span class="istickedoff">assignVar <span class="nottickedoff">cc</span> <span class="nottickedoff">md</span> var ptr</span></span>
<span class="lineno">  764 </span>
<span class="lineno">  765 </span>------------------------------------------------------------------------
<span class="lineno">  766 </span>
<span class="lineno">  767 </span>-- | Update the simulator state based on the postconditions from the
<span class="lineno">  768 </span>-- procedure specification.
<span class="lineno">  769 </span>executeSetupCondition ::
<span class="lineno">  770 </span>  Options                    -&gt;
<span class="lineno">  771 </span>  SharedContext              -&gt;
<span class="lineno">  772 </span>  JVMCrucibleContext            -&gt;
<span class="lineno">  773 </span>  CrucibleMethodSpecIR       -&gt;
<span class="lineno">  774 </span>  SetupCondition             -&gt;
<span class="lineno">  775 </span>  OverrideMatcher CJ.JVM RW ()
<span class="lineno">  776 </span><span class="decl"><span class="nottickedoff">executeSetupCondition opts sc cc spec =</span>
<span class="lineno">  777 </span><span class="spaces">  </span><span class="nottickedoff">\case</span>
<span class="lineno">  778 </span><span class="spaces">    </span><span class="nottickedoff">MS.SetupCond_Equal md val1 val2 -&gt;</span>
<span class="lineno">  779 </span><span class="spaces">      </span><span class="nottickedoff">executeEqual opts sc cc spec md val1 val2</span>
<span class="lineno">  780 </span><span class="spaces">    </span><span class="nottickedoff">MS.SetupCond_Pred md tm -&gt; executePred sc cc md tm</span>
<span class="lineno">  781 </span><span class="spaces">    </span><span class="nottickedoff">MS.SetupCond_Ghost md var val -&gt; executeGhost sc md var val</span></span>
<span class="lineno">  782 </span>
<span class="lineno">  783 </span>------------------------------------------------------------------------
<span class="lineno">  784 </span>
<span class="lineno">  785 </span>-- | Process a &quot;points_to&quot; statement from the postcondition section of
<span class="lineno">  786 </span>-- the CrucibleSetup block. First we compute the value indicated by
<span class="lineno">  787 </span>-- 'val', and then write it to the address indicated by 'ptr'.
<span class="lineno">  788 </span>executePointsTo ::
<span class="lineno">  789 </span>  Options                    -&gt;
<span class="lineno">  790 </span>  SharedContext              -&gt;
<span class="lineno">  791 </span>  JVMCrucibleContext            -&gt;
<span class="lineno">  792 </span>  CrucibleMethodSpecIR       -&gt;
<span class="lineno">  793 </span>  JVMPointsTo                   -&gt;
<span class="lineno">  794 </span>  OverrideMatcher CJ.JVM w ()
<span class="lineno">  795 </span><span class="decl"><span class="istickedoff">executePointsTo opts sc cc spec pt =</span>
<span class="lineno">  796 </span><span class="spaces">  </span><span class="istickedoff">jccWithBackend cc $ \bak -&gt; do</span>
<span class="lineno">  797 </span><span class="spaces">  </span><span class="istickedoff">let sym = backendGetSym bak</span>
<span class="lineno">  798 </span><span class="spaces">  </span><span class="istickedoff">globals &lt;- OM (use overrideGlobals)</span>
<span class="lineno">  799 </span><span class="spaces">  </span><span class="istickedoff">let jc = cc ^. jccJVMContext</span>
<span class="lineno">  800 </span><span class="spaces">  </span><span class="istickedoff">case pt of</span>
<span class="lineno">  801 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  802 </span><span class="spaces">    </span><span class="istickedoff">JVMPointsToField _loc ptr fid val -&gt;</span>
<span class="lineno">  803 </span><span class="spaces">      </span><span class="istickedoff">do dyn &lt;- maybe (pure CJ.unassignedJVMValue) (injectSetupValueJVM sym <span class="nottickedoff">opts</span> cc <span class="nottickedoff">sc</span> <span class="nottickedoff">spec</span>) val</span>
<span class="lineno">  804 </span><span class="spaces">         </span><span class="istickedoff">rval &lt;- resolveAllocIndexJVM ptr</span>
<span class="lineno">  805 </span><span class="spaces">         </span><span class="istickedoff">globals' &lt;- liftIO $ CJ.doFieldStore bak globals rval fid dyn</span>
<span class="lineno">  806 </span><span class="spaces">         </span><span class="istickedoff">OM (overrideGlobals .= globals')</span>
<span class="lineno">  807 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  808 </span><span class="spaces">    </span><span class="istickedoff">JVMPointsToStatic _loc fid val -&gt;</span>
<span class="lineno">  809 </span><span class="spaces">      </span><span class="istickedoff">do dyn &lt;- maybe (pure CJ.unassignedJVMValue) (injectSetupValueJVM sym <span class="nottickedoff">opts</span> cc <span class="nottickedoff">sc</span> <span class="nottickedoff">spec</span>) val</span>
<span class="lineno">  810 </span><span class="spaces">         </span><span class="istickedoff">globals' &lt;- liftIO $ CJ.doStaticFieldStore <span class="nottickedoff">bak</span> jc globals fid dyn</span>
<span class="lineno">  811 </span><span class="spaces">         </span><span class="istickedoff">OM (overrideGlobals .= globals')</span>
<span class="lineno">  812 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  813 </span><span class="spaces">    </span><span class="istickedoff">JVMPointsToElem _loc ptr idx val -&gt;</span>
<span class="lineno">  814 </span><span class="spaces">      </span><span class="istickedoff">do dyn &lt;- maybe (pure CJ.unassignedJVMValue) (injectSetupValueJVM sym <span class="nottickedoff">opts</span> cc <span class="nottickedoff">sc</span> <span class="nottickedoff">spec</span>) val</span>
<span class="lineno">  815 </span><span class="spaces">         </span><span class="istickedoff">rval &lt;- resolveAllocIndexJVM ptr</span>
<span class="lineno">  816 </span><span class="spaces">         </span><span class="istickedoff">globals' &lt;- liftIO $ CJ.doArrayStore bak globals rval idx dyn</span>
<span class="lineno">  817 </span><span class="spaces">         </span><span class="istickedoff">OM (overrideGlobals .= globals')</span>
<span class="lineno">  818 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  819 </span><span class="spaces">    </span><span class="istickedoff">JVMPointsToArray _loc ptr (Just tt) -&gt;</span>
<span class="lineno">  820 </span><span class="spaces">      </span><span class="istickedoff">do (_ety, tts) &lt;-</span>
<span class="lineno">  821 </span><span class="spaces">           </span><span class="istickedoff">liftIO (destVecTypedTerm sc tt) &gt;&gt;=</span>
<span class="lineno">  822 </span><span class="spaces">           </span><span class="istickedoff">\case</span>
<span class="lineno">  823 </span><span class="spaces">             </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail &quot;jvm_array_is: not a monomorphic sequence type&quot;</span></span>
<span class="lineno">  824 </span><span class="spaces">             </span><span class="istickedoff">Just x -&gt; pure x</span>
<span class="lineno">  825 </span><span class="spaces">         </span><span class="istickedoff">rval &lt;- resolveAllocIndexJVM ptr</span>
<span class="lineno">  826 </span><span class="spaces">         </span><span class="istickedoff">vs &lt;- traverse (injectSetupValueJVM sym <span class="nottickedoff">opts</span> cc sc <span class="nottickedoff">spec</span> . MS.SetupTerm) tts</span>
<span class="lineno">  827 </span><span class="spaces">         </span><span class="istickedoff">globals' &lt;- liftIO $ doEntireArrayStore bak globals rval vs</span>
<span class="lineno">  828 </span><span class="spaces">         </span><span class="istickedoff">OM (overrideGlobals .= globals')</span>
<span class="lineno">  829 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  830 </span><span class="spaces">    </span><span class="istickedoff">JVMPointsToArray _loc ptr Nothing -&gt;</span>
<span class="lineno">  831 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">case Map.lookup ptr (MS.csAllocations spec) of</span></span>
<span class="lineno">  832 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">Just (_, AllocArray len _) -&gt;</span></span>
<span class="lineno">  833 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">do let vs = replicate len CJ.unassignedJVMValue</span></span>
<span class="lineno">  834 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">rval &lt;- resolveAllocIndexJVM ptr</span></span>
<span class="lineno">  835 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">globals' &lt;- liftIO $ doEntireArrayStore bak globals rval vs</span></span>
<span class="lineno">  836 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">OM (overrideGlobals .= globals')</span></span>
<span class="lineno">  837 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; panic &quot;JVMSetup&quot; [&quot;executePointsTo&quot;, &quot;expected array allocation&quot;]</span></span></span>
<span class="lineno">  838 </span>
<span class="lineno">  839 </span>injectSetupValueJVM ::
<span class="lineno">  840 </span>  Sym                  -&gt;
<span class="lineno">  841 </span>  Options              -&gt;
<span class="lineno">  842 </span>  JVMCrucibleContext   -&gt;
<span class="lineno">  843 </span>  SharedContext        -&gt;
<span class="lineno">  844 </span>  CrucibleMethodSpecIR -&gt;
<span class="lineno">  845 </span>  SetupValue           -&gt;
<span class="lineno">  846 </span>  OverrideMatcher CJ.JVM w (Crucible.RegValue Sym CJ.JVMValueType)
<span class="lineno">  847 </span><span class="decl"><span class="istickedoff">injectSetupValueJVM sym opts cc sc spec val =</span>
<span class="lineno">  848 </span><span class="spaces">  </span><span class="istickedoff">injectJVMVal sym &lt;$&gt; resolveSetupValueJVM <span class="nottickedoff">opts</span> cc sc <span class="nottickedoff">spec</span> val</span></span>
<span class="lineno">  849 </span>
<span class="lineno">  850 </span>doEntireArrayStore ::
<span class="lineno">  851 </span>  (Crucible.IsSymBackend sym bak) =&gt;
<span class="lineno">  852 </span>  bak -&gt;
<span class="lineno">  853 </span>  Crucible.SymGlobalState sym -&gt;
<span class="lineno">  854 </span>  Crucible.RegValue sym CJ.JVMRefType -&gt;
<span class="lineno">  855 </span>  [Crucible.RegValue sym CJ.JVMValueType] -&gt;
<span class="lineno">  856 </span>  IO (Crucible.SymGlobalState sym)
<span class="lineno">  857 </span><span class="decl"><span class="istickedoff">doEntireArrayStore bak glob ref vs = foldM store glob (zip [0..] vs)</span>
<span class="lineno">  858 </span><span class="spaces">  </span><span class="istickedoff">where store g (i, v) = CJ.doArrayStore bak g ref i v</span></span>
<span class="lineno">  859 </span>
<span class="lineno">  860 </span>-- | Given a 'TypedTerm' with a vector type, return the element type
<span class="lineno">  861 </span>-- along with a list of its projected components. Return 'Nothing' if
<span class="lineno">  862 </span>-- the 'TypedTerm' does not have a vector type.
<span class="lineno">  863 </span>destVecTypedTerm :: SharedContext -&gt; TypedTerm -&gt; IO (Maybe (Cryptol.Type, [TypedTerm]))
<span class="lineno">  864 </span><span class="decl"><span class="istickedoff">destVecTypedTerm sc (TypedTerm ttp t) =</span>
<span class="lineno">  865 </span><span class="spaces">  </span><span class="istickedoff">case asVec of</span>
<span class="lineno">  866 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">pure Nothing</span></span>
<span class="lineno">  867 </span><span class="spaces">    </span><span class="istickedoff">Just (len, ety) -&gt;</span>
<span class="lineno">  868 </span><span class="spaces">      </span><span class="istickedoff">do len_tm &lt;- scNat sc (fromInteger len)</span>
<span class="lineno">  869 </span><span class="spaces">         </span><span class="istickedoff">ty_tm &lt;- Cryptol.importType sc <span class="nottickedoff">Cryptol.emptyEnv</span> ety</span>
<span class="lineno">  870 </span><span class="spaces">         </span><span class="istickedoff">idxs &lt;- traverse (scNat sc) (map fromInteger [0 .. len-1])</span>
<span class="lineno">  871 </span><span class="spaces">         </span><span class="istickedoff">ts &lt;- traverse (scAt sc len_tm ty_tm t) idxs</span>
<span class="lineno">  872 </span><span class="spaces">         </span><span class="istickedoff">pure $ Just (<span class="nottickedoff">ety</span>, map (TypedTerm (TypedTermSchema (Cryptol.tMono ety))) ts)</span>
<span class="lineno">  873 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  874 </span><span class="spaces">    </span><span class="istickedoff">asVec =</span>
<span class="lineno">  875 </span><span class="spaces">      </span><span class="istickedoff">do ty &lt;- ttIsMono ttp</span>
<span class="lineno">  876 </span><span class="spaces">         </span><span class="istickedoff">(n, a) &lt;- Cryptol.tIsSeq ty</span>
<span class="lineno">  877 </span><span class="spaces">         </span><span class="istickedoff">n' &lt;- Cryptol.tIsNum n</span>
<span class="lineno">  878 </span><span class="spaces">         </span><span class="istickedoff">Just (n', a)</span></span>
<span class="lineno">  879 </span>
<span class="lineno">  880 </span>------------------------------------------------------------------------
<span class="lineno">  881 </span>
<span class="lineno">  882 </span>
<span class="lineno">  883 </span>-- | Process a &quot;crucible_equal&quot; statement from the postcondition
<span class="lineno">  884 </span>-- section of the CrucibleSetup block.
<span class="lineno">  885 </span>executeEqual ::
<span class="lineno">  886 </span>  Options                                          -&gt;
<span class="lineno">  887 </span>  SharedContext                                    -&gt;
<span class="lineno">  888 </span>  JVMCrucibleContext                                  -&gt;
<span class="lineno">  889 </span>  CrucibleMethodSpecIR                             -&gt;
<span class="lineno">  890 </span>  MS.ConditionMetadata -&gt;
<span class="lineno">  891 </span>  SetupValue       {- ^ first value to compare  -} -&gt;
<span class="lineno">  892 </span>  SetupValue       {- ^ second value to compare -} -&gt;
<span class="lineno">  893 </span>  OverrideMatcher CJ.JVM w ()
<span class="lineno">  894 </span><span class="decl"><span class="nottickedoff">executeEqual opts sc cc spec md v1 v2 =</span>
<span class="lineno">  895 </span><span class="spaces">  </span><span class="nottickedoff">do val1 &lt;- resolveSetupValueJVM opts cc sc spec v1</span>
<span class="lineno">  896 </span><span class="spaces">     </span><span class="nottickedoff">val2 &lt;- resolveSetupValueJVM opts cc sc spec v2</span>
<span class="lineno">  897 </span><span class="spaces">     </span><span class="nottickedoff">p &lt;- liftIO (equalValsPred cc val1 val2)</span>
<span class="lineno">  898 </span><span class="spaces">     </span><span class="nottickedoff">addAssume p md</span></span>
<span class="lineno">  899 </span>
<span class="lineno">  900 </span>-- | Process a &quot;crucible_postcond&quot; statement from the postcondition
<span class="lineno">  901 </span>-- section of the CrucibleSetup block.
<span class="lineno">  902 </span>executePred ::
<span class="lineno">  903 </span>  SharedContext   -&gt;
<span class="lineno">  904 </span>  JVMCrucibleContext -&gt;
<span class="lineno">  905 </span>  MS.ConditionMetadata -&gt;
<span class="lineno">  906 </span>  TypedTerm        {- ^ the term to assert as a postcondition -} -&gt;
<span class="lineno">  907 </span>  OverrideMatcher CJ.JVM w ()
<span class="lineno">  908 </span><span class="decl"><span class="nottickedoff">executePred sc cc md tt =</span>
<span class="lineno">  909 </span><span class="spaces">  </span><span class="nottickedoff">do s &lt;- OM (use termSub)</span>
<span class="lineno">  910 </span><span class="spaces">     </span><span class="nottickedoff">t &lt;- liftIO $ scInstantiate sc s (ttTerm tt)</span>
<span class="lineno">  911 </span><span class="spaces">     </span><span class="nottickedoff">p &lt;- liftIO $ resolveBoolTerm (cc ^. jccSym) (cc ^. jccUninterp) t</span>
<span class="lineno">  912 </span><span class="spaces">     </span><span class="nottickedoff">addAssume p md</span></span>
<span class="lineno">  913 </span>
<span class="lineno">  914 </span>------------------------------------------------------------------------
<span class="lineno">  915 </span>
<span class="lineno">  916 </span>-- | Map the given substitution over all 'SetupTerm' constructors in
<span class="lineno">  917 </span>-- the given 'SetupValue'.
<span class="lineno">  918 </span>instantiateSetupValue ::
<span class="lineno">  919 </span>  SharedContext -&gt;
<span class="lineno">  920 </span>  IntMap Term -&gt;
<span class="lineno">  921 </span>  SetupValue -&gt;
<span class="lineno">  922 </span>  IO SetupValue
<span class="lineno">  923 </span><span class="decl"><span class="istickedoff">instantiateSetupValue sc s v =</span>
<span class="lineno">  924 </span><span class="spaces">  </span><span class="istickedoff">case v of</span>
<span class="lineno">  925 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupVar _                     -&gt; return v</span>
<span class="lineno">  926 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupTerm tt                   -&gt; MS.SetupTerm &lt;$&gt; doTerm tt</span>
<span class="lineno">  927 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupNull ()                   -&gt; <span class="nottickedoff">return v</span></span>
<span class="lineno">  928 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupGlobal empty _            -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno">  929 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupStruct empty _            -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno">  930 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupEnum empty                -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno">  931 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupTuple empty _             -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno">  932 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupSlice empty               -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno">  933 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupArray empty _             -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno">  934 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupElem empty _ _            -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno">  935 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupField empty _ _           -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno">  936 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupCast empty _              -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno">  937 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupUnion empty _ _           -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno">  938 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupGlobalInitializer empty _ -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno">  939 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupMux empty _ _ _           -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno">  940 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  941 </span><span class="spaces">    </span><span class="istickedoff">doTerm (TypedTerm schema t) = TypedTerm schema &lt;$&gt; scInstantiate sc s t</span></span>
<span class="lineno">  942 </span>
<span class="lineno">  943 </span>------------------------------------------------------------------------
<span class="lineno">  944 </span>
<span class="lineno">  945 </span>resolveAllocIndexJVM :: AllocIndex -&gt; OverrideMatcher CJ.JVM w JVMRefVal
<span class="lineno">  946 </span><span class="decl"><span class="istickedoff">resolveAllocIndexJVM i =</span>
<span class="lineno">  947 </span><span class="spaces">  </span><span class="istickedoff">do m &lt;- OM (use setupValueSub)</span>
<span class="lineno">  948 </span><span class="spaces">     </span><span class="istickedoff">case Map.lookup i m of</span>
<span class="lineno">  949 </span><span class="spaces">       </span><span class="istickedoff">Just rval -&gt; pure rval</span>
<span class="lineno">  950 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  951 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">panic &quot;JVMSetup (in resolveAllocIndexJVM)&quot; [</span></span>
<span class="lineno">  952 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">&quot;Unresolved prestate variable: &quot; &lt;&gt; Text.pack (show i)</span></span>
<span class="lineno">  953 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno">  954 </span>
<span class="lineno">  955 </span>resolveSetupValueJVM ::
<span class="lineno">  956 </span>  Options              -&gt;
<span class="lineno">  957 </span>  JVMCrucibleContext   -&gt;
<span class="lineno">  958 </span>  SharedContext        -&gt;
<span class="lineno">  959 </span>  CrucibleMethodSpecIR -&gt;
<span class="lineno">  960 </span>  SetupValue           -&gt;
<span class="lineno">  961 </span>  OverrideMatcher CJ.JVM w JVMVal
<span class="lineno">  962 </span><span class="decl"><span class="istickedoff">resolveSetupValueJVM opts cc sc spec sval =</span>
<span class="lineno">  963 </span><span class="spaces">  </span><span class="istickedoff">do m &lt;- OM (use setupValueSub)</span>
<span class="lineno">  964 </span><span class="spaces">     </span><span class="istickedoff">s &lt;- OM (use termSub)</span>
<span class="lineno">  965 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">tyenv = MS.csAllocations spec</span></span>
<span class="lineno">  966 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">nameEnv = MS.csTypeNames spec</span></span>
<span class="lineno">  967 </span><span class="spaces">     </span><span class="istickedoff">sval' &lt;- liftIO $ instantiateSetupValue sc s sval</span>
<span class="lineno">  968 </span><span class="spaces">     </span><span class="istickedoff">liftIO $ resolveSetupVal cc m <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span> sval' `X.catch` <span class="nottickedoff">handleException opts</span></span></span>
<span class="lineno">  969 </span>
<span class="lineno">  970 </span>typeOfSetupValueJVM ::
<span class="lineno">  971 </span>  JVMCrucibleContext   -&gt;
<span class="lineno">  972 </span>  CrucibleMethodSpecIR -&gt;
<span class="lineno">  973 </span>  SetupValue           -&gt;
<span class="lineno">  974 </span>  OverrideMatcher CJ.JVM w J.Type
<span class="lineno">  975 </span><span class="decl"><span class="istickedoff">typeOfSetupValueJVM cc spec sval =</span>
<span class="lineno">  976 </span><span class="spaces">  </span><span class="istickedoff">do let <span class="nottickedoff">tyenv = MS.csAllocations spec</span></span>
<span class="lineno">  977 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">nameEnv = MS.csTypeNames spec</span></span>
<span class="lineno">  978 </span><span class="spaces">     </span><span class="istickedoff">liftIO $ typeOfSetupValue <span class="nottickedoff">cc</span> <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span> sval</span></span>
<span class="lineno">  979 </span>
<span class="lineno">  980 </span>injectJVMVal :: Sym -&gt; JVMVal -&gt; Crucible.RegValue Sym CJ.JVMValueType
<span class="lineno">  981 </span><span class="decl"><span class="istickedoff">injectJVMVal sym jv =</span>
<span class="lineno">  982 </span><span class="spaces">  </span><span class="istickedoff">case jv of</span>
<span class="lineno">  983 </span><span class="spaces">    </span><span class="istickedoff">RVal x -&gt; Crucible.injectVariant sym W4.knownRepr CJ.tagR x</span>
<span class="lineno">  984 </span><span class="spaces">    </span><span class="istickedoff">IVal x -&gt; Crucible.injectVariant sym W4.knownRepr CJ.tagI x</span>
<span class="lineno">  985 </span><span class="spaces">    </span><span class="istickedoff">LVal x -&gt; Crucible.injectVariant sym W4.knownRepr CJ.tagL x</span></span>
<span class="lineno">  986 </span>
<span class="lineno">  987 </span>projectJVMVal :: OnlineSolver solver =&gt;
<span class="lineno">  988 </span>  Backend solver -&gt; J.Type -&gt; String -&gt; Crucible.RegValue Sym CJ.JVMValueType -&gt; IO JVMVal
<span class="lineno">  989 </span><span class="decl"><span class="istickedoff">projectJVMVal bak ty msg' v =</span>
<span class="lineno">  990 </span><span class="spaces">  </span><span class="istickedoff">case ty of</span>
<span class="lineno">  991 </span><span class="spaces">    </span><span class="istickedoff">J.BooleanType -&gt; IVal &lt;$&gt; proj v CJ.tagI</span>
<span class="lineno">  992 </span><span class="spaces">    </span><span class="istickedoff">J.ByteType    -&gt; IVal &lt;$&gt; proj v CJ.tagI</span>
<span class="lineno">  993 </span><span class="spaces">    </span><span class="istickedoff">J.CharType    -&gt; <span class="nottickedoff">IVal &lt;$&gt; proj v CJ.tagI</span></span>
<span class="lineno">  994 </span><span class="spaces">    </span><span class="istickedoff">J.ShortType   -&gt; IVal &lt;$&gt; proj v CJ.tagI</span>
<span class="lineno">  995 </span><span class="spaces">    </span><span class="istickedoff">J.IntType     -&gt; IVal &lt;$&gt; proj v CJ.tagI</span>
<span class="lineno">  996 </span><span class="spaces">    </span><span class="istickedoff">J.LongType    -&gt; LVal &lt;$&gt; proj v CJ.tagL</span>
<span class="lineno">  997 </span><span class="spaces">    </span><span class="istickedoff">J.FloatType   -&gt; <span class="nottickedoff">err</span> -- FIXME</span>
<span class="lineno">  998 </span><span class="spaces">    </span><span class="istickedoff">J.DoubleType  -&gt; <span class="nottickedoff">err</span> -- FIXME</span>
<span class="lineno">  999 </span><span class="spaces">    </span><span class="istickedoff">J.ArrayType{} -&gt; RVal &lt;$&gt; proj v CJ.tagR</span>
<span class="lineno"> 1000 </span><span class="spaces">    </span><span class="istickedoff">J.ClassType{} -&gt; <span class="nottickedoff">RVal &lt;$&gt; proj v CJ.tagR</span></span>
<span class="lineno"> 1001 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1002 </span><span class="spaces">    </span><span class="istickedoff">proj ::</span>
<span class="lineno"> 1003 </span><span class="spaces">      </span><span class="istickedoff">forall tp.</span>
<span class="lineno"> 1004 </span><span class="spaces">      </span><span class="istickedoff">Crucible.RegValue Sym CJ.JVMValueType -&gt;</span>
<span class="lineno"> 1005 </span><span class="spaces">      </span><span class="istickedoff">Ctx.Index CJ.JVMValueCtx tp -&gt;</span>
<span class="lineno"> 1006 </span><span class="spaces">      </span><span class="istickedoff">IO (Crucible.RegValue Sym tp)</span>
<span class="lineno"> 1007 </span><span class="spaces">    </span><span class="istickedoff">proj val idx = Crucible.readPartExpr bak (Crucible.unVB (val Ctx.! idx)) msg</span>
<span class="lineno"> 1008 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1009 </span><span class="spaces">    </span><span class="istickedoff">msg = Crucible.GenericSimError $ &quot;Ill-formed value for type &quot; ++ show ty ++ &quot; (&quot; ++ msg' ++ &quot;)&quot;</span>
<span class="lineno"> 1010 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">err = Crucible.addFailedAssertion bak msg</span></span></span>
<span class="lineno"> 1011 </span>
<span class="lineno"> 1012 </span>decodeJVMVal :: J.Type -&gt; Crucible.AnyValue Sym -&gt; Maybe JVMVal
<span class="lineno"> 1013 </span><span class="decl"><span class="istickedoff">decodeJVMVal ty v =</span>
<span class="lineno"> 1014 </span><span class="spaces">  </span><span class="istickedoff">case ty of</span>
<span class="lineno"> 1015 </span><span class="spaces">    </span><span class="istickedoff">J.BooleanType -&gt; go v CJ.intRepr IVal</span>
<span class="lineno"> 1016 </span><span class="spaces">    </span><span class="istickedoff">J.ByteType    -&gt; go v CJ.intRepr IVal</span>
<span class="lineno"> 1017 </span><span class="spaces">    </span><span class="istickedoff">J.CharType    -&gt; go v CJ.intRepr IVal</span>
<span class="lineno"> 1018 </span><span class="spaces">    </span><span class="istickedoff">J.ShortType   -&gt; go v CJ.intRepr IVal</span>
<span class="lineno"> 1019 </span><span class="spaces">    </span><span class="istickedoff">J.IntType     -&gt; go @CJ.JVMIntType v CJ.intRepr IVal</span>
<span class="lineno"> 1020 </span><span class="spaces">    </span><span class="istickedoff">J.LongType    -&gt; go @CJ.JVMLongType v CJ.longRepr LVal</span>
<span class="lineno"> 1021 </span><span class="spaces">    </span><span class="istickedoff">J.FloatType   -&gt; <span class="nottickedoff">Nothing</span> -- FIXME</span>
<span class="lineno"> 1022 </span><span class="spaces">    </span><span class="istickedoff">J.DoubleType  -&gt; <span class="nottickedoff">Nothing</span> -- FIXME</span>
<span class="lineno"> 1023 </span><span class="spaces">    </span><span class="istickedoff">J.ArrayType{} -&gt; go @CJ.JVMRefType v CJ.refRepr RVal</span>
<span class="lineno"> 1024 </span><span class="spaces">    </span><span class="istickedoff">J.ClassType{} -&gt; go @CJ.JVMRefType v CJ.refRepr RVal</span>
<span class="lineno"> 1025 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1026 </span><span class="spaces">    </span><span class="istickedoff">go ::</span>
<span class="lineno"> 1027 </span><span class="spaces">      </span><span class="istickedoff">forall t.</span>
<span class="lineno"> 1028 </span><span class="spaces">      </span><span class="istickedoff">Crucible.AnyValue Sym -&gt;</span>
<span class="lineno"> 1029 </span><span class="spaces">      </span><span class="istickedoff">Crucible.TypeRepr t -&gt;</span>
<span class="lineno"> 1030 </span><span class="spaces">      </span><span class="istickedoff">(Crucible.RegValue Sym t -&gt; JVMVal) -&gt;</span>
<span class="lineno"> 1031 </span><span class="spaces">      </span><span class="istickedoff">Maybe JVMVal</span>
<span class="lineno"> 1032 </span><span class="spaces">    </span><span class="istickedoff">go (Crucible.AnyValue repr rv) repr' k =</span>
<span class="lineno"> 1033 </span><span class="spaces">      </span><span class="istickedoff">case testEquality repr repr' of</span>
<span class="lineno"> 1034 </span><span class="spaces">        </span><span class="istickedoff">Just Refl -&gt; Just (k rv)</span>
<span class="lineno"> 1035 </span><span class="spaces">        </span><span class="istickedoff">Nothing   -&gt; <span class="nottickedoff">Nothing</span></span></span>

</pre>
</body>
</html>
