<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">    2 </span>{-# LANGUAGE NamedFieldPuns #-}
<span class="lineno">    3 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">    4 </span>
<span class="lineno">    5 </span>{- |
<span class="lineno">    6 </span>Module      : SAWCore.TermNet
<span class="lineno">    7 </span>Copyright   : Galois, Inc. 2012-2015
<span class="lineno">    8 </span>License     : BSD3
<span class="lineno">    9 </span>Maintainer  : saw@galois.com
<span class="lineno">   10 </span>Stability   : experimental
<span class="lineno">   11 </span>Portability : non-portable (language extensions)
<span class="lineno">   12 </span>-}
<span class="lineno">   13 </span>
<span class="lineno">   14 </span>module SAWCore.TermNet
<span class="lineno">   15 </span>  ( Pat(..)
<span class="lineno">   16 </span>  , Key
<span class="lineno">   17 </span>  , key_of_term  -- :: Pat -&gt; [Key]
<span class="lineno">   18 </span>  , Net          -- :: * -&gt; *
<span class="lineno">   19 </span>  , empty        -- :: Net a
<span class="lineno">   20 </span>  , insert       -- :: Eq a =&gt; ([Key], a) -&gt; Net a -&gt; Net a
<span class="lineno">   21 </span>  , insert_term  -- :: Eq a =&gt; (Pat, a) -&gt; Net a -&gt; Net a
<span class="lineno">   22 </span>  , delete       -- :: Eq a =&gt; ([Key], a) -&gt; Net a -&gt; Net a
<span class="lineno">   23 </span>  , delete_term  -- :: Eq a =&gt; (Pat, a) -&gt; Net a -&gt; Net a
<span class="lineno">   24 </span>  , lookup       -- :: Net a -&gt; [Key] -&gt; [a]
<span class="lineno">   25 </span>  , match_term   -- :: Net a -&gt; Pat -&gt; [a]
<span class="lineno">   26 </span>  , unify_term   -- :: Net a -&gt; Pat -&gt; [a]
<span class="lineno">   27 </span>  , merge        -- :: Eq a =&gt; Net a -&gt; Net a -&gt; Net a
<span class="lineno">   28 </span>  , content      -- :: Net a -&gt; [a]
<span class="lineno">   29 </span>  ) where
<span class="lineno">   30 </span>
<span class="lineno">   31 </span>import Data.Map (Map)
<span class="lineno">   32 </span>import qualified Data.Map as Map
<span class="lineno">   33 </span>import Data.Maybe (fromMaybe)
<span class="lineno">   34 </span>import qualified Data.List as List
<span class="lineno">   35 </span>import Data.Text (Text)
<span class="lineno">   36 </span>import Prelude hiding (lookup)
<span class="lineno">   37 </span>
<span class="lineno">   38 </span>{-
<span class="lineno">   39 </span>Based on Pure/net.ML from Isabelle 2012.
<span class="lineno">   40 </span>Ported from Standard ML to Haskell by Brian Huffman.
<span class="lineno">   41 </span>
<span class="lineno">   42 </span>    Title:      Pure/net.ML
<span class="lineno">   43 </span>    Author:     Lawrence C Paulson, Cambridge University Computer Laboratory
<span class="lineno">   44 </span>
<span class="lineno">   45 </span>Discrimination nets: a data structure for indexing items
<span class="lineno">   46 </span>
<span class="lineno">   47 </span>From the book
<span class="lineno">   48 </span>    E. Charniak, C. K. Riesbeck, D. V. McDermott.
<span class="lineno">   49 </span>    Artificial Intelligence Programming.
<span class="lineno">   50 </span>    (Lawrence Erlbaum Associates, 1980).  [Chapter 14]
<span class="lineno">   51 </span>
<span class="lineno">   52 </span>match_term no longer treats abstractions as wildcards; instead they match
<span class="lineno">   53 </span>only wildcards in patterns.  Requires operands to be beta-eta-normal.
<span class="lineno">   54 </span>-}
<span class="lineno">   55 </span>
<span class="lineno">   56 </span>-- Laziness is important here, as we will often create and partially
<span class="lineno">   57 </span>-- traverse patterns for very large terms.
<span class="lineno">   58 </span>data Pat = Atom Text | Var | App Pat Pat
<span class="lineno">   59 </span>    deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>
<span class="lineno">   60 </span>
<span class="lineno">   61 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show Pat</span></span></span></span> where
<span class="lineno">   62 </span>  <span class="decl"><span class="nottickedoff">showsPrec _ (Atom s) = shows s</span>
<span class="lineno">   63 </span><span class="spaces">  </span><span class="nottickedoff">showsPrec _ Var = showString &quot;_&quot;</span>
<span class="lineno">   64 </span><span class="spaces">  </span><span class="nottickedoff">showsPrec p (App x y) =</span>
<span class="lineno">   65 </span><span class="spaces">      </span><span class="nottickedoff">showParen (p &gt; 5) (showsPrec 5 x . showString &quot; &quot; . showsPrec 6 y)</span></span>
<span class="lineno">   66 </span>
<span class="lineno">   67 </span>isVarApp :: Pat -&gt; Bool
<span class="lineno">   68 </span><span class="decl"><span class="istickedoff">isVarApp t = case t of</span>
<span class="lineno">   69 </span><span class="spaces">  </span><span class="istickedoff">Atom _   -&gt; False</span>
<span class="lineno">   70 </span><span class="spaces">  </span><span class="istickedoff">Var      -&gt; True</span>
<span class="lineno">   71 </span><span class="spaces">  </span><span class="istickedoff">App t' _ -&gt; isVarApp t'</span></span>
<span class="lineno">   72 </span>
<span class="lineno">   73 </span>-- Start
<span class="lineno">   74 </span>
<span class="lineno">   75 </span>data Key = CombK | VarK | AtomK Text
<span class="lineno">   76 </span>
<span class="lineno">   77 </span>{-Keys are preorder lists of symbols -- Combinations, Vars, Atoms.
<span class="lineno">   78 </span>  Any term whose head is a Var is regarded entirely as a Var.
<span class="lineno">   79 </span>  Abstractions are also regarded as Vars;  this covers eta-conversion
<span class="lineno">   80 </span>    and &quot;near&quot; eta-conversions such as %x.?P(?f(x)).
<span class="lineno">   81 </span>-}
<span class="lineno">   82 </span>
<span class="lineno">   83 </span>add_key_of_terms :: Pat -&gt; [Key] -&gt; [Key]
<span class="lineno">   84 </span><span class="decl"><span class="istickedoff">add_key_of_terms t cs</span>
<span class="lineno">   85 </span><span class="spaces">  </span><span class="istickedoff">| isVarApp t = VarK : cs</span>
<span class="lineno">   86 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span>  = add_key_of_terms' t cs</span></span>
<span class="lineno">   87 </span>
<span class="lineno">   88 </span>-- | Precondition: not (isVarApp t).
<span class="lineno">   89 </span>add_key_of_terms' :: Pat -&gt; [Key] -&gt; [Key]
<span class="lineno">   90 </span><span class="decl"><span class="istickedoff">add_key_of_terms' (App f t) cs = CombK : add_key_of_terms' f (add_key_of_terms t cs)</span>
<span class="lineno">   91 </span><span class="spaces"></span><span class="istickedoff">add_key_of_terms' (Atom c)  cs = AtomK c : cs</span>
<span class="lineno">   92 </span><span class="spaces"></span><span class="istickedoff">add_key_of_terms' Var       _  = <span class="nottickedoff">error &quot;impossible&quot;</span></span></span>
<span class="lineno">   93 </span>
<span class="lineno">   94 </span>{-convert a term to a list of keys-}
<span class="lineno">   95 </span>key_of_term :: Pat -&gt; [Key]
<span class="lineno">   96 </span><span class="decl"><span class="istickedoff">key_of_term t = add_key_of_terms t []</span></span>
<span class="lineno">   97 </span>{- ^ Required property: @depth (key_of_term t) = 1@
<span class="lineno">   98 </span>depth :: [Key] -&gt; Int
<span class="lineno">   99 </span>depth [] = 0
<span class="lineno">  100 </span>depth (CombK   : keys) = depth keys - 1
<span class="lineno">  101 </span>depth (VarK    : keys) = depth keys + 1
<span class="lineno">  102 </span>depth (AtomK _ : keys) = depth keys + 1
<span class="lineno">  103 </span>-}
<span class="lineno">  104 </span>
<span class="lineno">  105 </span>{-Trees indexed by key lists: each arc is labelled by a key.
<span class="lineno">  106 </span>  Each node contains a list of items, and arcs to children.
<span class="lineno">  107 </span>  The empty key addresses the entire net.
<span class="lineno">  108 </span>  Lookup functions preserve order in items stored at same level.
<span class="lineno">  109 </span>-}
<span class="lineno">  110 </span>
<span class="lineno">  111 </span>data Net a
<span class="lineno">  112 </span>  = Leaf [a]
<span class="lineno">  113 </span>  | Net { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">comb</span></span></span> :: Net a, <span class="nottickedoff"><span class="decl"><span class="nottickedoff">var</span></span></span> :: Net a, <span class="nottickedoff"><span class="decl"><span class="nottickedoff">atoms</span></span></span> :: Map Text (Net a) }
<span class="lineno">  114 </span>  deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>
<span class="lineno">  115 </span>
<span class="lineno">  116 </span>{-
<span class="lineno">  117 </span>Invariant: A well-formed term net should satisfy @valid 1@.
<span class="lineno">  118 </span>Every sub-net should satisfy @valid n@ for some non-negative @n@.
<span class="lineno">  119 </span>
<span class="lineno">  120 </span>valid :: Int -&gt; Net a -&gt; Bool
<span class="lineno">  121 </span>valid n (Leaf xs) = null xs || n == 0
<span class="lineno">  122 </span>valid n (Net {comb, var, atoms}) =
<span class="lineno">  123 </span>  n &gt; 0 &amp;&amp; valid (n+1) comb &amp;&amp; valid (n-1) var &amp;&amp; all (valid (n-1)) (elems atoms)
<span class="lineno">  124 </span>-}
<span class="lineno">  125 </span>
<span class="lineno">  126 </span>empty :: Net a
<span class="lineno">  127 </span><span class="decl"><span class="istickedoff">empty = Leaf []</span></span>
<span class="lineno">  128 </span>
<span class="lineno">  129 </span>is_empty :: Net a -&gt; Bool
<span class="lineno">  130 </span><span class="decl"><span class="nottickedoff">is_empty (Leaf []) = True</span>
<span class="lineno">  131 </span><span class="spaces"></span><span class="nottickedoff">is_empty _ = False</span></span>
<span class="lineno">  132 </span>
<span class="lineno">  133 </span>emptynet :: Net a
<span class="lineno">  134 </span><span class="decl"><span class="istickedoff">emptynet = Net { comb = empty, var = empty, atoms = Map.empty }</span></span>
<span class="lineno">  135 </span>
<span class="lineno">  136 </span>{-** Insertion into a discrimination net **-}
<span class="lineno">  137 </span>
<span class="lineno">  138 </span>{-Adds item x to the list at the node addressed by the keys.
<span class="lineno">  139 </span>  Creates node if not already present.
<span class="lineno">  140 </span>  The empty list of keys generates a Leaf node, others a Net node.
<span class="lineno">  141 </span>-}
<span class="lineno">  142 </span>insert :: forall a. (Eq a) =&gt; ([Key], a) -&gt; Net a -&gt; Net a
<span class="lineno">  143 </span><span class="decl"><span class="istickedoff">insert (keys0, x) net = ins1 keys0 net</span>
<span class="lineno">  144 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  145 </span><span class="spaces">    </span><span class="istickedoff">ins1 :: [Key] -&gt; Net a -&gt; Net a</span>
<span class="lineno">  146 </span><span class="spaces">    </span><span class="istickedoff">ins1 [] (Leaf xs)</span>
<span class="lineno">  147 </span><span class="spaces">      </span><span class="istickedoff">| x `elem` xs = Leaf xs</span>
<span class="lineno">  148 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span>   = Leaf (x : xs)</span>
<span class="lineno">  149 </span><span class="spaces">    </span><span class="istickedoff">ins1 keys (Leaf []) = ins1 keys emptynet</span>
<span class="lineno">  150 </span><span class="spaces">    </span><span class="istickedoff">ins1 (CombK : keys) (Net {comb, var, atoms}) =</span>
<span class="lineno">  151 </span><span class="spaces">      </span><span class="istickedoff">Net {comb = ins1 keys comb, var = var, atoms = atoms}</span>
<span class="lineno">  152 </span><span class="spaces">    </span><span class="istickedoff">ins1 (VarK : keys) (Net {comb, var, atoms}) =</span>
<span class="lineno">  153 </span><span class="spaces">      </span><span class="istickedoff">Net {comb = comb, var = ins1 keys var, atoms = atoms}</span>
<span class="lineno">  154 </span><span class="spaces">    </span><span class="istickedoff">ins1 (AtomK a : keys) (Net {comb, var, atoms}) =</span>
<span class="lineno">  155 </span><span class="spaces">      </span><span class="istickedoff">let atoms' = Map.alter (Just . ins1 keys . fromMaybe empty) a atoms</span>
<span class="lineno">  156 </span><span class="spaces">      </span><span class="istickedoff">in Net {comb = comb, var = var, atoms = atoms'}</span>
<span class="lineno">  157 </span><span class="spaces">    </span><span class="istickedoff">ins1 [] (Net {}) = <span class="nottickedoff">error &quot;impossible&quot;</span></span>
<span class="lineno">  158 </span><span class="spaces">    </span><span class="istickedoff">ins1 (_ : _) (Leaf (_ : _)) = <span class="nottickedoff">error &quot;impossible&quot;</span></span></span>
<span class="lineno">  159 </span>
<span class="lineno">  160 </span>insert_term :: (Eq a) =&gt; (Pat, a) -&gt; Net a -&gt; Net a
<span class="lineno">  161 </span><span class="decl"><span class="istickedoff">insert_term (pat, x) = insert (key_of_term pat, x)</span></span>
<span class="lineno">  162 </span>
<span class="lineno">  163 </span>{-** Deletion from a discrimination net **-}
<span class="lineno">  164 </span>
<span class="lineno">  165 </span>{-Create a new Net node if it would be nonempty-}
<span class="lineno">  166 </span>newnet :: Net a -&gt; Net a -&gt; Map Text (Net a) -&gt; Net a
<span class="lineno">  167 </span><span class="decl"><span class="nottickedoff">newnet comb var atoms =</span>
<span class="lineno">  168 </span><span class="spaces">  </span><span class="nottickedoff">if is_empty comb &amp;&amp; is_empty var &amp;&amp; Map.null atoms</span>
<span class="lineno">  169 </span><span class="spaces">  </span><span class="nottickedoff">then empty else Net { comb = comb, var = var, atoms = atoms }</span></span>
<span class="lineno">  170 </span>
<span class="lineno">  171 </span>{-Deletes item x from the list at the node addressed by the keys.
<span class="lineno">  172 </span>  Returns Nothing if absent.  Collapses the net if possible. -}
<span class="lineno">  173 </span>delete :: (Eq a) =&gt; ([Key], a) -&gt; Net a -&gt; Net a
<span class="lineno">  174 </span><span class="decl"><span class="nottickedoff">delete (keys0, x) net0 = del1 keys0 net0</span>
<span class="lineno">  175 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  176 </span><span class="spaces">    </span><span class="nottickedoff">-- | Invariant: @del1 keys net@ requires @valid (depth keys) net@.</span>
<span class="lineno">  177 </span><span class="spaces">    </span><span class="nottickedoff">del1 [] (Leaf xs) = Leaf (List.delete x xs)</span>
<span class="lineno">  178 </span><span class="spaces">    </span><span class="nottickedoff">del1 _ (Leaf []) = Leaf []</span>
<span class="lineno">  179 </span><span class="spaces">    </span><span class="nottickedoff">del1 (CombK : keys) (Net {comb, var, atoms}) =</span>
<span class="lineno">  180 </span><span class="spaces">      </span><span class="nottickedoff">newnet (del1 keys comb) var atoms</span>
<span class="lineno">  181 </span><span class="spaces">    </span><span class="nottickedoff">del1 (VarK : keys) (Net {comb, var, atoms}) =</span>
<span class="lineno">  182 </span><span class="spaces">      </span><span class="nottickedoff">newnet comb (del1 keys var) atoms</span>
<span class="lineno">  183 </span><span class="spaces">    </span><span class="nottickedoff">del1 (AtomK a : keys) (Net {comb, var, atoms}) =</span>
<span class="lineno">  184 </span><span class="spaces">      </span><span class="nottickedoff">let nonempty (Leaf []) = Nothing</span>
<span class="lineno">  185 </span><span class="spaces">          </span><span class="nottickedoff">nonempty net = Just net</span>
<span class="lineno">  186 </span><span class="spaces">          </span><span class="nottickedoff">atoms' = Map.update (nonempty . del1 keys) a atoms</span>
<span class="lineno">  187 </span><span class="spaces">      </span><span class="nottickedoff">in newnet comb var atoms'</span>
<span class="lineno">  188 </span><span class="spaces">    </span><span class="nottickedoff">del1 [] (Net {}) = error &quot;impossible&quot;</span>
<span class="lineno">  189 </span><span class="spaces">    </span><span class="nottickedoff">del1 (_ : _) (Leaf (_ : _)) = error &quot;impossible&quot;</span></span>
<span class="lineno">  190 </span>
<span class="lineno">  191 </span>delete_term :: (Eq a) =&gt; (Pat, a) -&gt; Net a -&gt; Net a
<span class="lineno">  192 </span><span class="decl"><span class="nottickedoff">delete_term (pat, x) = delete (key_of_term pat, x)</span></span>
<span class="lineno">  193 </span>
<span class="lineno">  194 </span>{-** Retrieval functions for discrimination nets **-}
<span class="lineno">  195 </span>
<span class="lineno">  196 </span>{-Return the list of items at the given node, [] if no such node-}
<span class="lineno">  197 </span>-- | Invariant: @lookup net keys@ requires @valid (depth keys) net@.
<span class="lineno">  198 </span>lookup :: Net a -&gt; [Key] -&gt; [a]
<span class="lineno">  199 </span><span class="decl"><span class="nottickedoff">lookup (Leaf xs) [] = xs</span>
<span class="lineno">  200 </span><span class="spaces"></span><span class="nottickedoff">lookup (Leaf _) (_ : _) = []  {-non-empty keys and empty net-}</span>
<span class="lineno">  201 </span><span class="spaces"></span><span class="nottickedoff">lookup (Net {comb}) (CombK : keys) = lookup comb keys</span>
<span class="lineno">  202 </span><span class="spaces"></span><span class="nottickedoff">lookup (Net {var}) (VarK : keys) = lookup var keys</span>
<span class="lineno">  203 </span><span class="spaces"></span><span class="nottickedoff">lookup (Net {atoms}) (AtomK a : keys) =</span>
<span class="lineno">  204 </span><span class="spaces">  </span><span class="nottickedoff">case Map.lookup a atoms of</span>
<span class="lineno">  205 </span><span class="spaces">    </span><span class="nottickedoff">Just net -&gt; lookup net keys</span>
<span class="lineno">  206 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; []</span>
<span class="lineno">  207 </span><span class="spaces"></span><span class="nottickedoff">lookup (Net {}) [] = error &quot;impossible&quot;</span></span>
<span class="lineno">  208 </span>
<span class="lineno">  209 </span>{-Skipping a term in a net.  Recursively skip 2 levels if a combination-}
<span class="lineno">  210 </span>net_skip :: Net a -&gt; [Net a] -&gt; [Net a]
<span class="lineno">  211 </span><span class="decl"><span class="nottickedoff">net_skip (Leaf _) nets = nets</span>
<span class="lineno">  212 </span><span class="spaces"></span><span class="nottickedoff">net_skip (Net {comb, var, atoms}) nets =</span>
<span class="lineno">  213 </span><span class="spaces">  </span><span class="nottickedoff">foldr net_skip (Map.foldr (:) (var : nets) atoms) (net_skip comb [])</span></span>
<span class="lineno">  214 </span>
<span class="lineno">  215 </span>{-* Matching and Unification *-}
<span class="lineno">  216 </span>
<span class="lineno">  217 </span>{-conses the linked net, if present, to nets-}
<span class="lineno">  218 </span>look1 :: (Map Text (Net a), Text) -&gt; [Net a] -&gt; [Net a]
<span class="lineno">  219 </span><span class="decl"><span class="istickedoff">look1 (atoms, a) nets =</span>
<span class="lineno">  220 </span><span class="spaces">  </span><span class="istickedoff">case Map.lookup a atoms of</span>
<span class="lineno">  221 </span><span class="spaces">    </span><span class="istickedoff">Just net -&gt; net : nets</span>
<span class="lineno">  222 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; nets</span></span>
<span class="lineno">  223 </span>
<span class="lineno">  224 </span>{-Return the nodes accessible from the term (cons them before nets)
<span class="lineno">  225 </span>  &quot;unif&quot; signifies retrieval for unification rather than matching.
<span class="lineno">  226 </span>  Var in net matches any term.
<span class="lineno">  227 </span>  Abs or Var in object: if &quot;unif&quot;, regarded as wildcard,
<span class="lineno">  228 </span>                                   else matches only a variable in net.
<span class="lineno">  229 </span>-}
<span class="lineno">  230 </span>matching :: Bool -&gt; Pat -&gt; Net a -&gt; [Net a] -&gt; [Net a]
<span class="lineno">  231 </span><span class="decl"><span class="istickedoff">matching unif = match</span>
<span class="lineno">  232 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  233 </span><span class="spaces">    </span><span class="istickedoff">match :: Pat -&gt; Net a -&gt; [Net a] -&gt; [Net a]</span>
<span class="lineno">  234 </span><span class="spaces">    </span><span class="istickedoff">match t net nets =</span>
<span class="lineno">  235 </span><span class="spaces">      </span><span class="istickedoff">case net of</span>
<span class="lineno">  236 </span><span class="spaces">        </span><span class="istickedoff">Leaf _ -&gt; nets</span>
<span class="lineno">  237 </span><span class="spaces">        </span><span class="istickedoff">Net {var} -&gt;</span>
<span class="lineno">  238 </span><span class="spaces">          </span><span class="istickedoff">case t of</span>
<span class="lineno">  239 </span><span class="spaces">            </span><span class="istickedoff">Var -&gt; if <span class="tickonlyfalse">unif</span> then <span class="nottickedoff">net_skip net nets</span> else var : nets {-only matches Var in net-}</span>
<span class="lineno">  240 </span><span class="spaces">            </span><span class="istickedoff">_   -&gt; rands t net (var : nets)  {-var could match also-}</span>
<span class="lineno">  241 </span><span class="spaces">    </span><span class="istickedoff">rands :: Pat -&gt; Net a -&gt; [Net a] -&gt; [Net a]</span>
<span class="lineno">  242 </span><span class="spaces">    </span><span class="istickedoff">rands _ (Leaf _) nets = nets</span>
<span class="lineno">  243 </span><span class="spaces">    </span><span class="istickedoff">rands t (Net {comb, atoms}) nets =</span>
<span class="lineno">  244 </span><span class="spaces">      </span><span class="istickedoff">case t of</span>
<span class="lineno">  245 </span><span class="spaces">        </span><span class="istickedoff">Atom c    -&gt; look1 (atoms, c) nets</span>
<span class="lineno">  246 </span><span class="spaces">        </span><span class="istickedoff">Var       -&gt; nets</span>
<span class="lineno">  247 </span><span class="spaces">        </span><span class="istickedoff">App t1 t2 -&gt; foldr (match t2) nets (rands t1 comb [])</span></span>
<span class="lineno">  248 </span>
<span class="lineno">  249 </span>{- Invariant: Each list entry must be a Leaf. -}
<span class="lineno">  250 </span>extract_leaves :: [Net a] -&gt; [a]
<span class="lineno">  251 </span><span class="decl"><span class="istickedoff">extract_leaves = concatMap $ \case</span>
<span class="lineno">  252 </span><span class="spaces">  </span><span class="istickedoff">Leaf xs -&gt; xs</span>
<span class="lineno">  253 </span><span class="spaces">  </span><span class="istickedoff">Net{}   -&gt; <span class="nottickedoff">error &quot;extract_leaves: Unexpected Net node&quot;</span></span></span>
<span class="lineno">  254 </span>
<span class="lineno">  255 </span>{-return items whose key could match pat, WHICH MUST BE BETA-ETA NORMAL-}
<span class="lineno">  256 </span>match_term :: Net a -&gt; Pat -&gt; [a]
<span class="lineno">  257 </span><span class="decl"><span class="istickedoff">match_term net pat = extract_leaves (matching False pat net [])</span></span>
<span class="lineno">  258 </span>
<span class="lineno">  259 </span>{-return items whose key could unify with pat-}
<span class="lineno">  260 </span>unify_term :: Net a -&gt; Pat -&gt; [a]
<span class="lineno">  261 </span><span class="decl"><span class="nottickedoff">unify_term net pat = extract_leaves (matching True pat net [])</span></span>
<span class="lineno">  262 </span>
<span class="lineno">  263 </span>{--------------------------------------------------------------------
<span class="lineno">  264 </span>
<span class="lineno">  265 </span>{-* operations on nets *-}
<span class="lineno">  266 </span>
<span class="lineno">  267 </span>{-subtraction: collect entries of second net that are NOT present in first net-}
<span class="lineno">  268 </span>fun subtract eq net1 net2 =
<span class="lineno">  269 </span>  let
<span class="lineno">  270 </span>    fun subtr (Net _) (Leaf ys) = append ys
<span class="lineno">  271 </span>      | subtr (Leaf xs) (Leaf ys) =
<span class="lineno">  272 </span>          fold_rev (fn y =&gt; if member eq xs y then I else cons y) ys
<span class="lineno">  273 </span>      | subtr (Leaf _) (net as Net _) = subtr emptynet net
<span class="lineno">  274 </span>      | subtr (Net {comb = comb1, var = var1, atoms = atoms1})
<span class="lineno">  275 </span>            (Net {comb = comb2, var = var2, atoms = atoms2}) =
<span class="lineno">  276 </span>          subtr comb1 comb2
<span class="lineno">  277 </span>          #&gt; subtr var1 var2
<span class="lineno">  278 </span>          #&gt; Symtab.fold (fn (a, net) =&gt;
<span class="lineno">  279 </span>            subtr (the_default emptynet (Symtab.lookup atoms1 a)) net) atoms2
<span class="lineno">  280 </span>  in subtr net1 net2 [] end;
<span class="lineno">  281 </span>
<span class="lineno">  282 </span>fun entries net = subtract (K false) empty net;
<span class="lineno">  283 </span>
<span class="lineno">  284 </span>--------------------------------------------------------------------------------}
<span class="lineno">  285 </span>
<span class="lineno">  286 </span>{- merge -}
<span class="lineno">  287 </span>
<span class="lineno">  288 </span>cons_fst :: a -&gt; ([a], b) -&gt; ([a], b)
<span class="lineno">  289 </span><span class="decl"><span class="istickedoff">cons_fst x (xs, y) = (x : xs, y)</span></span>
<span class="lineno">  290 </span>
<span class="lineno">  291 </span>dest :: Net a -&gt; [([Key], a)]
<span class="lineno">  292 </span><span class="decl"><span class="istickedoff">dest (Leaf xs) = map ((,) []) xs</span>
<span class="lineno">  293 </span><span class="spaces"></span><span class="istickedoff">dest (Net {comb, var, atoms}) =</span>
<span class="lineno">  294 </span><span class="spaces">  </span><span class="istickedoff">map (cons_fst CombK) (dest comb) ++</span>
<span class="lineno">  295 </span><span class="spaces">  </span><span class="istickedoff">map (cons_fst VarK) (dest var) ++</span>
<span class="lineno">  296 </span><span class="spaces">  </span><span class="istickedoff">concatMap (\(a, net) -&gt; map (cons_fst (AtomK a)) (dest net)) (Map.assocs atoms)</span></span>
<span class="lineno">  297 </span>
<span class="lineno">  298 </span>merge :: Eq a =&gt; Net a -&gt; Net a -&gt; Net a
<span class="lineno">  299 </span><span class="decl"><span class="istickedoff">merge net1 net2 = foldl (flip insert) net1 (dest net2)</span></span>
<span class="lineno">  300 </span>
<span class="lineno">  301 </span>content :: Net a -&gt; [a]
<span class="lineno">  302 </span><span class="decl"><span class="nottickedoff">content (Leaf xs) = xs</span>
<span class="lineno">  303 </span><span class="spaces"></span><span class="nottickedoff">content (Net {comb, var, atoms}) =</span>
<span class="lineno">  304 </span><span class="spaces">  </span><span class="nottickedoff">content comb ++</span>
<span class="lineno">  305 </span><span class="spaces">  </span><span class="nottickedoff">content var ++</span>
<span class="lineno">  306 </span><span class="spaces">  </span><span class="nottickedoff">concatMap content (Map.elems atoms)</span></span>

</pre>
</body>
</html>
