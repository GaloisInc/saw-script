<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- |
<span class="lineno">    2 </span>Module      : SAWScript.Interpreter
<span class="lineno">    3 </span>Description : Interpreter for SAW-Script files and statements.
<span class="lineno">    4 </span>License     : BSD3
<span class="lineno">    5 </span>Maintainer  : huffman
<span class="lineno">    6 </span>Stability   : provisional
<span class="lineno">    7 </span>-}
<span class="lineno">    8 </span>{-# LANGUAGE FlexibleContexts #-}
<span class="lineno">    9 </span>{-# LANGUAGE FlexibleInstances #-}
<span class="lineno">   10 </span>{-# LANGUAGE GeneralizedNewtypeDeriving #-}
<span class="lineno">   11 </span>{-# LANGUAGE ImplicitParams #-}
<span class="lineno">   12 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">   13 </span>{-# LANGUAGE MultiParamTypeClasses #-}
<span class="lineno">   14 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">   15 </span>{-# LANGUAGE RankNTypes #-}
<span class="lineno">   16 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">   17 </span>{-# LANGUAGE TupleSections #-}
<span class="lineno">   18 </span>{-# LANGUAGE ViewPatterns #-}
<span class="lineno">   19 </span>{-# LANGUAGE NondecreasingIndentation #-}
<span class="lineno">   20 </span>-- See Note [-Wincomplete-uni-patterns and irrefutable patterns] in
<span class="lineno">   21 </span>-- SAWScript.Typechecker
<span class="lineno">   22 </span>{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}
<span class="lineno">   23 </span>
<span class="lineno">   24 </span>module SAWScript.Interpreter
<span class="lineno">   25 </span>  ( interpretTopStmt
<span class="lineno">   26 </span>  , interpretFile
<span class="lineno">   27 </span>  , processFile
<span class="lineno">   28 </span>  , buildTopLevelEnv
<span class="lineno">   29 </span>  )
<span class="lineno">   30 </span>  where
<span class="lineno">   31 </span>
<span class="lineno">   32 </span>import qualified Control.Exception as X
<span class="lineno">   33 </span>import Control.Monad (unless, (&gt;=&gt;), when)
<span class="lineno">   34 </span>import Control.Monad.Reader (ask, asks)
<span class="lineno">   35 </span>import Control.Monad.State (gets)
<span class="lineno">   36 </span>import Control.Monad.IO.Class (liftIO)
<span class="lineno">   37 </span>import qualified Data.ByteString as BS
<span class="lineno">   38 </span>import Data.Maybe (fromMaybe)
<span class="lineno">   39 </span>import Data.List (genericLength)
<span class="lineno">   40 </span>import qualified Data.Map as Map
<span class="lineno">   41 </span>import Data.Map ( Map )
<span class="lineno">   42 </span>import Data.Sequence (Seq( (:|&gt;) ))
<span class="lineno">   43 </span>import qualified Data.Sequence as Seq (empty)
<span class="lineno">   44 </span>import qualified Data.Set as Set
<span class="lineno">   45 </span>import qualified Data.Text as Text
<span class="lineno">   46 </span>import Data.Text (Text)
<span class="lineno">   47 </span>import qualified Data.Text.IO as TextIO
<span class="lineno">   48 </span>import System.Directory (getCurrentDirectory, setCurrentDirectory)
<span class="lineno">   49 </span>import System.FilePath (takeDirectory)
<span class="lineno">   50 </span>import System.Environment (lookupEnv)
<span class="lineno">   51 </span>import System.Process (readProcess)
<span class="lineno">   52 </span>
<span class="lineno">   53 </span>import Data.Parameterized.Some
<span class="lineno">   54 </span>
<span class="lineno">   55 </span>import qualified Text.LLVM.AST as LLVM (Type)
<span class="lineno">   56 </span>
<span class="lineno">   57 </span>import qualified Lang.JVM.Codebase as JSS
<span class="lineno">   58 </span>
<span class="lineno">   59 </span>import qualified Cryptol.TypeCheck.AST as Cryptol
<span class="lineno">   60 </span>
<span class="lineno">   61 </span>import qualified Lang.Crucible.JVM as CJ
<span class="lineno">   62 </span>import Lang.Crucible.LLVM.ArraySizeProfile (FunctionProfile)
<span class="lineno">   63 </span>import Mir.Intrinsics (MIR)
<span class="lineno">   64 </span>import qualified Mir.Generator as MIR (RustModule)
<span class="lineno">   65 </span>import qualified Mir.Mir as MIR
<span class="lineno">   66 </span>
<span class="lineno">   67 </span>import qualified SAWSupport.Pretty as PPS (MemoStyle(..), Opts(..), defaultOpts, pShow, pShowText)
<span class="lineno">   68 </span>
<span class="lineno">   69 </span>import SAWCore.FiniteValue (FirstOrderValue(..))
<span class="lineno">   70 </span>
<span class="lineno">   71 </span>import CryptolSAWCore.TypedTerm
<span class="lineno">   72 </span>
<span class="lineno">   73 </span>--import SAWCentral.Trace (Trace)
<span class="lineno">   74 </span>import qualified SAWCentral.Trace as Trace
<span class="lineno">   75 </span>
<span class="lineno">   76 </span>import qualified SAWCentral.AST as SS
<span class="lineno">   77 </span>import qualified SAWCentral.Position as SS
<span class="lineno">   78 </span>import SAWCentral.AST (Import(..), PrimitiveLifecycle(..), defaultAvailable)
<span class="lineno">   79 </span>import SAWCentral.Bisimulation
<span class="lineno">   80 </span>import SAWCentral.Builtins
<span class="lineno">   81 </span>import SAWCentral.Exceptions (failTypecheck)
<span class="lineno">   82 </span>import qualified SAWScript.Import
<span class="lineno">   83 </span>import SAWCentral.JavaExpr
<span class="lineno">   84 </span>import SAWCentral.LLVMBuiltins
<span class="lineno">   85 </span>import SAWCentral.Options
<span class="lineno">   86 </span>import SAWScript.Lexer (lexSAW)
<span class="lineno">   87 </span>import SAWScript.Typechecker (checkStmt, typesMatch)
<span class="lineno">   88 </span>import SAWScript.Parser (parseSchema)
<span class="lineno">   89 </span>import SAWScript.Panic (panic)
<span class="lineno">   90 </span>import SAWCentral.TopLevel
<span class="lineno">   91 </span>import SAWCentral.Utils
<span class="lineno">   92 </span>import SAWCentral.Value
<span class="lineno">   93 </span>import SAWScript.ValueOps
<span class="lineno">   94 </span>import SAWCentral.SolverCache
<span class="lineno">   95 </span>import SAWCentral.SolverVersions
<span class="lineno">   96 </span>import SAWCentral.Proof (ProofResult(..), Theorem, emptyTheoremDB)
<span class="lineno">   97 </span>import SAWCentral.Prover.Rewrite(basic_ss)
<span class="lineno">   98 </span>import SAWCentral.Prover.Exporter
<span class="lineno">   99 </span>import SAWCentral.Yosys -- XXX remove in favor of the following later
<span class="lineno">  100 </span>import qualified SAWCentral.Yosys as Yo (YosysIR)
<span class="lineno">  101 </span>import qualified SAWCentral.Yosys.State as Yo (YosysSequential)
<span class="lineno">  102 </span>import qualified SAWCentral.Yosys.Theorem as Yo (YosysImport, YosysTheorem)
<span class="lineno">  103 </span>
<span class="lineno">  104 </span>import SAWCore.Conversion
<span class="lineno">  105 </span>import SAWCore.Module (Def(..), emptyModule, moduleDefs)
<span class="lineno">  106 </span>import SAWCore.Name (mkModuleName, Name(..))
<span class="lineno">  107 </span>import SAWCore.Prim (rethrowEvalError)
<span class="lineno">  108 </span>import SAWCore.Rewriter (emptySimpset, rewritingSharedContext, scSimpset)
<span class="lineno">  109 </span>import SAWCore.SharedTerm
<span class="lineno">  110 </span>import qualified CryptolSAWCore.CryptolEnv as CEnv
<span class="lineno">  111 </span>
<span class="lineno">  112 </span>import qualified CryptolSAWCore.Prelude as CryptolSAW
<span class="lineno">  113 </span>
<span class="lineno">  114 </span>-- Crucible
<span class="lineno">  115 </span>import qualified SAWCentral.Crucible.Common as CC
<span class="lineno">  116 </span>import qualified SAWCentral.Crucible.Common.MethodSpec as CMS
<span class="lineno">  117 </span>import qualified SAWCentral.Crucible.JVM.BuiltinsJVM as CJ
<span class="lineno">  118 </span>import           SAWCentral.Crucible.LLVM.Builtins
<span class="lineno">  119 </span>import           SAWCentral.Crucible.JVM.Builtins
<span class="lineno">  120 </span>import           SAWCentral.Crucible.MIR.Builtins
<span class="lineno">  121 </span>import           SAWCentral.Crucible.LLVM.X86
<span class="lineno">  122 </span>import           SAWCentral.Crucible.LLVM.Boilerplate
<span class="lineno">  123 </span>import           SAWCentral.Crucible.LLVM.Skeleton (ModuleSkeleton, FunctionSkeleton)
<span class="lineno">  124 </span>import           SAWCentral.Crucible.LLVM.Skeleton.Builtins
<span class="lineno">  125 </span>import           SAWCentral.Crucible.LLVM.FFI
<span class="lineno">  126 </span>import qualified SAWCentral.Crucible.LLVM.MethodSpecIR as CIR
<span class="lineno">  127 </span>
<span class="lineno">  128 </span>-- Cryptol
<span class="lineno">  129 </span>import qualified Cryptol.Eval as V (PPOpts(..))
<span class="lineno">  130 </span>import qualified Cryptol.Backend.Monad as V (runEval)
<span class="lineno">  131 </span>import qualified Cryptol.Eval.Value as V (defaultPPOpts, ppValue)
<span class="lineno">  132 </span>import qualified Cryptol.Eval.Concrete as V (Concrete(..))
<span class="lineno">  133 </span>
<span class="lineno">  134 </span>import qualified Prettyprinter.Render.Text as PP (putDoc)
<span class="lineno">  135 </span>
<span class="lineno">  136 </span>import SAWScript.AutoMatch
<span class="lineno">  137 </span>
<span class="lineno">  138 </span>import qualified Lang.Crucible.FunctionHandle as Crucible
<span class="lineno">  139 </span>
<span class="lineno">  140 </span>
<span class="lineno">  141 </span>------------------------------------------------------------
<span class="lineno">  142 </span>-- Support
<span class="lineno">  143 </span>
<span class="lineno">  144 </span>-- This is used to reject top-level execution of polymorphic
<span class="lineno">  145 </span>-- expressions. Assumes we aren't inside an uninstantiated forall
<span class="lineno">  146 </span>-- quantifier. Also assumes the typechecker has already approved the
<span class="lineno">  147 </span>-- type. This means we know it doesn't contain unbound named type
<span class="lineno">  148 </span>-- variables. Fail if we encounter a unification var.
<span class="lineno">  149 </span>--
<span class="lineno">  150 </span>-- XXX: this serves little purpose. A polymorphic expression must
<span class="lineno">  151 </span>-- either be a partially applied (or unapplied) polymorphic function,
<span class="lineno">  152 </span>-- in which case we aren't going to actually execute anything anyway,
<span class="lineno">  153 </span>-- or be fully applied but have a polymorphic return type, and the
<span class="lineno">  154 </span>-- only such functions we can have are those that don't return (like
<span class="lineno">  155 </span>-- &quot;fail&quot;) so we don't actually care what they produce. So this code
<span class="lineno">  156 </span>-- and the check that calls it should probably be removed.
<span class="lineno">  157 </span>--
<span class="lineno">  158 </span>-- XXX: also, this is here transiently so that the rejection continues
<span class="lineno">  159 </span>-- to work while the interaction between the interpreter and the
<span class="lineno">  160 </span>-- typechecker is rationalized. In the long run, the rejection should
<span class="lineno">  161 </span>-- really belong only to the repl for repl purposes and the
<span class="lineno">  162 </span>-- polymorphism check should be part of the currently nonexistent
<span class="lineno">  163 </span>-- incremental interface to the typechecker. Alternatively, if there
<span class="lineno">  164 </span>-- are cases that really require rejection of polymorphic expressions
<span class="lineno">  165 </span>-- at the top level, they also require rejection of polymorphic
<span class="lineno">  166 </span>-- expressions in nested do-blocks that aren't inside functions, and
<span class="lineno">  167 </span>-- it can and should all happen inside the typechecker.
<span class="lineno">  168 </span>isPolymorphic :: SS.Type -&gt; Bool
<span class="lineno">  169 </span><span class="decl"><span class="istickedoff">isPolymorphic ty0 = case ty0 of</span>
<span class="lineno">  170 </span><span class="spaces">    </span><span class="istickedoff">SS.TyCon _pos _tycon args -&gt; any isPolymorphic args</span>
<span class="lineno">  171 </span><span class="spaces">    </span><span class="istickedoff">SS.TyRecord _pos fields -&gt; <span class="nottickedoff">any isPolymorphic fields</span></span>
<span class="lineno">  172 </span><span class="spaces">    </span><span class="istickedoff">SS.TyVar _pos _a -&gt; False</span>
<span class="lineno">  173 </span><span class="spaces">    </span><span class="istickedoff">SS.TyUnifyVar _pos _ix -&gt; True</span></span>
<span class="lineno">  174 </span>
<span class="lineno">  175 </span>-- Get the type of an AST element. For now, only patterns because that's
<span class="lineno">  176 </span>-- what we're using.
<span class="lineno">  177 </span>--
<span class="lineno">  178 </span>-- Assumes we have been through the typechecker and the types are filled in.
<span class="lineno">  179 </span>--
<span class="lineno">  180 </span>-- XXX: this should be a typeclass function with instances for all the AST
<span class="lineno">  181 </span>-- types.
<span class="lineno">  182 </span>--
<span class="lineno">  183 </span>-- XXX: also it should be moved to ASTUtil once we have such a place.
<span class="lineno">  184 </span>getType :: SS.Pattern -&gt; SS.Type
<span class="lineno">  185 </span><span class="decl"><span class="istickedoff">getType pat = case pat of</span>
<span class="lineno">  186 </span><span class="spaces">    </span><span class="istickedoff">SS.PWild _pos ~(Just t) -&gt; t</span>
<span class="lineno">  187 </span><span class="spaces">    </span><span class="istickedoff">SS.PVar _allpos _xpos _x ~(Just t) -&gt; t</span>
<span class="lineno">  188 </span><span class="spaces">    </span><span class="istickedoff">SS.PTuple tuplepos pats -&gt;</span>
<span class="lineno">  189 </span><span class="spaces">        </span><span class="istickedoff">SS.TyCon <span class="nottickedoff">tuplepos</span> (SS.TupleCon <span class="nottickedoff">(genericLength pats)</span>) (map getType pats)</span></span>
<span class="lineno">  190 </span>
<span class="lineno">  191 </span>-- Convert some text to an InputText for cryptol-saw-core.
<span class="lineno">  192 </span>toInputText :: SS.Pos -&gt; Text -&gt; CEnv.InputText
<span class="lineno">  193 </span><span class="decl"><span class="istickedoff">toInputText pos0 txt =</span>
<span class="lineno">  194 </span><span class="spaces">  </span><span class="istickedoff">CEnv.InputText {</span>
<span class="lineno">  195 </span><span class="spaces">    </span><span class="istickedoff">CEnv.inpText = txt,</span>
<span class="lineno">  196 </span><span class="spaces">    </span><span class="istickedoff">CEnv.inpFile = file,</span>
<span class="lineno">  197 </span><span class="spaces">    </span><span class="istickedoff">CEnv.inpLine = ln,</span>
<span class="lineno">  198 </span><span class="spaces">    </span><span class="istickedoff">CEnv.inpCol  = col + 2 -- for dropped }}</span>
<span class="lineno">  199 </span><span class="spaces">  </span><span class="istickedoff">}</span>
<span class="lineno">  200 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  201 </span><span class="spaces">  </span><span class="istickedoff">(file, ln, col) = extract pos0</span>
<span class="lineno">  202 </span><span class="spaces">  </span><span class="istickedoff">extract pos = case pos of</span>
<span class="lineno">  203 </span><span class="spaces">      </span><span class="istickedoff">SS.Range f sl sc _ _ -&gt; (f,sl, sc)</span>
<span class="lineno">  204 </span><span class="spaces">      </span><span class="istickedoff">SS.FileOnlyPos f -&gt; <span class="nottickedoff">(f, 1, 1)</span></span>
<span class="lineno">  205 </span><span class="spaces">      </span><span class="istickedoff">SS.FileAndFunctionPos f _ -&gt; <span class="nottickedoff">(f, 1, 1)</span></span>
<span class="lineno">  206 </span><span class="spaces">      </span><span class="istickedoff">SS.PosInferred _ pos' -&gt; <span class="nottickedoff">extract pos'</span></span>
<span class="lineno">  207 </span><span class="spaces">      </span><span class="istickedoff">SS.PosInternal s -&gt; <span class="nottickedoff">(s,1,1)</span></span>
<span class="lineno">  208 </span><span class="spaces">      </span><span class="istickedoff">SS.PosInsideBuiltin -&gt; <span class="nottickedoff">(&quot;(builtin)&quot;, 1, 1)</span></span>
<span class="lineno">  209 </span><span class="spaces">      </span><span class="istickedoff">SS.PosREPL       -&gt; <span class="nottickedoff">(&quot;&lt;interactive&gt;&quot;, 1, 1)</span></span>
<span class="lineno">  210 </span><span class="spaces">      </span><span class="istickedoff">SS.Unknown       -&gt; <span class="nottickedoff">(&quot;Unknown&quot;, 1, 1)</span></span></span>
<span class="lineno">  211 </span>
<span class="lineno">  212 </span>-- | &quot;Position of last reference&quot; for values that haven't been
<span class="lineno">  213 </span>--   referenced.
<span class="lineno">  214 </span>--
<span class="lineno">  215 </span>--   Used in toValue so it'll appear in the builtin table. However,
<span class="lineno">  216 </span>--   it should always be replaced when the value is retrieved and
<span class="lineno">  217 </span>--   before it's returned out or passed on by the interpreter for
<span class="lineno">  218 </span>--   execution. So users should never see it.
<span class="lineno">  219 </span>--
<span class="lineno">  220 </span>--   FUTURE: might make sense to set this to a panic.
<span class="lineno">  221 </span>atRestPos :: SS.Pos
<span class="lineno">  222 </span><span class="decl"><span class="nottickedoff">atRestPos = SS.PosInternal &quot;&lt;&lt;position of value at rest; shouldn't be seen&gt;&gt;&quot;</span></span>
<span class="lineno">  223 </span>
<span class="lineno">  224 </span>-- | Update the position in a plain monadic value.
<span class="lineno">  225 </span>injectPositionIntoMonadicValue :: SS.Pos -&gt; Value -&gt; Value
<span class="lineno">  226 </span><span class="decl"><span class="istickedoff">injectPositionIntoMonadicValue pos v = case v of</span>
<span class="lineno">  227 </span><span class="spaces">    </span><span class="istickedoff">VTopLevel _oldpos chain f -&gt; VTopLevel pos chain f</span>
<span class="lineno">  228 </span><span class="spaces">    </span><span class="istickedoff">VProofScript _oldpos chain f -&gt; VProofScript pos chain f</span>
<span class="lineno">  229 </span><span class="spaces">    </span><span class="istickedoff">VLLVMCrucibleSetup _oldpos chain f -&gt; VLLVMCrucibleSetup pos chain f</span>
<span class="lineno">  230 </span><span class="spaces">    </span><span class="istickedoff">VJVMSetup _oldpos chain f -&gt; VJVMSetup pos chain f</span>
<span class="lineno">  231 </span><span class="spaces">    </span><span class="istickedoff">VMIRSetup _oldpos chain f -&gt; VMIRSetup pos chain f</span>
<span class="lineno">  232 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; v</span></span>
<span class="lineno">  233 </span>
<span class="lineno">  234 </span>-- | Insert an entry in a plain monadic value's RefChain.
<span class="lineno">  235 </span>insertRefChain :: SS.Pos -&gt; SS.Name -&gt; Value -&gt; Value
<span class="lineno">  236 </span><span class="decl"><span class="istickedoff">insertRefChain pos name v =</span>
<span class="lineno">  237 </span><span class="spaces">  </span><span class="istickedoff">let insert chain = (pos, name) : chain in</span>
<span class="lineno">  238 </span><span class="spaces">  </span><span class="istickedoff">case v of</span>
<span class="lineno">  239 </span><span class="spaces">    </span><span class="istickedoff">VDo chain env body -&gt; VDo (insert chain) env body</span>
<span class="lineno">  240 </span><span class="spaces">    </span><span class="istickedoff">VBindOnce bindpos chain v1 v2 -&gt; VBindOnce bindpos (insert chain) v1 v2</span>
<span class="lineno">  241 </span><span class="spaces">    </span><span class="istickedoff">VTopLevel vpos chain f -&gt; VTopLevel <span class="nottickedoff">vpos</span> (insert chain) f</span>
<span class="lineno">  242 </span><span class="spaces">    </span><span class="istickedoff">VProofScript vpos chain f -&gt; VProofScript <span class="nottickedoff">vpos</span> (insert chain) f</span>
<span class="lineno">  243 </span><span class="spaces">    </span><span class="istickedoff">VLLVMCrucibleSetup vpos chain f -&gt; VLLVMCrucibleSetup <span class="nottickedoff">vpos</span> (insert chain) f</span>
<span class="lineno">  244 </span><span class="spaces">    </span><span class="istickedoff">VJVMSetup vpos chain f -&gt; VJVMSetup <span class="nottickedoff">vpos</span> (insert chain) f</span>
<span class="lineno">  245 </span><span class="spaces">    </span><span class="istickedoff">VMIRSetup vpos chain f -&gt; VMIRSetup <span class="nottickedoff">vpos</span> (insert chain) f</span>
<span class="lineno">  246 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; v</span></span>
<span class="lineno">  247 </span>
<span class="lineno">  248 </span>-- | Merge an ancestor RefChain (e.g. from a generating do block) into
<span class="lineno">  249 </span>--   a downstream one.
<span class="lineno">  250 </span>propagateRefChain :: RefChain -&gt; Value -&gt; Value
<span class="lineno">  251 </span><span class="decl"><span class="istickedoff">propagateRefChain chain1 v =</span>
<span class="lineno">  252 </span><span class="spaces">  </span><span class="istickedoff">let insert chain2 =</span>
<span class="lineno">  253 </span><span class="spaces">        </span><span class="istickedoff">-- concatenate the chain (older goes at the end)</span>
<span class="lineno">  254 </span><span class="spaces">        </span><span class="istickedoff">chain2 ++ chain1</span>
<span class="lineno">  255 </span><span class="spaces">  </span><span class="istickedoff">in</span>
<span class="lineno">  256 </span><span class="spaces">  </span><span class="istickedoff">case v of</span>
<span class="lineno">  257 </span><span class="spaces">    </span><span class="istickedoff">VDo chain2 env body -&gt; <span class="nottickedoff">VDo (insert chain2) env body</span></span>
<span class="lineno">  258 </span><span class="spaces">    </span><span class="istickedoff">VBindOnce pos chain2 v1 v2 -&gt; <span class="nottickedoff">VBindOnce pos (insert chain2) v1 v2</span></span>
<span class="lineno">  259 </span><span class="spaces">    </span><span class="istickedoff">VTopLevel pos chain2 f -&gt; VTopLevel <span class="nottickedoff">pos</span> (insert chain2) f</span>
<span class="lineno">  260 </span><span class="spaces">    </span><span class="istickedoff">VProofScript pos chain2 f -&gt; VProofScript <span class="nottickedoff">pos</span> (insert chain2) f</span>
<span class="lineno">  261 </span><span class="spaces">    </span><span class="istickedoff">VLLVMCrucibleSetup pos chain2 f -&gt; VLLVMCrucibleSetup pos (insert chain2) f</span>
<span class="lineno">  262 </span><span class="spaces">    </span><span class="istickedoff">VJVMSetup pos chain2 f -&gt; VJVMSetup pos (insert chain2) f</span>
<span class="lineno">  263 </span><span class="spaces">    </span><span class="istickedoff">VMIRSetup pos chain2 f -&gt; VMIRSetup pos (insert chain2) f</span>
<span class="lineno">  264 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">v</span></span></span>
<span class="lineno">  265 </span>
<span class="lineno">  266 </span>
<span class="lineno">  267 </span>------------------------------------------------------------
<span class="lineno">  268 </span>-- Environment updates
<span class="lineno">  269 </span>
<span class="lineno">  270 </span>-- The second argument (the schema, aka type) is Nothing in most
<span class="lineno">  271 </span>-- cases, but for Decls is taken from the Decl. This will always be
<span class="lineno">  272 </span>-- Just s for Decls that have been typechecked, which are the only
<span class="lineno">  273 </span>-- ones we should be handling here.
<span class="lineno">  274 </span>--
<span class="lineno">  275 </span>-- Meanwhile the Maybe Type field of PVar is also always Just ty for
<span class="lineno">  276 </span>-- patterns that have been typechecked, and the typechecker will have
<span class="lineno">  277 </span>-- established that the type of the pattern matches the type of the
<span class="lineno">  278 </span>-- Decl if there is one.
<span class="lineno">  279 </span>--
<span class="lineno">  280 </span>-- So we should be able to remove the schema argument (and with it the
<span class="lineno">  281 </span>-- mess for dividing up a passed-in tuple), but for the moment I'm
<span class="lineno">  282 </span>-- unwilling to in case there's something weird going on somewhere.
<span class="lineno">  283 </span>-- For the time being we'll just panic if the pattern type is missing
<span class="lineno">  284 </span>-- and use it to fill in the schema if there isn't a schema passed
<span class="lineno">  285 </span>-- down. We could also assert that the schema type and the pattern
<span class="lineno">  286 </span>-- type actually match, but it's intentionally difficult to do that
<span class="lineno">  287 </span>-- outside the typechecker and not really worthwhile.
<span class="lineno">  288 </span>--
<span class="lineno">  289 </span>-- XXX: at some point clean this up further.
<span class="lineno">  290 </span>--
<span class="lineno">  291 </span>bindPatternLocal ::
<span class="lineno">  292 </span>    SS.Rebindable -&gt; SS.Pattern -&gt; Maybe SS.Schema -&gt; Value -&gt;
<span class="lineno">  293 </span>    LocalEnv -&gt; LocalEnv
<span class="lineno">  294 </span><span class="decl"><span class="istickedoff">bindPatternLocal rb pat ms v env =</span>
<span class="lineno">  295 </span><span class="spaces">  </span><span class="istickedoff">case pat of</span>
<span class="lineno">  296 </span><span class="spaces">    </span><span class="istickedoff">SS.PWild _pos _ -&gt;</span>
<span class="lineno">  297 </span><span class="spaces">      </span><span class="istickedoff">env</span>
<span class="lineno">  298 </span><span class="spaces">    </span><span class="istickedoff">SS.PVar allpos _xpos _x Nothing -&gt;</span>
<span class="lineno">  299 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">panic &quot;bindPatternLocal&quot; [</span></span>
<span class="lineno">  300 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;Found pattern with no type in it&quot;,</span></span>
<span class="lineno">  301 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;Source position: &quot; &lt;&gt; Text.pack (show allpos),</span></span>
<span class="lineno">  302 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;Pattern: &quot; &lt;&gt; Text.pack (show pat)</span></span>
<span class="lineno">  303 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  304 </span><span class="spaces">    </span><span class="istickedoff">SS.PVar _allpos xpos x (Just ty) -&gt;</span>
<span class="lineno">  305 </span><span class="spaces">      </span><span class="istickedoff">let s = fromMaybe <span class="nottickedoff">(SS.tMono ty)</span> ms in</span>
<span class="lineno">  306 </span><span class="spaces">      </span><span class="istickedoff">extendLocal xpos x rb s <span class="nottickedoff">Nothing</span> v env</span>
<span class="lineno">  307 </span><span class="spaces">    </span><span class="istickedoff">SS.PTuple _pos ps -&gt;</span>
<span class="lineno">  308 </span><span class="spaces">      </span><span class="istickedoff">case v of</span>
<span class="lineno">  309 </span><span class="spaces">        </span><span class="istickedoff">VTuple vs -&gt; foldr ($) env (zipWith3 (bindPatternLocal <span class="nottickedoff">rb</span>) ps mss vs)</span>
<span class="lineno">  310 </span><span class="spaces">          </span><span class="istickedoff">where mss = case ms of</span>
<span class="lineno">  311 </span><span class="spaces">                  </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  312 </span><span class="spaces">                      </span><span class="istickedoff">repeat <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  313 </span><span class="spaces">                  </span><span class="istickedoff">Just (SS.Forall ks (SS.TyCon _ (SS.TupleCon _) ts)) -&gt;</span>
<span class="lineno">  314 </span><span class="spaces">                      </span><span class="istickedoff">[ Just (SS.Forall ks t) | t &lt;- ts ]</span>
<span class="lineno">  315 </span><span class="spaces">                  </span><span class="istickedoff">Just t -&gt;</span>
<span class="lineno">  316 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">panic &quot;bindPatternLocal&quot; [</span></span>
<span class="lineno">  317 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">&quot;Expected tuple type, got &quot; &lt;&gt; Text.pack (show t)</span></span>
<span class="lineno">  318 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  319 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  320 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">panic &quot;bindPatternLocal&quot; [</span></span>
<span class="lineno">  321 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">&quot;Expected tuple value; got &quot; &lt;&gt; Text.pack (show v)</span></span>
<span class="lineno">  322 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno">  323 </span>
<span class="lineno">  324 </span>-- See notes in bindPatternLocal above regarding the schema argument.
<span class="lineno">  325 </span>bindPatternEnv :: SS.Pattern -&gt; Maybe SS.Schema -&gt; Value -&gt; TopLevelRW -&gt; TopLevel TopLevelRW
<span class="lineno">  326 </span><span class="decl"><span class="istickedoff">bindPatternEnv pat ms v env =</span>
<span class="lineno">  327 </span><span class="spaces">  </span><span class="istickedoff">case pat of</span>
<span class="lineno">  328 </span><span class="spaces">    </span><span class="istickedoff">SS.PWild _pos _   -&gt;</span>
<span class="lineno">  329 </span><span class="spaces">        </span><span class="istickedoff">pure env</span>
<span class="lineno">  330 </span><span class="spaces">    </span><span class="istickedoff">SS.PVar allpos _xpos _x Nothing -&gt;</span>
<span class="lineno">  331 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">panic &quot;bindPatternEnv&quot; [</span></span>
<span class="lineno">  332 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot;Found pattern with no type in it&quot;,</span></span>
<span class="lineno">  333 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot;Source position: &quot; &lt;&gt; Text.pack (show allpos),</span></span>
<span class="lineno">  334 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot;Pattern: &quot; &lt;&gt; Text.pack (show pat)</span></span>
<span class="lineno">  335 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  336 </span><span class="spaces">    </span><span class="istickedoff">SS.PVar _allpos xpos x (Just ty) -&gt; do</span>
<span class="lineno">  337 </span><span class="spaces">        </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  338 </span><span class="spaces">        </span><span class="istickedoff">let s = fromMaybe <span class="nottickedoff">(SS.tMono ty)</span> ms</span>
<span class="lineno">  339 </span><span class="spaces">        </span><span class="istickedoff">liftIO $ extendEnv sc xpos x <span class="nottickedoff">SS.ReadOnlyVar</span> s <span class="nottickedoff">Nothing</span> v env</span>
<span class="lineno">  340 </span><span class="spaces">    </span><span class="istickedoff">SS.PTuple _pos ps -&gt;</span>
<span class="lineno">  341 </span><span class="spaces">      </span><span class="istickedoff">case v of</span>
<span class="lineno">  342 </span><span class="spaces">        </span><span class="istickedoff">VTuple vs -&gt; foldr (=&lt;&lt;) (pure env) (zipWith3 bindPatternEnv ps mss vs)</span>
<span class="lineno">  343 </span><span class="spaces">          </span><span class="istickedoff">where mss = case ms of</span>
<span class="lineno">  344 </span><span class="spaces">                  </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">repeat Nothing</span></span>
<span class="lineno">  345 </span><span class="spaces">                  </span><span class="istickedoff">Just (SS.Forall ks (SS.TyCon _ (SS.TupleCon _) ts)) -&gt;</span>
<span class="lineno">  346 </span><span class="spaces">                      </span><span class="istickedoff">[ Just (SS.Forall ks t) | t &lt;- ts ]</span>
<span class="lineno">  347 </span><span class="spaces">                  </span><span class="istickedoff">Just t -&gt;</span>
<span class="lineno">  348 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">panic &quot;bindPatternEnv&quot; [</span></span>
<span class="lineno">  349 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">&quot;Expected tuple type, got &quot; &lt;&gt; Text.pack (show t)</span></span>
<span class="lineno">  350 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  351 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  352 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">panic &quot;bindPatternEnv&quot; [</span></span>
<span class="lineno">  353 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">&quot;Expected tuple value; got &quot; &lt;&gt; Text.pack (show v)</span></span>
<span class="lineno">  354 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno">  355 </span>
<span class="lineno">  356 </span>
<span class="lineno">  357 </span>------------------------------------------------------------
<span class="lineno">  358 </span>-- InterpreterMonad
<span class="lineno">  359 </span>
<span class="lineno">  360 </span>-- Monad class to allow the interpreter to run in the Haskell
<span class="lineno">  361 </span>-- projection of the five SAWScript monads.
<span class="lineno">  362 </span>
<span class="lineno">  363 </span>class (Monad m, MonadFail m) =&gt; InterpreterMonad m where
<span class="lineno">  364 </span>  liftTopLevel :: TopLevel a -&gt; m a
<span class="lineno">  365 </span>  actionFromValue :: FromValue a =&gt; FromValueHow -&gt; Value -&gt; m a
<span class="lineno">  366 </span>  mkValue :: SS.Pos -&gt; RefChain -&gt; m Value -&gt; Value
<span class="lineno">  367 </span>  getMonadContext :: m SS.Context
<span class="lineno">  368 </span>  withLocalEnvAny :: LocalEnv -&gt; m a -&gt; m a
<span class="lineno">  369 </span>
<span class="lineno">  370 </span>instance InterpreterMonad TopLevel where
<span class="lineno">  371 </span>  <span class="decl"><span class="istickedoff">liftTopLevel m = m</span></span>
<span class="lineno">  372 </span>  <span class="decl"><span class="istickedoff">actionFromValue = fromValue</span></span>
<span class="lineno">  373 </span>  <span class="decl"><span class="istickedoff">mkValue pos chain m = VTopLevel <span class="nottickedoff">pos</span> chain m</span></span>
<span class="lineno">  374 </span>  <span class="decl"><span class="istickedoff">getMonadContext = return SS.TopLevel</span></span>
<span class="lineno">  375 </span>  <span class="decl"><span class="istickedoff">withLocalEnvAny = withLocalEnv</span></span>
<span class="lineno">  376 </span>
<span class="lineno">  377 </span>instance InterpreterMonad ProofScript where
<span class="lineno">  378 </span>  <span class="decl"><span class="istickedoff">liftTopLevel m = scriptTopLevel m</span></span>
<span class="lineno">  379 </span>  <span class="decl"><span class="istickedoff">actionFromValue = fromValue</span></span>
<span class="lineno">  380 </span>  <span class="decl"><span class="istickedoff">mkValue pos chain m = VProofScript <span class="nottickedoff">pos</span> chain m</span></span>
<span class="lineno">  381 </span>  <span class="decl"><span class="istickedoff">getMonadContext = return SS.ProofScript</span></span>
<span class="lineno">  382 </span>  <span class="decl"><span class="istickedoff">withLocalEnvAny = withLocalEnvProof</span></span>
<span class="lineno">  383 </span>
<span class="lineno">  384 </span>instance InterpreterMonad LLVMCrucibleSetupM where
<span class="lineno">  385 </span>  <span class="decl"><span class="istickedoff">liftTopLevel m = llvmTopLevel m</span></span>
<span class="lineno">  386 </span>  <span class="decl"><span class="istickedoff">actionFromValue = fromValue</span></span>
<span class="lineno">  387 </span>  <span class="decl"><span class="istickedoff">mkValue pos chain m = VLLVMCrucibleSetup pos chain m</span></span>
<span class="lineno">  388 </span>  <span class="decl"><span class="nottickedoff">getMonadContext = return SS.LLVMSetup</span></span>
<span class="lineno">  389 </span>  <span class="decl"><span class="istickedoff">withLocalEnvAny = withLocalEnvLLVM</span></span>
<span class="lineno">  390 </span>
<span class="lineno">  391 </span>instance InterpreterMonad JVMSetupM where
<span class="lineno">  392 </span>  <span class="decl"><span class="istickedoff">liftTopLevel m = jvmTopLevel m</span></span>
<span class="lineno">  393 </span>  <span class="decl"><span class="istickedoff">actionFromValue = fromValue</span></span>
<span class="lineno">  394 </span>  <span class="decl"><span class="istickedoff">mkValue pos chain m = VJVMSetup pos chain m</span></span>
<span class="lineno">  395 </span>  <span class="decl"><span class="nottickedoff">getMonadContext = return SS.JavaSetup</span></span>
<span class="lineno">  396 </span>  <span class="decl"><span class="istickedoff">withLocalEnvAny = withLocalEnvJVM</span></span>
<span class="lineno">  397 </span>
<span class="lineno">  398 </span>instance InterpreterMonad MIRSetupM where
<span class="lineno">  399 </span>  <span class="decl"><span class="istickedoff">liftTopLevel m = mirTopLevel m</span></span>
<span class="lineno">  400 </span>  <span class="decl"><span class="istickedoff">actionFromValue = fromValue</span></span>
<span class="lineno">  401 </span>  <span class="decl"><span class="istickedoff">mkValue pos chain m = VMIRSetup pos chain m</span></span>
<span class="lineno">  402 </span>  <span class="decl"><span class="nottickedoff">getMonadContext = return SS.MIRSetup</span></span>
<span class="lineno">  403 </span>  <span class="decl"><span class="istickedoff">withLocalEnvAny = withLocalEnvMIR</span></span>
<span class="lineno">  404 </span>
<span class="lineno">  405 </span>
<span class="lineno">  406 </span>------------------------------------------------------------
<span class="lineno">  407 </span>-- Typechecker
<span class="lineno">  408 </span>
<span class="lineno">  409 </span>-- Process a typechecker result.
<span class="lineno">  410 </span>-- Wraps the typechecker in the stuff needed to print its warnings and errors.
<span class="lineno">  411 </span>--
<span class="lineno">  412 </span>-- XXX: this code should probably live inside the typechecker.
<span class="lineno">  413 </span>--
<span class="lineno">  414 </span>-- Usage is processTypeCheck $ checkStmt ...
<span class="lineno">  415 </span>type MsgList = [(SS.Pos, String)]
<span class="lineno">  416 </span>processTypeCheck :: InterpreterMonad m =&gt; (Either MsgList a, MsgList) -&gt; m a
<span class="lineno">  417 </span><span class="decl"><span class="istickedoff">processTypeCheck (errs_or_output, warns) =</span>
<span class="lineno">  418 </span><span class="spaces">  </span><span class="istickedoff">liftTopLevel $ do</span>
<span class="lineno">  419 </span><span class="spaces">    </span><span class="istickedoff">let issueWarning (pos, msg) =</span>
<span class="lineno">  420 </span><span class="spaces">          </span><span class="istickedoff">-- XXX the print functions should be what knows how to show positions...</span>
<span class="lineno">  421 </span><span class="spaces">          </span><span class="istickedoff">printOutLnTop Warn (show pos ++ &quot;: Warning: &quot; ++ msg)</span>
<span class="lineno">  422 </span><span class="spaces">    </span><span class="istickedoff">mapM_ issueWarning warns</span>
<span class="lineno">  423 </span><span class="spaces">    </span><span class="istickedoff">either failTypecheck return errs_or_output</span></span>
<span class="lineno">  424 </span>
<span class="lineno">  425 </span>
<span class="lineno">  426 </span>------------------------------------------------------------
<span class="lineno">  427 </span>-- Interpreter core
<span class="lineno">  428 </span>
<span class="lineno">  429 </span>-- | Apply an argument value to a function value.
<span class="lineno">  430 </span>--   v1 must have type a -&gt; b; v2 must have type a.
<span class="lineno">  431 </span>--   The first (position) argument is the position where the
<span class="lineno">  432 </span>--   application happens.
<span class="lineno">  433 </span>--   The second (Text) argument is printed as part of the panic if v1
<span class="lineno">  434 </span>--   turns out not to be a function value.
<span class="lineno">  435 </span>applyValue :: SS.Pos -&gt; Text -&gt; Value -&gt; Value -&gt; TopLevel Value
<span class="lineno">  436 </span><span class="decl"><span class="istickedoff">applyValue pos v1info v1 v2 =</span>
<span class="lineno">  437 </span><span class="spaces">  </span><span class="istickedoff">let enter name = pushTraceFrame pos name</span>
<span class="lineno">  438 </span><span class="spaces">      </span><span class="istickedoff">leave = popTraceFrame</span>
<span class="lineno">  439 </span><span class="spaces">  </span><span class="istickedoff">in</span>
<span class="lineno">  440 </span><span class="spaces">  </span><span class="istickedoff">case v1 of</span>
<span class="lineno">  441 </span><span class="spaces">    </span><span class="istickedoff">VLambda env mname pat e -&gt; do</span>
<span class="lineno">  442 </span><span class="spaces">        </span><span class="istickedoff">let name = fromMaybe <span class="nottickedoff">&quot;(lambda)&quot;</span> mname</span>
<span class="lineno">  443 </span><span class="spaces">        </span><span class="istickedoff">enter name</span>
<span class="lineno">  444 </span><span class="spaces">        </span><span class="istickedoff">r &lt;- withLocalEnv (bindPatternLocal <span class="nottickedoff">SS.ReadOnlyVar</span> pat <span class="nottickedoff">Nothing</span> v2 env) (interpretExpr e)</span>
<span class="lineno">  445 </span><span class="spaces">        </span><span class="istickedoff">leave</span>
<span class="lineno">  446 </span><span class="spaces">        </span><span class="istickedoff">return $ insertRefChain pos name r</span>
<span class="lineno">  447 </span><span class="spaces">    </span><span class="istickedoff">VBuiltin name args wf -&gt; case wf of</span>
<span class="lineno">  448 </span><span class="spaces">        </span><span class="istickedoff">OneMoreArg f -&gt; do</span>
<span class="lineno">  449 </span><span class="spaces">            </span><span class="istickedoff">setPosition <span class="nottickedoff">pos</span></span>
<span class="lineno">  450 </span><span class="spaces">            </span><span class="istickedoff">enter name</span>
<span class="lineno">  451 </span><span class="spaces">            </span><span class="istickedoff">r &lt;- f v2</span>
<span class="lineno">  452 </span><span class="spaces">            </span><span class="istickedoff">leave</span>
<span class="lineno">  453 </span><span class="spaces">            </span><span class="istickedoff">return $ insertRefChain pos name r</span>
<span class="lineno">  454 </span><span class="spaces">        </span><span class="istickedoff">ManyMoreArgs f -&gt;</span>
<span class="lineno">  455 </span><span class="spaces">            </span><span class="istickedoff">-- f will still be partially applied after this, so it</span>
<span class="lineno">  456 </span><span class="spaces">            </span><span class="istickedoff">-- won't do anything and there's no need to enter/leave.</span>
<span class="lineno">  457 </span><span class="spaces">            </span><span class="istickedoff">VBuiltin name <span class="nottickedoff">(args :|&gt; v2)</span> &lt;$&gt; f v2</span>
<span class="lineno">  458 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  459 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">panic &quot;applyValue&quot; [</span></span>
<span class="lineno">  460 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot;Called object is not a function&quot;,</span></span>
<span class="lineno">  461 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot;Call site: &quot; &lt;&gt; Text.pack (show pos),</span></span>
<span class="lineno">  462 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot;Value found: &quot; &lt;&gt; Text.pack (show v1),</span></span>
<span class="lineno">  463 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">v1info</span></span>
<span class="lineno">  464 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno">  465 </span>
<span class="lineno">  466 </span>-- Eval an expression.
<span class="lineno">  467 </span>--
<span class="lineno">  468 </span>-- This executes purely: when we see a do-block, return it as a value.
<span class="lineno">  469 </span>-- If the caller is executing in a monad, it'll intercept that and
<span class="lineno">  470 </span>-- eval it.
<span class="lineno">  471 </span>--
<span class="lineno">  472 </span>-- This code lives in the interpreter monad anyway for two reasons:
<span class="lineno">  473 </span>-- first, properly, because it needs (readonly) access to the Cryptol
<span class="lineno">  474 </span>-- environment. This could conceivably just be passed in instead.
<span class="lineno">  475 </span>--
<span class="lineno">  476 </span>-- Second, improperly, a randomly-chosen selection of SAWScript
<span class="lineno">  477 </span>-- builtins are pure in SAWScript but not in Haskell; these execute
<span class="lineno">  478 </span>-- in TopLevel when the last argument is applied by applyValue, and
<span class="lineno">  479 </span>-- that happens inside here.
<span class="lineno">  480 </span>--
<span class="lineno">  481 </span>interpretExpr :: SS.Expr -&gt; TopLevel Value
<span class="lineno">  482 </span><span class="decl"><span class="istickedoff">interpretExpr expr =</span>
<span class="lineno">  483 </span><span class="spaces">    </span><span class="istickedoff">let ?fileReader = <span class="nottickedoff">BS.readFile</span> in</span>
<span class="lineno">  484 </span><span class="spaces">    </span><span class="istickedoff">case expr of</span>
<span class="lineno">  485 </span><span class="spaces">      </span><span class="istickedoff">SS.Bool _ b -&gt;</span>
<span class="lineno">  486 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">return $ VBool b</span></span>
<span class="lineno">  487 </span><span class="spaces">      </span><span class="istickedoff">SS.String _ s -&gt;</span>
<span class="lineno">  488 </span><span class="spaces">          </span><span class="istickedoff">return $ VString s</span>
<span class="lineno">  489 </span><span class="spaces">      </span><span class="istickedoff">SS.Int _ z -&gt;</span>
<span class="lineno">  490 </span><span class="spaces">          </span><span class="istickedoff">return $ VInteger z</span>
<span class="lineno">  491 </span><span class="spaces">      </span><span class="istickedoff">SS.Code pos str -&gt; do</span>
<span class="lineno">  492 </span><span class="spaces">          </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  493 </span><span class="spaces">          </span><span class="istickedoff">cenv &lt;- fmap rwCryptol getMergedEnv</span>
<span class="lineno">  494 </span><span class="spaces">          </span><span class="istickedoff">--io $ putStrLn $ &quot;Parsing code: &quot; ++ show str</span>
<span class="lineno">  495 </span><span class="spaces">          </span><span class="istickedoff">--showCryptolEnv' cenv</span>
<span class="lineno">  496 </span><span class="spaces">          </span><span class="istickedoff">let str' = toInputText pos str</span>
<span class="lineno">  497 </span><span class="spaces">          </span><span class="istickedoff">t &lt;- io $ CEnv.parseTypedTerm sc cenv str'</span>
<span class="lineno">  498 </span><span class="spaces">          </span><span class="istickedoff">return (VTerm t)</span>
<span class="lineno">  499 </span><span class="spaces">      </span><span class="istickedoff">SS.CType pos str -&gt; do</span>
<span class="lineno">  500 </span><span class="spaces">          </span><span class="istickedoff">cenv &lt;- fmap rwCryptol getMergedEnv</span>
<span class="lineno">  501 </span><span class="spaces">          </span><span class="istickedoff">let str' = toInputText pos str</span>
<span class="lineno">  502 </span><span class="spaces">          </span><span class="istickedoff">s &lt;- io $ CEnv.parseSchema cenv str'</span>
<span class="lineno">  503 </span><span class="spaces">          </span><span class="istickedoff">return (VType s)</span>
<span class="lineno">  504 </span><span class="spaces">      </span><span class="istickedoff">SS.Array _pos es -&gt;</span>
<span class="lineno">  505 </span><span class="spaces">          </span><span class="istickedoff">VArray &lt;$&gt; traverse interpretExpr es</span>
<span class="lineno">  506 </span><span class="spaces">      </span><span class="istickedoff">SS.Block _pos stmts -&gt; do</span>
<span class="lineno">  507 </span><span class="spaces">          </span><span class="istickedoff">env &lt;- getLocalEnv</span>
<span class="lineno">  508 </span><span class="spaces">          </span><span class="istickedoff">return $ VDo [] env stmts</span>
<span class="lineno">  509 </span><span class="spaces">      </span><span class="istickedoff">SS.Tuple _pos es -&gt;</span>
<span class="lineno">  510 </span><span class="spaces">          </span><span class="istickedoff">VTuple &lt;$&gt; traverse interpretExpr es</span>
<span class="lineno">  511 </span><span class="spaces">      </span><span class="istickedoff">SS.Record _pos bs -&gt;</span>
<span class="lineno">  512 </span><span class="spaces">          </span><span class="istickedoff">VRecord &lt;$&gt; traverse interpretExpr bs</span>
<span class="lineno">  513 </span><span class="spaces">      </span><span class="istickedoff">SS.Index pos e1 e2 -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  514 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">a &lt;- interpretExpr e1</span></span>
<span class="lineno">  515 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">i &lt;- interpretExpr e2</span></span>
<span class="lineno">  516 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">return (indexValue pos a i)</span></span>
<span class="lineno">  517 </span><span class="spaces">      </span><span class="istickedoff">SS.Lookup pos e n -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  518 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">a &lt;- interpretExpr e</span></span>
<span class="lineno">  519 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">return (lookupValue pos a n)</span></span>
<span class="lineno">  520 </span><span class="spaces">      </span><span class="istickedoff">SS.TLookup pos e i -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  521 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">a &lt;- interpretExpr e</span></span>
<span class="lineno">  522 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">return (tupleLookupValue pos a i)</span></span>
<span class="lineno">  523 </span><span class="spaces">      </span><span class="istickedoff">SS.Var pos x -&gt; do</span>
<span class="lineno">  524 </span><span class="spaces">          </span><span class="istickedoff">rw &lt;- getMergedEnv</span>
<span class="lineno">  525 </span><span class="spaces">          </span><span class="istickedoff">case Map.lookup x (rwValueInfo rw) of</span>
<span class="lineno">  526 </span><span class="spaces">            </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  527 </span><span class="spaces">                </span><span class="istickedoff">-- This should be rejected by the typechecker, so panic</span>
<span class="lineno">  528 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">panic &quot;interpretExpr&quot; [</span></span>
<span class="lineno">  529 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">&quot;Read of unknown variable &quot; &lt;&gt; x</span></span>
<span class="lineno">  530 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  531 </span><span class="spaces">            </span><span class="istickedoff">Just (_defpos, lc, _rebindable, _ty, v, _doc)</span>
<span class="lineno">  532 </span><span class="spaces">              </span><span class="istickedoff">| <span class="tickonlytrue">Set.member lc (rwPrimsAvail rw)</span> -&gt; do</span>
<span class="lineno">  533 </span><span class="spaces">                   </span><span class="istickedoff">let v' = injectPositionIntoMonadicValue <span class="nottickedoff">pos</span> v</span>
<span class="lineno">  534 </span><span class="spaces">                       </span><span class="istickedoff">v'' = insertRefChain pos x v'</span>
<span class="lineno">  535 </span><span class="spaces">                   </span><span class="istickedoff">return v''</span>
<span class="lineno">  536 </span><span class="spaces">              </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> -&gt;</span>
<span class="lineno">  537 </span><span class="spaces">                   </span><span class="istickedoff">-- This case is also rejected by the typechecker</span>
<span class="lineno">  538 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">panic &quot;interpretExpr&quot; [</span></span>
<span class="lineno">  539 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">&quot;Read of inaccessible variable &quot; &lt;&gt; x</span></span>
<span class="lineno">  540 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  541 </span><span class="spaces">      </span><span class="istickedoff">SS.Lambda _pos mname pat e -&gt; do</span>
<span class="lineno">  542 </span><span class="spaces">          </span><span class="istickedoff">env &lt;- getLocalEnv</span>
<span class="lineno">  543 </span><span class="spaces">          </span><span class="istickedoff">return $ VLambda env mname pat e</span>
<span class="lineno">  544 </span><span class="spaces">      </span><span class="istickedoff">SS.Application pos e1 e2 -&gt; do</span>
<span class="lineno">  545 </span><span class="spaces">          </span><span class="istickedoff">let <span class="nottickedoff">v1info = &quot;Expression: &quot; &lt;&gt; PPS.pShowText e1</span></span>
<span class="lineno">  546 </span><span class="spaces">          </span><span class="istickedoff">v1 &lt;- interpretExpr e1</span>
<span class="lineno">  547 </span><span class="spaces">          </span><span class="istickedoff">v2 &lt;- interpretExpr e2</span>
<span class="lineno">  548 </span><span class="spaces">          </span><span class="istickedoff">let v2' = injectPositionIntoMonadicValue (SS.getPos e2) v2</span>
<span class="lineno">  549 </span><span class="spaces">          </span><span class="istickedoff">applyValue pos <span class="nottickedoff">v1info</span> v1 v2'</span>
<span class="lineno">  550 </span><span class="spaces">      </span><span class="istickedoff">SS.Let _ dg e -&gt; do</span>
<span class="lineno">  551 </span><span class="spaces">          </span><span class="istickedoff">env' &lt;- interpretDeclGroup <span class="nottickedoff">SS.ReadOnlyVar</span> dg</span>
<span class="lineno">  552 </span><span class="spaces">          </span><span class="istickedoff">withLocalEnv env' (interpretExpr e)</span>
<span class="lineno">  553 </span><span class="spaces">      </span><span class="istickedoff">SS.TSig _ e _ -&gt;</span>
<span class="lineno">  554 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">interpretExpr e</span></span>
<span class="lineno">  555 </span><span class="spaces">      </span><span class="istickedoff">SS.IfThenElse pos e1 e2 e3 -&gt; do</span>
<span class="lineno">  556 </span><span class="spaces">          </span><span class="istickedoff">v1 &lt;- interpretExpr e1</span>
<span class="lineno">  557 </span><span class="spaces">          </span><span class="istickedoff">case v1 of</span>
<span class="lineno">  558 </span><span class="spaces">            </span><span class="istickedoff">VBool b -&gt;</span>
<span class="lineno">  559 </span><span class="spaces">              </span><span class="istickedoff">interpretExpr (if b then e2 else e3)</span>
<span class="lineno">  560 </span><span class="spaces">            </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  561 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">panic &quot;interpretExpr&quot; [</span></span>
<span class="lineno">  562 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">&quot;Ill-typed value in if-expression (should be Bool)&quot;,</span></span>
<span class="lineno">  563 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">&quot;Source position: &quot; &lt;&gt; Text.pack (show pos),</span></span>
<span class="lineno">  564 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">&quot;Value found: &quot; &lt;&gt; Text.pack (show v1),</span></span>
<span class="lineno">  565 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">&quot;Expression: &quot; &lt;&gt; PPS.pShowText e1</span></span>
<span class="lineno">  566 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno">  567 </span>
<span class="lineno">  568 </span>-- Eval a &quot;decl&quot;, which is the RHS of a let-binding.
<span class="lineno">  569 </span>-- Evaluates the body expression purely.
<span class="lineno">  570 </span>interpretDecl :: SS.Rebindable -&gt; LocalEnv -&gt; SS.Decl -&gt; TopLevel LocalEnv
<span class="lineno">  571 </span><span class="decl"><span class="istickedoff">interpretDecl rebindable env (SS.Decl _ pat mt expr) = do</span>
<span class="lineno">  572 </span><span class="spaces">    </span><span class="istickedoff">v &lt;- interpretExpr expr</span>
<span class="lineno">  573 </span><span class="spaces">    </span><span class="istickedoff">return (bindPatternLocal rebindable pat mt v env)</span></span>
<span class="lineno">  574 </span>
<span class="lineno">  575 </span>-- Eval the RHS of a single let-binding in a mutually recursive group.
<span class="lineno">  576 </span>-- These are required to be functions; that's enforced by the
<span class="lineno">  577 </span>-- typechecker.
<span class="lineno">  578 </span>interpretFunction :: LocalEnv -&gt; SS.Expr -&gt; Value
<span class="lineno">  579 </span><span class="decl"><span class="istickedoff">interpretFunction env expr =</span>
<span class="lineno">  580 </span><span class="spaces">    </span><span class="istickedoff">case expr of</span>
<span class="lineno">  581 </span><span class="spaces">      </span><span class="istickedoff">SS.Lambda _ mname pat e -&gt; VLambda <span class="nottickedoff">env</span> <span class="nottickedoff">mname</span> <span class="nottickedoff">pat</span> <span class="nottickedoff">e</span></span>
<span class="lineno">  582 </span><span class="spaces">      </span><span class="istickedoff">SS.TSig _ e _ -&gt; <span class="nottickedoff">interpretFunction env e</span></span>
<span class="lineno">  583 </span><span class="spaces">      </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  584 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">panic &quot;interpretFunction&quot; [</span></span>
<span class="lineno">  585 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot;Not a function&quot;,</span></span>
<span class="lineno">  586 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot;Expression found: &quot; &lt;&gt; PPS.pShowText expr</span></span>
<span class="lineno">  587 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno">  588 </span>
<span class="lineno">  589 </span>-- Eval a &quot;decl group&quot;, which is a let-binding or group of mutually
<span class="lineno">  590 </span>-- recursive let-bindings.
<span class="lineno">  591 </span>interpretDeclGroup :: SS.Rebindable -&gt; SS.DeclGroup -&gt; TopLevel LocalEnv
<span class="lineno">  592 </span><span class="decl"><span class="istickedoff">interpretDeclGroup rebindable (SS.NonRecursive d) = do</span>
<span class="lineno">  593 </span><span class="spaces">    </span><span class="istickedoff">env &lt;- getLocalEnv</span>
<span class="lineno">  594 </span><span class="spaces">    </span><span class="istickedoff">interpretDecl rebindable env d</span>
<span class="lineno">  595 </span><span class="spaces"></span><span class="istickedoff">interpretDeclGroup rebindable (SS.Recursive ds) = do</span>
<span class="lineno">  596 </span><span class="spaces">    </span><span class="istickedoff">env &lt;- getLocalEnv</span>
<span class="lineno">  597 </span><span class="spaces">    </span><span class="istickedoff">let addDecl (SS.Decl _ pat mty e) =</span>
<span class="lineno">  598 </span><span class="spaces">            </span><span class="istickedoff">bindPatternLocal <span class="nottickedoff">rebindable</span> pat <span class="nottickedoff">mty</span> (interpretFunction <span class="nottickedoff">env'</span> e)</span>
<span class="lineno">  599 </span><span class="spaces">        </span><span class="istickedoff">env' = foldr addDecl env ds</span>
<span class="lineno">  600 </span><span class="spaces">    </span><span class="istickedoff">return env'</span></span>
<span class="lineno">  601 </span>
<span class="lineno">  602 </span>-- Bind a monadic value into the monadic execution sequence.
<span class="lineno">  603 </span>--
<span class="lineno">  604 </span>-- Takes a monadic value that might be a VDo, VBindOnce, VReturn, or
<span class="lineno">  605 </span>-- plain monadic value, run it through the interpreter as necessary to
<span class="lineno">  606 </span>-- get a plain monadic value, then bind it in Haskell to get a result.
<span class="lineno">  607 </span>-- Returns the resulting Value. Runs in any interpreter monad.
<span class="lineno">  608 </span>--
<span class="lineno">  609 </span>-- Even though this is called from multiple places, in each case it's
<span class="lineno">  610 </span>-- the interpreter doing a SAWScript-level bind so we are always
<span class="lineno">  611 </span>-- coming from the interpreter.
<span class="lineno">  612 </span>--
<span class="lineno">  613 </span>-- There are three steps:
<span class="lineno">  614 </span>--    - Run it in the interpreter with interpretMonadAction, in case
<span class="lineno">  615 </span>--      it's a do-block. (plainVal should then always be a plain
<span class="lineno">  616 </span>--      monadic value with a Haskell monadic action in it.)
<span class="lineno">  617 </span>--    - Update the value metadata. (Specifically: insert the bind
<span class="lineno">  618 </span>--      position into the plain monadic value we get back from the
<span class="lineno">  619 </span>--      interpreter, as its position of last reference.)
<span class="lineno">  620 </span>--    - Fetch the Haskell-level monadic action with fromValue and bind
<span class="lineno">  621 </span>--      that in Haskell to execute it.
<span class="lineno">  622 </span>--
<span class="lineno">  623 </span>-- Note that calling interpretMonadAction here is necessary for the
<span class="lineno">  624 </span>-- moment (even though it's also called from fromValue /
<span class="lineno">  625 </span>-- actionFromValue) because we need the result to do the position
<span class="lineno">  626 </span>-- update.
<span class="lineno">  627 </span>--
<span class="lineno">  628 </span>bindMonadAction :: forall m. InterpreterMonad m =&gt; SS.Pos -&gt; Value -&gt; m Value
<span class="lineno">  629 </span><span class="decl"><span class="istickedoff">bindMonadAction pos baseVal = do</span>
<span class="lineno">  630 </span><span class="spaces">    </span><span class="istickedoff">plainVal &lt;- interpretMonadAction FromInterpreter baseVal</span>
<span class="lineno">  631 </span><span class="spaces">    </span><span class="istickedoff">let plainVal' = injectPositionIntoMonadicValue pos plainVal</span>
<span class="lineno">  632 </span><span class="spaces">    </span><span class="istickedoff">result &lt;- actionFromValue FromInterpreter plainVal'</span>
<span class="lineno">  633 </span><span class="spaces">    </span><span class="istickedoff">return result</span></span>
<span class="lineno">  634 </span>
<span class="lineno">  635 </span>-- Execute a monad action. This happens in any of the interpreter
<span class="lineno">  636 </span>-- monads.
<span class="lineno">  637 </span>interpretMonadAction :: forall m. InterpreterMonad m =&gt; FromValueHow -&gt; Value -&gt; m Value
<span class="lineno">  638 </span><span class="decl"><span class="istickedoff">interpretMonadAction fromHow v = case v of</span>
<span class="lineno">  639 </span><span class="spaces">  </span><span class="istickedoff">VReturn pos chain v' -&gt; do</span>
<span class="lineno">  640 </span><span class="spaces">    </span><span class="istickedoff">-- VReturn ... v' -&gt; VProofScript ... (return v')</span>
<span class="lineno">  641 </span><span class="spaces">    </span><span class="istickedoff">-- (or whichever value for whichever monad)</span>
<span class="lineno">  642 </span><span class="spaces">    </span><span class="istickedoff">let v'' :: m Value = return v'</span>
<span class="lineno">  643 </span><span class="spaces">    </span><span class="istickedoff">return $ mkValue <span class="nottickedoff">pos</span> chain v''</span>
<span class="lineno">  644 </span><span class="spaces">  </span><span class="istickedoff">VDo chain env body -&gt; do</span>
<span class="lineno">  645 </span><span class="spaces">    </span><span class="istickedoff">liftTopLevel $ do</span>
<span class="lineno">  646 </span><span class="spaces">      </span><span class="istickedoff">case fromHow of</span>
<span class="lineno">  647 </span><span class="spaces">          </span><span class="istickedoff">FromInterpreter -&gt; pure <span class="nottickedoff">()</span></span>
<span class="lineno">  648 </span><span class="spaces">          </span><span class="istickedoff">FromArgument -&gt; pushTraceFrame SS.PosInsideBuiltin &quot;(callback)&quot;</span>
<span class="lineno">  649 </span><span class="spaces">      </span><span class="istickedoff">pushTraceFrames chain</span>
<span class="lineno">  650 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  651 </span><span class="spaces">    </span><span class="istickedoff">r &lt;- withLocalEnvAny env (interpretDoStmts body)</span>
<span class="lineno">  652 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  653 </span><span class="spaces">    </span><span class="istickedoff">liftTopLevel $ do</span>
<span class="lineno">  654 </span><span class="spaces">      </span><span class="istickedoff">popTraceFrames chain</span>
<span class="lineno">  655 </span><span class="spaces">      </span><span class="istickedoff">case fromHow of</span>
<span class="lineno">  656 </span><span class="spaces">          </span><span class="istickedoff">FromInterpreter -&gt; pure <span class="nottickedoff">()</span></span>
<span class="lineno">  657 </span><span class="spaces">          </span><span class="istickedoff">FromArgument -&gt; popTraceFrame</span>
<span class="lineno">  658 </span><span class="spaces">    </span><span class="istickedoff">return $ propagateRefChain chain r</span>
<span class="lineno">  659 </span><span class="spaces">  </span><span class="istickedoff">VBindOnce pos chain baseVal1 val2 -&gt; do</span>
<span class="lineno">  660 </span><span class="spaces">    </span><span class="istickedoff">-- baseVal1 is a monadic value of the same class as returned by</span>
<span class="lineno">  661 </span><span class="spaces">    </span><span class="istickedoff">-- interpretExpr (that is, it might be a VDo or a VBindOnce).</span>
<span class="lineno">  662 </span><span class="spaces">    </span><span class="istickedoff">-- Bind it.</span>
<span class="lineno">  663 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno">  664 </span><span class="spaces">    </span><span class="istickedoff">-- Note that even if the _bind_ is triggered with FromArgument,</span>
<span class="lineno">  665 </span><span class="spaces">    </span><span class="istickedoff">-- the contents are executed right here from the interpreter.</span>
<span class="lineno">  666 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno">  667 </span><span class="spaces">    </span><span class="istickedoff">-- Wrap the execution (of the whole sequence of binds) in the frames</span>
<span class="lineno">  668 </span><span class="spaces">    </span><span class="istickedoff">-- from the RefChain the same way as a do-block.</span>
<span class="lineno">  669 </span><span class="spaces">    </span><span class="istickedoff">liftTopLevel $ do</span>
<span class="lineno">  670 </span><span class="spaces">      </span><span class="istickedoff">case fromHow of</span>
<span class="lineno">  671 </span><span class="spaces">          </span><span class="istickedoff">FromInterpreter -&gt; pure <span class="nottickedoff">()</span></span>
<span class="lineno">  672 </span><span class="spaces">          </span><span class="istickedoff">FromArgument -&gt; <span class="nottickedoff">pushTraceFrame SS.PosInsideBuiltin &quot;(callback)&quot;</span></span>
<span class="lineno">  673 </span><span class="spaces">      </span><span class="istickedoff">pushTraceFrames chain</span>
<span class="lineno">  674 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  675 </span><span class="spaces">    </span><span class="istickedoff">result1 &lt;- bindMonadAction pos baseVal1</span>
<span class="lineno">  676 </span><span class="spaces">    </span><span class="istickedoff">-- val2 is a lambda or equivalent that expects the result as an</span>
<span class="lineno">  677 </span><span class="spaces">    </span><span class="istickedoff">-- argument (the traditional &gt;&gt;= form of monad bind)</span>
<span class="lineno">  678 </span><span class="spaces">    </span><span class="istickedoff">result2 &lt;- liftTopLevel $ applyValue pos <span class="nottickedoff">&quot;Value in a VBindOnce&quot;</span> val2 result1</span>
<span class="lineno">  679 </span><span class="spaces">    </span><span class="istickedoff">result3 &lt;- interpretMonadAction FromInterpreter result2</span>
<span class="lineno">  680 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  681 </span><span class="spaces">    </span><span class="istickedoff">liftTopLevel $ do</span>
<span class="lineno">  682 </span><span class="spaces">      </span><span class="istickedoff">popTraceFrames chain</span>
<span class="lineno">  683 </span><span class="spaces">      </span><span class="istickedoff">case fromHow of</span>
<span class="lineno">  684 </span><span class="spaces">          </span><span class="istickedoff">FromInterpreter -&gt; pure <span class="nottickedoff">()</span></span>
<span class="lineno">  685 </span><span class="spaces">          </span><span class="istickedoff">FromArgument -&gt; <span class="nottickedoff">popTraceFrame</span></span>
<span class="lineno">  686 </span><span class="spaces">    </span><span class="istickedoff">-- Handle the RefChain the same way as a do-block. Note that with</span>
<span class="lineno">  687 </span><span class="spaces">    </span><span class="istickedoff">-- luck we don't have to worry about unwanted additional RefChain</span>
<span class="lineno">  688 </span><span class="spaces">    </span><span class="istickedoff">-- entries in the second and subsequent VBindOnce values in a</span>
<span class="lineno">  689 </span><span class="spaces">    </span><span class="istickedoff">-- sequence of them; they should never have the opportunity to</span>
<span class="lineno">  690 </span><span class="spaces">    </span><span class="istickedoff">-- grow their own references. If we had an explicit bind operator</span>
<span class="lineno">  691 </span><span class="spaces">    </span><span class="istickedoff">-- in the language, that might be a problem, but we don't and we</span>
<span class="lineno">  692 </span><span class="spaces">    </span><span class="istickedoff">-- aren't getting one. So the only bind sequences we have are</span>
<span class="lineno">  693 </span><span class="spaces">    </span><span class="istickedoff">-- canned. (And in particular there's only one, in the &quot;for&quot;</span>
<span class="lineno">  694 </span><span class="spaces">    </span><span class="istickedoff">-- builtin.)</span>
<span class="lineno">  695 </span><span class="spaces">    </span><span class="istickedoff">return $ propagateRefChain chain result3</span>
<span class="lineno">  696 </span><span class="spaces">  </span><span class="istickedoff">_ -&gt; pure v</span></span>
<span class="lineno">  697 </span>
<span class="lineno">  698 </span>
<span class="lineno">  699 </span>-- Eval a statement from a do-block. This happens in some monad; we
<span class="lineno">  700 </span>-- only come here once the monad action is executed. Therefore, we can
<span class="lineno">  701 </span>-- execute binds: if we get a do-block back, execute it recursively.
<span class="lineno">  702 </span>-- (Such a do-block must be in the same monad in order to be well
<span class="lineno">  703 </span>-- typed.)
<span class="lineno">  704 </span>--
<span class="lineno">  705 </span>-- In let-bindings the RHS is evaluated purely.
<span class="lineno">  706 </span>--
<span class="lineno">  707 </span>-- Returns the updated local environment.
<span class="lineno">  708 </span>-- (XXX: should that be stored into the monad context or not? Apparently
<span class="lineno">  709 </span>-- not, currently.)
<span class="lineno">  710 </span>--
<span class="lineno">  711 </span>interpretDoStmt :: forall m. InterpreterMonad m =&gt; SS.Stmt -&gt; m LocalEnv
<span class="lineno">  712 </span><span class="decl"><span class="istickedoff">interpretDoStmt stmt =</span>
<span class="lineno">  713 </span><span class="spaces">    </span><span class="istickedoff">let ?fileReader = <span class="nottickedoff">BS.readFile</span> in</span>
<span class="lineno">  714 </span><span class="spaces">    </span><span class="istickedoff">-- XXX are the uses of push/popPosition here suitable? not super clear</span>
<span class="lineno">  715 </span><span class="spaces">    </span><span class="istickedoff">case stmt of</span>
<span class="lineno">  716 </span><span class="spaces">      </span><span class="istickedoff">SS.StmtBind pos pat e -&gt; do</span>
<span class="lineno">  717 </span><span class="spaces">          </span><span class="istickedoff">env &lt;- liftTopLevel getLocalEnv</span>
<span class="lineno">  718 </span><span class="spaces">          </span><span class="istickedoff">-- Execute the expression purely first. (&quot;purely&quot;)</span>
<span class="lineno">  719 </span><span class="spaces">          </span><span class="istickedoff">baseVal :: Value &lt;- liftTopLevel $ interpretExpr e</span>
<span class="lineno">  720 </span><span class="spaces">          </span><span class="istickedoff">-- Now bind the resulting value to execute it.</span>
<span class="lineno">  721 </span><span class="spaces">          </span><span class="istickedoff">--</span>
<span class="lineno">  722 </span><span class="spaces">          </span><span class="istickedoff">-- No trace frames here because the logic is inside</span>
<span class="lineno">  723 </span><span class="spaces">          </span><span class="istickedoff">-- interpretMonadAction and fromValue (for the interpreter</span>
<span class="lineno">  724 </span><span class="spaces">          </span><span class="istickedoff">-- and Haskell-level execution respectively).</span>
<span class="lineno">  725 </span><span class="spaces">          </span><span class="istickedoff">result :: Value &lt;- bindMonadAction pos baseVal</span>
<span class="lineno">  726 </span><span class="spaces">          </span><span class="istickedoff">-- Bind (in the name-binding, not monad-binding sense) the</span>
<span class="lineno">  727 </span><span class="spaces">          </span><span class="istickedoff">-- result to the pattern.</span>
<span class="lineno">  728 </span><span class="spaces">          </span><span class="istickedoff">return $ bindPatternLocal <span class="nottickedoff">SS.ReadOnlyVar</span> pat Nothing result env</span>
<span class="lineno">  729 </span><span class="spaces">      </span><span class="istickedoff">SS.StmtLet _pos rebindable dg -&gt; do</span>
<span class="lineno">  730 </span><span class="spaces">          </span><span class="istickedoff">-- Process the declarations</span>
<span class="lineno">  731 </span><span class="spaces">          </span><span class="istickedoff">liftTopLevel $ interpretDeclGroup <span class="nottickedoff">rebindable</span> dg</span>
<span class="lineno">  732 </span><span class="spaces">      </span><span class="istickedoff">SS.StmtCode _ spos str -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  733 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">liftTopLevel $ do</span></span>
<span class="lineno">  734 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">sc &lt;- getSharedContext</span></span>
<span class="lineno">  735 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">rw &lt;- getMergedEnv</span></span>
<span class="lineno">  736 </span><span class="spaces"></span><span class="istickedoff"><span class="nottickedoff"></span></span>
<span class="lineno">  737 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">let str' = toInputText spos str</span></span>
<span class="lineno">  738 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">ce' &lt;- io $ CEnv.parseDecls sc (rwCryptol rw) str'</span></span>
<span class="lineno">  739 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">-- FIXME: Local bindings get saved into the global cryptol environment here.</span></span>
<span class="lineno">  740 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">-- We should change parseDecls to return only the new bindings instead.</span></span>
<span class="lineno">  741 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">putTopLevelRW $ rw{rwCryptol = ce'}</span></span>
<span class="lineno">  742 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">-- return the current local environment unchanged</span></span>
<span class="lineno">  743 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">liftTopLevel getLocalEnv</span></span>
<span class="lineno">  744 </span><span class="spaces">      </span><span class="istickedoff">SS.StmtImport _ _ -&gt;</span>
<span class="lineno">  745 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">fail &quot;block-level import unimplemented&quot;</span></span>
<span class="lineno">  746 </span><span class="spaces">      </span><span class="istickedoff">SS.StmtTypedef _ _ name ty -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  747 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">env &lt;- liftTopLevel $ getLocalEnv</span></span>
<span class="lineno">  748 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">return $ LocalTypedef name ty : env</span></span></span>
<span class="lineno">  749 </span>
<span class="lineno">  750 </span>-- Eval some statements from a do-block.
<span class="lineno">  751 </span>--
<span class="lineno">  752 </span>-- The last statement is special because it produces the value of the
<span class="lineno">  753 </span>-- do-block; it is just an expression and not a statement, and appears
<span class="lineno">  754 </span>-- as a bind of _. The typechecker enforces that we won't see a block
<span class="lineno">  755 </span>-- with something else at the end.
<span class="lineno">  756 </span>--
<span class="lineno">  757 </span>-- FUTURE: after fixing the environment handling this should be able
<span class="lineno">  758 </span>-- to just use mapM on the statements and not need to nest the last
<span class="lineno">  759 </span>-- expression inside recursing on the statements.
<span class="lineno">  760 </span>--
<span class="lineno">  761 </span>interpretDoStmts :: forall m. InterpreterMonad m =&gt; ([SS.Stmt], SS.Expr) -&gt; m Value
<span class="lineno">  762 </span><span class="decl"><span class="istickedoff">interpretDoStmts (stmts, lastexpr) =</span>
<span class="lineno">  763 </span><span class="spaces">    </span><span class="istickedoff">case stmts of</span>
<span class="lineno">  764 </span><span class="spaces">      </span><span class="istickedoff">[] -&gt; do</span>
<span class="lineno">  765 </span><span class="spaces">          </span><span class="istickedoff">-- The position for the bind we're about to do will be the</span>
<span class="lineno">  766 </span><span class="spaces">          </span><span class="istickedoff">-- source position of the expression.</span>
<span class="lineno">  767 </span><span class="spaces">          </span><span class="istickedoff">let pos = SS.getPos lastexpr</span>
<span class="lineno">  768 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  769 </span><span class="spaces">          </span><span class="istickedoff">-- Execute the expression purely first.</span>
<span class="lineno">  770 </span><span class="spaces">          </span><span class="istickedoff">baseVal :: Value &lt;- liftTopLevel $ interpretExpr lastexpr</span>
<span class="lineno">  771 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  772 </span><span class="spaces">          </span><span class="istickedoff">-- Now (monad-)bind the resulting value and execute it.</span>
<span class="lineno">  773 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  774 </span><span class="spaces">          </span><span class="istickedoff">-- If we got a do-block or similar back, execute it now.</span>
<span class="lineno">  775 </span><span class="spaces">          </span><span class="istickedoff">--</span>
<span class="lineno">  776 </span><span class="spaces">          </span><span class="istickedoff">-- In principle we should return the plain monadic value as</span>
<span class="lineno">  777 </span><span class="spaces">          </span><span class="istickedoff">-- the result of the block and let the caller execute</span>
<span class="lineno">  778 </span><span class="spaces">          </span><span class="istickedoff">-- it. Instead, bind it now and construct a return of the</span>
<span class="lineno">  779 </span><span class="spaces">          </span><span class="istickedoff">-- result. (As in: replace &quot;do { ...; e; }&quot; with &quot;do { ...;</span>
<span class="lineno">  780 </span><span class="spaces">          </span><span class="istickedoff">-- r &lt;- e; return r; }&quot;.) In the common case where the last</span>
<span class="lineno">  781 </span><span class="spaces">          </span><span class="istickedoff">-- expression is just a return, this has no effect, and</span>
<span class="lineno">  782 </span><span class="spaces">          </span><span class="istickedoff">-- these are semantically equivalent; but if it actually</span>
<span class="lineno">  783 </span><span class="spaces">          </span><span class="istickedoff">-- does something, letting the caller execute it is akin to</span>
<span class="lineno">  784 </span><span class="spaces">          </span><span class="istickedoff">-- tail-call optimization and breaks stack traces.</span>
<span class="lineno">  785 </span><span class="spaces">          </span><span class="istickedoff">--</span>
<span class="lineno">  786 </span><span class="spaces">          </span><span class="istickedoff">-- FUTURE: do this transform on the AST upstream before</span>
<span class="lineno">  787 </span><span class="spaces">          </span><span class="istickedoff">-- executing; that can more readily avoid doing the</span>
<span class="lineno">  788 </span><span class="spaces">          </span><span class="istickedoff">-- transform if the last expression is already a return.</span>
<span class="lineno">  789 </span><span class="spaces">          </span><span class="istickedoff">--</span>
<span class="lineno">  790 </span><span class="spaces">          </span><span class="istickedoff">-- No trace frames here because the logic is inside</span>
<span class="lineno">  791 </span><span class="spaces">          </span><span class="istickedoff">-- interpretMonadAction and fromValue (for the interpreter</span>
<span class="lineno">  792 </span><span class="spaces">          </span><span class="istickedoff">-- and Haskell-level execution respectively).</span>
<span class="lineno">  793 </span><span class="spaces">          </span><span class="istickedoff">--</span>
<span class="lineno">  794 </span><span class="spaces">          </span><span class="istickedoff">result :: Value &lt;- bindMonadAction pos baseVal</span>
<span class="lineno">  795 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  796 </span><span class="spaces">          </span><span class="istickedoff">-- Don't return a VReturn here, because there isn't</span>
<span class="lineno">  797 </span><span class="spaces">          </span><span class="istickedoff">-- necessarily a following call to interpretMonadAction to</span>
<span class="lineno">  798 </span><span class="spaces">          </span><span class="istickedoff">-- unfold it. Instead, produce the unfolded form directly.</span>
<span class="lineno">  799 </span><span class="spaces">          </span><span class="istickedoff">-- Which requires some gyrations to feed the monad type in.</span>
<span class="lineno">  800 </span><span class="spaces">          </span><span class="istickedoff">let result' :: m Value = return result</span>
<span class="lineno">  801 </span><span class="spaces">          </span><span class="istickedoff">return $ mkValue pos [] result'</span>
<span class="lineno">  802 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  803 </span><span class="spaces">      </span><span class="istickedoff">stmt : more -&gt; do</span>
<span class="lineno">  804 </span><span class="spaces">          </span><span class="istickedoff">-- Execute the expression and get the updated environment</span>
<span class="lineno">  805 </span><span class="spaces">          </span><span class="istickedoff">env' &lt;- interpretDoStmt stmt</span>
<span class="lineno">  806 </span><span class="spaces">          </span><span class="istickedoff">-- Run the rest of the block with the updated environment</span>
<span class="lineno">  807 </span><span class="spaces">          </span><span class="istickedoff">withLocalEnvAny env' (interpretDoStmts (more, lastexpr))</span></span>
<span class="lineno">  808 </span>
<span class="lineno">  809 </span>-- Execute a top-level bind.
<span class="lineno">  810 </span>processStmtBind ::
<span class="lineno">  811 </span>  InterpreterMonad m =&gt;
<span class="lineno">  812 </span>  Bool -&gt;
<span class="lineno">  813 </span>  SS.Pos -&gt;
<span class="lineno">  814 </span>  SS.Pattern -&gt;
<span class="lineno">  815 </span>  SS.Expr -&gt;
<span class="lineno">  816 </span>  m ()
<span class="lineno">  817 </span><span class="decl"><span class="istickedoff">processStmtBind printBinds pos pat expr = do -- mx mt</span>
<span class="lineno">  818 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- liftTopLevel getMergedEnv</span>
<span class="lineno">  819 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  820 </span><span class="spaces">  </span><span class="istickedoff">-- Eval the expression</span>
<span class="lineno">  821 </span><span class="spaces">  </span><span class="istickedoff">baseVal &lt;- liftTopLevel $ interpretExpr expr</span>
<span class="lineno">  822 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  823 </span><span class="spaces">  </span><span class="istickedoff">-- Fetch the type from updated pattern, since the typechecker will</span>
<span class="lineno">  824 </span><span class="spaces">  </span><span class="istickedoff">-- have filled it in there.</span>
<span class="lineno">  825 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno">  826 </span><span class="spaces">  </span><span class="istickedoff">-- Note that this type won't include the current monad type, because</span>
<span class="lineno">  827 </span><span class="spaces">  </span><span class="istickedoff">-- it's the type of the value that the pattern on the left of &lt;- is</span>
<span class="lineno">  828 </span><span class="spaces">  </span><span class="istickedoff">-- trying to bind.</span>
<span class="lineno">  829 </span><span class="spaces">  </span><span class="istickedoff">let ty = getType pat</span>
<span class="lineno">  830 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  831 </span><span class="spaces">  </span><span class="istickedoff">-- Reject polymorphic values. XXX: as noted above this should either</span>
<span class="lineno">  832 </span><span class="spaces">  </span><span class="istickedoff">-- be inside the typechecker or restricted to the repl.</span>
<span class="lineno">  833 </span><span class="spaces">  </span><span class="istickedoff">when (isPolymorphic ty) $ fail $ &quot;Not a monomorphic type: &quot; ++ PPS.pShow ty</span>
<span class="lineno">  834 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  835 </span><span class="spaces">  </span><span class="istickedoff">-- Now bind the resulting value using bindMonadAction.</span>
<span class="lineno">  836 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno">  837 </span><span class="spaces">  </span><span class="istickedoff">-- No trace frames here because the logic is inside</span>
<span class="lineno">  838 </span><span class="spaces">  </span><span class="istickedoff">-- interpretMonadAction and fromValue (for the interpreter and</span>
<span class="lineno">  839 </span><span class="spaces">  </span><span class="istickedoff">-- Haskell-level execution respectively).</span>
<span class="lineno">  840 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno">  841 </span><span class="spaces">  </span><span class="istickedoff">result &lt;- bindMonadAction pos baseVal</span>
<span class="lineno">  842 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  843 </span><span class="spaces">  </span><span class="istickedoff">--io $ putStrLn $ &quot;Top-level bind: &quot; ++ show mx</span>
<span class="lineno">  844 </span><span class="spaces">  </span><span class="istickedoff">--showCryptolEnv</span>
<span class="lineno">  845 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  846 </span><span class="spaces">  </span><span class="istickedoff">-- When in the repl, print the result.</span>
<span class="lineno">  847 </span><span class="spaces">  </span><span class="istickedoff">when printBinds $ do</span>
<span class="lineno">  848 </span><span class="spaces">    </span><span class="istickedoff">let <span class="nottickedoff">opts = rwPPOpts rw</span></span>
<span class="lineno">  849 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  850 </span><span class="spaces">    </span><span class="istickedoff">-- Extract the variable, if any, from the pattern. If there isn't</span>
<span class="lineno">  851 </span><span class="spaces">    </span><span class="istickedoff">-- any single variable use &quot;it&quot;.</span>
<span class="lineno">  852 </span><span class="spaces">    </span><span class="istickedoff">let <span class="nottickedoff">name = case pat of</span></span>
<span class="lineno">  853 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">SS.PWild _patpos _t -&gt; &quot;it&quot;</span></span>
<span class="lineno">  854 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">SS.PVar _patpos _xpos x _t -&gt; x</span></span>
<span class="lineno">  855 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">SS.PTuple _patpos _pats -&gt; &quot;it&quot;</span></span>
<span class="lineno">  856 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  857 </span><span class="spaces">    </span><span class="istickedoff">-- Print non-unit result if it was not bound to a variable</span>
<span class="lineno">  858 </span><span class="spaces">    </span><span class="istickedoff">case pat of</span>
<span class="lineno">  859 </span><span class="spaces">      </span><span class="istickedoff">SS.PWild _ _ | <span class="tickonlyfalse">not (isVUnit result)</span> -&gt;</span>
<span class="lineno">  860 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">liftTopLevel $</span></span>
<span class="lineno">  861 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">do nenv &lt;- io . scGetNamingEnv =&lt;&lt; getSharedContext</span></span>
<span class="lineno">  862 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">printOutLnTop Info (showsPrecValue opts nenv 0 result &quot;&quot;)</span></span>
<span class="lineno">  863 </span><span class="spaces">      </span><span class="istickedoff">_ -&gt; return <span class="nottickedoff">()</span></span>
<span class="lineno">  864 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  865 </span><span class="spaces">    </span><span class="istickedoff">-- Print function type if result was a function</span>
<span class="lineno">  866 </span><span class="spaces">    </span><span class="istickedoff">case ty of</span>
<span class="lineno">  867 </span><span class="spaces">      </span><span class="istickedoff">SS.TyCon _ SS.FunCon _ -&gt;</span>
<span class="lineno">  868 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">liftTopLevel $ printOutLnTop Info $ Text.unpack $ name &lt;&gt; &quot; : &quot; &lt;&gt; PPS.pShowText ty</span></span>
<span class="lineno">  869 </span><span class="spaces">      </span><span class="istickedoff">_ -&gt; return <span class="nottickedoff">()</span></span>
<span class="lineno">  870 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  871 </span><span class="spaces">  </span><span class="istickedoff">liftTopLevel $</span>
<span class="lineno">  872 </span><span class="spaces">   </span><span class="istickedoff">do rw' &lt;- getTopLevelRW</span>
<span class="lineno">  873 </span><span class="spaces">      </span><span class="istickedoff">putTopLevelRW =&lt;&lt; bindPatternEnv pat (Just (SS.tMono ty)) result rw'</span></span>
<span class="lineno">  874 </span>
<span class="lineno">  875 </span>-- | Interpret a top-level statement in an interpreter monad (any of the SAWScript monads)
<span class="lineno">  876 </span>--   This duplicates the logic in interpretDoStmt for no particularly good reason.
<span class="lineno">  877 </span>interpretTopStmt :: InterpreterMonad m =&gt;
<span class="lineno">  878 </span>  Bool {-^ whether to print non-unit result values -} -&gt;
<span class="lineno">  879 </span>  SS.Stmt -&gt;
<span class="lineno">  880 </span>  m ()
<span class="lineno">  881 </span><span class="decl"><span class="istickedoff">interpretTopStmt printBinds stmt = do</span>
<span class="lineno">  882 </span><span class="spaces">  </span><span class="istickedoff">let ?fileReader = BS.readFile</span>
<span class="lineno">  883 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  884 </span><span class="spaces">  </span><span class="istickedoff">ctx &lt;- getMonadContext</span>
<span class="lineno">  885 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- liftTopLevel getMergedEnv</span>
<span class="lineno">  886 </span><span class="spaces">  </span><span class="istickedoff">let valueInfo = rwValueInfo rw</span>
<span class="lineno">  887 </span><span class="spaces">      </span><span class="istickedoff">valueInfo' = Map.map (\(pos, lc, rb, ty, _v, _doc) -&gt; (pos, lc, rb, ty)) valueInfo</span>
<span class="lineno">  888 </span><span class="spaces">  </span><span class="istickedoff">stmt' &lt;- processTypeCheck $ checkStmt (rwPrimsAvail rw) valueInfo' (rwTypeInfo rw) ctx stmt</span>
<span class="lineno">  889 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  890 </span><span class="spaces">  </span><span class="istickedoff">case stmt' of</span>
<span class="lineno">  891 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  892 </span><span class="spaces">    </span><span class="istickedoff">SS.StmtBind pos pat expr -&gt; do</span>
<span class="lineno">  893 </span><span class="spaces">      </span><span class="istickedoff">-- Note that while liftTopLevel $ processStmtBind will typecheck,</span>
<span class="lineno">  894 </span><span class="spaces">      </span><span class="istickedoff">-- that runs it in TopLevel and not the current monad, which might</span>
<span class="lineno">  895 </span><span class="spaces">      </span><span class="istickedoff">-- be ProofScript, and then things come unstuck. See #2494.</span>
<span class="lineno">  896 </span><span class="spaces">      </span><span class="istickedoff">processStmtBind printBinds pos pat expr</span>
<span class="lineno">  897 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  898 </span><span class="spaces">    </span><span class="istickedoff">SS.StmtLet _pos rebindable dg -&gt;</span>
<span class="lineno">  899 </span><span class="spaces">      </span><span class="istickedoff">liftTopLevel $ do</span>
<span class="lineno">  900 </span><span class="spaces">         </span><span class="istickedoff">env &lt;- interpretDeclGroup rebindable dg</span>
<span class="lineno">  901 </span><span class="spaces">         </span><span class="istickedoff">rw' &lt;- getMergedEnv' env</span>
<span class="lineno">  902 </span><span class="spaces">         </span><span class="istickedoff">putTopLevelRW rw'</span>
<span class="lineno">  903 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  904 </span><span class="spaces">    </span><span class="istickedoff">SS.StmtCode _ spos str -&gt;</span>
<span class="lineno">  905 </span><span class="spaces">      </span><span class="istickedoff">liftTopLevel $ do</span>
<span class="lineno">  906 </span><span class="spaces">         </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  907 </span><span class="spaces">         </span><span class="istickedoff">--io $ putStrLn $ &quot;Processing toplevel code: &quot; ++ show str</span>
<span class="lineno">  908 </span><span class="spaces">         </span><span class="istickedoff">--showCryptolEnv</span>
<span class="lineno">  909 </span><span class="spaces">         </span><span class="istickedoff">cenv' &lt;- io $ CEnv.parseDecls sc (rwCryptol rw) $ toInputText spos str</span>
<span class="lineno">  910 </span><span class="spaces">         </span><span class="istickedoff">putTopLevelRW $ rw { rwCryptol = cenv' }</span>
<span class="lineno">  911 </span><span class="spaces">         </span><span class="istickedoff">--showCryptolEnv</span>
<span class="lineno">  912 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  913 </span><span class="spaces">    </span><span class="istickedoff">SS.StmtImport _ imp -&gt;</span>
<span class="lineno">  914 </span><span class="spaces">      </span><span class="istickedoff">liftTopLevel $ do</span>
<span class="lineno">  915 </span><span class="spaces">         </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  916 </span><span class="spaces">         </span><span class="istickedoff">--showCryptolEnv</span>
<span class="lineno">  917 </span><span class="spaces">         </span><span class="istickedoff">let mLoc = iModule imp</span>
<span class="lineno">  918 </span><span class="spaces">             </span><span class="istickedoff">qual = iAs imp</span>
<span class="lineno">  919 </span><span class="spaces">             </span><span class="istickedoff">spec = iSpec imp</span>
<span class="lineno">  920 </span><span class="spaces">         </span><span class="istickedoff">cenv' &lt;- io $ CEnv.importCryptolModule sc (rwCryptol rw) mLoc qual CEnv.PublicAndPrivate spec</span>
<span class="lineno">  921 </span><span class="spaces">         </span><span class="istickedoff">putTopLevelRW $ rw { rwCryptol = cenv' }</span>
<span class="lineno">  922 </span><span class="spaces">         </span><span class="istickedoff">--showCryptolEnv</span>
<span class="lineno">  923 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  924 </span><span class="spaces">    </span><span class="istickedoff">SS.StmtTypedef _ _ name ty -&gt;</span>
<span class="lineno">  925 </span><span class="spaces">      </span><span class="istickedoff">liftTopLevel $ do</span>
<span class="lineno">  926 </span><span class="spaces">         </span><span class="istickedoff">putTopLevelRW $ addTypedef name ty rw</span></span>
<span class="lineno">  927 </span>
<span class="lineno">  928 </span>-- Hook for AutoMatch
<span class="lineno">  929 </span>stmtInterpreter :: StmtInterpreter
<span class="lineno">  930 </span><span class="decl"><span class="nottickedoff">stmtInterpreter ro rw stmts =</span>
<span class="lineno">  931 </span><span class="spaces">  </span><span class="nottickedoff">-- What AutoMatch provides is supposed to be a full script for the</span>
<span class="lineno">  932 </span><span class="spaces">  </span><span class="nottickedoff">-- syntactic top level, not a do-block. Run it with interpretTopStmt</span>
<span class="lineno">  933 </span><span class="spaces">  </span><span class="nottickedoff">-- so as to (a) get the right behavior (as long as interpretTopStmt</span>
<span class="lineno">  934 </span><span class="spaces">  </span><span class="nottickedoff">-- and interpretDoStmt are different, which they are) and (b) avoid</span>
<span class="lineno">  935 </span><span class="spaces">  </span><span class="nottickedoff">-- needing to provide a block result value.</span>
<span class="lineno">  936 </span><span class="spaces">  </span><span class="nottickedoff">fst &lt;$&gt; runTopLevel (withLocalEnv emptyLocal (mapM_ (interpretTopStmt False) stmts)) ro rw</span></span>
<span class="lineno">  937 </span>
<span class="lineno">  938 </span>interpretFile :: FilePath -&gt; Bool {- ^ run main? -} -&gt; TopLevel ()
<span class="lineno">  939 </span><span class="decl"><span class="istickedoff">interpretFile file runMain =</span>
<span class="lineno">  940 </span><span class="spaces">  </span><span class="istickedoff">bracketTopLevel (io getCurrentDirectory) (io . setCurrentDirectory) (const interp)</span>
<span class="lineno">  941 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  942 </span><span class="spaces">    </span><span class="istickedoff">interp = do</span>
<span class="lineno">  943 </span><span class="spaces">      </span><span class="istickedoff">opts &lt;- getOptions</span>
<span class="lineno">  944 </span><span class="spaces">      </span><span class="istickedoff">stmts &lt;- io $ SAWScript.Import.loadFile opts file</span>
<span class="lineno">  945 </span><span class="spaces">      </span><span class="istickedoff">io $ setCurrentDirectory (takeDirectory file)</span>
<span class="lineno">  946 </span><span class="spaces">      </span><span class="istickedoff">mapM_ stmtWithPrint stmts</span>
<span class="lineno">  947 </span><span class="spaces">      </span><span class="istickedoff">when runMain interpretMain</span>
<span class="lineno">  948 </span><span class="spaces">      </span><span class="istickedoff">writeVerificationSummary</span>
<span class="lineno">  949 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  950 </span><span class="spaces">    </span><span class="istickedoff">stmtWithPrint s = do</span>
<span class="lineno">  951 </span><span class="spaces">      </span><span class="istickedoff">let <span class="nottickedoff">withPos str =</span></span>
<span class="lineno">  952 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">unlines $ (&quot;[output] at &quot; ++ show (SS.getPos s) ++ &quot;: &quot;) :</span></span>
<span class="lineno">  953 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">map (\l -&gt; &quot;\t&quot;  ++ l) (lines str)</span></span>
<span class="lineno">  954 </span><span class="spaces">      </span><span class="istickedoff">showLoc &lt;- printShowPos &lt;$&gt; getOptions</span>
<span class="lineno">  955 </span><span class="spaces">      </span><span class="istickedoff">if <span class="tickonlyfalse">showLoc</span> then</span>
<span class="lineno">  956 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">let wrapPrint oldFn = \lvl str -&gt; oldFn lvl (withPos str)</span></span>
<span class="lineno">  957 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">withPrint opts = opts { printOutFn = wrapPrint (printOutFn opts) }</span></span>
<span class="lineno">  958 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">in</span></span>
<span class="lineno">  959 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">withOptions withPrint (interpretTopStmt False s)</span></span>
<span class="lineno">  960 </span><span class="spaces">      </span><span class="istickedoff">else</span>
<span class="lineno">  961 </span><span class="spaces">        </span><span class="istickedoff">interpretTopStmt False s</span></span>
<span class="lineno">  962 </span>
<span class="lineno">  963 </span>-- | Evaluate the value called 'main' from the current environment.
<span class="lineno">  964 </span>interpretMain :: TopLevel ()
<span class="lineno">  965 </span><span class="decl"><span class="istickedoff">interpretMain = do</span>
<span class="lineno">  966 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  967 </span><span class="spaces">  </span><span class="istickedoff">avail &lt;- gets rwPrimsAvail</span>
<span class="lineno">  968 </span><span class="spaces">  </span><span class="istickedoff">tyenv &lt;- gets rwTypeInfo</span>
<span class="lineno">  969 </span><span class="spaces">  </span><span class="istickedoff">let pos = SS.PosInternal &quot;entry&quot;</span>
<span class="lineno">  970 </span><span class="spaces">      </span><span class="istickedoff">-- We need the type to be &quot;TopLevel a&quot;, not just &quot;TopLevel ()&quot;.</span>
<span class="lineno">  971 </span><span class="spaces">      </span><span class="istickedoff">-- There are several (old) tests in the test suite whose main</span>
<span class="lineno">  972 </span><span class="spaces">      </span><span class="istickedoff">-- returns something, e.g. several are TopLevel Theorem because</span>
<span class="lineno">  973 </span><span class="spaces">      </span><span class="istickedoff">-- they call prove_print or prove_sat or whatever and don't</span>
<span class="lineno">  974 </span><span class="spaces">      </span><span class="istickedoff">-- explicitly throw away the result.</span>
<span class="lineno">  975 </span><span class="spaces">      </span><span class="istickedoff">tyRet = SS.TyVar <span class="nottickedoff">pos</span> &quot;a&quot;</span>
<span class="lineno">  976 </span><span class="spaces">      </span><span class="istickedoff">tyMonadic = SS.tBlock <span class="nottickedoff">pos</span> (SS.tContext <span class="nottickedoff">pos</span> SS.TopLevel) tyRet</span>
<span class="lineno">  977 </span><span class="spaces">      </span><span class="istickedoff">tyExpected = SS.Forall [(<span class="nottickedoff">pos</span>, &quot;a&quot;)] tyMonadic</span>
<span class="lineno">  978 </span><span class="spaces">  </span><span class="istickedoff">case Map.lookup &quot;main&quot; (rwValueInfo rw) of</span>
<span class="lineno">  979 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  980 </span><span class="spaces">      </span><span class="istickedoff">-- Don't fail or complain if there's no main.</span>
<span class="lineno">  981 </span><span class="spaces">      </span><span class="istickedoff">return <span class="nottickedoff">()</span></span>
<span class="lineno">  982 </span><span class="spaces">    </span><span class="istickedoff">Just (_defpos, Current, _rebindable, tyFound, v, _doc) -&gt; case tyFound of</span>
<span class="lineno">  983 </span><span class="spaces">        </span><span class="istickedoff">SS.Forall _ (SS.TyCon _ SS.BlockCon [_, _]) -&gt;</span>
<span class="lineno">  984 </span><span class="spaces">            </span><span class="istickedoff">-- It looks like a monadic value, so check more carefully.</span>
<span class="lineno">  985 </span><span class="spaces">            </span><span class="istickedoff">case typesMatch avail tyenv tyFound tyExpected of</span>
<span class="lineno">  986 </span><span class="spaces">              </span><span class="istickedoff">False -&gt;</span>
<span class="lineno">  987 </span><span class="spaces">                  </span><span class="istickedoff">-- While we accept any TopLevel a, don't encourage people</span>
<span class="lineno">  988 </span><span class="spaces">                  </span><span class="istickedoff">-- to do that.</span>
<span class="lineno">  989 </span><span class="spaces">                  </span><span class="istickedoff">fail &quot;There is a 'main' defined but its type is not TopLevel ()&quot;</span>
<span class="lineno">  990 </span><span class="spaces">              </span><span class="istickedoff">True -&gt; do</span>
<span class="lineno">  991 </span><span class="spaces">                  </span><span class="istickedoff">let v' = injectPositionIntoMonadicValue <span class="nottickedoff">pos</span> v</span>
<span class="lineno">  992 </span><span class="spaces">                      </span><span class="istickedoff">v'' = insertRefChain pos &quot;main&quot; v'</span>
<span class="lineno">  993 </span><span class="spaces">                  </span><span class="istickedoff">fromValue FromInterpreter v''</span>
<span class="lineno">  994 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  995 </span><span class="spaces">            </span><span class="istickedoff">-- If the type is something entirely random, like a Term or a</span>
<span class="lineno">  996 </span><span class="spaces">            </span><span class="istickedoff">-- String or something, just ignore it.</span>
<span class="lineno">  997 </span><span class="spaces">            </span><span class="istickedoff">return <span class="nottickedoff">()</span></span>
<span class="lineno">  998 </span><span class="spaces">    </span><span class="istickedoff">Just (_defpos, lc, _rebindable, _ty, _v, _doc) -&gt;</span>
<span class="lineno">  999 </span><span class="spaces">      </span><span class="istickedoff">-- There is no way for things other than primitives to get marked</span>
<span class="lineno"> 1000 </span><span class="spaces">      </span><span class="istickedoff">-- experimental or deprecated, so this isn't possible. If we allow</span>
<span class="lineno"> 1001 </span><span class="spaces">      </span><span class="istickedoff">-- users to deprecate their own functions in the future, change</span>
<span class="lineno"> 1002 </span><span class="spaces">      </span><span class="istickedoff">-- this message to an actual error that says something snarky :-)</span>
<span class="lineno"> 1003 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">panic &quot;Interpreter&quot; [</span></span>
<span class="lineno"> 1004 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;Unexpected lifecycle state &quot; &lt;&gt; Text.pack (show lc) &lt;&gt; &quot; for main&quot;</span></span>
<span class="lineno"> 1005 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno"> 1006 </span>
<span class="lineno"> 1007 </span>
<span class="lineno"> 1008 </span>buildTopLevelEnv :: AIGProxy
<span class="lineno"> 1009 </span>                 -&gt; Options
<span class="lineno"> 1010 </span>                 -&gt; [Text]
<span class="lineno"> 1011 </span>                 -&gt; IO (BuiltinContext, TopLevelRO, TopLevelRW)
<span class="lineno"> 1012 </span><span class="decl"><span class="istickedoff">buildTopLevelEnv proxy opts scriptArgv =</span>
<span class="lineno"> 1013 </span><span class="spaces">    </span><span class="istickedoff">do let mn = mkModuleName [&quot;SAWScript&quot;]</span>
<span class="lineno"> 1014 </span><span class="spaces">       </span><span class="istickedoff">sc0 &lt;- mkSharedContext</span>
<span class="lineno"> 1015 </span><span class="spaces">       </span><span class="istickedoff">let ?fileReader = <span class="nottickedoff">BS.readFile</span></span>
<span class="lineno"> 1016 </span><span class="spaces">       </span><span class="istickedoff">CryptolSAW.scLoadPreludeModule sc0</span>
<span class="lineno"> 1017 </span><span class="spaces">       </span><span class="istickedoff">CryptolSAW.scLoadCryptolModule sc0</span>
<span class="lineno"> 1018 </span><span class="spaces">       </span><span class="istickedoff">scLoadModule sc0 (emptyModule mn)</span>
<span class="lineno"> 1019 </span><span class="spaces">       </span><span class="istickedoff">cryptol_mod &lt;- scFindModule sc0 $ mkModuleName [&quot;Cryptol&quot;]</span>
<span class="lineno"> 1020 </span><span class="spaces">       </span><span class="istickedoff">let convs = natConversions</span>
<span class="lineno"> 1021 </span><span class="spaces">                   </span><span class="istickedoff">++ bvConversions</span>
<span class="lineno"> 1022 </span><span class="spaces">                   </span><span class="istickedoff">++ vecConversions</span>
<span class="lineno"> 1023 </span><span class="spaces">                   </span><span class="istickedoff">++ [ tupleConversion</span>
<span class="lineno"> 1024 </span><span class="spaces">                      </span><span class="istickedoff">, recordConversion</span>
<span class="lineno"> 1025 </span><span class="spaces">                      </span><span class="istickedoff">, remove_ident_coerce</span>
<span class="lineno"> 1026 </span><span class="spaces">                      </span><span class="istickedoff">, remove_ident_unsafeCoerce</span>
<span class="lineno"> 1027 </span><span class="spaces">                      </span><span class="istickedoff">]</span>
<span class="lineno"> 1028 </span><span class="spaces">           </span><span class="istickedoff">cryptolDefs = filter defPred $ moduleDefs cryptol_mod</span>
<span class="lineno"> 1029 </span><span class="spaces">           </span><span class="istickedoff">defPred d =</span>
<span class="lineno"> 1030 </span><span class="spaces">             </span><span class="istickedoff">case nameInfo (defName d) of</span>
<span class="lineno"> 1031 </span><span class="spaces">               </span><span class="istickedoff">ModuleIdentifier ident -&gt; ident `Set.member` includedDefs</span>
<span class="lineno"> 1032 </span><span class="spaces">               </span><span class="istickedoff">ImportedName{} -&gt; <span class="nottickedoff">False</span></span>
<span class="lineno"> 1033 </span><span class="spaces">           </span><span class="istickedoff">includedDefs = Set.fromList</span>
<span class="lineno"> 1034 </span><span class="spaces">                          </span><span class="istickedoff">[ &quot;Cryptol.ecDemote&quot;</span>
<span class="lineno"> 1035 </span><span class="spaces">                          </span><span class="istickedoff">, &quot;Cryptol.seq&quot;</span>
<span class="lineno"> 1036 </span><span class="spaces">                          </span><span class="istickedoff">]</span>
<span class="lineno"> 1037 </span><span class="spaces">       </span><span class="istickedoff">simps &lt;- scSimpset sc0 cryptolDefs [] convs</span>
<span class="lineno"> 1038 </span><span class="spaces">       </span><span class="istickedoff">let sc = rewritingSharedContext sc0 simps</span>
<span class="lineno"> 1039 </span><span class="spaces">       </span><span class="istickedoff">ss &lt;- basic_ss sc</span>
<span class="lineno"> 1040 </span><span class="spaces">       </span><span class="istickedoff">currDir &lt;- getCurrentDirectory</span>
<span class="lineno"> 1041 </span><span class="spaces">       </span><span class="istickedoff">mb_cache &lt;- lookupEnv &quot;SAW_SOLVER_CACHE_PATH&quot; &gt;&gt;= \case</span>
<span class="lineno"> 1042 </span><span class="spaces">         </span><span class="istickedoff">Just path | <span class="tickonlytrue">not (null path)</span> -&gt; Just &lt;$&gt; lazyOpenSolverCache path</span>
<span class="lineno"> 1043 </span><span class="spaces">         </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">return Nothing</span></span>
<span class="lineno"> 1044 </span><span class="spaces">       </span><span class="istickedoff">Crucible.withHandleAllocator $ \halloc -&gt; do</span>
<span class="lineno"> 1045 </span><span class="spaces">       </span><span class="istickedoff">let ro0 = TopLevelRO</span>
<span class="lineno"> 1046 </span><span class="spaces">                   </span><span class="istickedoff">{ roOptions = opts</span>
<span class="lineno"> 1047 </span><span class="spaces">                   </span><span class="istickedoff">, roArgv = scriptArgv</span>
<span class="lineno"> 1048 </span><span class="spaces">                   </span><span class="istickedoff">, roHandleAlloc = halloc</span>
<span class="lineno"> 1049 </span><span class="spaces">                   </span><span class="istickedoff">, roProxy = proxy</span>
<span class="lineno"> 1050 </span><span class="spaces">                   </span><span class="istickedoff">, roInitWorkDir = <span class="nottickedoff">currDir</span></span>
<span class="lineno"> 1051 </span><span class="spaces">                   </span><span class="istickedoff">, roBasicSS = ss</span>
<span class="lineno"> 1052 </span><span class="spaces">                   </span><span class="istickedoff">, roSubshell = <span class="nottickedoff">fail &quot;Subshells not supported&quot;</span></span>
<span class="lineno"> 1053 </span><span class="spaces">                   </span><span class="istickedoff">, roProofSubshell = <span class="nottickedoff">fail &quot;Proof subshells not supported&quot;</span></span>
<span class="lineno"> 1054 </span><span class="spaces">                   </span><span class="istickedoff">}</span>
<span class="lineno"> 1055 </span><span class="spaces">       </span><span class="istickedoff">let bic = BuiltinContext {</span>
<span class="lineno"> 1056 </span><span class="spaces">                   </span><span class="istickedoff">biSharedContext = sc</span>
<span class="lineno"> 1057 </span><span class="spaces">                 </span><span class="istickedoff">, biBasicSS = <span class="nottickedoff">ss</span></span>
<span class="lineno"> 1058 </span><span class="spaces">                 </span><span class="istickedoff">}</span>
<span class="lineno"> 1059 </span><span class="spaces">       </span><span class="istickedoff">ce0 &lt;- CEnv.initCryptolEnv sc</span>
<span class="lineno"> 1060 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1061 </span><span class="spaces">       </span><span class="istickedoff">jvmTrans &lt;- CJ.mkInitialJVMContext <span class="nottickedoff">halloc</span></span>
<span class="lineno"> 1062 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1063 </span><span class="spaces">       </span><span class="istickedoff">let rw0 = TopLevelRW</span>
<span class="lineno"> 1064 </span><span class="spaces">                   </span><span class="istickedoff">{ rwValueInfo  = primValueEnv opts bic</span>
<span class="lineno"> 1065 </span><span class="spaces">                   </span><span class="istickedoff">, rwTypeInfo   = primNamedTypeEnv</span>
<span class="lineno"> 1066 </span><span class="spaces">                   </span><span class="istickedoff">, rwCryptol    = ce0</span>
<span class="lineno"> 1067 </span><span class="spaces">                   </span><span class="istickedoff">, rwPosition = <span class="nottickedoff">SS.Unknown</span></span>
<span class="lineno"> 1068 </span><span class="spaces">                   </span><span class="istickedoff">, rwStackTrace = Trace.empty</span>
<span class="lineno"> 1069 </span><span class="spaces">                   </span><span class="istickedoff">, rwLocalEnv = []</span>
<span class="lineno"> 1070 </span><span class="spaces">                   </span><span class="istickedoff">, rwProofs     = []</span>
<span class="lineno"> 1071 </span><span class="spaces">                   </span><span class="istickedoff">, rwPPOpts     = PPS.defaultOpts</span>
<span class="lineno"> 1072 </span><span class="spaces">                   </span><span class="istickedoff">, rwSharedContext = sc</span>
<span class="lineno"> 1073 </span><span class="spaces">                   </span><span class="istickedoff">, rwSolverCache = mb_cache</span>
<span class="lineno"> 1074 </span><span class="spaces">                   </span><span class="istickedoff">, rwTheoremDB = emptyTheoremDB</span>
<span class="lineno"> 1075 </span><span class="spaces">                   </span><span class="istickedoff">, rwJVMTrans   = jvmTrans</span>
<span class="lineno"> 1076 </span><span class="spaces">                   </span><span class="istickedoff">, rwPrimsAvail = defaultAvailable</span>
<span class="lineno"> 1077 </span><span class="spaces">                   </span><span class="istickedoff">, rwSMTArrayMemoryModel = False</span>
<span class="lineno"> 1078 </span><span class="spaces">                   </span><span class="istickedoff">, rwCrucibleAssertThenAssume = False</span>
<span class="lineno"> 1079 </span><span class="spaces">                   </span><span class="istickedoff">, rwProfilingFile = Nothing</span>
<span class="lineno"> 1080 </span><span class="spaces">                   </span><span class="istickedoff">, rwLaxArith = False</span>
<span class="lineno"> 1081 </span><span class="spaces">                   </span><span class="istickedoff">, rwLaxPointerOrdering = False</span>
<span class="lineno"> 1082 </span><span class="spaces">                   </span><span class="istickedoff">, rwLaxLoadsAndStores = False</span>
<span class="lineno"> 1083 </span><span class="spaces">                   </span><span class="istickedoff">, rwDebugIntrinsics = True</span>
<span class="lineno"> 1084 </span><span class="spaces">                   </span><span class="istickedoff">, rwWhat4HashConsing = False</span>
<span class="lineno"> 1085 </span><span class="spaces">                   </span><span class="istickedoff">, rwWhat4HashConsingX86 = False</span>
<span class="lineno"> 1086 </span><span class="spaces">                   </span><span class="istickedoff">, rwWhat4Eval = False</span>
<span class="lineno"> 1087 </span><span class="spaces">                   </span><span class="istickedoff">, rwPreservedRegs = []</span>
<span class="lineno"> 1088 </span><span class="spaces">                   </span><span class="istickedoff">, rwStackBaseAlign = defaultStackBaseAlign</span>
<span class="lineno"> 1089 </span><span class="spaces">                   </span><span class="istickedoff">, rwAllocSymInitCheck = True</span>
<span class="lineno"> 1090 </span><span class="spaces">                   </span><span class="istickedoff">, rwWhat4PushMuxOps = False</span>
<span class="lineno"> 1091 </span><span class="spaces">                   </span><span class="istickedoff">, rwNoSatisfyingWriteFreshConstant = True</span>
<span class="lineno"> 1092 </span><span class="spaces">                   </span><span class="istickedoff">, rwCrucibleTimeout = CC.defaultSAWCoreBackendTimeout</span>
<span class="lineno"> 1093 </span><span class="spaces">                   </span><span class="istickedoff">, rwPathSatSolver = CC.PathSat_Z3</span>
<span class="lineno"> 1094 </span><span class="spaces">                   </span><span class="istickedoff">, rwSkipSafetyProofs = False</span>
<span class="lineno"> 1095 </span><span class="spaces">                   </span><span class="istickedoff">, rwSingleOverrideSpecialCase = False</span>
<span class="lineno"> 1096 </span><span class="spaces">                   </span><span class="istickedoff">, rwSequentGoals = False</span>
<span class="lineno"> 1097 </span><span class="spaces">                   </span><span class="istickedoff">, rwJavaCodebase = JavaUninitialized</span>
<span class="lineno"> 1098 </span><span class="spaces">                   </span><span class="istickedoff">}</span>
<span class="lineno"> 1099 </span><span class="spaces">       </span><span class="istickedoff">return (<span class="nottickedoff">bic</span>, ro0, rw0)</span></span>
<span class="lineno"> 1100 </span>
<span class="lineno"> 1101 </span>processFile ::
<span class="lineno"> 1102 </span>  AIGProxy -&gt;
<span class="lineno"> 1103 </span>  Options -&gt;
<span class="lineno"> 1104 </span>  FilePath -&gt;
<span class="lineno"> 1105 </span>  [Text] -&gt;
<span class="lineno"> 1106 </span>  Maybe (TopLevel ()) -&gt;
<span class="lineno"> 1107 </span>  Maybe (ProofScript ()) -&gt;
<span class="lineno"> 1108 </span>  IO ()
<span class="lineno"> 1109 </span><span class="decl"><span class="istickedoff">processFile proxy opts file scriptArgv mbSubshell mbProofSubshell = do</span>
<span class="lineno"> 1110 </span><span class="spaces">  </span><span class="istickedoff">(_, ro, rw) &lt;- buildTopLevelEnv proxy opts scriptArgv</span>
<span class="lineno"> 1111 </span><span class="spaces">  </span><span class="istickedoff">let ro' = case mbSubshell of</span>
<span class="lineno"> 1112 </span><span class="spaces">              </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">ro</span></span>
<span class="lineno"> 1113 </span><span class="spaces">              </span><span class="istickedoff">Just m  -&gt; ro{ roSubshell = <span class="nottickedoff">m</span> }</span>
<span class="lineno"> 1114 </span><span class="spaces">  </span><span class="istickedoff">let ro'' = case mbProofSubshell of</span>
<span class="lineno"> 1115 </span><span class="spaces">              </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">ro'</span></span>
<span class="lineno"> 1116 </span><span class="spaces">              </span><span class="istickedoff">Just m  -&gt; ro'{ roProofSubshell = m }</span>
<span class="lineno"> 1117 </span><span class="spaces">  </span><span class="istickedoff">_ &lt;- runTopLevel (interpretFile file True) ro'' rw</span>
<span class="lineno"> 1118 </span><span class="spaces">            </span><span class="istickedoff">`X.catch` (handleException opts)</span>
<span class="lineno"> 1119 </span><span class="spaces">  </span><span class="istickedoff">return <span class="nottickedoff">()</span></span></span>
<span class="lineno"> 1120 </span>
<span class="lineno"> 1121 </span>
<span class="lineno"> 1122 </span>------------------------------------------------------------
<span class="lineno"> 1123 </span>-- IsValue and FromValue
<span class="lineno"> 1124 </span>
<span class="lineno"> 1125 </span>-- | Class for injecting Haskell values into SAWScript values. This
<span class="lineno"> 1126 </span>--   is straightforward for scalars. For functions, it gets a bit
<span class="lineno"> 1127 </span>--   wibbly.
<span class="lineno"> 1128 </span>--
<span class="lineno"> 1129 </span>--   First, some history. Until July 2025 there was a relatively
<span class="lineno"> 1130 </span>--   straightforward IsValue instance for (a -&gt; b) that matched any
<span class="lineno"> 1131 </span>--   argument type a that supported FromValue, and any result type
<span class="lineno"> 1132 </span>--   supporting IsValue, including functions. Thus, because Haskell
<span class="lineno"> 1133 </span>--   functions are curried, functions of more than one argument would
<span class="lineno"> 1134 </span>--   generate a Value that took one argument and produced a result
<span class="lineno"> 1135 </span>--   recursively using the IsValue instance for the rest of the
<span class="lineno"> 1136 </span>--   function. This produced a chain of Values, each being a closure
<span class="lineno"> 1137 </span>--   of type Value -&gt; TopLevel Value, and the interpreter could call
<span class="lineno"> 1138 </span>--   them by applying argument Values one at a time.
<span class="lineno"> 1139 </span>--
<span class="lineno"> 1140 </span>--   This is fine as long as you're ok with blindly applying arguments
<span class="lineno"> 1141 </span>--   until you get something else back, which is fine as long as all
<span class="lineno"> 1142 </span>--   the interpreter does is execute. However, there are some other
<span class="lineno"> 1143 </span>--   things we'd like to have: correct stack traces require knowing
<span class="lineno"> 1144 </span>--   the name of the function being called at the application of the
<span class="lineno"> 1145 </span>--   last argument. Nice stack traces also involve having the
<span class="lineno"> 1146 </span>--   arguments to the function at that point. Furthermore, if all you
<span class="lineno"> 1147 </span>--   have in the Value is a closure, and someone wants to print it for
<span class="lineno"> 1148 </span>--   debugging, all you can print is &quot;&lt;&lt;closure&gt;&gt;&quot; or &quot;&lt;&lt;function&gt;&gt;&quot;
<span class="lineno"> 1149 </span>--   or similar. It would be much nicer to at least be able to print
<span class="lineno"> 1150 </span>--   the name of the builtin hiding in the closure.
<span class="lineno"> 1151 </span>--
<span class="lineno"> 1152 </span>--   For all of these things, one wants additional info in the Value
<span class="lineno"> 1153 </span>--   besides just the closure, and critically, that info needs to be
<span class="lineno"> 1154 </span>--   carried over when an argument is applied. It is really ugly to do
<span class="lineno"> 1155 </span>--   that if you just have a closure that returns an arbitrary Value;
<span class="lineno"> 1156 </span>--   you have to apply the argument, unwrap the result and then try to
<span class="lineno"> 1157 </span>--   guess if you just applied the last argument and got a return
<span class="lineno"> 1158 </span>--   value (which might also be a lambda from somewhere else) or you
<span class="lineno"> 1159 </span>--   didn't and you should cary the metadata over. That really won't
<span class="lineno"> 1160 </span>--   do.
<span class="lineno"> 1161 </span>--
<span class="lineno"> 1162 </span>--   Therefore, in July 2025, we added another type BuiltinWrapper to
<span class="lineno"> 1163 </span>--   hold the closure chain. There are two cases of BuiltinWrapper,
<span class="lineno"> 1164 </span>--   one where you apply the last arg and get a Value back, and one
<span class="lineno"> 1165 </span>--   where you apply something less than the last arg and get a new
<span class="lineno"> 1166 </span>--   BuiltinWrapper back. Therefore, when applying an argument to a
<span class="lineno"> 1167 </span>--   value holding a builtin function, you can branch on the cases,
<span class="lineno"> 1168 </span>--   and if what you have is still a partly applied builtin, you can
<span class="lineno"> 1169 </span>--   carry over the metadata and update it accordingly. Furthermore,
<span class="lineno"> 1170 </span>--   for the purposes of managing the stack trace, you can know when
<span class="lineno"> 1171 </span>--   you're applying the last argument, because that's the time when
<span class="lineno"> 1172 </span>--   you need to add a frame to the trace.
<span class="lineno"> 1173 </span>--
<span class="lineno"> 1174 </span>--   In this environment, IsValue for a function must generate a chain
<span class="lineno"> 1175 </span>--   of BuiltinWrappers rather than a chain of Values. This turns out
<span class="lineno"> 1176 </span>--   to be problematic. A tidy way to do it would be to have a
<span class="lineno"> 1177 </span>--   separate IsFuncValue class that recursively collects that chain,
<span class="lineno"> 1178 </span>--   then have a single flat IsValue instance for functions that
<span class="lineno"> 1179 </span>--   splices it in. Or, alternatively, make IsFuncValue and
<span class="lineno"> 1180 </span>--   IsBaseValue classes, and then an umbrella IsValue class that
<span class="lineno"> 1181 </span>--   pulls them both in. None of this works. You can't have instances
<span class="lineno"> 1182 </span>--   of the form &quot;instance IsBaseValue a =&gt; IsValue a&quot;; Haskell treats
<span class="lineno"> 1183 </span>--   this as one instance for all types a, rather than as a derivation
<span class="lineno"> 1184 </span>--   rule to generate an instance for any type a that matches the
<span class="lineno"> 1185 </span>--   constraints.
<span class="lineno"> 1186 </span>--
<span class="lineno"> 1187 </span>--   Instead, we keep a single `IsValue` class and instead add more
<span class="lineno"> 1188 </span>--   members to it.
<span class="lineno"> 1189 </span>--
<span class="lineno"> 1190 </span>--   The `toValue` member produces a Value; this is the external entry
<span class="lineno"> 1191 </span>--   point, so it gets called on scalars and all full complete
<span class="lineno"> 1192 </span>--   function types in the builtins table.
<span class="lineno"> 1193 </span>--
<span class="lineno"> 1194 </span>--   The `isFunction` member returns a boolean indicating whether the
<span class="lineno"> 1195 </span>--   value type we're handling is a function. This function requires a
<span class="lineno"> 1196 </span>--   value of the appropriate type in order to allow the typeclass to
<span class="lineno"> 1197 </span>--   match, but doesn't use it. The class provides a default
<span class="lineno"> 1198 </span>--   implementation of False, which is overridden explicitly only in
<span class="lineno"> 1199 </span>--   the instance for functions.
<span class="lineno"> 1200 </span>--
<span class="lineno"> 1201 </span>--   The `toWrapper` member produces a `BuiltinWrapper`. The instance
<span class="lineno"> 1202 </span>--   for functions uses this to recurse and produce the chain of
<span class="lineno"> 1203 </span>--   `BuiltinWrapper` values containing closures. It uses
<span class="lineno"> 1204 </span>--   `isBaseValue` on the function return type to check whether it's
<span class="lineno"> 1205 </span>--   on the last argument or not, and constructs the wrapper
<span class="lineno"> 1206 </span>--   accordingly. A default implementation that panics is provided;
<span class="lineno"> 1207 </span>--   only the function instance overrides that.
<span class="lineno"> 1208 </span>--
<span class="lineno"> 1209 </span>--   Be careful: there's a possible hole in this logic, which is that
<span class="lineno"> 1210 </span>--   we treat Value itself as a non-function value. There needs to be
<span class="lineno"> 1211 </span>--   an IsValue instance for Value, because there are a number of
<span class="lineno"> 1212 </span>--   builtins whose Haskell type involves Value, generally in order to
<span class="lineno"> 1213 </span>--   be polymorphic at the SAWScript level. Any builtin that _returns_
<span class="lineno"> 1214 </span>--   Value (arguments use FromValue and are safe from these concerns),
<span class="lineno"> 1215 </span>--   and want that Value to wrap a Haskell function, need to cons up
<span class="lineno"> 1216 </span>--   the proper BuiltinWrapper chain by hand. A few examples exist.
<span class="lineno"> 1217 </span>--
<span class="lineno"> 1218 </span>--   (Also note that it must work this way; we _cannot_ examine the
<span class="lineno"> 1219 </span>--   argument to `isFunction` because the `toWrapper` logic for
<span class="lineno"> 1220 </span>--   functions must decide which case it's looking at without calling
<span class="lineno"> 1221 </span>--   its function to get a value of the proper type and there isn't
<span class="lineno"> 1222 </span>--   any other concrete one to use.)
<span class="lineno"> 1223 </span>--
<span class="lineno"> 1224 </span>--   There is no FromValue instance for functions. If we want to have
<span class="lineno"> 1225 </span>--   builtins taking callback arguments, we'll need to do something
<span class="lineno"> 1226 </span>--   about that, and it'll probably get complicated. (Currently
<span class="lineno"> 1227 </span>--   everything that looks like a callback is a monadic action taking
<span class="lineno"> 1228 </span>--   no arguments.)
<span class="lineno"> 1229 </span>--
<span class="lineno"> 1230 </span>--   Note if working on this code that any change to the logic that
<span class="lineno"> 1231 </span>--   involves additional annotations or explicitly distinguishing
<span class="lineno"> 1232 </span>--   functions from scalars will require touching ~every entry in the
<span class="lineno"> 1233 </span>--   builtins table, and there are a _lot_ of builtins.
<span class="lineno"> 1234 </span>--
<span class="lineno"> 1235 </span>--   Also be aware that there are a handful of builtins that _execute_
<span class="lineno"> 1236 </span>--   in TopLevel when applied, rather than returning a SAWScript
<span class="lineno"> 1237 </span>--   TopLevel action.  As things stand these _must_ circumvent this
<span class="lineno"> 1238 </span>--   logic and not use toValue directly; there is no way to get the
<span class="lineno"> 1239 </span>--   function values generated herein to behave that way, because
<span class="lineno"> 1240 </span>--   there's no difference in the types to work from.
<span class="lineno"> 1241 </span>--
<span class="lineno"> 1242 </span>class IsValue a where
<span class="lineno"> 1243 </span>    toValue :: Text -&gt; a -&gt; Value
<span class="lineno"> 1244 </span>    -- these will be overridden on the function instance
<span class="lineno"> 1245 </span>    isFunction :: a -&gt; Bool
<span class="lineno"> 1246 </span>    <span class="decl"><span class="istickedoff">isFunction _ = False</span></span>
<span class="lineno"> 1247 </span>    toWrapper :: Text -&gt; a -&gt; BuiltinWrapper
<span class="lineno"> 1248 </span>    <span class="decl"><span class="nottickedoff">toWrapper _ _ = panic &quot;toWrapper&quot; [&quot;Invalid call on base value&quot;]</span></span>
<span class="lineno"> 1249 </span>
<span class="lineno"> 1250 </span>-- | Flag to indicate where/how fromValue was triggered.
<span class="lineno"> 1251 </span>--   (Could be just a Bool, but having it be its own thing increases
<span class="lineno"> 1252 </span>--   legibility and this whole set of arrangements is delicate.)
<span class="lineno"> 1253 </span>data FromValueHow = FromInterpreter | FromArgument
<span class="lineno"> 1254 </span>
<span class="lineno"> 1255 </span>class FromValue a where
<span class="lineno"> 1256 </span>    fromValue :: FromValueHow -&gt; Value -&gt; a
<span class="lineno"> 1257 </span>
<span class="lineno"> 1258 </span>instance (FromValue a, IsValue b) =&gt; IsValue (a -&gt; b) where
<span class="lineno"> 1259 </span>    <span class="decl"><span class="istickedoff">toValue name f = VBuiltin name <span class="nottickedoff">Seq.empty</span> $ toWrapper <span class="nottickedoff">name</span> f</span></span>
<span class="lineno"> 1260 </span>    <span class="decl"><span class="istickedoff">isFunction _ = True</span></span>
<span class="lineno"> 1261 </span>    <span class="decl"><span class="istickedoff">toWrapper name f =</span>
<span class="lineno"> 1262 </span><span class="spaces">        </span><span class="istickedoff">-- | isFunction needs a value of type b, which we don't have,</span>
<span class="lineno"> 1263 </span><span class="spaces">        </span><span class="istickedoff">--   but doesn't look at it, so we can use a placeholder, and</span>
<span class="lineno"> 1264 </span><span class="spaces">        </span><span class="istickedoff">--   it's ok for it to be a bomb.</span>
<span class="lineno"> 1265 </span><span class="spaces">        </span><span class="istickedoff">let hook :: b = <span class="nottickedoff">panic &quot;toWrapper&quot; [&quot;isFunction must have used its argument&quot;]</span> in</span>
<span class="lineno"> 1266 </span><span class="spaces">        </span><span class="istickedoff">if isFunction <span class="nottickedoff">hook</span> then</span>
<span class="lineno"> 1267 </span><span class="spaces">          </span><span class="istickedoff">let f' v = return $ toWrapper <span class="nottickedoff">name</span> (f (fromValue FromArgument v)) in</span>
<span class="lineno"> 1268 </span><span class="spaces">          </span><span class="istickedoff">ManyMoreArgs f'</span>
<span class="lineno"> 1269 </span><span class="spaces">        </span><span class="istickedoff">else</span>
<span class="lineno"> 1270 </span><span class="spaces">          </span><span class="istickedoff">let f' v = return $ toValue <span class="nottickedoff">name</span> (f (fromValue FromArgument v)) in</span>
<span class="lineno"> 1271 </span><span class="spaces">          </span><span class="istickedoff">OneMoreArg f'</span></span>
<span class="lineno"> 1272 </span>
<span class="lineno"> 1273 </span>instance FromValue Value where
<span class="lineno"> 1274 </span>    <span class="decl"><span class="istickedoff">fromValue _ x = x</span></span>
<span class="lineno"> 1275 </span>
<span class="lineno"> 1276 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue Value</span></span></span></span> where
<span class="lineno"> 1277 </span>    <span class="decl"><span class="istickedoff">toValue _name x = x</span></span>
<span class="lineno"> 1278 </span>
<span class="lineno"> 1279 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue ()</span></span></span></span> where
<span class="lineno"> 1280 </span>    <span class="decl"><span class="istickedoff">toValue _name _ = VTuple []</span></span>
<span class="lineno"> 1281 </span>
<span class="lineno"> 1282 </span>instance FromValue () where
<span class="lineno"> 1283 </span>    <span class="decl"><span class="istickedoff">fromValue _ _ = ()</span></span>
<span class="lineno"> 1284 </span>
<span class="lineno"> 1285 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">(IsValue a, IsValue b) =&gt; IsValue (a, b)</span></span></span></span> where
<span class="lineno"> 1286 </span>    <span class="decl"><span class="nottickedoff">toValue name (x, y) = VTuple [toValue name x, toValue name y]</span></span>
<span class="lineno"> 1287 </span>
<span class="lineno"> 1288 </span>instance (FromValue a, FromValue b) =&gt; FromValue (a, b) where
<span class="lineno"> 1289 </span>    <span class="decl"><span class="nottickedoff">fromValue how (VTuple [x, y]) = (fromValue how x, fromValue how y)</span>
<span class="lineno"> 1290 </span><span class="spaces">    </span><span class="nottickedoff">fromValue _ _ = error &quot;fromValue (,)&quot;</span></span>
<span class="lineno"> 1291 </span>
<span class="lineno"> 1292 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">(IsValue a, IsValue b, IsValue c) =&gt; IsValue (a, b, c)</span></span></span></span> where
<span class="lineno"> 1293 </span>    <span class="decl"><span class="nottickedoff">toValue name (x, y, z) = VTuple [toValue name x, toValue name y, toValue name z]</span></span>
<span class="lineno"> 1294 </span>
<span class="lineno"> 1295 </span>instance (FromValue a, FromValue b, FromValue c) =&gt; FromValue (a, b, c) where
<span class="lineno"> 1296 </span>    <span class="decl"><span class="nottickedoff">fromValue how (VTuple [x, y, z]) = (fromValue how x, fromValue how y, fromValue how z)</span>
<span class="lineno"> 1297 </span><span class="spaces">    </span><span class="nottickedoff">fromValue _ _ = error &quot;fromValue (,,)&quot;</span></span>
<span class="lineno"> 1298 </span>
<span class="lineno"> 1299 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue a =&gt; IsValue [a]</span></span></span></span> where
<span class="lineno"> 1300 </span>    <span class="decl"><span class="istickedoff">toValue name xs = VArray (map (toValue <span class="nottickedoff">name</span>) xs)</span></span>
<span class="lineno"> 1301 </span>
<span class="lineno"> 1302 </span>
<span class="lineno"> 1303 </span>instance FromValue a =&gt; FromValue [a] where
<span class="lineno"> 1304 </span>    <span class="decl"><span class="istickedoff">fromValue how (VArray xs) = map (fromValue <span class="nottickedoff">how</span>) xs</span>
<span class="lineno"> 1305 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue []&quot;</span></span></span>
<span class="lineno"> 1306 </span>
<span class="lineno"> 1307 </span>
<span class="lineno"> 1308 </span>-- | Common logic for the FromValue instances for plain monadic values.
<span class="lineno"> 1309 </span>--   Runs in any interpreter monad.
<span class="lineno"> 1310 </span>--
<span class="lineno"> 1311 </span>--   Note: this won't actually run until the result action is bound into
<span class="lineno"> 1312 </span>--   the execution sequence somewhere (downstream from fromValue).
<span class="lineno"> 1313 </span>preparePlainMonadicAction ::
<span class="lineno"> 1314 </span>  forall m a. InterpreterMonad m =&gt; FromValueHow -&gt; SS.Pos -&gt; RefChain -&gt; m a -&gt; m a
<span class="lineno"> 1315 </span><span class="decl"><span class="istickedoff">preparePlainMonadicAction how pos chain action = do</span>
<span class="lineno"> 1316 </span><span class="spaces">  </span><span class="istickedoff">liftTopLevel $ do</span>
<span class="lineno"> 1317 </span><span class="spaces">    </span><span class="istickedoff">setPosition pos</span>
<span class="lineno"> 1318 </span><span class="spaces">    </span><span class="istickedoff">case how of</span>
<span class="lineno"> 1319 </span><span class="spaces">        </span><span class="istickedoff">FromInterpreter -&gt; pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 1320 </span><span class="spaces">        </span><span class="istickedoff">FromArgument -&gt; pushTraceFrame SS.PosInsideBuiltin &quot;(callback)&quot;</span>
<span class="lineno"> 1321 </span><span class="spaces">    </span><span class="istickedoff">pushTraceFrames chain</span>
<span class="lineno"> 1322 </span><span class="spaces">  </span><span class="istickedoff">ret &lt;- action</span>
<span class="lineno"> 1323 </span><span class="spaces">  </span><span class="istickedoff">liftTopLevel $ do</span>
<span class="lineno"> 1324 </span><span class="spaces">    </span><span class="istickedoff">popTraceFrames chain</span>
<span class="lineno"> 1325 </span><span class="spaces">    </span><span class="istickedoff">case how of</span>
<span class="lineno"> 1326 </span><span class="spaces">        </span><span class="istickedoff">FromInterpreter -&gt; pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 1327 </span><span class="spaces">        </span><span class="istickedoff">FromArgument -&gt; popTraceFrame</span>
<span class="lineno"> 1328 </span><span class="spaces">  </span><span class="istickedoff">return ret</span></span>
<span class="lineno"> 1329 </span>
<span class="lineno"> 1330 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue a =&gt; IsValue (IO a)</span></span></span></span> where
<span class="lineno"> 1331 </span>    <span class="decl"><span class="istickedoff">toValue name action = toValue <span class="nottickedoff">name</span> (io action)</span></span>
<span class="lineno"> 1332 </span>
<span class="lineno"> 1333 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue a =&gt; IsValue (TopLevel a)</span></span></span></span> where
<span class="lineno"> 1334 </span>    <span class="decl"><span class="istickedoff">toValue name action =</span>
<span class="lineno"> 1335 </span><span class="spaces">      </span><span class="istickedoff">VTopLevel <span class="nottickedoff">atRestPos</span> [] (fmap (toValue <span class="nottickedoff">name</span>) action)</span></span>
<span class="lineno"> 1336 </span>
<span class="lineno"> 1337 </span>instance FromValue a =&gt; FromValue (TopLevel a) where
<span class="lineno"> 1338 </span>    <span class="decl"><span class="istickedoff">fromValue how v = do</span>
<span class="lineno"> 1339 </span><span class="spaces">      </span><span class="istickedoff">v' &lt;- interpretMonadAction how v</span>
<span class="lineno"> 1340 </span><span class="spaces">      </span><span class="istickedoff">case v' of</span>
<span class="lineno"> 1341 </span><span class="spaces">        </span><span class="istickedoff">VTopLevel pos chain action -&gt;</span>
<span class="lineno"> 1342 </span><span class="spaces">          </span><span class="istickedoff">fromValue <span class="nottickedoff">how</span> &lt;$&gt; preparePlainMonadicAction how pos chain action</span>
<span class="lineno"> 1343 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 1344 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">panic &quot;fromValue (TopLevel)&quot; [</span></span>
<span class="lineno"> 1345 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">&quot;Invalid/ill-typed value: &quot; &lt;&gt; Text.pack (show v')</span></span>
<span class="lineno"> 1346 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno"> 1347 </span>
<span class="lineno"> 1348 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue a =&gt; IsValue (ProofScript a)</span></span></span></span> where
<span class="lineno"> 1349 </span>    <span class="decl"><span class="istickedoff">toValue name m =</span>
<span class="lineno"> 1350 </span><span class="spaces">      </span><span class="istickedoff">VProofScript <span class="nottickedoff">atRestPos</span> [] (fmap (toValue <span class="nottickedoff">name</span>) m)</span></span>
<span class="lineno"> 1351 </span>
<span class="lineno"> 1352 </span>instance FromValue a =&gt; FromValue (ProofScript a) where
<span class="lineno"> 1353 </span>    <span class="decl"><span class="istickedoff">fromValue how v = do</span>
<span class="lineno"> 1354 </span><span class="spaces">      </span><span class="istickedoff">v' &lt;- interpretMonadAction how v</span>
<span class="lineno"> 1355 </span><span class="spaces">      </span><span class="istickedoff">case v' of</span>
<span class="lineno"> 1356 </span><span class="spaces">        </span><span class="istickedoff">VProofScript pos chain action -&gt;</span>
<span class="lineno"> 1357 </span><span class="spaces">          </span><span class="istickedoff">fromValue <span class="nottickedoff">how</span> &lt;$&gt; preparePlainMonadicAction how pos chain action</span>
<span class="lineno"> 1358 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 1359 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">panic &quot;fromValue (ProofScript)&quot; [</span></span>
<span class="lineno"> 1360 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">&quot;Invalid/ill-typed value: &quot; &lt;&gt; Text.pack (show v')</span></span>
<span class="lineno"> 1361 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno"> 1362 </span>
<span class="lineno"> 1363 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue a =&gt; IsValue (LLVMCrucibleSetupM a)</span></span></span></span> where
<span class="lineno"> 1364 </span>    <span class="decl"><span class="istickedoff">toValue name m =</span>
<span class="lineno"> 1365 </span><span class="spaces">      </span><span class="istickedoff">VLLVMCrucibleSetup <span class="nottickedoff">atRestPos</span> [] (fmap (toValue <span class="nottickedoff">name</span>) m)</span></span>
<span class="lineno"> 1366 </span>
<span class="lineno"> 1367 </span>instance FromValue a =&gt; FromValue (LLVMCrucibleSetupM a) where
<span class="lineno"> 1368 </span>    <span class="decl"><span class="istickedoff">fromValue how v = do</span>
<span class="lineno"> 1369 </span><span class="spaces">      </span><span class="istickedoff">v' &lt;- interpretMonadAction how v</span>
<span class="lineno"> 1370 </span><span class="spaces">      </span><span class="istickedoff">case v' of</span>
<span class="lineno"> 1371 </span><span class="spaces">        </span><span class="istickedoff">VLLVMCrucibleSetup pos chain action -&gt;</span>
<span class="lineno"> 1372 </span><span class="spaces">          </span><span class="istickedoff">fromValue <span class="nottickedoff">how</span> &lt;$&gt; preparePlainMonadicAction how pos chain action</span>
<span class="lineno"> 1373 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 1374 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">panic &quot;fromValue (LLVMSetup)&quot; [</span></span>
<span class="lineno"> 1375 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">&quot;Invalid/ill-typed value: &quot; &lt;&gt; Text.pack (show v')</span></span>
<span class="lineno"> 1376 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno"> 1377 </span>
<span class="lineno"> 1378 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue a =&gt; IsValue (JVMSetupM a)</span></span></span></span> where
<span class="lineno"> 1379 </span>    <span class="decl"><span class="istickedoff">toValue name m =</span>
<span class="lineno"> 1380 </span><span class="spaces">      </span><span class="istickedoff">VJVMSetup <span class="nottickedoff">atRestPos</span> [] (fmap (toValue <span class="nottickedoff">name</span>) m)</span></span>
<span class="lineno"> 1381 </span>
<span class="lineno"> 1382 </span>instance FromValue a =&gt; FromValue (JVMSetupM a) where
<span class="lineno"> 1383 </span>    <span class="decl"><span class="istickedoff">fromValue how v = do</span>
<span class="lineno"> 1384 </span><span class="spaces">      </span><span class="istickedoff">v' &lt;- interpretMonadAction how v</span>
<span class="lineno"> 1385 </span><span class="spaces">      </span><span class="istickedoff">case v' of</span>
<span class="lineno"> 1386 </span><span class="spaces">        </span><span class="istickedoff">VJVMSetup pos chain action -&gt;</span>
<span class="lineno"> 1387 </span><span class="spaces">          </span><span class="istickedoff">fromValue <span class="nottickedoff">how</span> &lt;$&gt; preparePlainMonadicAction how pos chain action</span>
<span class="lineno"> 1388 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 1389 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">panic &quot;fromValue (JVMSetup)&quot; [</span></span>
<span class="lineno"> 1390 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">&quot;Invalid/ill-typed value: &quot; &lt;&gt; Text.pack (show v')</span></span>
<span class="lineno"> 1391 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno"> 1392 </span>
<span class="lineno"> 1393 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue a =&gt; IsValue (MIRSetupM a)</span></span></span></span> where
<span class="lineno"> 1394 </span>    <span class="decl"><span class="istickedoff">toValue name m =</span>
<span class="lineno"> 1395 </span><span class="spaces">      </span><span class="istickedoff">VMIRSetup <span class="nottickedoff">atRestPos</span> [] (fmap (toValue <span class="nottickedoff">name</span>) m)</span></span>
<span class="lineno"> 1396 </span>
<span class="lineno"> 1397 </span>instance FromValue a =&gt; FromValue (MIRSetupM a) where
<span class="lineno"> 1398 </span>    <span class="decl"><span class="istickedoff">fromValue how v = do</span>
<span class="lineno"> 1399 </span><span class="spaces">      </span><span class="istickedoff">v' &lt;- interpretMonadAction how v</span>
<span class="lineno"> 1400 </span><span class="spaces">      </span><span class="istickedoff">case v' of</span>
<span class="lineno"> 1401 </span><span class="spaces">        </span><span class="istickedoff">VMIRSetup pos chain action -&gt;</span>
<span class="lineno"> 1402 </span><span class="spaces">          </span><span class="istickedoff">fromValue <span class="nottickedoff">how</span> &lt;$&gt; preparePlainMonadicAction how pos chain action</span>
<span class="lineno"> 1403 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 1404 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">panic &quot;fromValue (MIRSetup)&quot; [</span></span>
<span class="lineno"> 1405 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">&quot;Invalid/ill-typed value: &quot; &lt;&gt; Text.pack (show v')</span></span>
<span class="lineno"> 1406 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno"> 1407 </span>
<span class="lineno"> 1408 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue (CIR.AllLLVM CMS.SetupValue)</span></span></span></span> where
<span class="lineno"> 1409 </span>  <span class="decl"><span class="istickedoff">toValue _name v = VLLVMCrucibleSetupValue v</span></span>
<span class="lineno"> 1410 </span>
<span class="lineno"> 1411 </span>instance FromValue (CIR.AllLLVM CMS.SetupValue) where
<span class="lineno"> 1412 </span>  <span class="decl"><span class="istickedoff">fromValue _ (VLLVMCrucibleSetupValue v) = v</span>
<span class="lineno"> 1413 </span><span class="spaces">  </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue Crucible.SetupValue&quot;</span></span></span>
<span class="lineno"> 1414 </span>
<span class="lineno"> 1415 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue (CMS.SetupValue CJ.JVM)</span></span></span></span> where
<span class="lineno"> 1416 </span>  <span class="decl"><span class="istickedoff">toValue _name v = VJVMSetupValue v</span></span>
<span class="lineno"> 1417 </span>
<span class="lineno"> 1418 </span>instance FromValue (CMS.SetupValue CJ.JVM) where
<span class="lineno"> 1419 </span>  <span class="decl"><span class="istickedoff">fromValue _ (VJVMSetupValue v) = v</span>
<span class="lineno"> 1420 </span><span class="spaces">  </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue Crucible.SetupValue&quot;</span></span></span>
<span class="lineno"> 1421 </span>
<span class="lineno"> 1422 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue (CMS.SetupValue MIR)</span></span></span></span> where
<span class="lineno"> 1423 </span>  <span class="decl"><span class="istickedoff">toValue _name v = VMIRSetupValue v</span></span>
<span class="lineno"> 1424 </span>
<span class="lineno"> 1425 </span>instance FromValue (CMS.SetupValue MIR) where
<span class="lineno"> 1426 </span>  <span class="decl"><span class="istickedoff">fromValue _ (VMIRSetupValue v) = v</span>
<span class="lineno"> 1427 </span><span class="spaces">  </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue Crucible.SetupValue&quot;</span></span></span>
<span class="lineno"> 1428 </span>
<span class="lineno"> 1429 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue SAW_CFG</span></span></span></span> where
<span class="lineno"> 1430 </span>    <span class="decl"><span class="nottickedoff">toValue _name t = VCFG t</span></span>
<span class="lineno"> 1431 </span>
<span class="lineno"> 1432 </span>instance FromValue SAW_CFG where
<span class="lineno"> 1433 </span>    <span class="decl"><span class="nottickedoff">fromValue _ (VCFG t) = t</span>
<span class="lineno"> 1434 </span><span class="spaces">    </span><span class="nottickedoff">fromValue _ _ = error &quot;fromValue CFG&quot;</span></span>
<span class="lineno"> 1435 </span>
<span class="lineno"> 1436 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue (CIR.SomeLLVM CMS.ProvedSpec)</span></span></span></span> where
<span class="lineno"> 1437 </span>    <span class="decl"><span class="istickedoff">toValue _name mir = VLLVMCrucibleMethodSpec mir</span></span>
<span class="lineno"> 1438 </span>
<span class="lineno"> 1439 </span>instance FromValue (CIR.SomeLLVM CMS.ProvedSpec) where
<span class="lineno"> 1440 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VLLVMCrucibleMethodSpec mir) = mir</span>
<span class="lineno"> 1441 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue ProvedSpec LLVM&quot;</span></span></span>
<span class="lineno"> 1442 </span>
<span class="lineno"> 1443 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue (CMS.ProvedSpec CJ.JVM)</span></span></span></span> where
<span class="lineno"> 1444 </span>    <span class="decl"><span class="istickedoff">toValue _name t = VJVMMethodSpec t</span></span>
<span class="lineno"> 1445 </span>
<span class="lineno"> 1446 </span>instance FromValue (CMS.ProvedSpec CJ.JVM) where
<span class="lineno"> 1447 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VJVMMethodSpec t) = t</span>
<span class="lineno"> 1448 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue ProvedSpec JVM&quot;</span></span></span>
<span class="lineno"> 1449 </span>
<span class="lineno"> 1450 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue (CMS.ProvedSpec MIR)</span></span></span></span> where
<span class="lineno"> 1451 </span>    <span class="decl"><span class="istickedoff">toValue _name t = VMIRMethodSpec t</span></span>
<span class="lineno"> 1452 </span>
<span class="lineno"> 1453 </span>instance FromValue (CMS.ProvedSpec MIR) where
<span class="lineno"> 1454 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VMIRMethodSpec t) = t</span>
<span class="lineno"> 1455 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue ProvedSpec MIR&quot;</span></span></span>
<span class="lineno"> 1456 </span>
<span class="lineno"> 1457 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue ModuleSkeleton</span></span></span></span> where
<span class="lineno"> 1458 </span>    <span class="decl"><span class="nottickedoff">toValue _name s = VLLVMModuleSkeleton s</span></span>
<span class="lineno"> 1459 </span>
<span class="lineno"> 1460 </span>instance FromValue ModuleSkeleton where
<span class="lineno"> 1461 </span>    <span class="decl"><span class="nottickedoff">fromValue _ (VLLVMModuleSkeleton s) = s</span>
<span class="lineno"> 1462 </span><span class="spaces">    </span><span class="nottickedoff">fromValue _ _ = error &quot;fromValue ModuleSkeleton&quot;</span></span>
<span class="lineno"> 1463 </span>
<span class="lineno"> 1464 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue FunctionSkeleton</span></span></span></span> where
<span class="lineno"> 1465 </span>    <span class="decl"><span class="nottickedoff">toValue _name s = VLLVMFunctionSkeleton s</span></span>
<span class="lineno"> 1466 </span>
<span class="lineno"> 1467 </span>instance FromValue FunctionSkeleton where
<span class="lineno"> 1468 </span>    <span class="decl"><span class="nottickedoff">fromValue _ (VLLVMFunctionSkeleton s) = s</span>
<span class="lineno"> 1469 </span><span class="spaces">    </span><span class="nottickedoff">fromValue _ _ = error &quot;fromValue FunctionSkeleton&quot;</span></span>
<span class="lineno"> 1470 </span>
<span class="lineno"> 1471 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue SkeletonState</span></span></span></span> where
<span class="lineno"> 1472 </span>    <span class="decl"><span class="nottickedoff">toValue _name s = VLLVMSkeletonState s</span></span>
<span class="lineno"> 1473 </span>
<span class="lineno"> 1474 </span>instance FromValue SkeletonState where
<span class="lineno"> 1475 </span>    <span class="decl"><span class="nottickedoff">fromValue _ (VLLVMSkeletonState s) = s</span>
<span class="lineno"> 1476 </span><span class="spaces">    </span><span class="nottickedoff">fromValue _ _ = error &quot;fromValue SkeletonState&quot;</span></span>
<span class="lineno"> 1477 </span>
<span class="lineno"> 1478 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue FunctionProfile</span></span></span></span> where
<span class="lineno"> 1479 </span>    <span class="decl"><span class="nottickedoff">toValue _name s = VLLVMFunctionProfile s</span></span>
<span class="lineno"> 1480 </span>
<span class="lineno"> 1481 </span>instance FromValue FunctionProfile where
<span class="lineno"> 1482 </span>    <span class="decl"><span class="nottickedoff">fromValue _ (VLLVMFunctionProfile s) = s</span>
<span class="lineno"> 1483 </span><span class="spaces">    </span><span class="nottickedoff">fromValue _ _ = error &quot;fromValue FunctionProfile&quot;</span></span>
<span class="lineno"> 1484 </span>
<span class="lineno"> 1485 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue (AIGNetwork)</span></span></span></span> where
<span class="lineno"> 1486 </span>    <span class="decl"><span class="nottickedoff">toValue _name t = VAIG t</span></span>
<span class="lineno"> 1487 </span>
<span class="lineno"> 1488 </span>instance FromValue (AIGNetwork) where
<span class="lineno"> 1489 </span>    <span class="decl"><span class="nottickedoff">fromValue _ (VAIG t) = t</span>
<span class="lineno"> 1490 </span><span class="spaces">    </span><span class="nottickedoff">fromValue _ _ = error &quot;fromValue AIGNetwork&quot;</span></span>
<span class="lineno"> 1491 </span>
<span class="lineno"> 1492 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue TypedTerm</span></span></span></span> where
<span class="lineno"> 1493 </span>    <span class="decl"><span class="istickedoff">toValue _name t = VTerm t</span></span>
<span class="lineno"> 1494 </span>
<span class="lineno"> 1495 </span>instance FromValue TypedTerm where
<span class="lineno"> 1496 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VTerm t) = t</span>
<span class="lineno"> 1497 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue TypedTerm&quot;</span></span></span>
<span class="lineno"> 1498 </span>
<span class="lineno"> 1499 </span>instance FromValue Term where
<span class="lineno"> 1500 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VTerm t) = ttTerm t</span>
<span class="lineno"> 1501 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue SharedTerm&quot;</span></span></span>
<span class="lineno"> 1502 </span>
<span class="lineno"> 1503 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue Cryptol.Schema</span></span></span></span> where
<span class="lineno"> 1504 </span>    <span class="decl"><span class="nottickedoff">toValue _name s = VType s</span></span>
<span class="lineno"> 1505 </span>
<span class="lineno"> 1506 </span>instance FromValue Cryptol.Schema where
<span class="lineno"> 1507 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VType s) = s</span>
<span class="lineno"> 1508 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue Schema&quot;</span></span></span>
<span class="lineno"> 1509 </span>
<span class="lineno"> 1510 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue Text</span></span></span></span> where
<span class="lineno"> 1511 </span>    <span class="decl"><span class="istickedoff">toValue _name n = VString n</span></span>
<span class="lineno"> 1512 </span>
<span class="lineno"> 1513 </span>instance FromValue Text where
<span class="lineno"> 1514 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VString n) = n</span>
<span class="lineno"> 1515 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = error &quot;fromValue Text&quot;</span></span>
<span class="lineno"> 1516 </span>
<span class="lineno"> 1517 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue Integer</span></span></span></span> where
<span class="lineno"> 1518 </span>    <span class="decl"><span class="istickedoff">toValue _name n = VInteger n</span></span>
<span class="lineno"> 1519 </span>
<span class="lineno"> 1520 </span>instance FromValue Integer where
<span class="lineno"> 1521 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VInteger n) = n</span>
<span class="lineno"> 1522 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue Integer&quot;</span></span></span>
<span class="lineno"> 1523 </span>
<span class="lineno"> 1524 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue Int</span></span></span></span> where
<span class="lineno"> 1525 </span>    <span class="decl"><span class="istickedoff">toValue _name n = VInteger (toInteger n)</span></span>
<span class="lineno"> 1526 </span>
<span class="lineno"> 1527 </span>instance FromValue Int where
<span class="lineno"> 1528 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VInteger n)</span>
<span class="lineno"> 1529 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">toInteger (minBound :: Int) &lt;= n &amp;&amp;</span></span>
<span class="lineno"> 1530 </span><span class="spaces">        </span><span class="istickedoff"><span class="tickonlytrue">toInteger (maxBound :: Int) &gt;= n</span> = fromIntegral n</span>
<span class="lineno"> 1531 </span><span class="spaces">      </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> = <span class="nottickedoff">error $ &quot;fromValue Int: out of range: &quot; ++ show n</span></span>
<span class="lineno"> 1532 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue Int&quot;</span></span></span>
<span class="lineno"> 1533 </span>
<span class="lineno"> 1534 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue Bool</span></span></span></span> where
<span class="lineno"> 1535 </span>    <span class="decl"><span class="istickedoff">toValue _name b = VBool b</span></span>
<span class="lineno"> 1536 </span>
<span class="lineno"> 1537 </span>instance FromValue Bool where
<span class="lineno"> 1538 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VBool b) = b</span>
<span class="lineno"> 1539 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue Bool&quot;</span></span></span>
<span class="lineno"> 1540 </span>
<span class="lineno"> 1541 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue SAWSimpset</span></span></span></span> where
<span class="lineno"> 1542 </span>    <span class="decl"><span class="istickedoff">toValue _name ss = VSimpset ss</span></span>
<span class="lineno"> 1543 </span>
<span class="lineno"> 1544 </span>instance FromValue SAWSimpset where
<span class="lineno"> 1545 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VSimpset ss) = ss</span>
<span class="lineno"> 1546 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue Simpset&quot;</span></span></span>
<span class="lineno"> 1547 </span>
<span class="lineno"> 1548 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue Theorem</span></span></span></span> where
<span class="lineno"> 1549 </span>    <span class="decl"><span class="istickedoff">toValue _name t = VTheorem t</span></span>
<span class="lineno"> 1550 </span>
<span class="lineno"> 1551 </span>instance FromValue Theorem where
<span class="lineno"> 1552 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VTheorem t) = t</span>
<span class="lineno"> 1553 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue Theorem&quot;</span></span></span>
<span class="lineno"> 1554 </span>
<span class="lineno"> 1555 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue BisimTheorem</span></span></span></span> where
<span class="lineno"> 1556 </span>    <span class="decl"><span class="istickedoff">toValue _name = VBisimTheorem</span></span>
<span class="lineno"> 1557 </span>
<span class="lineno"> 1558 </span>instance FromValue BisimTheorem where
<span class="lineno"> 1559 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VBisimTheorem t) = t</span>
<span class="lineno"> 1560 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue BisimTheorem&quot;</span></span></span>
<span class="lineno"> 1561 </span>
<span class="lineno"> 1562 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue JavaType</span></span></span></span> where
<span class="lineno"> 1563 </span>    <span class="decl"><span class="istickedoff">toValue _name t = VJavaType t</span></span>
<span class="lineno"> 1564 </span>
<span class="lineno"> 1565 </span>instance FromValue JavaType where
<span class="lineno"> 1566 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VJavaType t) = t</span>
<span class="lineno"> 1567 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue JavaType&quot;</span></span></span>
<span class="lineno"> 1568 </span>
<span class="lineno"> 1569 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue LLVM.Type</span></span></span></span> where
<span class="lineno"> 1570 </span>    <span class="decl"><span class="istickedoff">toValue _name t = VLLVMType t</span></span>
<span class="lineno"> 1571 </span>
<span class="lineno"> 1572 </span>instance FromValue LLVM.Type where
<span class="lineno"> 1573 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VLLVMType t) = t</span>
<span class="lineno"> 1574 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue LLVMType&quot;</span></span></span>
<span class="lineno"> 1575 </span>
<span class="lineno"> 1576 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue MIR.Ty</span></span></span></span> where
<span class="lineno"> 1577 </span>    <span class="decl"><span class="istickedoff">toValue _name t = VMIRType t</span></span>
<span class="lineno"> 1578 </span>
<span class="lineno"> 1579 </span>instance FromValue MIR.Ty where
<span class="lineno"> 1580 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VMIRType t) = t</span>
<span class="lineno"> 1581 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue MIRType&quot;</span></span></span>
<span class="lineno"> 1582 </span>
<span class="lineno"> 1583 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue CEnv.ExtCryptolModule</span></span></span></span> where
<span class="lineno"> 1584 </span>    <span class="decl"><span class="istickedoff">toValue _name m = VCryptolModule m</span></span>
<span class="lineno"> 1585 </span>
<span class="lineno"> 1586 </span>instance FromValue CEnv.ExtCryptolModule where
<span class="lineno"> 1587 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VCryptolModule m) = m</span>
<span class="lineno"> 1588 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue CryptolModule&quot;</span></span></span>
<span class="lineno"> 1589 </span>
<span class="lineno"> 1590 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue JSS.Class</span></span></span></span> where
<span class="lineno"> 1591 </span>    <span class="decl"><span class="istickedoff">toValue _name c = VJavaClass c</span></span>
<span class="lineno"> 1592 </span>
<span class="lineno"> 1593 </span>instance FromValue JSS.Class where
<span class="lineno"> 1594 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VJavaClass c) = c</span>
<span class="lineno"> 1595 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue JavaClass&quot;</span></span></span>
<span class="lineno"> 1596 </span>
<span class="lineno"> 1597 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue (Some CIR.LLVMModule)</span></span></span></span> where
<span class="lineno"> 1598 </span>    <span class="decl"><span class="istickedoff">toValue _name m = VLLVMModule m</span></span>
<span class="lineno"> 1599 </span>
<span class="lineno"> 1600 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue (CIR.LLVMModule arch)</span></span></span></span> where
<span class="lineno"> 1601 </span>    <span class="decl"><span class="nottickedoff">toValue _name m = VLLVMModule (Some m)</span></span>
<span class="lineno"> 1602 </span>
<span class="lineno"> 1603 </span>instance FromValue (Some CIR.LLVMModule) where
<span class="lineno"> 1604 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VLLVMModule m) = m</span>
<span class="lineno"> 1605 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue LLVMModule&quot;</span></span></span>
<span class="lineno"> 1606 </span>
<span class="lineno"> 1607 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue MIR.RustModule</span></span></span></span> where
<span class="lineno"> 1608 </span>    <span class="decl"><span class="istickedoff">toValue _name m = VMIRModule m</span></span>
<span class="lineno"> 1609 </span>
<span class="lineno"> 1610 </span>instance FromValue MIR.RustModule where
<span class="lineno"> 1611 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VMIRModule m) = m</span>
<span class="lineno"> 1612 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue RustModule&quot;</span></span></span>
<span class="lineno"> 1613 </span>
<span class="lineno"> 1614 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue MIR.Adt</span></span></span></span> where
<span class="lineno"> 1615 </span>    <span class="decl"><span class="istickedoff">toValue _name adt = VMIRAdt adt</span></span>
<span class="lineno"> 1616 </span>
<span class="lineno"> 1617 </span>instance FromValue MIR.Adt where
<span class="lineno"> 1618 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VMIRAdt adt) = adt</span>
<span class="lineno"> 1619 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue Adt&quot;</span></span></span>
<span class="lineno"> 1620 </span>
<span class="lineno"> 1621 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue ProofResult</span></span></span></span> where
<span class="lineno"> 1622 </span>   <span class="decl"><span class="istickedoff">toValue _name r = VProofResult r</span></span>
<span class="lineno"> 1623 </span>
<span class="lineno"> 1624 </span>instance FromValue ProofResult where
<span class="lineno"> 1625 </span>   <span class="decl"><span class="istickedoff">fromValue _ (VProofResult r) = r</span>
<span class="lineno"> 1626 </span><span class="spaces">   </span><span class="istickedoff">fromValue _ v = <span class="nottickedoff">error $ &quot;fromValue ProofResult: &quot; ++ show v</span></span></span>
<span class="lineno"> 1627 </span>
<span class="lineno"> 1628 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue SatResult</span></span></span></span> where
<span class="lineno"> 1629 </span>   <span class="decl"><span class="istickedoff">toValue _name r = VSatResult r</span></span>
<span class="lineno"> 1630 </span>
<span class="lineno"> 1631 </span>instance FromValue SatResult where
<span class="lineno"> 1632 </span>   <span class="decl"><span class="istickedoff">fromValue _ (VSatResult r) = r</span>
<span class="lineno"> 1633 </span><span class="spaces">   </span><span class="istickedoff">fromValue _ v = <span class="nottickedoff">error $ &quot;fromValue SatResult: &quot; ++ show v</span></span></span>
<span class="lineno"> 1634 </span>
<span class="lineno"> 1635 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue CMS.GhostGlobal</span></span></span></span> where
<span class="lineno"> 1636 </span>  <span class="decl"><span class="nottickedoff">toValue _name x = VGhostVar x</span></span>
<span class="lineno"> 1637 </span>
<span class="lineno"> 1638 </span>instance FromValue CMS.GhostGlobal where
<span class="lineno"> 1639 </span>  <span class="decl"><span class="istickedoff">fromValue _ (VGhostVar r) = r</span>
<span class="lineno"> 1640 </span><span class="spaces">  </span><span class="istickedoff">fromValue _ v = <span class="nottickedoff">error (&quot;fromValue GlobalVar: &quot; ++ show v)</span></span></span>
<span class="lineno"> 1641 </span>
<span class="lineno"> 1642 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue Yo.YosysIR</span></span></span></span> where
<span class="lineno"> 1643 </span>  <span class="decl"><span class="nottickedoff">toValue _name ym = VYosysModule ym</span></span>
<span class="lineno"> 1644 </span>
<span class="lineno"> 1645 </span>instance FromValue Yo.YosysIR where
<span class="lineno"> 1646 </span>  <span class="decl"><span class="nottickedoff">fromValue _ (VYosysModule ir) = ir</span>
<span class="lineno"> 1647 </span><span class="spaces">  </span><span class="nottickedoff">fromValue _ v = error (&quot;fromValue YosysIR: &quot; ++ show v)</span></span>
<span class="lineno"> 1648 </span>
<span class="lineno"> 1649 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue Yo.YosysImport</span></span></span></span> where
<span class="lineno"> 1650 </span>  <span class="decl"><span class="nottickedoff">toValue _name yi = VYosysImport yi</span></span>
<span class="lineno"> 1651 </span>
<span class="lineno"> 1652 </span>instance FromValue Yo.YosysImport where
<span class="lineno"> 1653 </span>  <span class="decl"><span class="nottickedoff">fromValue _ (VYosysImport i) = i</span>
<span class="lineno"> 1654 </span><span class="spaces">  </span><span class="nottickedoff">fromValue _ v = error (&quot;fromValue YosysImport: &quot; ++ show v)</span></span>
<span class="lineno"> 1655 </span>
<span class="lineno"> 1656 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue Yo.YosysSequential</span></span></span></span> where
<span class="lineno"> 1657 </span>  <span class="decl"><span class="istickedoff">toValue _name ysq = VYosysSequential ysq</span></span>
<span class="lineno"> 1658 </span>
<span class="lineno"> 1659 </span>instance FromValue Yo.YosysSequential where
<span class="lineno"> 1660 </span>  <span class="decl"><span class="istickedoff">fromValue _ (VYosysSequential s) = s</span>
<span class="lineno"> 1661 </span><span class="spaces">  </span><span class="istickedoff">fromValue _ v = <span class="nottickedoff">error (&quot;fromValue YosysSequential: &quot; ++ show v)</span></span></span>
<span class="lineno"> 1662 </span>
<span class="lineno"> 1663 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue Yo.YosysTheorem</span></span></span></span> where
<span class="lineno"> 1664 </span>  <span class="decl"><span class="istickedoff">toValue _name yt = VYosysTheorem yt</span></span>
<span class="lineno"> 1665 </span>
<span class="lineno"> 1666 </span>instance FromValue Yo.YosysTheorem where
<span class="lineno"> 1667 </span>  <span class="decl"><span class="istickedoff">fromValue _ (VYosysTheorem thm) = thm</span>
<span class="lineno"> 1668 </span><span class="spaces">  </span><span class="istickedoff">fromValue _ v = <span class="nottickedoff">error (&quot;fromValue YosysTheorem: &quot; ++ show v)</span></span></span>
<span class="lineno"> 1669 </span>
<span class="lineno"> 1670 </span>
<span class="lineno"> 1671 </span>------------------------------------------------------------
<span class="lineno"> 1672 </span>-- Primitives
<span class="lineno"> 1673 </span>
<span class="lineno"> 1674 </span>add_primitives :: PrimitiveLifecycle -&gt; BuiltinContext -&gt; Options -&gt; TopLevel ()
<span class="lineno"> 1675 </span><span class="decl"><span class="istickedoff">add_primitives lc _bic _opts = do</span>
<span class="lineno"> 1676 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1677 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw {</span>
<span class="lineno"> 1678 </span><span class="spaces">    </span><span class="istickedoff">rwPrimsAvail = Set.insert lc (rwPrimsAvail rw)</span>
<span class="lineno"> 1679 </span><span class="spaces">  </span><span class="istickedoff">}</span></span>
<span class="lineno"> 1680 </span>
<span class="lineno"> 1681 </span>toplevelSubshell :: () -&gt; TopLevel Value
<span class="lineno"> 1682 </span><span class="decl"><span class="nottickedoff">toplevelSubshell () = do</span>
<span class="lineno"> 1683 </span><span class="spaces">     </span><span class="nottickedoff">m &lt;- roSubshell &lt;$&gt; ask</span>
<span class="lineno"> 1684 </span><span class="spaces">     </span><span class="nottickedoff">env &lt;- getLocalEnv</span>
<span class="lineno"> 1685 </span><span class="spaces">     </span><span class="nottickedoff">toValue &quot;subshell&quot; &lt;$&gt; withLocalEnv env m</span></span>
<span class="lineno"> 1686 </span>
<span class="lineno"> 1687 </span>proofScriptSubshell :: () -&gt; ProofScript Value
<span class="lineno"> 1688 </span><span class="decl"><span class="istickedoff">proofScriptSubshell () = do</span>
<span class="lineno"> 1689 </span><span class="spaces">     </span><span class="istickedoff">m &lt;- scriptTopLevel $ asks roProofSubshell</span>
<span class="lineno"> 1690 </span><span class="spaces">     </span><span class="istickedoff">env &lt;- scriptTopLevel $ getLocalEnv</span>
<span class="lineno"> 1691 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">toValue &quot;proof_subshell&quot;</span> &lt;$&gt; withLocalEnvProof env m</span></span>
<span class="lineno"> 1692 </span>
<span class="lineno"> 1693 </span>-- The &quot;for&quot; builtin.
<span class="lineno"> 1694 </span>--
<span class="lineno"> 1695 </span>-- XXX: this is the only thing in the tree that uses VBindOnce.
<span class="lineno"> 1696 </span>-- Unfortunately, for the time being it needs to be this way:
<span class="lineno"> 1697 </span>--    - as a builtin it can only operate in Value;
<span class="lineno"> 1698 </span>--    - VDo contains abstract syntax;
<span class="lineno"> 1699 </span>--    - there is no way to lift an arbitrary Value into the abstract
<span class="lineno"> 1700 </span>--      syntax, and there won't be anytime soon, because there's
<span class="lineno"> 1701 </span>--      already enough of a tangle with Value and the interpreter
<span class="lineno"> 1702 </span>--      state without also including the entire abstract syntax in
<span class="lineno"> 1703 </span>--      the yarn ball;
<span class="lineno"> 1704 </span>--    - it needs to be able to do SAWScript-level binds and those
<span class="lineno"> 1705 </span>--      are the only ways.
<span class="lineno"> 1706 </span>--
<span class="lineno"> 1707 </span>-- Probably the best long-term solution is to move the implementation
<span class="lineno"> 1708 </span>-- into the SAWScript prelude, once we have one (see #253; that
<span class="lineno"> 1709 </span>-- issue's been open a long time), since the only thing stopping that
<span class="lineno"> 1710 </span>-- is having a place to put the code.
<span class="lineno"> 1711 </span>--
<span class="lineno"> 1712 </span>-- Failing that, at some point the SAWScript interpreter will
<span class="lineno"> 1713 </span>-- hopefully have been cleaned up to the point where there's a Value
<span class="lineno"> 1714 </span>-- case in the abstract syntax, which there properly speaking should
<span class="lineno"> 1715 </span>-- be anyway, at which point this can be rewritten with VDo.
<span class="lineno"> 1716 </span>--
<span class="lineno"> 1717 </span>-- Failing _that_, it's probably possible to open-code the bind here
<span class="lineno"> 1718 </span>-- in terms of calling pieces of the interpreter directly, but that's
<span class="lineno"> 1719 </span>-- likely to be quite messy.
<span class="lineno"> 1720 </span>--
<span class="lineno"> 1721 </span>forValue :: [Value] -&gt; Value -&gt; TopLevel Value
<span class="lineno"> 1722 </span><span class="decl"><span class="istickedoff">forValue [] _ = return $ VReturn <span class="nottickedoff">atRestPos</span> [] (VArray [])</span>
<span class="lineno"> 1723 </span><span class="spaces"></span><span class="istickedoff">forValue (x : xs) f = do</span>
<span class="lineno"> 1724 </span><span class="spaces">   </span><span class="istickedoff">let pos = SS.PosInsideBuiltin</span>
<span class="lineno"> 1725 </span><span class="spaces">   </span><span class="istickedoff">m1 &lt;- applyValue pos <span class="nottickedoff">&quot;(value was in a \&quot;for\&quot;)&quot;</span> f x</span>
<span class="lineno"> 1726 </span><span class="spaces">   </span><span class="istickedoff">m2 &lt;- forValue xs f</span>
<span class="lineno"> 1727 </span><span class="spaces">   </span><span class="istickedoff">return $ VBindOnce pos [] m1 $ VBuiltin &quot;for&quot; <span class="nottickedoff">Seq.empty</span> $ OneMoreArg $ \v1 -&gt;</span>
<span class="lineno"> 1728 </span><span class="spaces">     </span><span class="istickedoff">return $ VBindOnce <span class="nottickedoff">pos</span> [] m2 $ VBuiltin <span class="nottickedoff">&quot;for&quot;</span> <span class="nottickedoff">Seq.empty</span> $ OneMoreArg $ \v2 -&gt;</span>
<span class="lineno"> 1729 </span><span class="spaces">       </span><span class="istickedoff">return $ VReturn <span class="nottickedoff">atRestPos</span> [] (VArray (v1 : fromValue <span class="nottickedoff">FromArgument</span> v2))</span></span>
<span class="lineno"> 1730 </span>
<span class="lineno"> 1731 </span>caseProofResultPrim ::
<span class="lineno"> 1732 </span>  ProofResult -&gt;
<span class="lineno"> 1733 </span>  Value {- ^ valid case -} -&gt;
<span class="lineno"> 1734 </span>  Value {- ^ invalid/unknown case -} -&gt;
<span class="lineno"> 1735 </span>  TopLevel Value
<span class="lineno"> 1736 </span><span class="decl"><span class="istickedoff">caseProofResultPrim pr vValid vInvalid = do</span>
<span class="lineno"> 1737 </span><span class="spaces">  </span><span class="istickedoff">let <span class="nottickedoff">infoValid = &quot;(value was the valid case of caseProofResult)&quot;</span></span>
<span class="lineno"> 1738 </span><span class="spaces">  </span><span class="istickedoff">let <span class="nottickedoff">infoInvalid = &quot;(value was the invalid case of caseProofResult)&quot;</span></span>
<span class="lineno"> 1739 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1740 </span><span class="spaces">  </span><span class="istickedoff">-- This is a builtin; we can use the posted global position</span>
<span class="lineno"> 1741 </span><span class="spaces">  </span><span class="istickedoff">pos &lt;- getPosition</span>
<span class="lineno"> 1742 </span><span class="spaces">  </span><span class="istickedoff">case pr of</span>
<span class="lineno"> 1743 </span><span class="spaces">    </span><span class="istickedoff">ValidProof _ thm -&gt;</span>
<span class="lineno"> 1744 </span><span class="spaces">      </span><span class="istickedoff">applyValue <span class="nottickedoff">pos</span> <span class="nottickedoff">infoValid</span> vValid (VTheorem thm)</span>
<span class="lineno"> 1745 </span><span class="spaces">    </span><span class="istickedoff">InvalidProof _ pairs _pst -&gt; do</span>
<span class="lineno"> 1746 </span><span class="spaces">      </span><span class="istickedoff">let fov = FOVTuple (map snd pairs)</span>
<span class="lineno"> 1747 </span><span class="spaces">      </span><span class="istickedoff">tt &lt;- io $ typedTermOfFirstOrderValue sc fov</span>
<span class="lineno"> 1748 </span><span class="spaces">      </span><span class="istickedoff">applyValue <span class="nottickedoff">pos</span> <span class="nottickedoff">infoInvalid</span> vInvalid (VTerm tt)</span>
<span class="lineno"> 1749 </span><span class="spaces">    </span><span class="istickedoff">UnfinishedProof _ -&gt; do</span>
<span class="lineno"> 1750 </span><span class="spaces">      </span><span class="istickedoff">tt &lt;- io $ typedTermOfFirstOrderValue sc (FOVTuple [])</span>
<span class="lineno"> 1751 </span><span class="spaces">      </span><span class="istickedoff">applyValue <span class="nottickedoff">pos</span> <span class="nottickedoff">infoInvalid</span> vInvalid (VTerm tt)</span></span>
<span class="lineno"> 1752 </span>
<span class="lineno"> 1753 </span>caseSatResultPrim ::
<span class="lineno"> 1754 </span>  SatResult -&gt;
<span class="lineno"> 1755 </span>  Value {- ^ unsat case -} -&gt;
<span class="lineno"> 1756 </span>  Value {- ^ sat/unknown case -} -&gt;
<span class="lineno"> 1757 </span>  TopLevel Value
<span class="lineno"> 1758 </span><span class="decl"><span class="istickedoff">caseSatResultPrim sr vUnsat vSat = do</span>
<span class="lineno"> 1759 </span><span class="spaces">  </span><span class="istickedoff">let <span class="nottickedoff">info = &quot;(value was the sat case of caseSatResult)&quot;</span></span>
<span class="lineno"> 1760 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1761 </span><span class="spaces">  </span><span class="istickedoff">-- This is a builtin; we can use the posted global position</span>
<span class="lineno"> 1762 </span><span class="spaces">  </span><span class="istickedoff">pos &lt;- getPosition</span>
<span class="lineno"> 1763 </span><span class="spaces">  </span><span class="istickedoff">case sr of</span>
<span class="lineno"> 1764 </span><span class="spaces">    </span><span class="istickedoff">Unsat _ -&gt; return vUnsat</span>
<span class="lineno"> 1765 </span><span class="spaces">    </span><span class="istickedoff">Sat _ pairs -&gt; do</span>
<span class="lineno"> 1766 </span><span class="spaces">      </span><span class="istickedoff">let fov = FOVTuple (map snd pairs)</span>
<span class="lineno"> 1767 </span><span class="spaces">      </span><span class="istickedoff">tt &lt;- io $ typedTermOfFirstOrderValue sc fov</span>
<span class="lineno"> 1768 </span><span class="spaces">      </span><span class="istickedoff">applyValue <span class="nottickedoff">pos</span> <span class="nottickedoff">info</span> vSat (VTerm tt)</span>
<span class="lineno"> 1769 </span><span class="spaces">    </span><span class="istickedoff">SatUnknown -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno"> 1770 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">let fov = FOVTuple []</span></span>
<span class="lineno"> 1771 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">tt &lt;- io $ typedTermOfFirstOrderValue sc fov</span></span>
<span class="lineno"> 1772 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">applyValue pos info vSat (VTerm tt)</span></span></span>
<span class="lineno"> 1773 </span>
<span class="lineno"> 1774 </span>print_stack :: TopLevel ()
<span class="lineno"> 1775 </span><span class="decl"><span class="istickedoff">print_stack = do</span>
<span class="lineno"> 1776 </span><span class="spaces">  </span><span class="istickedoff">-- We are inside a builtin here, namely print_stack.</span>
<span class="lineno"> 1777 </span><span class="spaces">  </span><span class="istickedoff">let pos = SS.PosInsideBuiltin</span>
<span class="lineno"> 1778 </span><span class="spaces">  </span><span class="istickedoff">trace &lt;- getStackTrace</span>
<span class="lineno"> 1779 </span><span class="spaces">  </span><span class="istickedoff">let trace' = Trace.ppTrace trace pos</span>
<span class="lineno"> 1780 </span><span class="spaces">  </span><span class="istickedoff">io $ TextIO.putStrLn &quot;Stack trace:&quot;</span>
<span class="lineno"> 1781 </span><span class="spaces">  </span><span class="istickedoff">io $ TextIO.putStrLn trace'</span></span>
<span class="lineno"> 1782 </span>
<span class="lineno"> 1783 </span>proof_stack :: ProofScript ()
<span class="lineno"> 1784 </span><span class="decl"><span class="istickedoff">proof_stack = scriptTopLevel print_stack</span></span>
<span class="lineno"> 1785 </span>
<span class="lineno"> 1786 </span>llvm_stack :: LLVMCrucibleSetupM ()
<span class="lineno"> 1787 </span><span class="decl"><span class="istickedoff">llvm_stack = llvmTopLevel print_stack</span></span>
<span class="lineno"> 1788 </span>
<span class="lineno"> 1789 </span>jvm_stack :: JVMSetupM ()
<span class="lineno"> 1790 </span><span class="decl"><span class="nottickedoff">jvm_stack = jvmTopLevel print_stack</span></span>
<span class="lineno"> 1791 </span>
<span class="lineno"> 1792 </span>mir_stack :: MIRSetupM ()
<span class="lineno"> 1793 </span><span class="decl"><span class="nottickedoff">mir_stack = mirTopLevel print_stack</span></span>
<span class="lineno"> 1794 </span>
<span class="lineno"> 1795 </span>enable_safety_proofs :: TopLevel ()
<span class="lineno"> 1796 </span><span class="decl"><span class="nottickedoff">enable_safety_proofs = do</span>
<span class="lineno"> 1797 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1798 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw{ rwSkipSafetyProofs = False }</span></span>
<span class="lineno"> 1799 </span>
<span class="lineno"> 1800 </span>disable_safety_proofs :: TopLevel ()
<span class="lineno"> 1801 </span><span class="decl"><span class="nottickedoff">disable_safety_proofs = do</span>
<span class="lineno"> 1802 </span><span class="spaces">  </span><span class="nottickedoff">opts &lt;- getOptions</span>
<span class="lineno"> 1803 </span><span class="spaces">  </span><span class="nottickedoff">io $ printOutLn opts Warn &quot;Safety proofs disabled! This is unsound!&quot;</span>
<span class="lineno"> 1804 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1805 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw{ rwSkipSafetyProofs = True }</span></span>
<span class="lineno"> 1806 </span>
<span class="lineno"> 1807 </span>enable_sequent_goals :: TopLevel ()
<span class="lineno"> 1808 </span><span class="decl"><span class="nottickedoff">enable_sequent_goals = do</span>
<span class="lineno"> 1809 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1810 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw{ rwSequentGoals = True }</span></span>
<span class="lineno"> 1811 </span>
<span class="lineno"> 1812 </span>disable_sequent_goals :: TopLevel ()
<span class="lineno"> 1813 </span><span class="decl"><span class="nottickedoff">disable_sequent_goals = do</span>
<span class="lineno"> 1814 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1815 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw{ rwSequentGoals = False }</span></span>
<span class="lineno"> 1816 </span>
<span class="lineno"> 1817 </span>enable_smt_array_memory_model :: TopLevel ()
<span class="lineno"> 1818 </span><span class="decl"><span class="istickedoff">enable_smt_array_memory_model = do</span>
<span class="lineno"> 1819 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1820 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwSMTArrayMemoryModel = True }</span></span>
<span class="lineno"> 1821 </span>
<span class="lineno"> 1822 </span>disable_smt_array_memory_model :: TopLevel ()
<span class="lineno"> 1823 </span><span class="decl"><span class="nottickedoff">disable_smt_array_memory_model = do</span>
<span class="lineno"> 1824 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1825 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwSMTArrayMemoryModel = False }</span></span>
<span class="lineno"> 1826 </span>
<span class="lineno"> 1827 </span>enable_crucible_assert_then_assume :: TopLevel ()
<span class="lineno"> 1828 </span><span class="decl"><span class="istickedoff">enable_crucible_assert_then_assume = do</span>
<span class="lineno"> 1829 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1830 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwCrucibleAssertThenAssume = True }</span></span>
<span class="lineno"> 1831 </span>
<span class="lineno"> 1832 </span>disable_crucible_assert_then_assume :: TopLevel ()
<span class="lineno"> 1833 </span><span class="decl"><span class="istickedoff">disable_crucible_assert_then_assume = do</span>
<span class="lineno"> 1834 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1835 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwCrucibleAssertThenAssume = False }</span></span>
<span class="lineno"> 1836 </span>
<span class="lineno"> 1837 </span>enable_single_override_special_case :: TopLevel ()
<span class="lineno"> 1838 </span><span class="decl"><span class="nottickedoff">enable_single_override_special_case = do</span>
<span class="lineno"> 1839 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1840 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwSingleOverrideSpecialCase = True }</span></span>
<span class="lineno"> 1841 </span>
<span class="lineno"> 1842 </span>disable_single_override_special_case :: TopLevel ()
<span class="lineno"> 1843 </span><span class="decl"><span class="nottickedoff">disable_single_override_special_case = do</span>
<span class="lineno"> 1844 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1845 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwSingleOverrideSpecialCase = False }</span></span>
<span class="lineno"> 1846 </span>
<span class="lineno"> 1847 </span>
<span class="lineno"> 1848 </span>enable_crucible_profiling :: Text -&gt; TopLevel ()
<span class="lineno"> 1849 </span><span class="decl"><span class="istickedoff">enable_crucible_profiling f = do</span>
<span class="lineno"> 1850 </span><span class="spaces">  </span><span class="istickedoff">let f' :: FilePath = Text.unpack f</span>
<span class="lineno"> 1851 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1852 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwProfilingFile = Just f' }</span></span>
<span class="lineno"> 1853 </span>
<span class="lineno"> 1854 </span>disable_crucible_profiling :: TopLevel ()
<span class="lineno"> 1855 </span><span class="decl"><span class="istickedoff">disable_crucible_profiling = do</span>
<span class="lineno"> 1856 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1857 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwProfilingFile = <span class="nottickedoff">Nothing</span> }</span></span>
<span class="lineno"> 1858 </span>
<span class="lineno"> 1859 </span>enable_lax_arithmetic :: TopLevel ()
<span class="lineno"> 1860 </span><span class="decl"><span class="nottickedoff">enable_lax_arithmetic = do</span>
<span class="lineno"> 1861 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1862 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwLaxArith = True }</span></span>
<span class="lineno"> 1863 </span>
<span class="lineno"> 1864 </span>disable_lax_arithmetic :: TopLevel ()
<span class="lineno"> 1865 </span><span class="decl"><span class="nottickedoff">disable_lax_arithmetic = do</span>
<span class="lineno"> 1866 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1867 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwLaxArith = False }</span></span>
<span class="lineno"> 1868 </span>
<span class="lineno"> 1869 </span>enable_lax_pointer_ordering :: TopLevel ()
<span class="lineno"> 1870 </span><span class="decl"><span class="istickedoff">enable_lax_pointer_ordering = do</span>
<span class="lineno"> 1871 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1872 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwLaxPointerOrdering = True }</span></span>
<span class="lineno"> 1873 </span>
<span class="lineno"> 1874 </span>disable_lax_pointer_ordering :: TopLevel ()
<span class="lineno"> 1875 </span><span class="decl"><span class="nottickedoff">disable_lax_pointer_ordering = do</span>
<span class="lineno"> 1876 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1877 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwLaxPointerOrdering = False }</span></span>
<span class="lineno"> 1878 </span>
<span class="lineno"> 1879 </span>enable_lax_loads_and_stores :: TopLevel ()
<span class="lineno"> 1880 </span><span class="decl"><span class="istickedoff">enable_lax_loads_and_stores = do</span>
<span class="lineno"> 1881 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1882 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwLaxLoadsAndStores = True }</span></span>
<span class="lineno"> 1883 </span>
<span class="lineno"> 1884 </span>disable_lax_loads_and_stores :: TopLevel ()
<span class="lineno"> 1885 </span><span class="decl"><span class="nottickedoff">disable_lax_loads_and_stores = do</span>
<span class="lineno"> 1886 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1887 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwLaxLoadsAndStores = False }</span></span>
<span class="lineno"> 1888 </span>
<span class="lineno"> 1889 </span>set_solver_cache_path :: Text -&gt; TopLevel ()
<span class="lineno"> 1890 </span><span class="decl"><span class="istickedoff">set_solver_cache_path pathtxt = do</span>
<span class="lineno"> 1891 </span><span class="spaces">  </span><span class="istickedoff">let path :: FilePath = Text.unpack pathtxt</span>
<span class="lineno"> 1892 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1893 </span><span class="spaces">  </span><span class="istickedoff">case rwSolverCache rw of</span>
<span class="lineno"> 1894 </span><span class="spaces">    </span><span class="istickedoff">Just _ -&gt; onSolverCache (setSolverCachePath path)</span>
<span class="lineno"> 1895 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">do cache &lt;- io $ openSolverCache path</span></span>
<span class="lineno"> 1896 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">putTopLevelRW rw { rwSolverCache = Just cache }</span></span></span>
<span class="lineno"> 1897 </span>
<span class="lineno"> 1898 </span>set_solver_cache_timeout :: Int -&gt; TopLevel ()
<span class="lineno"> 1899 </span><span class="decl"><span class="istickedoff">set_solver_cache_timeout tout =</span>
<span class="lineno"> 1900 </span><span class="spaces">  </span><span class="istickedoff">onSolverCache (setSolverCacheTimeout tout)</span></span>
<span class="lineno"> 1901 </span>
<span class="lineno"> 1902 </span>clean_mismatched_versions_solver_cache :: TopLevel ()
<span class="lineno"> 1903 </span><span class="decl"><span class="istickedoff">clean_mismatched_versions_solver_cache = do</span>
<span class="lineno"> 1904 </span><span class="spaces">  </span><span class="istickedoff">vs &lt;- io $ getSolverBackendVersions allBackends</span>
<span class="lineno"> 1905 </span><span class="spaces">  </span><span class="istickedoff">onSolverCache (cleanMismatchedVersionsSolverCache vs)</span></span>
<span class="lineno"> 1906 </span>
<span class="lineno"> 1907 </span>test_solver_cache_stats :: Integer -&gt; Integer -&gt; Integer -&gt; Integer -&gt;
<span class="lineno"> 1908 </span>                           Integer -&gt; TopLevel ()
<span class="lineno"> 1909 </span><span class="decl"><span class="istickedoff">test_solver_cache_stats sz ls ls_f is is_f =</span>
<span class="lineno"> 1910 </span><span class="spaces">  </span><span class="istickedoff">onSolverCache (testSolverCacheStats sz ls ls_f is is_f)</span></span>
<span class="lineno"> 1911 </span>
<span class="lineno"> 1912 </span>enable_debug_intrinsics :: TopLevel ()
<span class="lineno"> 1913 </span><span class="decl"><span class="nottickedoff">enable_debug_intrinsics = do</span>
<span class="lineno"> 1914 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1915 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwDebugIntrinsics = True }</span></span>
<span class="lineno"> 1916 </span>
<span class="lineno"> 1917 </span>disable_debug_intrinsics :: TopLevel ()
<span class="lineno"> 1918 </span><span class="decl"><span class="nottickedoff">disable_debug_intrinsics = do</span>
<span class="lineno"> 1919 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1920 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwDebugIntrinsics = False }</span></span>
<span class="lineno"> 1921 </span>
<span class="lineno"> 1922 </span>enable_what4_hash_consing :: TopLevel ()
<span class="lineno"> 1923 </span><span class="decl"><span class="nottickedoff">enable_what4_hash_consing = do</span>
<span class="lineno"> 1924 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1925 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwWhat4HashConsing = True }</span></span>
<span class="lineno"> 1926 </span>
<span class="lineno"> 1927 </span>disable_what4_hash_consing :: TopLevel ()
<span class="lineno"> 1928 </span><span class="decl"><span class="nottickedoff">disable_what4_hash_consing = do</span>
<span class="lineno"> 1929 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1930 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwWhat4HashConsing = False }</span></span>
<span class="lineno"> 1931 </span>
<span class="lineno"> 1932 </span>enable_x86_what4_hash_consing :: TopLevel ()
<span class="lineno"> 1933 </span><span class="decl"><span class="nottickedoff">enable_x86_what4_hash_consing = do</span>
<span class="lineno"> 1934 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1935 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwWhat4HashConsingX86 = True }</span></span>
<span class="lineno"> 1936 </span>
<span class="lineno"> 1937 </span>disable_x86_what4_hash_consing :: TopLevel ()
<span class="lineno"> 1938 </span><span class="decl"><span class="nottickedoff">disable_x86_what4_hash_consing = do</span>
<span class="lineno"> 1939 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1940 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwWhat4HashConsingX86 = False }</span></span>
<span class="lineno"> 1941 </span>
<span class="lineno"> 1942 </span>enable_what4_eval :: TopLevel ()
<span class="lineno"> 1943 </span><span class="decl"><span class="istickedoff">enable_what4_eval = do</span>
<span class="lineno"> 1944 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1945 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwWhat4Eval = True }</span></span>
<span class="lineno"> 1946 </span>
<span class="lineno"> 1947 </span>disable_what4_eval :: TopLevel ()
<span class="lineno"> 1948 </span><span class="decl"><span class="nottickedoff">disable_what4_eval = do</span>
<span class="lineno"> 1949 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1950 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwWhat4Eval = False }</span></span>
<span class="lineno"> 1951 </span>
<span class="lineno"> 1952 </span>add_x86_preserved_reg :: Text -&gt; TopLevel ()
<span class="lineno"> 1953 </span><span class="decl"><span class="istickedoff">add_x86_preserved_reg r = do</span>
<span class="lineno"> 1954 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1955 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwPreservedRegs = r:rwPreservedRegs rw }</span></span>
<span class="lineno"> 1956 </span>
<span class="lineno"> 1957 </span>default_x86_preserved_reg :: TopLevel ()
<span class="lineno"> 1958 </span><span class="decl"><span class="istickedoff">default_x86_preserved_reg = do</span>
<span class="lineno"> 1959 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1960 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwPreservedRegs = <span class="nottickedoff">mempty</span> }</span></span>
<span class="lineno"> 1961 </span>
<span class="lineno"> 1962 </span>set_x86_stack_base_align :: Integer -&gt; TopLevel ()
<span class="lineno"> 1963 </span><span class="decl"><span class="nottickedoff">set_x86_stack_base_align a = do</span>
<span class="lineno"> 1964 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1965 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwStackBaseAlign = a }</span></span>
<span class="lineno"> 1966 </span>
<span class="lineno"> 1967 </span>default_x86_stack_base_align :: TopLevel ()
<span class="lineno"> 1968 </span><span class="decl"><span class="nottickedoff">default_x86_stack_base_align = do</span>
<span class="lineno"> 1969 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1970 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwStackBaseAlign = defaultStackBaseAlign }</span></span>
<span class="lineno"> 1971 </span>
<span class="lineno"> 1972 </span>enable_alloc_sym_init_check :: TopLevel ()
<span class="lineno"> 1973 </span><span class="decl"><span class="istickedoff">enable_alloc_sym_init_check = do</span>
<span class="lineno"> 1974 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1975 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwAllocSymInitCheck = True }</span></span>
<span class="lineno"> 1976 </span>
<span class="lineno"> 1977 </span>disable_alloc_sym_init_check :: TopLevel ()
<span class="lineno"> 1978 </span><span class="decl"><span class="istickedoff">disable_alloc_sym_init_check = do</span>
<span class="lineno"> 1979 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1980 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwAllocSymInitCheck = False }</span></span>
<span class="lineno"> 1981 </span>
<span class="lineno"> 1982 </span>enable_no_satisfying_write_fresh_constant :: TopLevel ()
<span class="lineno"> 1983 </span><span class="decl"><span class="nottickedoff">enable_no_satisfying_write_fresh_constant = do</span>
<span class="lineno"> 1984 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1985 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwNoSatisfyingWriteFreshConstant = True }</span></span>
<span class="lineno"> 1986 </span>
<span class="lineno"> 1987 </span>disable_no_satisfying_write_fresh_constant :: TopLevel ()
<span class="lineno"> 1988 </span><span class="decl"><span class="nottickedoff">disable_no_satisfying_write_fresh_constant = do</span>
<span class="lineno"> 1989 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1990 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwNoSatisfyingWriteFreshConstant = False }</span></span>
<span class="lineno"> 1991 </span>
<span class="lineno"> 1992 </span>enable_what4_push_mux_ops :: TopLevel ()
<span class="lineno"> 1993 </span><span class="decl"><span class="nottickedoff">enable_what4_push_mux_ops = do</span>
<span class="lineno"> 1994 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1995 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwWhat4PushMuxOps = True }</span></span>
<span class="lineno"> 1996 </span>
<span class="lineno"> 1997 </span>disable_what4_push_mux_ops :: TopLevel ()
<span class="lineno"> 1998 </span><span class="decl"><span class="nottickedoff">disable_what4_push_mux_ops = do</span>
<span class="lineno"> 1999 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2000 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwWhat4PushMuxOps = False }</span></span>
<span class="lineno"> 2001 </span>
<span class="lineno"> 2002 </span>set_crucible_timeout :: Integer -&gt; TopLevel ()
<span class="lineno"> 2003 </span><span class="decl"><span class="nottickedoff">set_crucible_timeout t = do</span>
<span class="lineno"> 2004 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2005 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwCrucibleTimeout = t }</span></span>
<span class="lineno"> 2006 </span>
<span class="lineno"> 2007 </span>include_value :: Text -&gt; TopLevel ()
<span class="lineno"> 2008 </span><span class="decl"><span class="istickedoff">include_value file = do</span>
<span class="lineno"> 2009 </span><span class="spaces">  </span><span class="istickedoff">let file' :: FilePath = Text.unpack file</span>
<span class="lineno"> 2010 </span><span class="spaces">  </span><span class="istickedoff">interpretFile file' False</span></span>
<span class="lineno"> 2011 </span>
<span class="lineno"> 2012 </span>set_ascii :: Bool -&gt; TopLevel ()
<span class="lineno"> 2013 </span><span class="decl"><span class="nottickedoff">set_ascii b = do</span>
<span class="lineno"> 2014 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2015 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwPPOpts = (rwPPOpts rw) { PPS.ppUseAscii = b } }</span></span>
<span class="lineno"> 2016 </span>
<span class="lineno"> 2017 </span>set_base :: Int -&gt; TopLevel ()
<span class="lineno"> 2018 </span><span class="decl"><span class="istickedoff">set_base b = do</span>
<span class="lineno"> 2019 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2020 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwPPOpts = (rwPPOpts rw) { PPS.ppBase = b } }</span></span>
<span class="lineno"> 2021 </span>
<span class="lineno"> 2022 </span>set_color :: Bool -&gt; TopLevel ()
<span class="lineno"> 2023 </span><span class="decl"><span class="nottickedoff">set_color b = do</span>
<span class="lineno"> 2024 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2025 </span><span class="spaces">  </span><span class="nottickedoff">opts &lt;- getOptions</span>
<span class="lineno"> 2026 </span><span class="spaces">  </span><span class="nottickedoff">-- Keep color disabled if `--no-color` command-line option is present</span>
<span class="lineno"> 2027 </span><span class="spaces">  </span><span class="nottickedoff">let b' = b &amp;&amp; useColor opts</span>
<span class="lineno"> 2028 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwPPOpts = (rwPPOpts rw) { PPS.ppColor = b' } }</span></span>
<span class="lineno"> 2029 </span>
<span class="lineno"> 2030 </span>set_min_sharing :: Int -&gt; TopLevel ()
<span class="lineno"> 2031 </span><span class="decl"><span class="nottickedoff">set_min_sharing b = do</span>
<span class="lineno"> 2032 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2033 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwPPOpts = (rwPPOpts rw) { PPS.ppMinSharing = b } }</span></span>
<span class="lineno"> 2034 </span>
<span class="lineno"> 2035 </span>-- | 'set_memoization_hash i' changes the memoization strategy for terms:
<span class="lineno"> 2036 </span>-- memoization identifiers will include the first 'i' digits of the hash of the
<span class="lineno"> 2037 </span>-- term they memoize. This is useful to help keep memoization identifiers of the
<span class="lineno"> 2038 </span>-- same term as constant as possible across different executions of a proof
<span class="lineno"> 2039 </span>-- script over the course of its development.
<span class="lineno"> 2040 </span>set_memoization_hash :: Int -&gt; TopLevel ()
<span class="lineno"> 2041 </span><span class="decl"><span class="nottickedoff">set_memoization_hash i = do</span>
<span class="lineno"> 2042 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2043 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwPPOpts = (rwPPOpts rw) { PPS.ppMemoStyle = PPS.Hash i } }</span></span>
<span class="lineno"> 2044 </span>
<span class="lineno"> 2045 </span>-- | 'set_memoization_hash_incremental i' changes the memoization strategy for
<span class="lineno"> 2046 </span>-- terms: memoization identifiers will include the first 'i' digits of the hash
<span class="lineno"> 2047 </span>-- of the term they memoize, as well as the value of a global counter that
<span class="lineno"> 2048 </span>-- increments each time a term is memoized. This is useful to help keep
<span class="lineno"> 2049 </span>-- memoization identifiers of the same term as constant as possible across
<span class="lineno"> 2050 </span>-- different executions of a proof script over the course of its development, as
<span class="lineno"> 2051 </span>-- well as to freshen memoization identifiers in the unlikely case of term hash
<span class="lineno"> 2052 </span>-- collisions.
<span class="lineno"> 2053 </span>set_memoization_hash_incremental :: Int -&gt; TopLevel ()
<span class="lineno"> 2054 </span><span class="decl"><span class="nottickedoff">set_memoization_hash_incremental i = do</span>
<span class="lineno"> 2055 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2056 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwPPOpts = (rwPPOpts rw) { PPS.ppMemoStyle = PPS.HashIncremental i } }</span></span>
<span class="lineno"> 2057 </span>
<span class="lineno"> 2058 </span>-- | `set_memoization_incremental` changes the memoization strategy for terms:
<span class="lineno"> 2059 </span>-- memoization identifiers will only include the value of a global counter that
<span class="lineno"> 2060 </span>-- increments each time a term is memoized.
<span class="lineno"> 2061 </span>set_memoization_incremental :: TopLevel ()
<span class="lineno"> 2062 </span><span class="decl"><span class="nottickedoff">set_memoization_incremental = do</span>
<span class="lineno"> 2063 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2064 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwPPOpts = (rwPPOpts rw) { PPS.ppMemoStyle = PPS.Incremental } }</span></span>
<span class="lineno"> 2065 </span>
<span class="lineno"> 2066 </span>print_value :: Value -&gt; TopLevel ()
<span class="lineno"> 2067 </span><span class="decl"><span class="istickedoff">print_value (VString s) = printOutLnTop Info (Text.unpack s)</span>
<span class="lineno"> 2068 </span><span class="spaces"></span><span class="istickedoff">print_value (VTerm t) = do</span>
<span class="lineno"> 2069 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 2070 </span><span class="spaces">  </span><span class="istickedoff">cenv &lt;- fmap rwCryptol getTopLevelRW</span>
<span class="lineno"> 2071 </span><span class="spaces">  </span><span class="istickedoff">let cfg = CEnv.meSolverConfig (CEnv.eModuleEnv cenv)</span>
<span class="lineno"> 2072 </span><span class="spaces">  </span><span class="istickedoff">unless (null (getAllExts (ttTerm t))) $</span>
<span class="lineno"> 2073 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">fail &quot;term contains symbolic variables&quot;</span></span>
<span class="lineno"> 2074 </span><span class="spaces">  </span><span class="istickedoff">sawopts &lt;- getOptions</span>
<span class="lineno"> 2075 </span><span class="spaces">  </span><span class="istickedoff">t' &lt;- io $ defaultTypedTerm sawopts sc cfg t</span>
<span class="lineno"> 2076 </span><span class="spaces">  </span><span class="istickedoff">opts &lt;- fmap rwPPOpts getTopLevelRW</span>
<span class="lineno"> 2077 </span><span class="spaces">  </span><span class="istickedoff">let opts' = V.defaultPPOpts { V.useAscii = PPS.ppUseAscii opts</span>
<span class="lineno"> 2078 </span><span class="spaces">                              </span><span class="istickedoff">, V.useBase = PPS.ppBase opts</span>
<span class="lineno"> 2079 </span><span class="spaces">                              </span><span class="istickedoff">}</span>
<span class="lineno"> 2080 </span><span class="spaces">  </span><span class="istickedoff">evaled_t &lt;- io $ evaluateTypedTerm sc t'</span>
<span class="lineno"> 2081 </span><span class="spaces">  </span><span class="istickedoff">doc &lt;- io $ V.runEval <span class="nottickedoff">mempty</span> (V.ppValue <span class="nottickedoff">V.Concrete</span> opts' evaled_t)</span>
<span class="lineno"> 2082 </span><span class="spaces">  </span><span class="istickedoff">sawOpts &lt;- getOptions</span>
<span class="lineno"> 2083 </span><span class="spaces">  </span><span class="istickedoff">io (rethrowEvalError $ printOutLn sawOpts Info $ show $ doc)</span>
<span class="lineno"> 2084 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2085 </span><span class="spaces"></span><span class="istickedoff">print_value v = do</span>
<span class="lineno"> 2086 </span><span class="spaces">  </span><span class="istickedoff">opts &lt;- fmap rwPPOpts getTopLevelRW</span>
<span class="lineno"> 2087 </span><span class="spaces">  </span><span class="istickedoff">nenv &lt;- io . scGetNamingEnv =&lt;&lt; getSharedContext</span>
<span class="lineno"> 2088 </span><span class="spaces">  </span><span class="istickedoff">printOutLnTop Info (showsPrecValue opts nenv <span class="nottickedoff">0</span> v &quot;&quot;)</span></span>
<span class="lineno"> 2089 </span>
<span class="lineno"> 2090 </span>dump_file_AST :: BuiltinContext -&gt; Options -&gt; Text -&gt; IO ()
<span class="lineno"> 2091 </span><span class="decl"><span class="istickedoff">dump_file_AST _bic opts filetxt = do</span>
<span class="lineno"> 2092 </span><span class="spaces">  </span><span class="istickedoff">let file = Text.unpack filetxt</span>
<span class="lineno"> 2093 </span><span class="spaces">  </span><span class="istickedoff">(SAWScript.Import.loadFile opts &gt;=&gt; mapM_ print) file</span></span>
<span class="lineno"> 2094 </span>
<span class="lineno"> 2095 </span>parser_printer_roundtrip :: BuiltinContext -&gt; Options -&gt; Text -&gt; IO ()
<span class="lineno"> 2096 </span><span class="decl"><span class="istickedoff">parser_printer_roundtrip _bic opts filetxt = do</span>
<span class="lineno"> 2097 </span><span class="spaces">  </span><span class="istickedoff">let file = Text.unpack filetxt</span>
<span class="lineno"> 2098 </span><span class="spaces">  </span><span class="istickedoff">(SAWScript.Import.loadFile opts &gt;=&gt; PP.putDoc . SS.prettyWholeModule) file</span></span>
<span class="lineno"> 2099 </span>
<span class="lineno"> 2100 </span>exec :: Text -&gt; [Text] -&gt; Text -&gt; IO Text
<span class="lineno"> 2101 </span><span class="decl"><span class="istickedoff">exec name args input = do</span>
<span class="lineno"> 2102 </span><span class="spaces">  </span><span class="istickedoff">let name' = Text.unpack name</span>
<span class="lineno"> 2103 </span><span class="spaces">      </span><span class="istickedoff">args' = map Text.unpack args</span>
<span class="lineno"> 2104 </span><span class="spaces">      </span><span class="istickedoff">input' = Text.unpack input</span>
<span class="lineno"> 2105 </span><span class="spaces">  </span><span class="istickedoff">output &lt;- readProcess name' args' input'</span>
<span class="lineno"> 2106 </span><span class="spaces">  </span><span class="istickedoff">return $ Text.pack output</span></span>
<span class="lineno"> 2107 </span>
<span class="lineno"> 2108 </span>------------------------------------------------------------
<span class="lineno"> 2109 </span>-- Filename wrappers
<span class="lineno"> 2110 </span>
<span class="lineno"> 2111 </span>-- The interpreter deals only in Text, and FilePath is actually String.
<span class="lineno"> 2112 </span>-- Rather than push Text through the various backend places (which gets
<span class="lineno"> 2113 </span>-- messy) we'll unpack Text to FilePath up front. Or at least until the
<span class="lineno"> 2114 </span>-- stdlib comes up with a Text-based interface for filenames.
<span class="lineno"> 2115 </span>
<span class="lineno"> 2116 </span>-- | Wrapper for writeAIGviaVerilog because the interpreter deals only in
<span class="lineno"> 2117 </span>--   Text and FilePath is actually String.
<span class="lineno"> 2118 </span>doWriteAIGviaVerilog :: Text -&gt; Term -&gt; TopLevel ()
<span class="lineno"> 2119 </span><span class="decl"><span class="nottickedoff">doWriteAIGviaVerilog filetext e =</span>
<span class="lineno"> 2120 </span><span class="spaces">  </span><span class="nottickedoff">let file :: FilePath = Text.unpack filetext in</span>
<span class="lineno"> 2121 </span><span class="spaces">  </span><span class="nottickedoff">writeAIGviaVerilog file e</span></span>
<span class="lineno"> 2122 </span>
<span class="lineno"> 2123 </span>do_offline_aig :: Text -&gt; ProofScript ()
<span class="lineno"> 2124 </span><span class="decl"><span class="nottickedoff">do_offline_aig file =</span>
<span class="lineno"> 2125 </span><span class="spaces">  </span><span class="nottickedoff">offline_aig (Text.unpack file)</span></span>
<span class="lineno"> 2126 </span>
<span class="lineno"> 2127 </span>do_offline_aig_external :: Text -&gt; ProofScript ()
<span class="lineno"> 2128 </span><span class="decl"><span class="nottickedoff">do_offline_aig_external file =</span>
<span class="lineno"> 2129 </span><span class="spaces">  </span><span class="nottickedoff">offline_aig_external (Text.unpack file)</span></span>
<span class="lineno"> 2130 </span>
<span class="lineno"> 2131 </span>do_write_cnf :: Text -&gt; TypedTerm -&gt; TopLevel ()
<span class="lineno"> 2132 </span><span class="decl"><span class="istickedoff">do_write_cnf f tt =</span>
<span class="lineno"> 2133 </span><span class="spaces">  </span><span class="istickedoff">write_cnf (Text.unpack f) tt</span></span>
<span class="lineno"> 2134 </span>
<span class="lineno"> 2135 </span>do_write_cnf_external :: Text -&gt; TypedTerm -&gt; TopLevel ()
<span class="lineno"> 2136 </span><span class="decl"><span class="nottickedoff">do_write_cnf_external f tt =</span>
<span class="lineno"> 2137 </span><span class="spaces">  </span><span class="nottickedoff">write_cnf_external (Text.unpack f) tt</span></span>
<span class="lineno"> 2138 </span>
<span class="lineno"> 2139 </span>do_write_smtlib2 :: Text -&gt; TypedTerm -&gt; TopLevel ()
<span class="lineno"> 2140 </span><span class="decl"><span class="istickedoff">do_write_smtlib2 f tt =</span>
<span class="lineno"> 2141 </span><span class="spaces">  </span><span class="istickedoff">write_smtlib2 (Text.unpack f) tt</span></span>
<span class="lineno"> 2142 </span>
<span class="lineno"> 2143 </span>do_write_smtlib2_w4 :: Text -&gt; TypedTerm -&gt; TopLevel ()
<span class="lineno"> 2144 </span><span class="decl"><span class="nottickedoff">do_write_smtlib2_w4 f tt =</span>
<span class="lineno"> 2145 </span><span class="spaces">  </span><span class="nottickedoff">write_smtlib2_w4 (Text.unpack f) tt</span></span>
<span class="lineno"> 2146 </span>
<span class="lineno"> 2147 </span>do_write_core :: Text -&gt; Term -&gt; TopLevel ()
<span class="lineno"> 2148 </span><span class="decl"><span class="istickedoff">do_write_core f t =</span>
<span class="lineno"> 2149 </span><span class="spaces">  </span><span class="istickedoff">writeCore (Text.unpack f) t</span></span>
<span class="lineno"> 2150 </span>
<span class="lineno"> 2151 </span>do_write_verilog :: SharedContext -&gt; Text -&gt; Term -&gt; IO ()
<span class="lineno"> 2152 </span><span class="decl"><span class="nottickedoff">do_write_verilog sc f t =</span>
<span class="lineno"> 2153 </span><span class="spaces">  </span><span class="nottickedoff">writeVerilog sc (Text.unpack f) t</span></span>
<span class="lineno"> 2154 </span>
<span class="lineno"> 2155 </span>do_write_coq_term :: Text -&gt; [(Text, Text)] -&gt; [Text] -&gt; Text -&gt; Term -&gt; TopLevel ()
<span class="lineno"> 2156 </span><span class="decl"><span class="nottickedoff">do_write_coq_term name notations skips path t =</span>
<span class="lineno"> 2157 </span><span class="spaces">  </span><span class="nottickedoff">writeCoqTerm name notations skips (Text.unpack path) t</span></span>
<span class="lineno"> 2158 </span>
<span class="lineno"> 2159 </span>do_write_coq_cryptol_module :: Text -&gt; Text -&gt; [(Text, Text)] -&gt; [Text] -&gt; TopLevel ()
<span class="lineno"> 2160 </span><span class="decl"><span class="nottickedoff">do_write_coq_cryptol_module infile outfile notations skips =</span>
<span class="lineno"> 2161 </span><span class="spaces">  </span><span class="nottickedoff">writeCoqCryptolModule (Text.unpack infile) (Text.unpack outfile) notations skips</span></span>
<span class="lineno"> 2162 </span>
<span class="lineno"> 2163 </span>do_write_coq_sawcore_prelude :: Text -&gt; [(Text, Text)] -&gt; [Text] -&gt; IO ()
<span class="lineno"> 2164 </span><span class="decl"><span class="nottickedoff">do_write_coq_sawcore_prelude outfile notations skips =</span>
<span class="lineno"> 2165 </span><span class="spaces">  </span><span class="nottickedoff">writeCoqSAWCorePrelude (Text.unpack outfile) notations skips</span></span>
<span class="lineno"> 2166 </span>
<span class="lineno"> 2167 </span>do_write_coq_cryptol_primitives_for_sawcore :: Text -&gt; [(Text, Text)] -&gt; [Text] -&gt; IO ()
<span class="lineno"> 2168 </span><span class="decl"><span class="nottickedoff">do_write_coq_cryptol_primitives_for_sawcore cryfile notations skips =</span>
<span class="lineno"> 2169 </span><span class="spaces">  </span><span class="nottickedoff">let cryfile' = Text.unpack cryfile</span>
<span class="lineno"> 2170 </span><span class="spaces">  </span><span class="nottickedoff">in</span>
<span class="lineno"> 2171 </span><span class="spaces">  </span><span class="nottickedoff">writeCoqCryptolPrimitivesForSAWCore cryfile' notations skips</span></span>
<span class="lineno"> 2172 </span>
<span class="lineno"> 2173 </span>do_offline_coq :: Text -&gt; ProofScript ()
<span class="lineno"> 2174 </span><span class="decl"><span class="nottickedoff">do_offline_coq f =</span>
<span class="lineno"> 2175 </span><span class="spaces">  </span><span class="nottickedoff">offline_coq (Text.unpack f)</span></span>
<span class="lineno"> 2176 </span>
<span class="lineno"> 2177 </span>do_auto_match :: Text -&gt; Text -&gt; TopLevel ()
<span class="lineno"> 2178 </span><span class="decl"><span class="nottickedoff">do_auto_match f1 f2 =</span>
<span class="lineno"> 2179 </span><span class="spaces">  </span><span class="nottickedoff">autoMatch stmtInterpreter (Text.unpack f1) (Text.unpack f2)</span></span>
<span class="lineno"> 2180 </span>
<span class="lineno"> 2181 </span>do_write_goal :: Text -&gt; ProofScript ()
<span class="lineno"> 2182 </span><span class="decl"><span class="nottickedoff">do_write_goal f =</span>
<span class="lineno"> 2183 </span><span class="spaces">  </span><span class="nottickedoff">write_goal (Text.unpack f)</span></span>
<span class="lineno"> 2184 </span>
<span class="lineno"> 2185 </span>do_offline_w4_unint_bitwuzla :: [Text] -&gt; Text -&gt; ProofScript ()
<span class="lineno"> 2186 </span><span class="decl"><span class="nottickedoff">do_offline_w4_unint_bitwuzla unints path =</span>
<span class="lineno"> 2187 </span><span class="spaces">  </span><span class="nottickedoff">offline_w4_unint_bitwuzla unints (Text.unpack path)</span></span>
<span class="lineno"> 2188 </span>
<span class="lineno"> 2189 </span>do_offline_w4_unint_z3 :: [Text] -&gt; Text -&gt; ProofScript ()
<span class="lineno"> 2190 </span><span class="decl"><span class="nottickedoff">do_offline_w4_unint_z3 unints path =</span>
<span class="lineno"> 2191 </span><span class="spaces">  </span><span class="nottickedoff">offline_w4_unint_z3 unints (Text.unpack path)</span></span>
<span class="lineno"> 2192 </span>
<span class="lineno"> 2193 </span>do_offline_w4_unint_cvc4 :: [Text] -&gt; Text -&gt; ProofScript ()
<span class="lineno"> 2194 </span><span class="decl"><span class="nottickedoff">do_offline_w4_unint_cvc4 unints path =</span>
<span class="lineno"> 2195 </span><span class="spaces">  </span><span class="nottickedoff">offline_w4_unint_cvc4 unints (Text.unpack path)</span></span>
<span class="lineno"> 2196 </span>
<span class="lineno"> 2197 </span>do_offline_w4_unint_cvc5 :: [Text] -&gt; Text -&gt; ProofScript ()
<span class="lineno"> 2198 </span><span class="decl"><span class="nottickedoff">do_offline_w4_unint_cvc5 unints path =</span>
<span class="lineno"> 2199 </span><span class="spaces">  </span><span class="nottickedoff">offline_w4_unint_cvc5 unints (Text.unpack path)</span></span>
<span class="lineno"> 2200 </span>
<span class="lineno"> 2201 </span>do_offline_w4_unint_yices :: [Text] -&gt; Text -&gt; ProofScript ()
<span class="lineno"> 2202 </span><span class="decl"><span class="nottickedoff">do_offline_w4_unint_yices unints path =</span>
<span class="lineno"> 2203 </span><span class="spaces">  </span><span class="nottickedoff">offline_w4_unint_yices unints (Text.unpack path)</span></span>
<span class="lineno"> 2204 </span>
<span class="lineno"> 2205 </span>do_cryptol_load :: (FilePath -&gt; IO BS.ByteString) -&gt; Text -&gt; TopLevel CEnv.ExtCryptolModule
<span class="lineno"> 2206 </span><span class="decl"><span class="istickedoff">do_cryptol_load loader path =</span>
<span class="lineno"> 2207 </span><span class="spaces">  </span><span class="istickedoff">cryptol_load loader (Text.unpack path)</span></span>
<span class="lineno"> 2208 </span>
<span class="lineno"> 2209 </span>do_offline_cnf :: Text -&gt; ProofScript ()
<span class="lineno"> 2210 </span><span class="decl"><span class="istickedoff">do_offline_cnf path =</span>
<span class="lineno"> 2211 </span><span class="spaces">  </span><span class="istickedoff">offline_cnf (Text.unpack path)</span></span>
<span class="lineno"> 2212 </span>
<span class="lineno"> 2213 </span>do_offline_cnf_external :: Text -&gt; ProofScript ()
<span class="lineno"> 2214 </span><span class="decl"><span class="nottickedoff">do_offline_cnf_external path =</span>
<span class="lineno"> 2215 </span><span class="spaces">  </span><span class="nottickedoff">offline_cnf_external (Text.unpack path)</span></span>
<span class="lineno"> 2216 </span>
<span class="lineno"> 2217 </span>do_offline_extcore :: Text -&gt; ProofScript ()
<span class="lineno"> 2218 </span><span class="decl"><span class="nottickedoff">do_offline_extcore path =</span>
<span class="lineno"> 2219 </span><span class="spaces">  </span><span class="nottickedoff">offline_extcore (Text.unpack path)</span></span>
<span class="lineno"> 2220 </span>
<span class="lineno"> 2221 </span>do_offline_smtlib2 :: Text -&gt; ProofScript ()
<span class="lineno"> 2222 </span><span class="decl"><span class="istickedoff">do_offline_smtlib2 path =</span>
<span class="lineno"> 2223 </span><span class="spaces">  </span><span class="istickedoff">offline_smtlib2 (Text.unpack path)</span></span>
<span class="lineno"> 2224 </span>
<span class="lineno"> 2225 </span>do_w4_offline_smtlib2 :: Text -&gt; ProofScript ()
<span class="lineno"> 2226 </span><span class="decl"><span class="nottickedoff">do_w4_offline_smtlib2 path =</span>
<span class="lineno"> 2227 </span><span class="spaces">  </span><span class="nottickedoff">w4_offline_smtlib2 (Text.unpack path)</span></span>
<span class="lineno"> 2228 </span>
<span class="lineno"> 2229 </span>do_offline_unint_smtlib2 :: [Text] -&gt; Text -&gt; ProofScript ()
<span class="lineno"> 2230 </span><span class="decl"><span class="nottickedoff">do_offline_unint_smtlib2 unints path =</span>
<span class="lineno"> 2231 </span><span class="spaces">  </span><span class="nottickedoff">offline_unint_smtlib2 unints (Text.unpack path)</span></span>
<span class="lineno"> 2232 </span>
<span class="lineno"> 2233 </span>do_offline_verilog :: Text -&gt; ProofScript ()
<span class="lineno"> 2234 </span><span class="decl"><span class="nottickedoff">do_offline_verilog path =</span>
<span class="lineno"> 2235 </span><span class="spaces">  </span><span class="nottickedoff">offline_verilog (Text.unpack path)</span></span>
<span class="lineno"> 2236 </span>
<span class="lineno"> 2237 </span>do_cryptol_add_path :: Text -&gt; TopLevel ()
<span class="lineno"> 2238 </span><span class="decl"><span class="nottickedoff">do_cryptol_add_path path =</span>
<span class="lineno"> 2239 </span><span class="spaces">  </span><span class="nottickedoff">cryptol_add_path (Text.unpack path)</span></span>
<span class="lineno"> 2240 </span>
<span class="lineno"> 2241 </span>do_llvm_load_module :: Text -&gt; TopLevel (Some CIR.LLVMModule)
<span class="lineno"> 2242 </span><span class="decl"><span class="istickedoff">do_llvm_load_module path =</span>
<span class="lineno"> 2243 </span><span class="spaces">  </span><span class="istickedoff">llvm_load_module (Text.unpack path)</span></span>
<span class="lineno"> 2244 </span>
<span class="lineno"> 2245 </span>do_llvm_boilerplate :: Text -&gt; ModuleSkeleton -&gt; Bool -&gt; TopLevel ()
<span class="lineno"> 2246 </span><span class="decl"><span class="nottickedoff">do_llvm_boilerplate path mskel builtins =</span>
<span class="lineno"> 2247 </span><span class="spaces">  </span><span class="nottickedoff">llvm_boilerplate (Text.unpack path) mskel builtins</span></span>
<span class="lineno"> 2248 </span>
<span class="lineno"> 2249 </span>do_llvm_verify_x86 ::
<span class="lineno"> 2250 </span>  Some CIR.LLVMModule -&gt; Text -&gt; Text -&gt; [(Text, Integer)] -&gt; Bool -&gt;
<span class="lineno"> 2251 </span>    LLVMCrucibleSetupM () -&gt; ProofScript () -&gt; TopLevel (CIR.SomeLLVM CMS.ProvedSpec)
<span class="lineno"> 2252 </span><span class="decl"><span class="istickedoff">do_llvm_verify_x86 llvm path nm globsyms checkSat spec ps =</span>
<span class="lineno"> 2253 </span><span class="spaces">  </span><span class="istickedoff">llvm_verify_x86 llvm (Text.unpack path) nm globsyms checkSat spec ps</span></span>
<span class="lineno"> 2254 </span>
<span class="lineno"> 2255 </span>do_llvm_verify_fixpoint_x86 ::
<span class="lineno"> 2256 </span>  Some CIR.LLVMModule -&gt; Text -&gt; Text -&gt; [(Text, Integer)] -&gt; Bool -&gt; TypedTerm -&gt;
<span class="lineno"> 2257 </span>    LLVMCrucibleSetupM () -&gt; ProofScript () -&gt; TopLevel (CIR.SomeLLVM CMS.ProvedSpec)
<span class="lineno"> 2258 </span><span class="decl"><span class="nottickedoff">do_llvm_verify_fixpoint_x86 llvm path nm globsyms checkSat tt spec ps =</span>
<span class="lineno"> 2259 </span><span class="spaces">  </span><span class="nottickedoff">llvm_verify_fixpoint_x86 llvm (Text.unpack path) nm globsyms checkSat tt spec ps</span></span>
<span class="lineno"> 2260 </span>
<span class="lineno"> 2261 </span>do_llvm_verify_fixpoint_chc_x86 ::
<span class="lineno"> 2262 </span>  Some CIR.LLVMModule -&gt; Text -&gt; Text -&gt; [(Text, Integer)] -&gt; Bool -&gt; TypedTerm -&gt;
<span class="lineno"> 2263 </span>  LLVMCrucibleSetupM () -&gt; ProofScript ()  -&gt; TopLevel (CIR.SomeLLVM CMS.ProvedSpec)
<span class="lineno"> 2264 </span><span class="decl"><span class="nottickedoff">do_llvm_verify_fixpoint_chc_x86 llvm path nm globsyms checkSat tt spec ps =</span>
<span class="lineno"> 2265 </span><span class="spaces">  </span><span class="nottickedoff">llvm_verify_fixpoint_chc_x86 llvm (Text.unpack path) nm globsyms checkSat tt spec ps</span></span>
<span class="lineno"> 2266 </span>
<span class="lineno"> 2267 </span>do_llvm_verify_x86_with_invariant ::
<span class="lineno"> 2268 </span>  Some CIR.LLVMModule -&gt; Text -&gt; Text -&gt; [(Text, Integer)] -&gt; Bool -&gt;
<span class="lineno"> 2269 </span>  (Text, Integer, TypedTerm)  -&gt;
<span class="lineno"> 2270 </span>  LLVMCrucibleSetupM () -&gt; ProofScript () -&gt; TopLevel (CIR.SomeLLVM CMS.ProvedSpec)
<span class="lineno"> 2271 </span><span class="decl"><span class="nottickedoff">do_llvm_verify_x86_with_invariant llvm path nm globsyms checkSat info spec ps =</span>
<span class="lineno"> 2272 </span><span class="spaces">  </span><span class="nottickedoff">llvm_verify_x86_with_invariant llvm (Text.unpack path) nm globsyms checkSat info spec ps</span></span>
<span class="lineno"> 2273 </span>
<span class="lineno"> 2274 </span>do_mir_load_module :: Text -&gt; TopLevel MIR.RustModule
<span class="lineno"> 2275 </span><span class="decl"><span class="istickedoff">do_mir_load_module file =</span>
<span class="lineno"> 2276 </span><span class="spaces">  </span><span class="istickedoff">mir_load_module (Text.unpack file)</span></span>
<span class="lineno"> 2277 </span>
<span class="lineno"> 2278 </span>do_yosys_import :: Text -&gt; TopLevel TypedTerm
<span class="lineno"> 2279 </span><span class="decl"><span class="istickedoff">do_yosys_import path =</span>
<span class="lineno"> 2280 </span><span class="spaces">  </span><span class="istickedoff">yosys_import (Text.unpack path)</span></span>
<span class="lineno"> 2281 </span>
<span class="lineno"> 2282 </span>do_yosys_import_sequential :: Text -&gt; Text -&gt; TopLevel Yo.YosysSequential
<span class="lineno"> 2283 </span><span class="decl"><span class="istickedoff">do_yosys_import_sequential nm path =</span>
<span class="lineno"> 2284 </span><span class="spaces">  </span><span class="istickedoff">yosys_import_sequential nm (Text.unpack path)</span></span>
<span class="lineno"> 2285 </span>
<span class="lineno"> 2286 </span>do_yosys_verify_sequential_sally :: Yo.YosysSequential -&gt; Text -&gt; TypedTerm -&gt; [Text] -&gt; TopLevel ()
<span class="lineno"> 2287 </span><span class="decl"><span class="istickedoff">do_yosys_verify_sequential_sally s path q fixed =</span>
<span class="lineno"> 2288 </span><span class="spaces">  </span><span class="istickedoff">yosys_verify_sequential_sally s (Text.unpack path) q fixed</span></span>
<span class="lineno"> 2289 </span>
<span class="lineno"> 2290 </span>do_load_sawcore_from_file :: BuiltinContext -&gt; Options -&gt; Text -&gt; TopLevel ()
<span class="lineno"> 2291 </span><span class="decl"><span class="istickedoff">do_load_sawcore_from_file _ _ mod_filename =</span>
<span class="lineno"> 2292 </span><span class="spaces">  </span><span class="istickedoff">load_sawcore_from_file (Text.unpack mod_filename)</span></span>
<span class="lineno"> 2293 </span>
<span class="lineno"> 2294 </span>do_summarize_verification_json :: Text -&gt; TopLevel ()
<span class="lineno"> 2295 </span><span class="decl"><span class="nottickedoff">do_summarize_verification_json fpath =</span>
<span class="lineno"> 2296 </span><span class="spaces">  </span><span class="nottickedoff">summarize_verification_json (Text.unpack fpath)</span></span>
<span class="lineno"> 2297 </span>
<span class="lineno"> 2298 </span>
<span class="lineno"> 2299 </span>------------------------------------------------------------
<span class="lineno"> 2300 </span>-- Primitive tables
<span class="lineno"> 2301 </span>
<span class="lineno"> 2302 </span>-- | Read a type schema. This is used to digest the type signatures
<span class="lineno"> 2303 </span>-- for builtins, and the expansions for builtin typedefs.
<span class="lineno"> 2304 </span>--
<span class="lineno"> 2305 </span>-- The first argument (fakeFileName) is a string to pass as the
<span class="lineno"> 2306 </span>-- filename for the lexer, which (complete with line and column
<span class="lineno"> 2307 </span>-- numbering of dubious value) will go into the positions of the
<span class="lineno"> 2308 </span>-- elements of the resulting type.
<span class="lineno"> 2309 </span>--
<span class="lineno"> 2310 </span>-- FUTURE: we should figure out how to generate more meaningful
<span class="lineno"> 2311 </span>-- positions (like &quot;third argument of concat&quot;) but this at least
<span class="lineno"> 2312 </span>-- allows telling the user which builtin the type came from.
<span class="lineno"> 2313 </span>--
<span class="lineno"> 2314 </span>readSchema :: FilePath -&gt; Text -&gt; SS.Schema
<span class="lineno"> 2315 </span><span class="decl"><span class="istickedoff">readSchema fakeFileName str =</span>
<span class="lineno"> 2316 </span><span class="spaces">  </span><span class="istickedoff">let <span class="nottickedoff">croak what msg =</span></span>
<span class="lineno"> 2317 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">error (what ++ &quot; error in builtin &quot; ++ Text.unpack str ++ &quot;: &quot; ++ msg)</span></span>
<span class="lineno"> 2318 </span><span class="spaces">      </span><span class="istickedoff">tokens =</span>
<span class="lineno"> 2319 </span><span class="spaces">        </span><span class="istickedoff">-- XXX clean this up when we clean out the message printing infrastructure</span>
<span class="lineno"> 2320 </span><span class="spaces">        </span><span class="istickedoff">case lexSAW fakeFileName str of</span>
<span class="lineno"> 2321 </span><span class="spaces">          </span><span class="istickedoff">Left (_, _, msg) -&gt; <span class="nottickedoff">croak &quot;Lexer&quot; $ Text.unpack msg</span></span>
<span class="lineno"> 2322 </span><span class="spaces">          </span><span class="istickedoff">Right (tokens', Nothing) -&gt; tokens'</span>
<span class="lineno"> 2323 </span><span class="spaces">          </span><span class="istickedoff">Right (_      , Just (Error, _pos, msg)) -&gt; <span class="nottickedoff">croak &quot;Lexer&quot; $ Text.unpack msg</span></span>
<span class="lineno"> 2324 </span><span class="spaces">          </span><span class="istickedoff">Right (tokens', Just (_, _pos, _msg)) -&gt; <span class="nottickedoff">tokens'</span></span>
<span class="lineno"> 2325 </span><span class="spaces">  </span><span class="istickedoff">in</span>
<span class="lineno"> 2326 </span><span class="spaces">  </span><span class="istickedoff">case parseSchema tokens of</span>
<span class="lineno"> 2327 </span><span class="spaces">    </span><span class="istickedoff">Left err -&gt; <span class="nottickedoff">croak &quot;Parse&quot; $ show err</span></span>
<span class="lineno"> 2328 </span><span class="spaces">    </span><span class="istickedoff">Right schema -&gt; schema</span></span>
<span class="lineno"> 2329 </span>
<span class="lineno"> 2330 </span>data PrimType
<span class="lineno"> 2331 </span>  = PrimType
<span class="lineno"> 2332 </span>    { <span class="istickedoff"><span class="decl"><span class="istickedoff">primTypeType</span></span></span> :: SS.NamedType
<span class="lineno"> 2333 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">primTypeLife</span></span></span> :: PrimitiveLifecycle
<span class="lineno"> 2334 </span>    -- FUTURE: add doc strings for these?
<span class="lineno"> 2335 </span>    }
<span class="lineno"> 2336 </span>
<span class="lineno"> 2337 </span>data Primitive
<span class="lineno"> 2338 </span>  = Primitive
<span class="lineno"> 2339 </span>    { <span class="istickedoff"><span class="decl"><span class="istickedoff">primitiveType</span></span></span> :: SS.Schema
<span class="lineno"> 2340 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">primitiveLife</span></span></span> :: PrimitiveLifecycle
<span class="lineno"> 2341 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">primitiveDoc</span></span></span>  :: [Text]
<span class="lineno"> 2342 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">primitiveFn</span></span></span>   :: Options -&gt; BuiltinContext -&gt; Value
<span class="lineno"> 2343 </span>    }
<span class="lineno"> 2344 </span>
<span class="lineno"> 2345 </span>-- | Primitive types, that is, builtin types used by the primitives.
<span class="lineno"> 2346 </span>--
<span class="lineno"> 2347 </span>-- This excludes certain types that are built in more deeply and
<span class="lineno"> 2348 </span>-- appear as entries in @TyCon in AST.hs. Note that those are also
<span class="lineno"> 2349 </span>-- handled as reserved words in the lexer and parser. XXX: and there's
<span class="lineno"> 2350 </span>-- no particular system to which are there and which are here; some of
<span class="lineno"> 2351 </span>-- the ones there have no special syntax or semantics and should
<span class="lineno"> 2352 </span>-- probably be moved here at some point.
<span class="lineno"> 2353 </span>primTypes :: Map SS.Name PrimType
<span class="lineno"> 2354 </span><span class="decl"><span class="istickedoff">primTypes = Map.fromList</span>
<span class="lineno"> 2355 </span><span class="spaces">  </span><span class="istickedoff">[ abstype &quot;BisimTheorem&quot; Experimental</span>
<span class="lineno"> 2356 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;CryptolModule&quot; Current</span>
<span class="lineno"> 2357 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;FunctionProfile&quot; <span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2358 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;FunctionSkeleton&quot; <span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2359 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;Ghost&quot; Current</span>
<span class="lineno"> 2360 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;JVMSetup&quot; Current</span>
<span class="lineno"> 2361 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;JVMValue&quot; Current</span>
<span class="lineno"> 2362 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;JavaClass&quot; Current</span>
<span class="lineno"> 2363 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;JavaType&quot; Current</span>
<span class="lineno"> 2364 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;LLVMModule&quot; Current</span>
<span class="lineno"> 2365 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;LLVMType&quot; Current</span>
<span class="lineno"> 2366 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;MIRAdt&quot; Experimental</span>
<span class="lineno"> 2367 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;MIRModule&quot; Experimental</span>
<span class="lineno"> 2368 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;MIRType&quot; Experimental</span>
<span class="lineno"> 2369 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;MIRValue&quot; Experimental</span>
<span class="lineno"> 2370 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;ModuleSkeleton&quot; <span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2371 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;ProofResult&quot; Current</span>
<span class="lineno"> 2372 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;SatResult&quot; Current</span>
<span class="lineno"> 2373 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;SetupValue&quot; Current</span>
<span class="lineno"> 2374 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;Simpset&quot; Current</span>
<span class="lineno"> 2375 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;SkeletonState&quot; <span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2376 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;Theorem&quot; Current</span>
<span class="lineno"> 2377 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;YosysSequential&quot; Experimental</span>
<span class="lineno"> 2378 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;YosysTheorem&quot; Experimental</span>
<span class="lineno"> 2379 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;__DEPRECATED__&quot; HideDeprecated</span>
<span class="lineno"> 2380 </span><span class="spaces">  </span><span class="istickedoff">]</span>
<span class="lineno"> 2381 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 2382 </span><span class="spaces">    </span><span class="istickedoff">-- abstract type</span>
<span class="lineno"> 2383 </span><span class="spaces">    </span><span class="istickedoff">abstype :: Text -&gt; PrimitiveLifecycle -&gt; (SS.Name, PrimType)</span>
<span class="lineno"> 2384 </span><span class="spaces">    </span><span class="istickedoff">abstype name lc = (name, info)</span>
<span class="lineno"> 2385 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno"> 2386 </span><span class="spaces">        </span><span class="istickedoff">info = PrimType</span>
<span class="lineno"> 2387 </span><span class="spaces">          </span><span class="istickedoff">{ primTypeType = SS.AbstractType</span>
<span class="lineno"> 2388 </span><span class="spaces">          </span><span class="istickedoff">, primTypeLife = lc</span>
<span class="lineno"> 2389 </span><span class="spaces">          </span><span class="istickedoff">}</span>
<span class="lineno"> 2390 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2391 </span><span class="spaces">    </span><span class="istickedoff">-- concrete type (not currently used)</span>
<span class="lineno"> 2392 </span><span class="spaces">    </span><span class="istickedoff">_conctype :: Text -&gt; Text -&gt; PrimitiveLifecycle -&gt; (SS.Name, PrimType)</span>
<span class="lineno"> 2393 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">_conctype name tystr lc = (name, info)</span></span>
<span class="lineno"> 2394 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">where</span></span>
<span class="lineno"> 2395 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">info = PrimType</span></span>
<span class="lineno"> 2396 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">{ primTypeType = SS.ConcreteType ty</span></span>
<span class="lineno"> 2397 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">, primTypeLife = lc</span></span>
<span class="lineno"> 2398 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">}</span></span>
<span class="lineno"> 2399 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">fakeFileName = Text.unpack $ &quot;&lt;definition of builtin type &quot; &lt;&gt; name &lt;&gt; &quot;&gt;&quot;</span></span>
<span class="lineno"> 2400 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">ty = case readSchema fakeFileName tystr of</span></span>
<span class="lineno"> 2401 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">SS.Forall [] ty' -&gt; ty'</span></span>
<span class="lineno"> 2402 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; panic &quot;primTypes&quot; [&quot;Builtin typedef name not monomorphic&quot;]</span></span></span>
<span class="lineno"> 2403 </span>
<span class="lineno"> 2404 </span>
<span class="lineno"> 2405 </span>primitives :: Map SS.Name Primitive
<span class="lineno"> 2406 </span><span class="decl"><span class="istickedoff">primitives = Map.fromList $</span>
<span class="lineno"> 2407 </span><span class="spaces">  </span><span class="istickedoff">[ prim &quot;return&quot;              &quot;{m, a} a -&gt; m a&quot;</span>
<span class="lineno"> 2408 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (\v -&gt; VReturn <span class="nottickedoff">atRestPos</span> [] v))</span>
<span class="lineno"> 2409 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2410 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Yield a value in a command context. The command&quot;</span></span>
<span class="lineno"> 2411 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;    x &lt;- return e&quot;</span></span>
<span class="lineno"> 2412 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">,&quot;will result in the same value being bound to 'x' as the command&quot;</span></span>
<span class="lineno"> 2413 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;    let x = e&quot;</span></span>
<span class="lineno"> 2414 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2415 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2416 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;true&quot;                &quot;Bool&quot;</span>
<span class="lineno"> 2417 </span><span class="spaces">    </span><span class="istickedoff">(pureVal True)</span>
<span class="lineno"> 2418 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2419 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A boolean value.&quot; ]</span></span>
<span class="lineno"> 2420 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2421 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;false&quot;               &quot;Bool&quot;</span>
<span class="lineno"> 2422 </span><span class="spaces">    </span><span class="istickedoff">(pureVal False)</span>
<span class="lineno"> 2423 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2424 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A boolean value.&quot; ]</span></span>
<span class="lineno"> 2425 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2426 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;for&quot;                 &quot;{m, a, b} [a] -&gt; (a -&gt; m b) -&gt; m [b]&quot;</span>
<span class="lineno"> 2427 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 forValue)</span>
<span class="lineno"> 2428 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2429 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Apply the given command in sequence to the given list. Return&quot;</span></span>
<span class="lineno"> 2430 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the list containing the result returned by the command at each&quot;</span></span>
<span class="lineno"> 2431 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;iteration.&quot;</span></span>
<span class="lineno"> 2432 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2433 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2434 </span><span class="spaces">    </span><span class="istickedoff">-- In principle we could have one monad-polymorphic builtin, but</span>
<span class="lineno"> 2435 </span><span class="spaces">    </span><span class="istickedoff">-- monad-polymorphic builtins don't currently work.</span>
<span class="lineno"> 2436 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno"> 2437 </span><span class="spaces">    </span><span class="istickedoff">-- FUTURE: because these are only intended for use by the test</span>
<span class="lineno"> 2438 </span><span class="spaces">    </span><span class="istickedoff">-- suite, it might make sense to add a different category for that</span>
<span class="lineno"> 2439 </span><span class="spaces">    </span><span class="istickedoff">-- instead of Experimental, to make it extra clear that third</span>
<span class="lineno"> 2440 </span><span class="spaces">    </span><span class="istickedoff">-- parties shouldn't use these.</span>
<span class="lineno"> 2441 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_stack&quot;         &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2442 </span><span class="spaces">    </span><span class="istickedoff">(pureVal print_stack)</span>
<span class="lineno"> 2443 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2444 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the SAWScript interpreter's current stack trace, for testing.&quot; ]</span></span>
<span class="lineno"> 2445 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;proof_stack&quot;         &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2446 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proof_stack)</span>
<span class="lineno"> 2447 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2448 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;ProofScript version of print_stack.&quot; ]</span></span>
<span class="lineno"> 2449 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_stack&quot;          &quot;LLVMSetup ()&quot;</span>
<span class="lineno"> 2450 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_stack)</span>
<span class="lineno"> 2451 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2452 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;LLVMSetup version of print_stack.&quot; ]</span></span>
<span class="lineno"> 2453 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_stack&quot;           &quot;JVMSetup ()&quot;</span>
<span class="lineno"> 2454 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal jvm_stack)</span></span>
<span class="lineno"> 2455 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2456 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;JVMSetup version of print_stack.&quot; ]</span></span>
<span class="lineno"> 2457 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_stack&quot;           &quot;MIRSetup ()&quot;</span>
<span class="lineno"> 2458 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal mir_stack)</span></span>
<span class="lineno"> 2459 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2460 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;MIRSetup version of print_stack.&quot; ]</span></span>
<span class="lineno"> 2461 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2462 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;run&quot;                 &quot;{a} TopLevel a -&gt; a&quot;</span>
<span class="lineno"> 2463 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 (id :: TopLevel Value -&gt; TopLevel Value))</span>
<span class="lineno"> 2464 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2465 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Evaluate a monadic TopLevel computation to produce a value.&quot; ]</span></span>
<span class="lineno"> 2466 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2467 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;null&quot;                &quot;{a} [a] -&gt; Bool&quot;</span>
<span class="lineno"> 2468 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (null :: [Value] -&gt; Bool))</span>
<span class="lineno"> 2469 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2470 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Test whether a list value is empty.&quot; ]</span></span>
<span class="lineno"> 2471 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2472 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;nth&quot;                 &quot;{a} [a] -&gt; Int -&gt; a&quot;</span>
<span class="lineno"> 2473 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 (nthPrim :: [Value] -&gt; Int -&gt; TopLevel Value))</span>
<span class="lineno"> 2474 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2475 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Look up the value at the given list position.&quot; ]</span></span>
<span class="lineno"> 2476 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2477 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;head&quot;                &quot;{a} [a] -&gt; a&quot;</span>
<span class="lineno"> 2478 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 (headPrim :: [Value] -&gt; TopLevel Value))</span>
<span class="lineno"> 2479 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2480 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Get the first element from the list.&quot; ]</span></span>
<span class="lineno"> 2481 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2482 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;tail&quot;                &quot;{a} [a] -&gt; [a]&quot;</span>
<span class="lineno"> 2483 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 (tailPrim :: [Value] -&gt; TopLevel [Value]))</span>
<span class="lineno"> 2484 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2485 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Drop the first element from a list.&quot; ]</span></span>
<span class="lineno"> 2486 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2487 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;concat&quot;              &quot;{a} [a] -&gt; [a] -&gt; [a]&quot;</span>
<span class="lineno"> 2488 </span><span class="spaces">    </span><span class="istickedoff">(pureVal ((++) :: [Value] -&gt; [Value] -&gt; [Value]))</span>
<span class="lineno"> 2489 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2490 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Concatenate two lists to yield a third.&quot; ]</span></span>
<span class="lineno"> 2491 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2492 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;length&quot;              &quot;{a} [a] -&gt; Int&quot;</span>
<span class="lineno"> 2493 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (length :: [Value] -&gt; Int))</span>
<span class="lineno"> 2494 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2495 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Compute the length of a list.&quot; ]</span></span>
<span class="lineno"> 2496 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2497 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;str_concat&quot;          &quot;String -&gt; String -&gt; String&quot;</span>
<span class="lineno"> 2498 </span><span class="spaces">    </span><span class="istickedoff">(pureVal ((&lt;&gt;) :: Text -&gt; Text -&gt; Text))</span>
<span class="lineno"> 2499 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2500 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Concatenate two strings to yield a third.&quot; ]</span></span>
<span class="lineno"> 2501 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2502 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;str_concats&quot;          &quot;[String] -&gt; String&quot;</span>
<span class="lineno"> 2503 </span><span class="spaces">    </span><span class="istickedoff">(pureVal Text.concat)</span>
<span class="lineno"> 2504 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2505 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Concatenate a list of strings together to yield a string.&quot; ]</span></span>
<span class="lineno"> 2506 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2507 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;checkpoint&quot;          &quot;TopLevel (() -&gt; TopLevel ())&quot;</span>
<span class="lineno"> 2508 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal checkpoint)</span></span>
<span class="lineno"> 2509 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2510 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Capture the current state of the SAW interpreter, and return&quot;</span></span>
<span class="lineno"> 2511 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;A TopLevel monadic action that, if invoked, will reset the&quot;</span></span>
<span class="lineno"> 2512 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;state of the interpreter back to to what it was at the&quot;</span></span>
<span class="lineno"> 2513 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;moment checkpoint was invoked.&quot;</span></span>
<span class="lineno"> 2514 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2515 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;NOTE that this facility is highly experimental and may not&quot;</span></span>
<span class="lineno"> 2516 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;be entirely reliable.  It is intended only for proof development&quot;</span></span>
<span class="lineno"> 2517 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;where it can speed up the process of experimenting with&quot;</span></span>
<span class="lineno"> 2518 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;mid-proof changes. Finalized proofs should not use this facility.&quot;</span></span>
<span class="lineno"> 2519 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2520 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2521 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;subshell&quot;            &quot;() -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2522 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal toplevelSubshell)</span></span>
<span class="lineno"> 2523 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2524 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Open an interactive subshell instance in the context where&quot;</span></span>
<span class="lineno"> 2525 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'subshell' was called. This works either from within execution&quot;</span></span>
<span class="lineno"> 2526 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of a outer shell instance, or from interpreting a file in batch&quot;</span></span>
<span class="lineno"> 2527 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;mode. Enter the end-of-file character in your terminal (Ctrl^D, usually)&quot;</span></span>
<span class="lineno"> 2528 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to exit the subshell and resume execution.&quot;</span></span>
<span class="lineno"> 2529 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2530 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This command is especially useful in conjunction with the 'checkpoint'&quot;</span></span>
<span class="lineno"> 2531 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;command, which allows returning to a prior state.&quot;</span></span>
<span class="lineno"> 2532 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2533 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Note that, due to the way the SAW script interpreter works, changes made&quot;</span></span>
<span class="lineno"> 2534 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to a script file in which the 'subshell' command directly appears will&quot;</span></span>
<span class="lineno"> 2535 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;NOT affect subsequent execution following a 'checkpoint' use.&quot;</span></span>
<span class="lineno"> 2536 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;However, changes made in a file that executed via 'include' WILL affect&quot;</span></span>
<span class="lineno"> 2537 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;restarted executions, as the 'include' command will read and parse the&quot;</span></span>
<span class="lineno"> 2538 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;file from scratch.&quot;</span></span>
<span class="lineno"> 2539 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2540 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2541 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;proof_subshell&quot;      &quot;() -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2542 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proofScriptSubshell)</span>
<span class="lineno"> 2543 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2544 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Open an interactive subshell instance in the context of the current proof.&quot;</span></span>
<span class="lineno"> 2545 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This allows the user to interactively execute 'ProofScript' tactic commands&quot;</span></span>
<span class="lineno"> 2546 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;directly on the command line an examine their effects using, e.g., 'print_goal'.&quot;</span></span>
<span class="lineno"> 2547 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In proof mode, the command prompt will change to 'proof (n)', where the 'n'&quot;</span></span>
<span class="lineno"> 2548 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;indicates the number of subgoals remaining to proof for the current overall goal.&quot;</span></span>
<span class="lineno"> 2549 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In this mode, tactic commands applied will only affect the current subgoal.&quot;</span></span>
<span class="lineno"> 2550 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;When a particular subgoal is completed, the next subgoal will automatically become&quot;</span></span>
<span class="lineno"> 2551 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the active subgoal. An overall goal is completed when all subgoals are proved&quot;</span></span>
<span class="lineno"> 2552 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;and the current number of subgoals is 0.&quot;</span></span>
<span class="lineno"> 2553 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2554 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Enter the end-of-file character in your terminal (Ctrl^D, usually) to exit the proof&quot;</span></span>
<span class="lineno"> 2555 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;subshell and resume execution.&quot;</span></span>
<span class="lineno"> 2556 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2557 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2558 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;proof_checkpoint&quot;      &quot;ProofScript (() -&gt; ProofScript ())&quot;</span>
<span class="lineno"> 2559 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proof_checkpoint)</span></span>
<span class="lineno"> 2560 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2561 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Capture the current state of the proof and return a&quot;</span></span>
<span class="lineno"> 2562 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;ProofScript monadic action that, if invoked, will reset the&quot;</span></span>
<span class="lineno"> 2563 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;state of the proof back to to what it was at the&quot;</span></span>
<span class="lineno"> 2564 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;moment checkpoint was invoked.&quot;</span></span>
<span class="lineno"> 2565 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2566 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;NOTE that this facility is highly experimental and may not&quot;</span></span>
<span class="lineno"> 2567 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;be entirely reliable.  It is intended only for proof development&quot;</span></span>
<span class="lineno"> 2568 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;where it can speed up the process of experimenting with&quot;</span></span>
<span class="lineno"> 2569 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;mid-proof changes. Finalized proofs should not use this facility.&quot;</span></span>
<span class="lineno"> 2570 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2571 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2572 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;define&quot;              &quot;String -&gt; Term -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 2573 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal definePrim)</span></span>
<span class="lineno"> 2574 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2575 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Wrap a term with a name that allows its body to be hidden or&quot;</span></span>
<span class="lineno"> 2576 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;revealed. This can allow any sub-term to be treated as an&quot;</span></span>
<span class="lineno"> 2577 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;uninterpreted function during proofs.&quot;</span></span>
<span class="lineno"> 2578 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2579 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2580 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;include&quot;             &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2581 </span><span class="spaces">    </span><span class="istickedoff">(pureVal include_value)</span>
<span class="lineno"> 2582 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2583 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Execute the given SAWScript file.&quot; ]</span></span>
<span class="lineno"> 2584 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2585 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_deprecated&quot;   &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2586 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal (add_primitives HideDeprecated))</span></span>
<span class="lineno"> 2587 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2588 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable the use of deprecated commands. When commands are first deprecated they&quot;</span></span>
<span class="lineno"> 2589 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;generate warnings. At a later stage they become invisible unless explicitly&quot;</span></span>
<span class="lineno"> 2590 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;enabled with this command. The next stage is to remove them entirely. Therefore,&quot;</span></span>
<span class="lineno"> 2591 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the use of this command should always be considered a temporary stopgap until&quot;</span></span>
<span class="lineno"> 2592 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;your scripts can be updated.&quot;</span></span>
<span class="lineno"> 2593 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2594 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2595 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_experimental&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2596 </span><span class="spaces">    </span><span class="istickedoff">(bicVal (add_primitives Experimental))</span>
<span class="lineno"> 2597 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2598 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable the use of experimental commands.&quot; ]</span></span>
<span class="lineno"> 2599 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2600 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_smt_array_memory_model&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2601 </span><span class="spaces">    </span><span class="istickedoff">(pureVal enable_smt_array_memory_model)</span>
<span class="lineno"> 2602 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2603 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable the SMT array memory model.&quot; ]</span></span>
<span class="lineno"> 2604 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2605 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_smt_array_memory_model&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2606 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_smt_array_memory_model)</span></span>
<span class="lineno"> 2607 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2608 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable the SMT array memory model.&quot; ]</span></span>
<span class="lineno"> 2609 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2610 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_sequent_goals&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2611 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal enable_sequent_goals)</span></span>
<span class="lineno"> 2612 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2613 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;When verifying proof obligations arising from `llvm_verify` and similar commands,&quot;</span></span>
<span class="lineno"> 2614 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;generate sequents for the proof obligations instead of a single boolean goal.&quot;</span></span>
<span class="lineno"> 2615 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2616 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2617 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_sequent_goals&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2618 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_sequent_goals)</span></span>
<span class="lineno"> 2619 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2620 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Restore the default behavior, which is to generate single boolean goals&quot;</span></span>
<span class="lineno"> 2621 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;for proof obligations arising from verification commands.&quot;</span></span>
<span class="lineno"> 2622 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2623 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2624 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_safety_proofs&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2625 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal enable_safety_proofs)</span></span>
<span class="lineno"> 2626 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2627 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Restore the default state, where safety obligations&quot;</span></span>
<span class="lineno"> 2628 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;encountered during symbolic execution are proofed normally.&quot;</span></span>
<span class="lineno"> 2629 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2630 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2631 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_safety_proofs&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2632 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_safety_proofs)</span></span>
<span class="lineno"> 2633 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2634 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable checking of safety obligations encountered during symbolic&quot;</span></span>
<span class="lineno"> 2635 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;execution. This is unsound! However, it can be useful during&quot;</span></span>
<span class="lineno"> 2636 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;initial proof construction to focus only on the stated correctness&quot;</span></span>
<span class="lineno"> 2637 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specifications.&quot;</span></span>
<span class="lineno"> 2638 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2639 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2640 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_single_override_special_case&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2641 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal enable_single_override_special_case)</span></span>
<span class="lineno"> 2642 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2643 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable special-case handling when there is exactly one override&quot;</span></span>
<span class="lineno"> 2644 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;that appies at a given call site after structural matching.&quot;</span></span>
<span class="lineno"> 2645 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This special case handling asserts the override preconditions as separate&quot;</span></span>
<span class="lineno"> 2646 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;proof goals, instead of combining them into a single one.  In general,&quot;</span></span>
<span class="lineno"> 2647 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;this may produce more, but simpler, goals than when disabled.&quot;</span></span>
<span class="lineno"> 2648 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2649 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2650 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_single_override_special_case&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2651 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_single_override_special_case)</span></span>
<span class="lineno"> 2652 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2653 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable special case handling for single overrides.&quot;</span></span>
<span class="lineno"> 2654 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This is the default behavior.&quot;</span></span>
<span class="lineno"> 2655 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2656 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2657 </span><span class="spaces"> </span><span class="istickedoff">, prim &quot;enable_crucible_assert_then_assume&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2658 </span><span class="spaces">    </span><span class="istickedoff">(pureVal enable_crucible_assert_then_assume)</span>
<span class="lineno"> 2659 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2660 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Assume predicate after asserting it during Crucible symbolic simulation.&quot; ]</span></span>
<span class="lineno"> 2661 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2662 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_crucible_assert_then_assume&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2663 </span><span class="spaces">    </span><span class="istickedoff">(pureVal disable_crucible_assert_then_assume)</span>
<span class="lineno"> 2664 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2665 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Do not assume predicate after asserting it during Crucible symbolic simulation.&quot; ]</span></span>
<span class="lineno"> 2666 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2667 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_lax_arithmetic&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2668 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal enable_lax_arithmetic)</span></span>
<span class="lineno"> 2669 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2670 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable lax rules for arithmetic overflow in Crucible.&quot; ]</span></span>
<span class="lineno"> 2671 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2672 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_lax_arithmetic&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2673 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_lax_arithmetic)</span></span>
<span class="lineno"> 2674 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2675 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable lax rules for arithmetic overflow in Crucible.&quot; ]</span></span>
<span class="lineno"> 2676 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2677 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_lax_pointer_ordering&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2678 </span><span class="spaces">    </span><span class="istickedoff">(pureVal enable_lax_pointer_ordering)</span>
<span class="lineno"> 2679 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2680 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable lax rules for pointer ordering comparisons in Crucible.&quot; ]</span></span>
<span class="lineno"> 2681 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2682 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_lax_pointer_ordering&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2683 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_lax_pointer_ordering)</span></span>
<span class="lineno"> 2684 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2685 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable lax rules for pointer ordering comparisons in Crucible.&quot; ]</span></span>
<span class="lineno"> 2686 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2687 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_lax_loads_and_stores&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2688 </span><span class="spaces">    </span><span class="istickedoff">(pureVal enable_lax_loads_and_stores)</span>
<span class="lineno"> 2689 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2690 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable relaxed validity checking for memory loads and stores in Crucible.&quot; ]</span></span>
<span class="lineno"> 2691 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2692 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_lax_loads_and_stores&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2693 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_lax_loads_and_stores)</span></span>
<span class="lineno"> 2694 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2695 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable relaxed validity checking for memory loads and stores in Crucible.&quot; ]</span></span>
<span class="lineno"> 2696 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2697 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_path_sat_solver&quot; &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2698 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_path_sat_solver)</span></span>
<span class="lineno"> 2699 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2700 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Set the path satisfiablity solver to use.  Accepted values&quot;</span></span>
<span class="lineno"> 2701 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;currently are 'z3' and 'yices'.&quot;</span></span>
<span class="lineno"> 2702 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2703 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2704 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_solver_cache_path&quot; &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2705 </span><span class="spaces">    </span><span class="istickedoff">(pureVal set_solver_cache_path)</span>
<span class="lineno"> 2706 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2707 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a solver result cache at the given path, add to that cache all results&quot;</span></span>
<span class="lineno"> 2708 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the currently used solver result cache, if there is one, then use the newly&quot;</span></span>
<span class="lineno"> 2709 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;created cache as the solver result cache going forward. Note that if the&quot;</span></span>
<span class="lineno"> 2710 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;SAW_SOLVER_CACHE_PATH environment variable was set at startup but solver&quot;</span></span>
<span class="lineno"> 2711 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;caching has yet to actually be used, then the value of the environment&quot;</span></span>
<span class="lineno"> 2712 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;variable is ignored.&quot;</span></span>
<span class="lineno"> 2713 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2714 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2715 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_solver_cache_timeout&quot; &quot;Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2716 </span><span class="spaces">    </span><span class="istickedoff">(pureVal set_solver_cache_timeout)</span>
<span class="lineno"> 2717 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2718 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Set the solver result cache's timeout (in microseconds) to use for&quot;</span></span>
<span class="lineno"> 2719 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;database lookups and inserts. The default timeout is 2,000,000&quot;</span></span>
<span class="lineno"> 2720 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;microseconds (2 seconds).&quot;</span></span>
<span class="lineno"> 2721 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2722 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2723 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;clean_mismatched_versions_solver_cache&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2724 </span><span class="spaces">    </span><span class="istickedoff">(pureVal clean_mismatched_versions_solver_cache)</span>
<span class="lineno"> 2725 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2726 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Remove all entries in the solver result cache which were created&quot;</span></span>
<span class="lineno"> 2727 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;using solver backend versions which do not match the versions&quot;</span></span>
<span class="lineno"> 2728 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the current environment.&quot;</span></span>
<span class="lineno"> 2729 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2730 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2731 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_solver_cache&quot; &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2732 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (onSolverCache . printSolverCacheByHex))</span></span>
<span class="lineno"> 2733 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2734 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print all entries in the solver result cache whose SHA256 hash&quot;</span></span>
<span class="lineno"> 2735 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;keys start with the given hex string. Providing an empty string&quot;</span></span>
<span class="lineno"> 2736 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;results in all entries in the cache being printed.&quot;</span></span>
<span class="lineno"> 2737 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2738 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2739 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_solver_cache_stats&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2740 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (onSolverCache printSolverCacheStats))</span></span>
<span class="lineno"> 2741 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2742 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print out statistics about how the solver cache has been used, namely:&quot;</span></span>
<span class="lineno"> 2743 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;1. How many entries are in the cache (and where the cache is stored)&quot;</span></span>
<span class="lineno"> 2744 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;2. How many insertions into the cache have been made so far this session&quot;</span></span>
<span class="lineno"> 2745 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;3. How many failed insertion attempts have been made so far this session&quot;</span></span>
<span class="lineno"> 2746 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;4. How times cached results have been used so far this session&quot;</span></span>
<span class="lineno"> 2747 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;5. How many failed attempted usages have occurred so far this session.&quot; ]</span></span>
<span class="lineno"> 2748 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2749 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;test_solver_cache_stats&quot; &quot;Int -&gt; Int -&gt; Int -&gt; Int -&gt; Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2750 </span><span class="spaces">    </span><span class="istickedoff">(pureVal test_solver_cache_stats)</span>
<span class="lineno"> 2751 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2752 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Test whether the values of the statistics printed out by&quot;</span></span>
<span class="lineno"> 2753 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;print_solver_cache_stats are equal to those given, failing if this does not&quot;</span></span>
<span class="lineno"> 2754 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;hold. Specifically, the arguments represent:&quot;</span></span>
<span class="lineno"> 2755 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;1. How many entries are in the cache&quot;</span></span>
<span class="lineno"> 2756 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;2. How many insertions into the cache have been made so far this session&quot;</span></span>
<span class="lineno"> 2757 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;3. How many failed insertion attempts have been made so far this session&quot;</span></span>
<span class="lineno"> 2758 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;4. How times cached results have been used so far this session&quot;</span></span>
<span class="lineno"> 2759 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;5. How many failed attempted usages have occurred so far this session&quot; ]</span></span>
<span class="lineno"> 2760 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2761 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_debug_intrinsics&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2762 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal enable_debug_intrinsics)</span></span>
<span class="lineno"> 2763 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2764 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable translating statements using certain llvm.dbg intrinsic functions in Crucible.&quot; ]</span></span>
<span class="lineno"> 2765 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2766 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_debug_intrinsics&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2767 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_debug_intrinsics)</span></span>
<span class="lineno"> 2768 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2769 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable translating statements using certain llvm.dbg intrinsic functions in Crucible.&quot; ]</span></span>
<span class="lineno"> 2770 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2771 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_what4_hash_consing&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2772 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal enable_what4_hash_consing)</span></span>
<span class="lineno"> 2773 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2774 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable hash consing for What4 expressions.&quot; ]</span></span>
<span class="lineno"> 2775 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2776 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_what4_hash_consing&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2777 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_what4_hash_consing)</span></span>
<span class="lineno"> 2778 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2779 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable hash consing for What4 expressions.&quot; ]</span></span>
<span class="lineno"> 2780 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2781 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;env&quot;                 &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2782 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal envCmd)</span></span>
<span class="lineno"> 2783 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">WarnDeprecated</span></span>
<span class="lineno"> 2784 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print all sawscript values in scope.&quot;</span></span>
<span class="lineno"> 2785 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Deprecated; use the :env REPL command instead.&quot;</span></span>
<span class="lineno"> 2786 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2787 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Expected to be hidden by default in SAW 1.5.&quot;</span></span>
<span class="lineno"> 2788 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2789 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2790 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_ascii&quot;           &quot;Bool -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2791 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_ascii)</span></span>
<span class="lineno"> 2792 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2793 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Select whether to pretty-print arrays of 8-bit numbers as ascii strings.&quot; ]</span></span>
<span class="lineno"> 2794 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2795 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_base&quot;            &quot;Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2796 </span><span class="spaces">    </span><span class="istickedoff">(pureVal set_base)</span>
<span class="lineno"> 2797 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2798 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Set the number base for pretty-printing numeric literals.&quot;</span></span>
<span class="lineno"> 2799 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Permissible values include 2, 8, 10, and 16.&quot; ]</span></span>
<span class="lineno"> 2800 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2801 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_color&quot;           &quot;Bool -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2802 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_color)</span></span>
<span class="lineno"> 2803 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2804 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Select whether to pretty-print SAWCore terms using color.&quot; ]</span></span>
<span class="lineno"> 2805 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2806 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_min_sharing&quot;     &quot;Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2807 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_min_sharing)</span></span>
<span class="lineno"> 2808 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2809 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Set the number times a subterm must be shared for it to be&quot;</span></span>
<span class="lineno"> 2810 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">,  &quot;let-bound in printer output.&quot; ]</span></span>
<span class="lineno"> 2811 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2812 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_memoization_hash&quot; &quot;Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2813 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_memoization_hash)</span></span>
<span class="lineno"> 2814 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2815 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;`set_memoization_hash i` changes the memoization strategy &quot;</span></span>
<span class="lineno"> 2816 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;for terms: memoization identifiers will include the first `i` &quot;</span></span>
<span class="lineno"> 2817 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;digits of the hash of the term they memoize. This is useful &quot;</span></span>
<span class="lineno"> 2818 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to help keep memoization identifiers of the same term as &quot;</span></span>
<span class="lineno"> 2819 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;constant as possible across different executions of a proof &quot;</span></span>
<span class="lineno"> 2820 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;script over the course of its development.&quot;</span></span>
<span class="lineno"> 2821 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2822 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2823 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_memoization_hash_incremental&quot; &quot;Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2824 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_memoization_hash_incremental)</span></span>
<span class="lineno"> 2825 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2826 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;`set_memoization_hash_incremental i` changes the memoization &quot;</span></span>
<span class="lineno"> 2827 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;strategy for terms: memoization identifiers will include the &quot;</span></span>
<span class="lineno"> 2828 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;first `i` digits of the hash of the term they memoize, as well &quot;</span></span>
<span class="lineno"> 2829 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;as the value of a global counter that increments each time a &quot;</span></span>
<span class="lineno"> 2830 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;term is memoized. This is useful to help keep memoization &quot;</span></span>
<span class="lineno"> 2831 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;identifiers of the same term as constant as possible across &quot;</span></span>
<span class="lineno"> 2832 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;different executions of a proof script over the course of its &quot;</span></span>
<span class="lineno"> 2833 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;development, as well as to freshen memoization identifiers in &quot;</span></span>
<span class="lineno"> 2834 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the unlikely case of term hash collisions.&quot;</span></span>
<span class="lineno"> 2835 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2836 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2837 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_memoization_incremental&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2838 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_memoization_incremental)</span></span>
<span class="lineno"> 2839 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2840 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;`set_memoization_incremental` changes the memoization strategy &quot;</span></span>
<span class="lineno"> 2841 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;for terms: memoization identifiers will only include the value &quot;</span></span>
<span class="lineno"> 2842 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of a global counter that increments each time a term is memoized. &quot;</span></span>
<span class="lineno"> 2843 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This is the default.&quot;</span></span>
<span class="lineno"> 2844 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2845 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2846 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_timeout&quot;         &quot;Int -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2847 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_timeout)</span></span>
<span class="lineno"> 2848 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2849 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Set the timeout, in milliseconds, for any automated prover at the&quot;</span></span>
<span class="lineno"> 2850 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;end of this proof script. Note that this is simply ignored for provers&quot;</span></span>
<span class="lineno"> 2851 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;that don't support timeouts, for now.&quot;</span></span>
<span class="lineno"> 2852 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2853 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2854 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;show&quot;                &quot;{a} a -&gt; String&quot;</span>
<span class="lineno"> 2855 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 showPrim)</span>
<span class="lineno"> 2856 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2857 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Convert the value of the given expression to a string.&quot; ]</span></span>
<span class="lineno"> 2858 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2859 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print&quot;               &quot;{a} a -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2860 </span><span class="spaces">    </span><span class="istickedoff">(pureVal print_value)</span>
<span class="lineno"> 2861 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2862 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the value of the given expression.&quot; ]</span></span>
<span class="lineno"> 2863 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2864 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_term&quot;          &quot;Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2865 </span><span class="spaces">    </span><span class="istickedoff">(pureVal print_term)</span>
<span class="lineno"> 2866 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2867 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Pretty-print the given term in SAWCore syntax.&quot; ]</span></span>
<span class="lineno"> 2868 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2869 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_term_depth&quot;    &quot;Int -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2870 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal print_term_depth)</span></span>
<span class="lineno"> 2871 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2872 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Pretty-print the given term in SAWCore syntax up to a given depth.&quot; ]</span></span>
<span class="lineno"> 2873 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2874 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;dump_file_AST&quot;       &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2875 </span><span class="spaces">    </span><span class="istickedoff">(bicVal dump_file_AST)</span>
<span class="lineno"> 2876 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2877 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Dump a pretty representation of the SAWScript AST for a file.&quot; ]</span></span>
<span class="lineno"> 2878 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2879 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;parser_printer_roundtrip&quot;       &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2880 </span><span class="spaces">    </span><span class="istickedoff">(bicVal parser_printer_roundtrip)</span>
<span class="lineno"> 2881 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2882 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Parses the file as SAWScript and renders the resultant AST back to SAWScript concrete syntax.&quot; ]</span></span>
<span class="lineno"> 2883 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2884 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_type&quot;          &quot;Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2885 </span><span class="spaces">    </span><span class="istickedoff">(pureVal print_type)</span>
<span class="lineno"> 2886 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2887 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the type of the given term.&quot; ]</span></span>
<span class="lineno"> 2888 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2889 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;type&quot;                &quot;Term -&gt; Type&quot;</span>
<span class="lineno"> 2890 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal1 term_type)</span></span>
<span class="lineno"> 2891 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2892 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return the type of the given term.&quot; ]</span></span>
<span class="lineno"> 2893 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2894 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;show_term&quot;           &quot;Term -&gt; String&quot;</span>
<span class="lineno"> 2895 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 show_term)</span>
<span class="lineno"> 2896 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2897 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Pretty-print the given term in SAWCore syntax, yielding a String.&quot; ]</span></span>
<span class="lineno"> 2898 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2899 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;check_term&quot;          &quot;Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2900 </span><span class="spaces">    </span><span class="istickedoff">(pureVal check_term)</span>
<span class="lineno"> 2901 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2902 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Type-check the given term, printing an error message if ill-typed.&quot; ]</span></span>
<span class="lineno"> 2903 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2904 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;check_goal&quot;          &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2905 </span><span class="spaces">    </span><span class="istickedoff">(pureVal check_goal)</span>
<span class="lineno"> 2906 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2907 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Type-check the current proof goal, printing an error message if ill-typed.&quot; ]</span></span>
<span class="lineno"> 2908 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2909 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;term_size&quot;           &quot;Term -&gt; Int&quot;</span>
<span class="lineno"> 2910 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal scSharedSize)</span></span>
<span class="lineno"> 2911 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2912 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return the size of the given term in the number of DAG nodes.&quot; ]</span></span>
<span class="lineno"> 2913 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2914 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;term_tree_size&quot;      &quot;Term -&gt; Int&quot;</span>
<span class="lineno"> 2915 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal scTreeSize)</span></span>
<span class="lineno"> 2916 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2917 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return the size of the given term in the number of nodes it would&quot;</span></span>
<span class="lineno"> 2918 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;have if treated as a tree instead of a DAG.&quot;</span></span>
<span class="lineno"> 2919 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2920 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2921 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;abstract_symbolic&quot;   &quot;Term -&gt; Term&quot;</span>
<span class="lineno"> 2922 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 abstractSymbolicPrim)</span>
<span class="lineno"> 2923 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2924 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Take a term containing symbolic variables of the form returned&quot;</span></span>
<span class="lineno"> 2925 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;by 'fresh_symbolic' and return a new lambda term in which those&quot;</span></span>
<span class="lineno"> 2926 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;variables have been replaced by parameter references.&quot;</span></span>
<span class="lineno"> 2927 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2928 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2929 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;fresh_symbolic&quot;      &quot;String -&gt; Type -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 2930 </span><span class="spaces">    </span><span class="istickedoff">(pureVal freshSymbolicPrim)</span>
<span class="lineno"> 2931 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2932 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a fresh symbolic variable of the given type. The given name&quot;</span></span>
<span class="lineno"> 2933 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;is used only for pretty-printing.&quot;</span></span>
<span class="lineno"> 2934 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2935 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2936 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;term_apply&quot;          &quot;Term -&gt; [Term] -&gt; Term&quot;</span>
<span class="lineno"> 2937 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 term_apply)</span></span>
<span class="lineno"> 2938 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2939 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Build a term application node that applies the first term&quot;</span></span>
<span class="lineno"> 2940 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(which much be a term representing a function) to given list of arguments.&quot;</span></span>
<span class="lineno"> 2941 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2942 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2943 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;lambda&quot;              &quot;Term -&gt; Term -&gt; Term&quot;</span>
<span class="lineno"> 2944 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 lambda)</span>
<span class="lineno"> 2945 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2946 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Take a 'fresh_symbolic' variable and another term containing that&quot;</span></span>
<span class="lineno"> 2947 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;variable, and return a new lambda abstraction over that variable.&quot;</span></span>
<span class="lineno"> 2948 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2949 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2950 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;lambdas&quot;             &quot;[Term] -&gt; Term -&gt; Term&quot;</span>
<span class="lineno"> 2951 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 lambdas)</span>
<span class="lineno"> 2952 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2953 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Take a list of 'fresh_symbolic' variable and another term containing&quot;</span></span>
<span class="lineno"> 2954 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;those variables, and return a new lambda abstraction over the list of&quot;</span></span>
<span class="lineno"> 2955 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;variables.&quot;</span></span>
<span class="lineno"> 2956 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2957 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2958 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;generalize_term&quot;   &quot;[Term] -&gt; Term -&gt; Term&quot;</span>
<span class="lineno"> 2959 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 generalize_term)</span></span>
<span class="lineno"> 2960 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2961 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Take a list of 'fresh_symbolic' variables and another term containing those&quot;</span></span>
<span class="lineno"> 2962 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;variables, and return a new Pi generalization over the list of variables.&quot;</span></span>
<span class="lineno"> 2963 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2964 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2965 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;implies_term&quot;      &quot;Term -&gt; Term -&gt; Term&quot;</span>
<span class="lineno"> 2966 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 implies_term)</span></span>
<span class="lineno"> 2967 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2968 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given two terms, which must be Prop terms, construct the SAWCore implication&quot;</span></span>
<span class="lineno"> 2969 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of those terms.&quot;</span></span>
<span class="lineno"> 2970 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2971 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2972 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;size_to_term&quot;      &quot;Type -&gt; Term&quot;</span>
<span class="lineno"> 2973 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal1 size_to_term)</span></span>
<span class="lineno"> 2974 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2975 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Convert a Cryptol size type into a Term representation.&quot;</span></span>
<span class="lineno"> 2976 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2977 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2978 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;int_to_term&quot;      &quot;Int -&gt; Term&quot;</span>
<span class="lineno"> 2979 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal1 int_to_term)</span></span>
<span class="lineno"> 2980 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2981 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Convert a concrete integer value into an integer term.&quot; ]</span></span>
<span class="lineno"> 2982 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2983 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;nat_to_term&quot;      &quot;Int -&gt; Term&quot;</span>
<span class="lineno"> 2984 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal1 nat_to_term)</span></span>
<span class="lineno"> 2985 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2986 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Convert a non-negative integer value into a natural number term.&quot; ]</span></span>
<span class="lineno"> 2987 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2988 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;term_theories&quot; &quot;[String] -&gt; Term -&gt; [String]&quot;</span>
<span class="lineno"> 2989 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 term_theories)</span></span>
<span class="lineno"> 2990 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2991 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a term of type \'Bool\', compute the SMT theories required&quot;</span></span>
<span class="lineno"> 2992 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to reason about this term. The functions (if any) given in the&quot;</span></span>
<span class="lineno"> 2993 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;first argument will be treated as uninterpreted.&quot;</span></span>
<span class="lineno"> 2994 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2995 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;If the returned list is empty, the given term represents a problem&quot;</span></span>
<span class="lineno"> 2996 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;that can be solved purely by boolean SAT reasoning.&quot;</span></span>
<span class="lineno"> 2997 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2998 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Note: the given term will be simplified using the What4 backend&quot;</span></span>
<span class="lineno"> 2999 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;before evaluating what theories are required.  For simple problems,&quot;</span></span>
<span class="lineno"> 3000 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;this may simplify away some aspects of the problem altogether and may result&quot;</span></span>
<span class="lineno"> 3001 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in requiring fewer theories than one might expect.&quot;</span></span>
<span class="lineno"> 3002 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3003 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3004 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;default_term&quot; &quot;Term -&gt; Term&quot;</span>
<span class="lineno"> 3005 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal1 default_typed_term)</span></span>
<span class="lineno"> 3006 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3007 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Apply Cryptol defaulting rules to the given term.&quot; ]</span></span>
<span class="lineno"> 3008 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3009 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;congruence_for&quot; &quot;Term -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 3010 </span><span class="spaces">    </span><span class="istickedoff">(pureVal congruence_for)</span>
<span class="lineno"> 3011 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3012 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a term representing a (nondependent) function, attempt&quot;</span></span>
<span class="lineno"> 3013 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to automatically construct the statement of a congruence lemma&quot;</span></span>
<span class="lineno"> 3014 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;for the function.&quot;</span></span>
<span class="lineno"> 3015 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3016 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3017 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;is_convertible&quot;  &quot;Term -&gt; Term -&gt; TopLevel Bool&quot;</span>
<span class="lineno"> 3018 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal isConvertiblePrim)</span></span>
<span class="lineno"> 3019 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3020 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Returns true iff the two terms are convertible.&quot; ]</span></span>
<span class="lineno"> 3021 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3022 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;check_convertible&quot;  &quot;Term -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3023 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal checkConvertiblePrim)</span></span>
<span class="lineno"> 3024 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3025 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Check if two terms are convertible and print the result.&quot; ]</span></span>
<span class="lineno"> 3026 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3027 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;replace&quot;             &quot;Term -&gt; Term -&gt; Term -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 3028 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal replacePrim)</span></span>
<span class="lineno"> 3029 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3030 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;'replace x y z' rewrites occurences of term x into y inside the&quot;</span></span>
<span class="lineno"> 3031 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;term z.  x and y must be closed terms.&quot;</span></span>
<span class="lineno"> 3032 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3033 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3034 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;hoist_ifs&quot;            &quot;Term -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 3035 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal hoistIfsPrim)</span></span>
<span class="lineno"> 3036 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3037 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Hoist all if-then-else expressions as high as possible.&quot; ]</span></span>
<span class="lineno"> 3038 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3039 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;read_bytes&quot;          &quot;String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 3040 </span><span class="spaces">    </span><span class="istickedoff">(pureVal readBytes)</span>
<span class="lineno"> 3041 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3042 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Read binary file as a value of type [n][8].&quot; ]</span></span>
<span class="lineno"> 3043 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3044 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;load_aig&quot;            &quot;String -&gt; TopLevel AIG&quot;</span>
<span class="lineno"> 3045 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal loadAIGPrim)</span></span>
<span class="lineno"> 3046 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3047 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Read an AIG file in binary AIGER format, yielding an AIG value.&quot; ]</span></span>
<span class="lineno"> 3048 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;save_aig&quot;            &quot;String -&gt; AIG -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3049 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal saveAIGPrim)</span></span>
<span class="lineno"> 3050 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3051 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write an AIG to a file in binary AIGER format.&quot; ]</span></span>
<span class="lineno"> 3052 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;save_aig_as_cnf&quot;     &quot;String -&gt; AIG -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3053 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal saveAIGasCNFPrim)</span></span>
<span class="lineno"> 3054 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3055 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write an AIG representing a boolean function to a file in DIMACS&quot;</span></span>
<span class="lineno"> 3056 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;CNF format.&quot;</span></span>
<span class="lineno"> 3057 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3058 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3059 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;dsec_print&quot;                &quot;Term -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3060 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal dsecPrint)</span></span>
<span class="lineno"> 3061 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3062 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use ABC's 'dsec' command to compare two terms as SAIGs.&quot;</span></span>
<span class="lineno"> 3063 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The terms must have a type as described in ':help write_saig',&quot;</span></span>
<span class="lineno"> 3064 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;i.e. of the form '(i, s) -&gt; (o, s)'. Note that nothing is returned:&quot;</span></span>
<span class="lineno"> 3065 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;you must read the output to see what happened.&quot;</span></span>
<span class="lineno"> 3066 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3067 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;You must have an 'abc' executable on your PATH to use this command.&quot;</span></span>
<span class="lineno"> 3068 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3069 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3070 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;bitblast&quot;            &quot;Term -&gt; TopLevel AIG&quot;</span>
<span class="lineno"> 3071 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal bbPrim)</span></span>
<span class="lineno"> 3072 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3073 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Translate a term into an AIG.  The term must be representable as a&quot;</span></span>
<span class="lineno"> 3074 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;function from a finite number of bits to a finite number of bits.&quot;</span></span>
<span class="lineno"> 3075 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3076 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3077 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;read_aig&quot;            &quot;String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 3078 </span><span class="spaces">    </span><span class="istickedoff">(pureVal readAIGPrim)</span>
<span class="lineno"> 3079 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3080 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Read an AIG file in AIGER format and translate to a term.&quot; ]</span></span>
<span class="lineno"> 3081 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3082 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;read_core&quot;           &quot;String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 3083 </span><span class="spaces">    </span><span class="istickedoff">(pureVal readCore)</span>
<span class="lineno"> 3084 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3085 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Read a term from a file in the SAWCore external format.&quot; ]</span></span>
<span class="lineno"> 3086 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3087 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_aig&quot;           &quot;String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3088 </span><span class="spaces">    </span><span class="istickedoff">(pureVal writeAIGPrim)</span>
<span class="lineno"> 3089 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3090 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of a term in binary AIGER format. The&quot;</span></span>
<span class="lineno"> 3091 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;term must be representable as a function from a finite number of&quot;</span></span>
<span class="lineno"> 3092 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;bits to a finite number of bits.&quot;</span></span>
<span class="lineno"> 3093 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3094 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3095 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_aig_external&quot;  &quot;String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3096 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal doWriteAIGviaVerilog)</span></span>
<span class="lineno"> 3097 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3098 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of a term in binary AIGER format. The&quot;</span></span>
<span class="lineno"> 3099 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;term must be representable as a function from a finite number of&quot;</span></span>
<span class="lineno"> 3100 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;bits to a finite number of bits. Uses ABC to convert an intermediate&quot;</span></span>
<span class="lineno"> 3101 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Verilog file.&quot;</span></span>
<span class="lineno"> 3102 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3103 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3104 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_saig&quot;          &quot;String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3105 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal writeSAIGPrim)</span></span>
<span class="lineno"> 3106 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3107 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of a term in binary AIGER format. The&quot;</span></span>
<span class="lineno"> 3108 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;term must be representable as a function from a finite number of&quot;</span></span>
<span class="lineno"> 3109 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;bits to a finite number of bits. The type must be of the form&quot;</span></span>
<span class="lineno"> 3110 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'(i, s) -&gt; (o, s)' and is interpreted as an '[|i| + |s|] -&gt; [|o| + |s|]'&quot;</span></span>
<span class="lineno"> 3111 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;AIG with '|s|' latches.&quot;</span></span>
<span class="lineno"> 3112 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3113 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Arguments:&quot;</span></span>
<span class="lineno"> 3114 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  file to translation to : String&quot;</span></span>
<span class="lineno"> 3115 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  function to translate to sequential AIG : Term&quot;</span></span>
<span class="lineno"> 3116 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3117 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3118 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_saig'&quot;         &quot;String -&gt; Term -&gt; Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3119 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal writeSAIGComputedPrim)</span></span>
<span class="lineno"> 3120 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3121 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of a term in binary AIGER format. The&quot;</span></span>
<span class="lineno"> 3122 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;term must be representable as a function from a finite number of&quot;</span></span>
<span class="lineno"> 3123 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;bits to a finite number of bits, '[m] -&gt; [n]'. The int argument,&quot;</span></span>
<span class="lineno"> 3124 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'k', must be at most 'min {m, n}', and specifies that the *last* 'k'&quot;</span></span>
<span class="lineno"> 3125 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;input and output bits are joined as latches.&quot;</span></span>
<span class="lineno"> 3126 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3127 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Arguments:&quot;</span></span>
<span class="lineno"> 3128 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  file to translation to : String&quot;</span></span>
<span class="lineno"> 3129 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  function to translate to sequential AIG : Term&quot;</span></span>
<span class="lineno"> 3130 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  number of latches : Int&quot;</span></span>
<span class="lineno"> 3131 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3132 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3133 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_cnf&quot;           &quot;String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3134 </span><span class="spaces">    </span><span class="istickedoff">(pureVal do_write_cnf)</span>
<span class="lineno"> 3135 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3136 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the given term to the named file in CNF format.&quot; ]</span></span>
<span class="lineno"> 3137 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3138 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_cnf_external&quot;  &quot;String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3139 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_write_cnf_external)</span></span>
<span class="lineno"> 3140 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3141 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the given term to the named file in CNF format.&quot; ]</span></span>
<span class="lineno"> 3142 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3143 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_smtlib2&quot;       &quot;String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3144 </span><span class="spaces">    </span><span class="istickedoff">(pureVal do_write_smtlib2)</span>
<span class="lineno"> 3145 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3146 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the given term to the named file in SMT-Lib version 2 format.&quot; ]</span></span>
<span class="lineno"> 3147 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3148 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_smtlib2_w4&quot;    &quot;String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3149 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_write_smtlib2_w4)</span></span>
<span class="lineno"> 3150 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3151 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the given term to the named file in SMT-Lib version 2 format,&quot;</span></span>
<span class="lineno"> 3152 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;using the What4 backend instead of the SBV backend.&quot;</span></span>
<span class="lineno"> 3153 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3154 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3155 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_core&quot;          &quot;String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3156 </span><span class="spaces">    </span><span class="istickedoff">(pureVal do_write_core)</span>
<span class="lineno"> 3157 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3158 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of a term in SAWCore external format.&quot; ]</span></span>
<span class="lineno"> 3159 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3160 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_verilog&quot;       &quot;String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3161 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(scVal do_write_verilog)</span></span>
<span class="lineno"> 3162 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3163 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of a term in Verilog format.&quot; ]</span></span>
<span class="lineno"> 3164 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3165 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_coq_term&quot; &quot;String -&gt; [(String, String)] -&gt; [String] -&gt; String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3166 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_write_coq_term)</span></span>
<span class="lineno"> 3167 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3168 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of a term in Gallina syntax for Coq.&quot;</span></span>
<span class="lineno"> 3169 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The first argument is the name to use in a Definition.&quot;</span></span>
<span class="lineno"> 3170 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The second argument is a list of pairs of notation substitutions:&quot;</span></span>
<span class="lineno"> 3171 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the operator on the left will be replaced with the identifier on&quot;</span></span>
<span class="lineno"> 3172 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the right, as we do not support notations on the Coq side.&quot;</span></span>
<span class="lineno"> 3173 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The third argument is a list of identifiers to skip translating.&quot;</span></span>
<span class="lineno"> 3174 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The fourth argument is the name of the file to output into,&quot;</span></span>
<span class="lineno"> 3175 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;use an empty string to output to standard output.&quot;</span></span>
<span class="lineno"> 3176 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The fifth argument is the term to export.&quot;</span></span>
<span class="lineno"> 3177 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3178 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3179 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_coq_cryptol_module&quot; &quot;String -&gt; String -&gt; [(String, String)] -&gt; [String] -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3180 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_write_coq_cryptol_module)</span></span>
<span class="lineno"> 3181 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3182 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of a Cryptol module in Gallina syntax for&quot;</span></span>
<span class="lineno"> 3183 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Coq.&quot;</span></span>
<span class="lineno"> 3184 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The first argument is the file containing the module to export.&quot;</span></span>
<span class="lineno"> 3185 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The second argument is the name of the file to output into,&quot;</span></span>
<span class="lineno"> 3186 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;use an empty string to output to standard output.&quot;</span></span>
<span class="lineno"> 3187 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The third argument is a list of pairs of notation substitutions:&quot;</span></span>
<span class="lineno"> 3188 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the operator on the left will be replaced with the identifier on&quot;</span></span>
<span class="lineno"> 3189 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the right, as we do not support notations on the Coq side.&quot;</span></span>
<span class="lineno"> 3190 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The fourth argument is a list of identifiers to skip translating.&quot;</span></span>
<span class="lineno"> 3191 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3192 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3193 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_coq_sawcore_prelude&quot; &quot;String -&gt; [(String, String)] -&gt; [String] -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3194 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_write_coq_sawcore_prelude)</span></span>
<span class="lineno"> 3195 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3196 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of the SAW Core prelude in Gallina syntax for&quot;</span></span>
<span class="lineno"> 3197 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Coq.&quot;</span></span>
<span class="lineno"> 3198 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The first argument is the name of the file to output into,&quot;</span></span>
<span class="lineno"> 3199 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;use an empty string to output to standard output.&quot;</span></span>
<span class="lineno"> 3200 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The second argument is a list of pairs of notation substitutions:&quot;</span></span>
<span class="lineno"> 3201 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the operator on the left will be replaced with the identifier on&quot;</span></span>
<span class="lineno"> 3202 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the right, as we do not support notations on the Coq side.&quot;</span></span>
<span class="lineno"> 3203 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The third argument is a list of identifiers to skip translating.&quot;</span></span>
<span class="lineno"> 3204 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3205 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3206 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_coq_cryptol_primitives_for_sawcore&quot;</span>
<span class="lineno"> 3207 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; [(String, String)] -&gt; [String] -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3208 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_write_coq_cryptol_primitives_for_sawcore)</span></span>
<span class="lineno"> 3209 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3210 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of cryptol-saw-core's Cryptol.sawcore&quot;</span></span>
<span class="lineno"> 3211 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in Gallina syntax for Coq.&quot;</span></span>
<span class="lineno"> 3212 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The first argument is the name of the output file for translating&quot;</span></span>
<span class="lineno"> 3213 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Cryptol.sawcore.&quot;</span></span>
<span class="lineno"> 3214 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Use an empty string to output to standard output.&quot;</span></span>
<span class="lineno"> 3215 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The second argument is a list of pairs of notation substitutions:&quot;</span></span>
<span class="lineno"> 3216 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the operator on the left will be replaced with the identifier on&quot;</span></span>
<span class="lineno"> 3217 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the right, as we do not support notations on the Coq side.&quot;</span></span>
<span class="lineno"> 3218 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The third argument is a list of identifiers to skip translating.&quot;</span></span>
<span class="lineno"> 3219 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3220 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3221 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_coq&quot; &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3222 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_offline_coq)</span></span>
<span class="lineno"> 3223 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3224 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of the current goal in Gallina syntax&quot;</span></span>
<span class="lineno"> 3225 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(for Coq). The argument is a prefix to use for file names.&quot;</span></span>
<span class="lineno"> 3226 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3227 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3228 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;auto_match&quot; &quot;String -&gt; String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3229 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_auto_match)</span></span>
<span class="lineno"> 3230 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3231 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Interactively decides how to align two modules of potentially heterogeneous&quot;</span></span>
<span class="lineno"> 3232 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;language and prints the result.&quot;</span></span>
<span class="lineno"> 3233 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3234 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3235 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;prove&quot;               &quot;ProofScript () -&gt; Term -&gt; TopLevel ProofResult&quot;</span>
<span class="lineno"> 3236 </span><span class="spaces">    </span><span class="istickedoff">(pureVal provePrim)</span>
<span class="lineno"> 3237 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3238 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the given proof script to attempt to prove that a term is valid&quot;</span></span>
<span class="lineno"> 3239 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(true for all inputs). Returns a proof result that can be analyzed&quot;</span></span>
<span class="lineno"> 3240 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;with 'caseProofResult' to determine whether it represents a successful&quot;</span></span>
<span class="lineno"> 3241 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;proof or a counter-example.&quot;</span></span>
<span class="lineno"> 3242 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3243 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3244 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;prove_print&quot;         &quot;ProofScript () -&gt; Term -&gt; TopLevel Theorem&quot;</span>
<span class="lineno"> 3245 </span><span class="spaces">    </span><span class="istickedoff">(pureVal provePrintPrim)</span>
<span class="lineno"> 3246 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3247 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the given proof script to attempt to prove that a term is valid&quot;</span></span>
<span class="lineno"> 3248 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(true for all inputs). Returns a Theorem if successful, and aborts&quot;</span></span>
<span class="lineno"> 3249 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;if unsuccessful.&quot;</span></span>
<span class="lineno"> 3250 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3251 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3252 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;prove_by_bv_induction&quot;  &quot;ProofScript () -&gt; Term -&gt; TopLevel Theorem&quot;</span>
<span class="lineno"> 3253 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveByBVInduction)</span></span>
<span class="lineno"> 3254 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3255 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Attempt to prove a fact by induction on the less-than order on bitvectors.&quot;</span></span>
<span class="lineno"> 3256 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The given term is expected to be a function of one or more arguments&quot;</span></span>
<span class="lineno"> 3257 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;which returns a tuple containing two values: first, a bitvector expression&quot;</span></span>
<span class="lineno"> 3258 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(which will be the expression we perform induction on), and second, a boolean value&quot;</span></span>
<span class="lineno"> 3259 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;defining the theorem to prove.&quot;</span></span>
<span class="lineno"> 3260 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3261 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This command will attempt to prove the theorem expressed in the second&quot;</span></span>
<span class="lineno"> 3262 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;element of the tuple by induction. The goal presented to the user-provided&quot;</span></span>
<span class="lineno"> 3263 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;tactic will ask to prove the stated goal and will be provided with an induction&quot;</span></span>
<span class="lineno"> 3264 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;hypothesis which states that the goal holds for all values of the variables&quot;</span></span>
<span class="lineno"> 3265 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;where the expression given in the first element of the tuple has decreased.&quot;</span></span>
<span class="lineno"> 3266 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3267 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3268 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;prove_extcore&quot;         &quot;ProofScript () -&gt; Term -&gt; TopLevel Theorem&quot;</span>
<span class="lineno"> 3269 </span><span class="spaces">    </span><span class="istickedoff">(pureVal provePropPrim)</span>
<span class="lineno"> 3270 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3271 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the given proof script to attempt to prove that a term representing&quot;</span></span>
<span class="lineno"> 3272 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a proposition is valid. For example, this is useful for proving a goal&quot;</span></span>
<span class="lineno"> 3273 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;obtained with 'offline_extcore' or 'parse_core'. Returns a Theorem if&quot;</span></span>
<span class="lineno"> 3274 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;successful, and aborts if unsuccessful.&quot;</span></span>
<span class="lineno"> 3275 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3276 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3277 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;prove_bisim&quot;         &quot;ProofScript () -&gt; [BisimTheorem] -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; TopLevel BisimTheorem&quot;</span>
<span class="lineno"> 3278 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveBisimulation)</span>
<span class="lineno"> 3279 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3280 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use bisimulation to prove that two terms simulate each other.  The &quot;</span></span>
<span class="lineno"> 3281 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;command takes the following arguments: &quot;</span></span>
<span class="lineno"> 3282 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;1. The proof strategy to use&quot;</span></span>
<span class="lineno"> 3283 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;2. A list of already proven bisimulation theorems&quot;</span></span>
<span class="lineno"> 3284 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;3. A state relation `srel : lhsState -&gt; rhsState -&gt; Bit`&quot;</span></span>
<span class="lineno"> 3285 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;4. An output relation `orel : (lhsState, output) -&gt; (rhsState, output) -&gt; Bit`&quot;</span></span>
<span class="lineno"> 3286 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;5. A term `lhs : (lhsState, input) -&gt; (lhsState, output)`&quot;</span></span>
<span class="lineno"> 3287 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;6. A term `rhs : (rhsState, input) -&gt; (rhsState, output)`&quot;</span></span>
<span class="lineno"> 3288 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;and considers `lhs` and `rhs` bisimilar when the following two theorems hold:&quot;</span></span>
<span class="lineno"> 3289 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;* OUTPUT RELATION THEOREM:&quot;</span></span>
<span class="lineno"> 3290 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   forall s1 s2 in.&quot;</span></span>
<span class="lineno"> 3291 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;     srel s1 s2 -&gt; orel (lhs (s1, in)) (rhs (s2, in))&quot;</span></span>
<span class="lineno"> 3292 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;* STATE RELATION THEOREM:&quot;</span></span>
<span class="lineno"> 3293 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   forall s1 s2 out1 out2.&quot;</span></span>
<span class="lineno"> 3294 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;     orel (s1, out1) (s2, out2) -&gt; srel s1 s2&quot;</span></span>
<span class="lineno"> 3295 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3296 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;LIMITATIONS: For now, the prove_bisim command has a couple limitations:&quot;</span></span>
<span class="lineno"> 3297 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;* `lhs` and `rhs` (arguments 5 and 6) must be named functions.&quot;</span></span>
<span class="lineno"> 3298 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;* Each subterm present in the list of bisimulation theorems already&quot;</span></span>
<span class="lineno"> 3299 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  proven (argument 2) may be invoked at most once in `lhs` or `rhs`.&quot;</span></span>
<span class="lineno"> 3300 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3301 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3302 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sat&quot;                 &quot;ProofScript () -&gt; Term -&gt; TopLevel SatResult&quot;</span>
<span class="lineno"> 3303 </span><span class="spaces">    </span><span class="istickedoff">(pureVal satPrim)</span>
<span class="lineno"> 3304 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3305 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the given proof script to attempt to prove that a term is&quot;</span></span>
<span class="lineno"> 3306 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;satisfiable (is true for some input). Returns a proof result that can&quot;</span></span>
<span class="lineno"> 3307 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;be analyzed with 'caseSatResult' to determine whether it represents&quot;</span></span>
<span class="lineno"> 3308 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a satisfying assignment or an indication of unsatisfiability.&quot;</span></span>
<span class="lineno"> 3309 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3310 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3311 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sat_print&quot;           &quot;ProofScript () -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3312 </span><span class="spaces">    </span><span class="istickedoff">(pureVal satPrintPrim)</span>
<span class="lineno"> 3313 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3314 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the given proof script to attempt to prove that a term is&quot;</span></span>
<span class="lineno"> 3315 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;satisfiable (true for any input). Returns nothing if successful, and&quot;</span></span>
<span class="lineno"> 3316 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;aborts if unsuccessful.&quot;</span></span>
<span class="lineno"> 3317 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3318 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3319 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;qc_print&quot;            &quot;Int -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3320 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(scVal' quickCheckPrintPrim)</span></span>
<span class="lineno"> 3321 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3322 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Quick Check a term by applying it to a sequence of random inputs&quot;</span></span>
<span class="lineno"> 3323 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;and print the results. The 'Int' arg specifies how many tests to run.&quot;</span></span>
<span class="lineno"> 3324 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3325 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3326 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;codegen&quot;             &quot;String -&gt; [String] -&gt; String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3327 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(scVal codegenSBV)</span></span>
<span class="lineno"> 3328 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3329 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Generate straight-line C code for the given term using SBV.&quot;</span></span>
<span class="lineno"> 3330 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3331 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;First argument is directory path (\&quot;\&quot; for stdout) for generating files.&quot;</span></span>
<span class="lineno"> 3332 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Second argument is the list of function names to leave uninterpreted.&quot;</span></span>
<span class="lineno"> 3333 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Third argument is C function name.&quot;</span></span>
<span class="lineno"> 3334 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Fourth argument is the term to generate code for. It must be a&quot;</span></span>
<span class="lineno"> 3335 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;first-order function whose arguments and result are all of type&quot;</span></span>
<span class="lineno"> 3336 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Bit, [8], [16], [32], or [64].&quot;</span></span>
<span class="lineno"> 3337 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3338 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3339 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;unfolding&quot;           &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3340 </span><span class="spaces">    </span><span class="istickedoff">(pureVal unfoldGoal)</span>
<span class="lineno"> 3341 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3342 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Unfold the named subterm(s) within the current goal.&quot; ]</span></span>
<span class="lineno"> 3343 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3344 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;unfolding_fix_once&quot; &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3345 </span><span class="spaces">    </span><span class="istickedoff">(pureVal unfoldFixOnceGoal)</span>
<span class="lineno"> 3346 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3347 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Unfold the named recursive constants once within the current goal.&quot;</span></span>
<span class="lineno"> 3348 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Like `unfolding`, except that the recursive constants are unfolded&quot;</span></span>
<span class="lineno"> 3349 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;only once, avoiding possible infinite evaluation.&quot;</span></span>
<span class="lineno"> 3350 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3351 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3352 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;simplify&quot;            &quot;Simpset -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3353 </span><span class="spaces">    </span><span class="istickedoff">(pureVal simplifyGoal)</span>
<span class="lineno"> 3354 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3355 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Apply the given simplifier rule set to the current goal.&quot; ]</span></span>
<span class="lineno"> 3356 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3357 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;simplify_local&quot;       &quot;[Int] -&gt; Simpset -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3358 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal simplifyGoalWithLocals)</span></span>
<span class="lineno"> 3359 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3360 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Apply the given simplifier rule set to the current goal.&quot;</span></span>
<span class="lineno"> 3361 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Also, use the given numbered hypotheses as rewrites.&quot;</span></span>
<span class="lineno"> 3362 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3363 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3364 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;unfocus&quot;        &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3365 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal unfocus)</span></span>
<span class="lineno"> 3366 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3367 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Remove any sequent focus point.&quot; ]</span></span>
<span class="lineno"> 3368 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3369 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;focus_concl&quot;      &quot;Int -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3370 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal focus_concl)</span></span>
<span class="lineno"> 3371 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3372 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Focus on the numbered conclusion within a sequent. This will fail if there are&quot;</span></span>
<span class="lineno"> 3373 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;not enough conclusions.&quot;</span></span>
<span class="lineno"> 3374 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3375 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3376 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;focus_hyp&quot;       &quot;Int -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3377 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal focus_hyp)</span></span>
<span class="lineno"> 3378 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3379 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Focus on the numbered conclusion with a sequent.  This will fail if there are&quot;</span></span>
<span class="lineno"> 3380 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;enough hypotheses.&quot;</span></span>
<span class="lineno"> 3381 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3382 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3383 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;normalize_sequent&quot; &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3384 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal normalize_sequent)</span></span>
<span class="lineno"> 3385 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3386 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Normalize the current goal sequent by applying reversable sequent calculus rules.&quot;</span></span>
<span class="lineno"> 3387 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The resulting sequent will be unfocused.&quot;</span></span>
<span class="lineno"> 3388 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3389 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3390 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_cut&quot; &quot;Term -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3391 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_cut)</span></span>
<span class="lineno"> 3392 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3393 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a term provided by the user (which must be a boolean expression&quot;</span></span>
<span class="lineno"> 3394 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;or a Prop) the current goal is split into two subgoals. In the first subgoal,&quot;</span></span>
<span class="lineno"> 3395 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the given proposition is assumed as a new hypothesis. In the second subgoal,&quot;</span></span>
<span class="lineno"> 3396 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the given proposition is a new focused, conclusion. This implements the&quot;</span></span>
<span class="lineno"> 3397 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;usual cut rule of sequent calculus.&quot;</span></span>
<span class="lineno"> 3398 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3399 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3400 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;retain_hyps&quot; &quot;[Int] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3401 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal retain_hyps)</span></span>
<span class="lineno"> 3402 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3403 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Remove all hypotheses from the current sequent other than the ones listed.&quot; ]</span></span>
<span class="lineno"> 3404 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3405 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;delete_hyps&quot; &quot;[Int] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3406 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal delete_hyps)</span></span>
<span class="lineno"> 3407 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3408 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Remove the numbered hypotheses from the current sequent.&quot; ]</span></span>
<span class="lineno"> 3409 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3410 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;retain_concl&quot; &quot;[Int] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3411 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal retain_concl)</span></span>
<span class="lineno"> 3412 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3413 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Remove all conclusions from the current sequent other than the ones listed.&quot; ]</span></span>
<span class="lineno"> 3414 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3415 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;delete_concl&quot; &quot;[Int] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3416 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal delete_concl)</span></span>
<span class="lineno"> 3417 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3418 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Remove the numbered conclusions from the current sequent.&quot; ]</span></span>
<span class="lineno"> 3419 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3420 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;hoist_ifs_in_goal&quot;            &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3421 </span><span class="spaces">    </span><span class="istickedoff">(pureVal hoistIfsInGoalPrim)</span>
<span class="lineno"> 3422 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3423 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Hoist ifs in the current proof goal.&quot; ]</span></span>
<span class="lineno"> 3424 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3425 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;normalize_term&quot;      &quot;Term -&gt; Term&quot;</span>
<span class="lineno"> 3426 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 normalize_term)</span>
<span class="lineno"> 3427 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3428 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Normalize the given term by performing evaluation in SAWCore.&quot; ]</span></span>
<span class="lineno"> 3429 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3430 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;normalize_term_opaque&quot; &quot;[String] -&gt; Term -&gt; Term&quot;</span>
<span class="lineno"> 3431 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 normalize_term_opaque)</span></span>
<span class="lineno"> 3432 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3433 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Normalize the given term by performing evaluation in SAWCore.&quot;</span></span>
<span class="lineno"> 3434 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The named values will be treated opaquely and not unfolded during evaluation.&quot;</span></span>
<span class="lineno"> 3435 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3436 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3437 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_normalize&quot;  &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3438 </span><span class="spaces">    </span><span class="istickedoff">(pureVal goal_normalize)</span>
<span class="lineno"> 3439 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3440 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Evaluate the current proof goal by performing evaluation in SAWCore.&quot;</span></span>
<span class="lineno"> 3441 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The currently-focused term will be evaluated.  If the sequent is unfocused&quot;</span></span>
<span class="lineno"> 3442 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;all terms will be evaluated. The given names will be treated as uninterpreted.&quot;</span></span>
<span class="lineno"> 3443 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3444 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3445 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_eval&quot;           &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3446 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (goal_eval []))</span>
<span class="lineno"> 3447 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3448 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Evaluate the proof goal to a first-order combination of primitives.&quot; ]</span></span>
<span class="lineno"> 3449 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3450 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_eval_unint&quot;     &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3451 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_eval)</span></span>
<span class="lineno"> 3452 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3453 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Evaluate the proof goal to a first-order combination of primitives.&quot;</span></span>
<span class="lineno"> 3454 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Leave the given names as uninterpreted.&quot; ]</span></span>
<span class="lineno"> 3455 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3456 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;beta_reduce_goal&quot;    &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3457 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal beta_reduce_goal)</span></span>
<span class="lineno"> 3458 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3459 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Reduce the current goal to beta-normal form.&quot; ]</span></span>
<span class="lineno"> 3460 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3461 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_apply&quot;          &quot;Theorem -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3462 </span><span class="spaces">    </span><span class="istickedoff">(pureVal goal_apply)</span>
<span class="lineno"> 3463 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3464 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Apply an introduction rule to the current goal. Depending on the&quot;</span></span>
<span class="lineno"> 3465 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;rule, this will result in zero or more new subgoals.&quot;</span></span>
<span class="lineno"> 3466 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3467 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3468 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_exact&quot;          &quot;Term -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3469 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_exact)</span></span>
<span class="lineno"> 3470 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3471 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal by giving an explicit proof term.&quot;</span></span>
<span class="lineno"> 3472 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This will succeed if the type of the given term matches the current goal.&quot;</span></span>
<span class="lineno"> 3473 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3474 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3475 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_intro_hyp&quot;      &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3476 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_intro_hyp)</span></span>
<span class="lineno"> 3477 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3478 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;When focused on a conclusion that represents an implication,&quot;</span></span>
<span class="lineno"> 3479 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;simplify the conclusion by removing the implication and introducing&quot;</span></span>
<span class="lineno"> 3480 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a new sequent hypothesis instead.&quot;</span></span>
<span class="lineno"> 3481 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3482 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3483 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_intro_hyps&quot;     &quot;Int -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3484 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_intro_hyps)</span></span>
<span class="lineno"> 3485 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3486 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;When focused on a conclusion that represents an implication,&quot;</span></span>
<span class="lineno"> 3487 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;simplify the conclusion by removing the implication and introducing&quot;</span></span>
<span class="lineno"> 3488 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a new sequent hypothesis instead. The given number indicates how many&quot;</span></span>
<span class="lineno"> 3489 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;hypotheses to introduce.&quot;</span></span>
<span class="lineno"> 3490 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3491 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3492 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_revert_hyp&quot;     &quot;Int -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3493 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_revert_hyp)</span></span>
<span class="lineno"> 3494 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3495 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;When focused on a conclusion, weaken the focused conclusion&quot;</span></span>
<span class="lineno"> 3496 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;by introducing an implication using the numbered sequent hypothesis.&quot;</span></span>
<span class="lineno"> 3497 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This is essentially the reverse of 'goal_intro_hyps'.&quot;</span></span>
<span class="lineno"> 3498 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3499 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3500 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_insert&quot;         &quot;Theorem -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3501 </span><span class="spaces">    </span><span class="istickedoff">(pureVal goal_insert)</span>
<span class="lineno"> 3502 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3503 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Insert a Theorem as a new hypothesis in the current proof goal.&quot;</span></span>
<span class="lineno"> 3504 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3505 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3506 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_insert_and_specialize&quot;  &quot;Theorem -&gt; [Term] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3507 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_insert_and_specialize)</span></span>
<span class="lineno"> 3508 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3509 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Insert a Theorem as a new hypothesis in the current proof goal, after&quot;</span></span>
<span class="lineno"> 3510 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specializing some of its universal quantifiers using the given terms.&quot;</span></span>
<span class="lineno"> 3511 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3512 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3513 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_apply_hyp&quot;      &quot;Int -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3514 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_apply_hyp)</span></span>
<span class="lineno"> 3515 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3516 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Apply the numbered local hypothesis to the focused conclusion.&quot; ]</span></span>
<span class="lineno"> 3517 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3518 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_specialize_hyp&quot; &quot;[Term] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3519 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_specialize_hyp)</span></span>
<span class="lineno"> 3520 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3521 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specialize the focused local hypothesis by supplying the values&quot;</span></span>
<span class="lineno"> 3522 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;for universal quantifiers. A new specialized hypothesis will be&quot;</span></span>
<span class="lineno"> 3523 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;added to the sequent.&quot;</span></span>
<span class="lineno"> 3524 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3525 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3526 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_intro&quot;          &quot;String -&gt; ProofScript Term&quot;</span>
<span class="lineno"> 3527 </span><span class="spaces">    </span><span class="istickedoff">(pureVal goal_intro)</span>
<span class="lineno"> 3528 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3529 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Introduce a quantified variable in the current proof goal, returning&quot;</span></span>
<span class="lineno"> 3530 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the variable as a Term.&quot;</span></span>
<span class="lineno"> 3531 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3532 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_when&quot;           &quot;String -&gt; ProofScript () -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3533 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_when)</span></span>
<span class="lineno"> 3534 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3535 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Run the given proof script only when the goal name contains&quot;</span></span>
<span class="lineno"> 3536 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the given string.&quot;</span></span>
<span class="lineno"> 3537 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3538 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_has_tags&quot;      &quot;[String] -&gt; ProofScript Bool&quot;</span>
<span class="lineno"> 3539 </span><span class="spaces">    </span><span class="istickedoff">(pureVal goal_has_tags)</span>
<span class="lineno"> 3540 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3541 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Returns true if the current goal is tagged with all the tags&quot;</span></span>
<span class="lineno"> 3542 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the given list. This function returns true for all goals&quot;</span></span>
<span class="lineno"> 3543 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;when given an empty list. Tags may be added to goals using&quot;</span></span>
<span class="lineno"> 3544 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'llvm_setup_with_tag' and similar operations in the specification&quot;</span></span>
<span class="lineno"> 3545 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;setup phase.&quot;</span></span>
<span class="lineno"> 3546 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3547 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_has_some_tag&quot;  &quot;[String] -&gt; ProofScript Bool&quot;</span>
<span class="lineno"> 3548 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_has_some_tag)</span></span>
<span class="lineno"> 3549 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3550 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Returns true if the current goal is tagged with any the tags&quot;</span></span>
<span class="lineno"> 3551 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the given list. This function returns false for all goals&quot;</span></span>
<span class="lineno"> 3552 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;when given an empty list. Tags may be added to goals using&quot;</span></span>
<span class="lineno"> 3553 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'llvm_setup_with_tag' and similar operations in the specification&quot;</span></span>
<span class="lineno"> 3554 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;setup phase.&quot;</span></span>
<span class="lineno"> 3555 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3556 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_num_ite&quot;       &quot;{a} Int -&gt; ProofScript a -&gt; ProofScript a -&gt; ProofScript a&quot;</span>
<span class="lineno"> 3557 </span><span class="spaces">    </span><span class="istickedoff">(pureVal goal_num_ite)</span>
<span class="lineno"> 3558 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3559 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;If the goal number is the given number, runs the first script.&quot;</span></span>
<span class="lineno"> 3560 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Otherwise runs the second script&quot; ]</span></span>
<span class="lineno"> 3561 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_num_when&quot;       &quot;Int -&gt; ProofScript () -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3562 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_num_when)</span></span>
<span class="lineno"> 3563 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3564 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Run the given proof script only when the goal number is the&quot;</span></span>
<span class="lineno"> 3565 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the given number.&quot;</span></span>
<span class="lineno"> 3566 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3567 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_goal&quot;          &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3568 </span><span class="spaces">    </span><span class="istickedoff">(pureVal print_goal)</span>
<span class="lineno"> 3569 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3570 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the current goal that a proof script is attempting to prove.&quot; ]</span></span>
<span class="lineno"> 3571 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_goal_inline&quot;   &quot;[Int] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3572 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal print_goal_inline)</span></span>
<span class="lineno"> 3573 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3574 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the current goal that a proof script is attempting to prove,&quot;</span></span>
<span class="lineno"> 3575 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;without generating `let` bindings for the provided indices. For&quot;</span></span>
<span class="lineno"> 3576 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;example, `print_goal_inline [1,9,3]` will print the goal without&quot;</span></span>
<span class="lineno"> 3577 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;inlining the variables that would otherwise be abstracted as `x@1`,&quot;</span></span>
<span class="lineno"> 3578 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; `x@9`, and `x@3`. These indices are assigned deterministically with&quot;</span></span>
<span class="lineno"> 3579 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;regard to a particular goal, but are not persistent across goals. As&quot;</span></span>
<span class="lineno"> 3580 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;such, this should be used primarily when debugging a proof.&quot;</span></span>
<span class="lineno"> 3581 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3582 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Note: incompatible with non-incremental memoization strategies - see&quot;</span></span>
<span class="lineno"> 3583 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;`set_memoization_incremental` and `set_memoization_hash_incremental`.&quot;</span></span>
<span class="lineno"> 3584 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3585 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_goal&quot; &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3586 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_write_goal)</span></span>
<span class="lineno"> 3587 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3588 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal that a proof script is attempting to prove&quot;</span></span>
<span class="lineno"> 3589 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;into the named file.&quot;</span></span>
<span class="lineno"> 3590 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3591 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_goal_summary&quot; &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3592 </span><span class="spaces">    </span><span class="istickedoff">(pureVal print_goal_summary)</span>
<span class="lineno"> 3593 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3594 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the number and description of the goal that a proof script&quot;</span></span>
<span class="lineno"> 3595 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;is attempting to prove.&quot;</span></span>
<span class="lineno"> 3596 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3597 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_focus&quot; &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3598 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal print_focus)</span></span>
<span class="lineno"> 3599 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3600 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print just the focused part of the current goal.&quot;</span></span>
<span class="lineno"> 3601 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Prints a message without failing if there is no current focus.&quot;</span></span>
<span class="lineno"> 3602 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3603 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3604 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_num&quot; &quot;ProofScript Int&quot;</span>
<span class="lineno"> 3605 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_num)</span></span>
<span class="lineno"> 3606 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3607 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Returns the number of the current proof goal.&quot;</span></span>
<span class="lineno"> 3608 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3609 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_goal_depth&quot;    &quot;Int -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3610 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal print_goal_depth)</span></span>
<span class="lineno"> 3611 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3612 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the current goal that a proof script is attempting to prove,&quot;</span></span>
<span class="lineno"> 3613 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;limited to a maximum depth.&quot;</span></span>
<span class="lineno"> 3614 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3615 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_goal_consts&quot;   &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3616 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal printGoalConsts)</span></span>
<span class="lineno"> 3617 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3618 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the list of unfoldable constants in the current proof goal.&quot;</span></span>
<span class="lineno"> 3619 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3620 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_goal_size&quot;     &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3621 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal printGoalSize)</span></span>
<span class="lineno"> 3622 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3623 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the size of the goal in terms of both the number of DAG nodes&quot;</span></span>
<span class="lineno"> 3624 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;and the number of nodes it would have if represented as a tree.&quot;</span></span>
<span class="lineno"> 3625 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3626 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3627 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;assume_valid&quot;        &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3628 </span><span class="spaces">    </span><span class="istickedoff">(pureVal assumeValid)</span>
<span class="lineno"> 3629 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3630 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Assume the current goal is valid, completing the proof.&quot;</span></span>
<span class="lineno"> 3631 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Prefer to use 'admit', this command will eventually be removed.&quot;</span></span>
<span class="lineno"> 3632 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3633 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3634 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;assume_unsat&quot;        &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3635 </span><span class="spaces">    </span><span class="istickedoff">(pureVal assumeUnsat)</span>
<span class="lineno"> 3636 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3637 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Assume the current goal is unsatisfiable, completing the proof.&quot;</span></span>
<span class="lineno"> 3638 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Prefer to use 'admit', this command will eventually be removed.&quot;</span></span>
<span class="lineno"> 3639 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3640 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3641 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;admit&quot;               &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3642 </span><span class="spaces">    </span><span class="istickedoff">(pureVal admitProof)</span>
<span class="lineno"> 3643 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3644 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Admit the current goal, completing the proof by assumption.&quot;</span></span>
<span class="lineno"> 3645 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The string argument provides a description of why the user&quot;</span></span>
<span class="lineno"> 3646 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;had decided to admit this goal.&quot;</span></span>
<span class="lineno"> 3647 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3648 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3649 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;quickcheck&quot;          &quot;Int -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3650 </span><span class="spaces">    </span><span class="istickedoff">(scVal quickcheckGoal)</span>
<span class="lineno"> 3651 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3652 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Quick Check the current goal by applying it to a sequence of random&quot;</span></span>
<span class="lineno"> 3653 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;inputs. Fail the proof script if the goal returns 'False' for any&quot;</span></span>
<span class="lineno"> 3654 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of these inputs.&quot;</span></span>
<span class="lineno"> 3655 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3656 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3657 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;abc&quot;                 &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3658 </span><span class="spaces">    </span><span class="istickedoff">(pureVal w4_abc_aiger)</span>
<span class="lineno"> 3659 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3660 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the ABC theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 3661 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3662 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_abc&quot;             &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3663 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveABC_SBV)</span></span>
<span class="lineno"> 3664 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3665 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the ABC theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 3666 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3667 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;bitwuzla&quot;            &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3668 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveBitwuzla)</span>
<span class="lineno"> 3669 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3670 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Bitwuzla theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 3671 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3672 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;boolector&quot;           &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3673 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveBoolector)</span></span>
<span class="lineno"> 3674 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3675 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Boolector theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 3676 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3677 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;cvc4&quot;                &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3678 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveCVC4)</span>
<span class="lineno"> 3679 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3680 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the CVC4 theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 3681 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3682 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;cvc5&quot;                &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3683 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveCVC5)</span></span>
<span class="lineno"> 3684 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3685 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the CVC5 theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 3686 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3687 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;z3&quot;                  &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3688 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveZ3)</span>
<span class="lineno"> 3689 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3690 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Z3 theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 3691 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3692 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mathsat&quot;             &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3693 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveMathSAT)</span></span>
<span class="lineno"> 3694 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3695 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the MathSAT theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 3696 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3697 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;yices&quot;               &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3698 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveYices)</span>
<span class="lineno"> 3699 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3700 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Yices theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 3701 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3702 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;unint_bitwuzla&quot; &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3703 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveUnintBitwuzla)</span></span>
<span class="lineno"> 3704 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3705 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Bitwuzla theorem prover to prove the current goal. Leave the&quot;</span></span>
<span class="lineno"> 3706 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 3707 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3708 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3709 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;unint_z3&quot;            &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3710 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveUnintZ3)</span>
<span class="lineno"> 3711 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3712 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Z3 theorem prover to prove the current goal. Leave the&quot;</span></span>
<span class="lineno"> 3713 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 3714 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3715 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3716 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;unint_cvc4&quot;            &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3717 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveUnintCVC4)</span></span>
<span class="lineno"> 3718 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3719 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the CVC4 theorem prover to prove the current goal. Leave the&quot;</span></span>
<span class="lineno"> 3720 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 3721 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3722 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3723 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;unint_cvc5&quot;            &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3724 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveUnintCVC5)</span></span>
<span class="lineno"> 3725 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3726 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the CVC5 theorem prover to prove the current goal. Leave the&quot;</span></span>
<span class="lineno"> 3727 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 3728 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3729 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3730 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;unint_yices&quot;           &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3731 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveUnintYices)</span>
<span class="lineno"> 3732 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3733 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Yices theorem prover to prove the current goal. Leave the&quot;</span></span>
<span class="lineno"> 3734 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 3735 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3736 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3737 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_bitwuzla&quot;        &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3738 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveBitwuzla)</span>
<span class="lineno"> 3739 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3740 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Bitwuzla theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 3741 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3742 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_boolector&quot;       &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3743 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveBoolector)</span></span>
<span class="lineno"> 3744 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3745 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Boolector theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 3746 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3747 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_cvc4&quot;            &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3748 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveCVC4)</span></span>
<span class="lineno"> 3749 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3750 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the CVC4 theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 3751 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3752 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_cvc5&quot;            &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3753 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveCVC5)</span></span>
<span class="lineno"> 3754 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3755 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the CVC5 theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 3756 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3757 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_z3&quot;              &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3758 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveZ3)</span>
<span class="lineno"> 3759 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3760 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Z3 theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 3761 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3762 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_mathsat&quot;         &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3763 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveMathSAT)</span></span>
<span class="lineno"> 3764 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3765 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the MathSAT theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 3766 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3767 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_yices&quot;           &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3768 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveYices)</span></span>
<span class="lineno"> 3769 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3770 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Yices theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 3771 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3772 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_unint_bitwuzla&quot; &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3773 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveUnintBitwuzla)</span></span>
<span class="lineno"> 3774 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3775 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Bitwuzla theorem prover to prove the current goal. Leave the&quot;</span></span>
<span class="lineno"> 3776 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 3777 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3778 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3779 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_unint_z3&quot;        &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3780 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveUnintZ3)</span>
<span class="lineno"> 3781 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3782 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Z3 theorem prover to prove the current goal. Leave the&quot;</span></span>
<span class="lineno"> 3783 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 3784 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3785 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3786 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_unint_cvc4&quot;        &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3787 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveUnintCVC4)</span></span>
<span class="lineno"> 3788 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3789 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the CVC4 theorem prover to prove the current goal. Leave the&quot;</span></span>
<span class="lineno"> 3790 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 3791 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3792 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3793 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_unint_cvc5&quot;        &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3794 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveUnintCVC5)</span></span>
<span class="lineno"> 3795 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3796 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the CVC5 theorem prover to prove the current goal. Leave the&quot;</span></span>
<span class="lineno"> 3797 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 3798 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3799 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3800 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_unint_yices&quot;       &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3801 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveUnintYices)</span></span>
<span class="lineno"> 3802 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3803 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Yices theorem prover to prove the current goal. Leave the&quot;</span></span>
<span class="lineno"> 3804 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 3805 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3806 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3807 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_aig&quot;         &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3808 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_offline_aig)</span></span>
<span class="lineno"> 3809 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3810 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file in AIGER format.&quot; ]</span></span>
<span class="lineno"> 3811 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3812 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_aig_external&quot; &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3813 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_offline_aig_external)</span></span>
<span class="lineno"> 3814 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3815 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file in AIGER format.&quot;</span></span>
<span class="lineno"> 3816 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Uses ABC and an intermediate Verilog file.&quot;</span></span>
<span class="lineno"> 3817 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3818 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3819 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_cnf&quot;         &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3820 </span><span class="spaces">    </span><span class="istickedoff">(pureVal do_offline_cnf)</span>
<span class="lineno"> 3821 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3822 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file in CNF format.&quot; ]</span></span>
<span class="lineno"> 3823 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3824 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_cnf_external&quot; &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3825 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_offline_cnf_external)</span></span>
<span class="lineno"> 3826 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3827 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file in CNF format.&quot;</span></span>
<span class="lineno"> 3828 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Uses ABC and an intermediate Verilog file.&quot;</span></span>
<span class="lineno"> 3829 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3830 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3831 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_extcore&quot;     &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3832 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_offline_extcore)</span></span>
<span class="lineno"> 3833 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3834 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file in SAWCore format.&quot; ]</span></span>
<span class="lineno"> 3835 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3836 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_smtlib2&quot;     &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3837 </span><span class="spaces">    </span><span class="istickedoff">(pureVal do_offline_smtlib2)</span>
<span class="lineno"> 3838 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3839 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file in SMT-Lib2 format.&quot; ]</span></span>
<span class="lineno"> 3840 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3841 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_offline_smtlib2&quot;  &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3842 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_w4_offline_smtlib2)</span></span>
<span class="lineno"> 3843 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3844 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file in SMT-Lib2 format.&quot; ]</span></span>
<span class="lineno"> 3845 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3846 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_unint_smtlib2&quot;  &quot;[String] -&gt; String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3847 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_offline_unint_smtlib2)</span></span>
<span class="lineno"> 3848 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3849 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file in SMT-Lib2 format,&quot;</span></span>
<span class="lineno"> 3850 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;leaving the listed functions uninterpreted.&quot;</span></span>
<span class="lineno"> 3851 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3852 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3853 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_verilog&quot;        &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3854 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_offline_verilog)</span></span>
<span class="lineno"> 3855 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3856 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file in Verilog format.&quot; ]</span></span>
<span class="lineno"> 3857 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3858 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;external_cnf_solver&quot; &quot;String -&gt; [String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3859 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (satExternal True))</span></span>
<span class="lineno"> 3860 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3861 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use an external SAT solver supporting CNF to prove the current goal.&quot;</span></span>
<span class="lineno"> 3862 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The first argument is the executable name of the solver, and the&quot;</span></span>
<span class="lineno"> 3863 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;second is the list of arguments to pass to the solver. The string '%f'&quot;</span></span>
<span class="lineno"> 3864 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;anywhere in the argument list will be replaced with the name of the&quot;</span></span>
<span class="lineno"> 3865 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;temporary file holding the CNF version of the formula.&quot;]</span></span>
<span class="lineno"> 3866 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3867 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;external_aig_solver&quot; &quot;String -&gt; [String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3868 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (satExternal False))</span></span>
<span class="lineno"> 3869 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3870 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use an external SAT solver supporting AIG to prove the current goal.&quot;</span></span>
<span class="lineno"> 3871 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The first argument is the executable name of the solver, and the&quot;</span></span>
<span class="lineno"> 3872 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;second is the list of arguments to pass to the solver. The string '%f'&quot;</span></span>
<span class="lineno"> 3873 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;anywhere in the argument list will be replaced with the name of the&quot;</span></span>
<span class="lineno"> 3874 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;temporary file holding the AIG version of the formula.&quot;]</span></span>
<span class="lineno"> 3875 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3876 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;rme&quot;                 &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3877 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveRME)</span>
<span class="lineno"> 3878 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3879 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal by expansion to Reed-Muller Normal Form.&quot; ]</span></span>
<span class="lineno"> 3880 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3881 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;trivial&quot;             &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3882 </span><span class="spaces">    </span><span class="istickedoff">(pureVal trivial)</span>
<span class="lineno"> 3883 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3884 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Succeeds if the goal is trivial. This tactic recognizes goals&quot;</span></span>
<span class="lineno"> 3885 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;that are instances of reflexivity, possibly with quantified variables.&quot;</span></span>
<span class="lineno"> 3886 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In particular, it will prove goals of the form 'EqTrue x' when 'x' reduces&quot;</span></span>
<span class="lineno"> 3887 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to the constant value 'True'.&quot;</span></span>
<span class="lineno"> 3888 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3889 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3890 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4&quot;                  &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3891 </span><span class="spaces">    </span><span class="istickedoff">(pureVal w4_z3)</span>
<span class="lineno"> 3892 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3893 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal using What4 (Z3 backend).&quot; ]</span></span>
<span class="lineno"> 3894 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3895 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_unint_bitwuzla&quot; &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3896 </span><span class="spaces">    </span><span class="istickedoff">(pureVal w4_unint_bitwuzla)</span>
<span class="lineno"> 3897 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3898 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal using What4 (Bitwuzla backend). Leave the&quot;</span></span>
<span class="lineno"> 3899 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 3900 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3901 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3902 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_unint_rme&quot; &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3903 </span><span class="spaces">    </span><span class="istickedoff">(pureVal w4_unint_rme)</span>
<span class="lineno"> 3904 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3905 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal using What4 (RME backend). Leave the&quot;</span></span>
<span class="lineno"> 3906 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 3907 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3908 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3909 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_unint_z3&quot;         &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3910 </span><span class="spaces">    </span><span class="istickedoff">(pureVal w4_unint_z3)</span>
<span class="lineno"> 3911 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3912 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal using What4 (Z3 backend). Leave the&quot;</span></span>
<span class="lineno"> 3913 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 3914 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3915 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3916 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_unint_z3_using&quot; &quot;String -&gt; [String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3917 </span><span class="spaces">    </span><span class="istickedoff">(pureVal w4_unint_z3_using)</span>
<span class="lineno"> 3918 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3919 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal using What4 (Z3 backend) using the given&quot;</span></span>
<span class="lineno"> 3920 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Z3 tactic. Leave the given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 3921 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3922 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3923 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_unint_yices&quot;         &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3924 </span><span class="spaces">    </span><span class="istickedoff">(pureVal w4_unint_yices)</span>
<span class="lineno"> 3925 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3926 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal using What4 (Yices backend). Leave the&quot;</span></span>
<span class="lineno"> 3927 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 3928 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3929 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3930 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_unint_cvc4&quot;         &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3931 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal w4_unint_cvc4)</span></span>
<span class="lineno"> 3932 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3933 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal using What4 (CVC4 backend). Leave the&quot;</span></span>
<span class="lineno"> 3934 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 3935 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3936 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3937 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_unint_cvc5&quot;         &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3938 </span><span class="spaces">    </span><span class="istickedoff">(pureVal w4_unint_cvc5)</span>
<span class="lineno"> 3939 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3940 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal using What4 (CVC5 backend). Leave the&quot;</span></span>
<span class="lineno"> 3941 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 3942 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3943 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3944 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_abc_aiger&quot;        &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3945 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal w4_abc_aiger)</span></span>
<span class="lineno"> 3946 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3947 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the ABC theorem prover as an external process to prove the&quot;</span></span>
<span class="lineno"> 3948 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;current goal, with AIGER as an interchange format, generated&quot;</span></span>
<span class="lineno"> 3949 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;using the What4 backend.&quot;</span></span>
<span class="lineno"> 3950 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3951 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3952 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_abc_smtlib2&quot;        &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3953 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal w4_abc_smtlib2)</span></span>
<span class="lineno"> 3954 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3955 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the ABC theorem prover as an external process to prove the&quot;</span></span>
<span class="lineno"> 3956 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;current goal, with SMT-Lib2 as an interchange format, generated&quot;</span></span>
<span class="lineno"> 3957 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;using the What4 backend.&quot;</span></span>
<span class="lineno"> 3958 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3959 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3960 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_abc_verilog&quot;        &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3961 </span><span class="spaces">    </span><span class="istickedoff">(pureVal w4_abc_verilog)</span>
<span class="lineno"> 3962 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3963 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the ABC theorem prover as an external process to prove the&quot;</span></span>
<span class="lineno"> 3964 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;current goal, with Verilog as an interchange format, generated&quot;</span></span>
<span class="lineno"> 3965 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;using the What4 backend.&quot;</span></span>
<span class="lineno"> 3966 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3967 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3968 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_w4_unint_bitwuzla&quot; &quot;[String] -&gt; String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3969 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_offline_w4_unint_bitwuzla)</span></span>
<span class="lineno"> 3970 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3971 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file using What4 (Bitwuzla backend)&quot;</span></span>
<span class="lineno"> 3972 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; in SMT-Lib2 format. Leave the given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 3973 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3974 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3975 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_w4_unint_z3&quot;    &quot;[String] -&gt; String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3976 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_offline_w4_unint_z3)</span></span>
<span class="lineno"> 3977 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3978 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file using What4 (Z3 backend) in&quot;</span></span>
<span class="lineno"> 3979 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">,&quot; SMT-Lib2 format. Leave the given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 3980 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3981 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3982 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_w4_unint_yices&quot; &quot;[String] -&gt; String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3983 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_offline_w4_unint_yices)</span></span>
<span class="lineno"> 3984 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3985 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file using What4 (Yices backend) in&quot;</span></span>
<span class="lineno"> 3986 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">,&quot; SMT-Lib2 format. Leave the given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 3987 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3988 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3989 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_w4_unint_cvc4&quot;  &quot;[String] -&gt; String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3990 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_offline_w4_unint_cvc4)</span></span>
<span class="lineno"> 3991 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3992 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file using What4 (CVC4 backend) in&quot;</span></span>
<span class="lineno"> 3993 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">,&quot; SMT-Lib2 format. Leave the given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 3994 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3995 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3996 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_w4_unint_cvc5&quot;  &quot;[String] -&gt; String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3997 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_offline_w4_unint_cvc5)</span></span>
<span class="lineno"> 3998 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3999 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file using What4 (CVC5 backend) in&quot;</span></span>
<span class="lineno"> 4000 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">,&quot; SMT-Lib2 format. Leave the given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 4001 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4002 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4003 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;split_goal&quot;          &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4004 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal split_goal)</span></span>
<span class="lineno"> 4005 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4006 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Split a goal of the form 'Prelude.and prop1 prop2' into two separate&quot;</span></span>
<span class="lineno"> 4007 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">,  &quot;goals 'prop1' and 'prop2'.&quot; ]</span></span>
<span class="lineno"> 4008 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4009 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;empty_ss&quot;            &quot;Simpset&quot;</span>
<span class="lineno"> 4010 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (emptySimpset :: SAWSimpset))</span>
<span class="lineno"> 4011 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4012 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The empty simplification rule set, containing no rules.&quot; ]</span></span>
<span class="lineno"> 4013 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4014 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;cryptol_ss&quot;          &quot;() -&gt; Simpset&quot;</span>
<span class="lineno"> 4015 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 (\() -&gt; cryptolSimpset))</span>
<span class="lineno"> 4016 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4017 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A set of simplification rules that will expand definitions from the&quot;</span></span>
<span class="lineno"> 4018 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Cryptol module.&quot;</span></span>
<span class="lineno"> 4019 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4020 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4021 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;add_prelude_eqs&quot;     &quot;[String] -&gt; Simpset -&gt; Simpset&quot;</span>
<span class="lineno"> 4022 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 addPreludeEqs)</span>
<span class="lineno"> 4023 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4024 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add the named equality rules from the Prelude module to the given&quot;</span></span>
<span class="lineno"> 4025 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;simplification rule set.&quot;</span></span>
<span class="lineno"> 4026 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4027 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4028 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;add_cryptol_eqs&quot;     &quot;[String] -&gt; Simpset -&gt; Simpset&quot;</span>
<span class="lineno"> 4029 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 addCryptolEqs)</span></span>
<span class="lineno"> 4030 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4031 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add the named equality rules from the Cryptol module to the given&quot;</span></span>
<span class="lineno"> 4032 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;simplification rule set.&quot;</span></span>
<span class="lineno"> 4033 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4034 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4035 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;add_prelude_defs&quot;    &quot;[String] -&gt; Simpset -&gt; Simpset&quot;</span>
<span class="lineno"> 4036 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 add_prelude_defs)</span></span>
<span class="lineno"> 4037 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4038 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add the named definitions from the Prelude module to the given&quot;</span></span>
<span class="lineno"> 4039 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;simplification rule set.&quot;</span></span>
<span class="lineno"> 4040 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4041 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4042 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;add_cryptol_defs&quot;    &quot;[String] -&gt; Simpset -&gt; Simpset&quot;</span>
<span class="lineno"> 4043 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 add_cryptol_defs)</span>
<span class="lineno"> 4044 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4045 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add the named definitions from the Cryptol module to the given&quot;</span></span>
<span class="lineno"> 4046 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;simplification rule set.&quot;</span></span>
<span class="lineno"> 4047 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4048 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4049 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;basic_ss&quot;            &quot;Simpset&quot;</span>
<span class="lineno"> 4050 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal $ \bic _ -&gt; toValue &quot;basic_ss&quot; $ biBasicSS bic)</span></span>
<span class="lineno"> 4051 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 4052 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A basic rewriting simplification set containing some boolean identities&quot;</span></span>
<span class="lineno"> 4053 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;and conversions relating to bitvectors, natural numbers, and vectors.&quot;</span></span>
<span class="lineno"> 4054 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4055 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4056 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;addsimp&quot;             &quot;Theorem -&gt; Simpset -&gt; Simpset&quot;</span>
<span class="lineno"> 4057 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 addsimp)</span>
<span class="lineno"> 4058 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4059 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add a proved equality theorem to a given simplification rule set.&quot; ]</span></span>
<span class="lineno"> 4060 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4061 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;addsimp_shallow&quot;    &quot;Theorem -&gt; Simpset -&gt; Simpset&quot;</span>
<span class="lineno"> 4062 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 addsimp_shallow)</span></span>
<span class="lineno"> 4063 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4064 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add a proved equality theorem to a given simplification rule set.&quot;</span></span>
<span class="lineno"> 4065 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The rule is treated as a 'shallow' rewrite, which means that further&quot;</span></span>
<span class="lineno"> 4066 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;rewrite rules will not be applied to the result if this rule fires.&quot;</span></span>
<span class="lineno"> 4067 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4068 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4069 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;addsimps&quot;            &quot;[Theorem] -&gt; Simpset -&gt; Simpset&quot;</span>
<span class="lineno"> 4070 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 addsimps)</span>
<span class="lineno"> 4071 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4072 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add proved equality theorems to a given simplification rule set.&quot; ]</span></span>
<span class="lineno"> 4073 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4074 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;addsimp'&quot;            &quot;Term -&gt; Simpset -&gt; Simpset&quot;</span>
<span class="lineno"> 4075 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 addsimp')</span></span>
<span class="lineno"> 4076 </span><span class="spaces">    </span><span class="istickedoff">HideDeprecated</span>
<span class="lineno"> 4077 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add an arbitrary equality term to a given simplification rule set.&quot;</span></span>
<span class="lineno"> 4078 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Use `admit` or `core_axiom` and `addsimp` instead.&quot;</span></span>
<span class="lineno"> 4079 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4080 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Expected to be removed in SAW 1.5.&quot;</span></span>
<span class="lineno"> 4081 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4082 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4083 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;addsimps'&quot;           &quot;[Term] -&gt; Simpset -&gt; Simpset&quot;</span>
<span class="lineno"> 4084 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 addsimps')</span></span>
<span class="lineno"> 4085 </span><span class="spaces">    </span><span class="istickedoff">HideDeprecated</span>
<span class="lineno"> 4086 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add arbitrary equality terms to a given simplification rule set.&quot;</span></span>
<span class="lineno"> 4087 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Use `admit` or `core_axiom` and `addsimps` instead.&quot;</span></span>
<span class="lineno"> 4088 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4089 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Expected to be removed in SAW 1.5.&quot;</span></span>
<span class="lineno"> 4090 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4091 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4092 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;rewrite&quot;             &quot;Simpset -&gt; Term -&gt; Term&quot;</span>
<span class="lineno"> 4093 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 rewritePrim)</span>
<span class="lineno"> 4094 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4095 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Rewrite a term using a specific simplification rule set, returning&quot;</span></span>
<span class="lineno"> 4096 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the rewritten term.&quot;</span></span>
<span class="lineno"> 4097 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4098 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4099 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;unfold_term&quot;         &quot;[String] -&gt; Term -&gt; Term&quot;</span>
<span class="lineno"> 4100 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 unfold_term)</span>
<span class="lineno"> 4101 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4102 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Unfold the definitions of the specified constants in the given term.&quot; ]</span></span>
<span class="lineno"> 4103 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4104 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;beta_reduce_term&quot;    &quot;Term -&gt; Term&quot;</span>
<span class="lineno"> 4105 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal1 beta_reduce_term)</span></span>
<span class="lineno"> 4106 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4107 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Reduce the given term to beta-normal form.&quot; ]</span></span>
<span class="lineno"> 4108 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4109 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;term_eval&quot;           &quot;Term -&gt; Term&quot;</span>
<span class="lineno"> 4110 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal1 (term_eval []))</span></span>
<span class="lineno"> 4111 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4112 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Evaluate the term to a first-order combination of primitives.&quot; ]</span></span>
<span class="lineno"> 4113 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4114 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;term_eval_unint&quot;     &quot;[String] -&gt; Term -&gt; Term&quot;</span>
<span class="lineno"> 4115 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 term_eval)</span></span>
<span class="lineno"> 4116 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4117 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Evaluate the term to a first-order combination of primitives.&quot;</span></span>
<span class="lineno"> 4118 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Leave the given names, as defined with 'define', as uninterpreted.&quot; ]</span></span>
<span class="lineno"> 4119 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4120 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;cryptol_load&quot;        &quot;String -&gt; TopLevel CryptolModule&quot;</span>
<span class="lineno"> 4121 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (do_cryptol_load BS.readFile))</span>
<span class="lineno"> 4122 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4123 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Load the given file as a Cryptol module.&quot; ]</span></span>
<span class="lineno"> 4124 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4125 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;cryptol_extract&quot;     &quot;CryptolModule -&gt; String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 4126 </span><span class="spaces">    </span><span class="istickedoff">(pureVal cryptol_extract)</span>
<span class="lineno"> 4127 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4128 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Load a single definition from a Cryptol module and translate it into&quot;</span></span>
<span class="lineno"> 4129 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a 'Term'.&quot;</span></span>
<span class="lineno"> 4130 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4131 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4132 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;cryptol_prims&quot;       &quot;() -&gt; CryptolModule&quot;</span>
<span class="lineno"> 4133 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 (\() -&gt; cryptol_prims))</span>
<span class="lineno"> 4134 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4135 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return a Cryptol module containing extra primitive operations,&quot;</span></span>
<span class="lineno"> 4136 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;including array updates, truncate/extend, and signed comparisons.&quot;</span></span>
<span class="lineno"> 4137 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4138 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4139 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;cryptol_add_path&quot;    &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4140 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_cryptol_add_path)</span></span>
<span class="lineno"> 4141 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 4142 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add a directory to the Cryptol search path. The Cryptol file loader&quot;</span></span>
<span class="lineno"> 4143 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;will look in this directory when following `import` statements in&quot;</span></span>
<span class="lineno"> 4144 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Cryptol source files.&quot;</span></span>
<span class="lineno"> 4145 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4146 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4147 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;cryptol_add_prim&quot;    &quot;String -&gt; String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4148 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal cryptol_add_prim)</span></span>
<span class="lineno"> 4149 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4150 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;cryptol_add_prim mod nm trm sets the translation of Cryptol primitive&quot;</span></span>
<span class="lineno"> 4151 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;nm in module mod to trm&quot;</span></span>
<span class="lineno"> 4152 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4153 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4154 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;cryptol_add_prim_type&quot;    &quot;String -&gt; String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4155 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal cryptol_add_prim_type)</span></span>
<span class="lineno"> 4156 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4157 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;cryptol_add_prim_type mod nm tp sets the translation of Cryptol&quot;</span></span>
<span class="lineno"> 4158 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;primitive type nm in module mod to tp&quot;</span></span>
<span class="lineno"> 4159 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4160 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4161 </span><span class="spaces">    </span><span class="istickedoff">----------------------------------------</span>
<span class="lineno"> 4162 </span><span class="spaces">    </span><span class="istickedoff">-- Java stuff</span>
<span class="lineno"> 4163 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4164 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_bool&quot;           &quot;JavaType&quot;</span>
<span class="lineno"> 4165 </span><span class="spaces">    </span><span class="istickedoff">(pureVal JavaBoolean)</span>
<span class="lineno"> 4166 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4167 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The Java type of booleans.&quot; ]</span></span>
<span class="lineno"> 4168 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4169 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_byte&quot;           &quot;JavaType&quot;</span>
<span class="lineno"> 4170 </span><span class="spaces">    </span><span class="istickedoff">(pureVal JavaByte)</span>
<span class="lineno"> 4171 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4172 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The Java type of bytes.&quot; ]</span></span>
<span class="lineno"> 4173 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4174 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_char&quot;           &quot;JavaType&quot;</span>
<span class="lineno"> 4175 </span><span class="spaces">    </span><span class="istickedoff">(pureVal JavaChar)</span>
<span class="lineno"> 4176 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4177 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The Java type of characters.&quot; ]</span></span>
<span class="lineno"> 4178 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4179 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_short&quot;          &quot;JavaType&quot;</span>
<span class="lineno"> 4180 </span><span class="spaces">    </span><span class="istickedoff">(pureVal JavaShort)</span>
<span class="lineno"> 4181 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4182 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The Java type of short integers.&quot; ]</span></span>
<span class="lineno"> 4183 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4184 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_int&quot;            &quot;JavaType&quot;</span>
<span class="lineno"> 4185 </span><span class="spaces">    </span><span class="istickedoff">(pureVal JavaInt)</span>
<span class="lineno"> 4186 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4187 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The standard Java integer type.&quot; ]</span></span>
<span class="lineno"> 4188 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4189 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_long&quot;           &quot;JavaType&quot;</span>
<span class="lineno"> 4190 </span><span class="spaces">    </span><span class="istickedoff">(pureVal JavaLong)</span>
<span class="lineno"> 4191 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4192 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The Java type of long integers.&quot; ]</span></span>
<span class="lineno"> 4193 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4194 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_float&quot;          &quot;JavaType&quot;</span>
<span class="lineno"> 4195 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal JavaFloat)</span></span>
<span class="lineno"> 4196 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 4197 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The Java type of single-precision floating point values.&quot; ]</span></span>
<span class="lineno"> 4198 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4199 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_double&quot;         &quot;JavaType&quot;</span>
<span class="lineno"> 4200 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal JavaDouble)</span></span>
<span class="lineno"> 4201 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 4202 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The Java type of double-precision floating point values.&quot; ]</span></span>
<span class="lineno"> 4203 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4204 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_array&quot;          &quot;Int -&gt; JavaType -&gt; JavaType&quot;</span>
<span class="lineno"> 4205 </span><span class="spaces">    </span><span class="istickedoff">(pureVal JavaArray)</span>
<span class="lineno"> 4206 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4207 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The Java type of arrays of a fixed number of elements of the given&quot;</span></span>
<span class="lineno"> 4208 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;type.&quot;</span></span>
<span class="lineno"> 4209 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4210 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4211 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_class&quot;          &quot;String -&gt; JavaType&quot;</span>
<span class="lineno"> 4212 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal JavaClass)</span></span>
<span class="lineno"> 4213 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 4214 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The Java type corresponding to the named class.&quot; ]</span></span>
<span class="lineno"> 4215 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4216 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_load_class&quot;     &quot;String -&gt; TopLevel JavaClass&quot;</span>
<span class="lineno"> 4217 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CJ.loadJavaClass)</span>
<span class="lineno"> 4218 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4219 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Load the named Java class and return a handle to it.&quot; ]</span></span>
<span class="lineno"> 4220 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4221 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_extract&quot;  &quot;JavaClass -&gt; String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 4222 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CJ.jvm_extract)</span>
<span class="lineno"> 4223 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4224 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Translate a Java method directly to a Term. The parameters of the&quot;</span></span>
<span class="lineno"> 4225 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Term will be the parameters of the Java method, and the return&quot;</span></span>
<span class="lineno"> 4226 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;value will be the return value of the method. Only methods with&quot;</span></span>
<span class="lineno"> 4227 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;scalar argument and return types are currently supported.&quot;</span></span>
<span class="lineno"> 4228 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4229 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_java_extract&quot;  &quot;JavaClass -&gt; String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 4230 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal CJ.jvm_extract)</span></span>
<span class="lineno"> 4231 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 4232 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `jvm_extract`.&quot;</span></span>
<span class="lineno"> 4233 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4234 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4235 </span><span class="spaces">    </span><span class="istickedoff">----------------------------------------</span>
<span class="lineno"> 4236 </span><span class="spaces">    </span><span class="istickedoff">-- LLVM stuff</span>
<span class="lineno"> 4237 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4238 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_sizeof&quot;         &quot;LLVMModule -&gt; LLVMType -&gt; Int&quot;</span>
<span class="lineno"> 4239 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 llvm_sizeof)</span>
<span class="lineno"> 4240 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4241 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;In the context of the given LLVM module, compute the size of the&quot;</span></span>
<span class="lineno"> 4242 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given LLVM type in bytes. The module determines details of struct&quot;</span></span>
<span class="lineno"> 4243 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;layout and the meaning of type aliases.&quot; ]</span></span>
<span class="lineno"> 4244 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4245 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_type&quot;           &quot;String -&gt; LLVMType&quot;</span>
<span class="lineno"> 4246 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 llvm_type)</span>
<span class="lineno"> 4247 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4248 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Parse the given string as LLVM type syntax.&quot; ]</span></span>
<span class="lineno"> 4249 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4250 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_int&quot;            &quot;Int -&gt; LLVMType&quot;</span>
<span class="lineno"> 4251 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_int)</span>
<span class="lineno"> 4252 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4253 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of LLVM integers, of the given bit width.&quot; ]</span></span>
<span class="lineno"> 4254 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4255 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_float&quot;          &quot;LLVMType&quot;</span>
<span class="lineno"> 4256 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_float)</span></span>
<span class="lineno"> 4257 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 4258 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of single-precision floating point numbers in LLVM.&quot; ]</span></span>
<span class="lineno"> 4259 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4260 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_double&quot;         &quot;LLVMType&quot;</span>
<span class="lineno"> 4261 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_double)</span></span>
<span class="lineno"> 4262 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 4263 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of double-precision floating point numbers in LLVM.&quot; ]</span></span>
<span class="lineno"> 4264 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4265 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_array&quot;          &quot;Int -&gt; LLVMType -&gt; LLVMType&quot;</span>
<span class="lineno"> 4266 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_array)</span>
<span class="lineno"> 4267 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4268 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of LLVM arrays with the given number of elements of the&quot;</span></span>
<span class="lineno"> 4269 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given type.&quot;</span></span>
<span class="lineno"> 4270 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4271 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4272 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_alias&quot;          &quot;String -&gt; LLVMType&quot;</span>
<span class="lineno"> 4273 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_alias)</span>
<span class="lineno"> 4274 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4275 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of an LLVM alias for the given name. Often times, this is used&quot;</span></span>
<span class="lineno"> 4276 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to alias a struct type.&quot;</span></span>
<span class="lineno"> 4277 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4278 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_struct&quot;         &quot;String -&gt; LLVMType&quot;</span>
<span class="lineno"> 4279 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_alias)</span></span>
<span class="lineno"> 4280 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">WarnDeprecated</span></span>
<span class="lineno"> 4281 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_alias`.&quot;</span></span>
<span class="lineno"> 4282 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;If you are trying to create a struct type from its contents, you want llvm_struct_type.&quot;</span></span>
<span class="lineno"> 4283 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4284 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Expected to be hidden by default in SAW 1.5.&quot;</span></span>
<span class="lineno"> 4285 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4286 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4287 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_pointer&quot;        &quot;LLVMType -&gt; LLVMType&quot;</span>
<span class="lineno"> 4288 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_pointer)</span>
<span class="lineno"> 4289 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4290 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of an LLVM pointer that points to the given type.&quot;</span></span>
<span class="lineno"> 4291 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4292 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4293 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_load_module&quot;    &quot;String -&gt; TopLevel LLVMModule&quot;</span>
<span class="lineno"> 4294 </span><span class="spaces">    </span><span class="istickedoff">(pureVal do_llvm_load_module)</span>
<span class="lineno"> 4295 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4296 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Load an LLVM bitcode file and return a handle to it.&quot; ]</span></span>
<span class="lineno"> 4297 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4298 </span><span class="spaces">    </span><span class="istickedoff">----------------------------------------</span>
<span class="lineno"> 4299 </span><span class="spaces">    </span><span class="istickedoff">-- LLVM skeletons</span>
<span class="lineno"> 4300 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4301 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;module_skeleton&quot; &quot;LLVMModule -&gt; TopLevel ModuleSkeleton&quot;</span>
<span class="lineno"> 4302 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal module_skeleton)</span></span>
<span class="lineno"> 4303 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4304 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a handle to an LLVM module, return a skeleton for that module.&quot;</span></span>
<span class="lineno"> 4305 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4306 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4307 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;function_skeleton&quot; &quot;ModuleSkeleton -&gt; String -&gt; TopLevel FunctionSkeleton&quot;</span>
<span class="lineno"> 4308 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal function_skeleton)</span></span>
<span class="lineno"> 4309 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4310 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a module skeleton and a function name, return the corresponding&quot;</span></span>
<span class="lineno"> 4311 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;function skeleton.&quot;</span></span>
<span class="lineno"> 4312 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4313 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4314 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_resize_arg_index&quot; &quot;FunctionSkeleton -&gt; Int -&gt; Int -&gt; Bool -&gt; TopLevel FunctionSkeleton&quot;</span>
<span class="lineno"> 4315 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_resize_arg_index)</span></span>
<span class="lineno"> 4316 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4317 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a function skeleton, argument index, array length, and whether or&quot;</span></span>
<span class="lineno"> 4318 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;not that argument is initialized, return a new function skeleton where&quot;</span></span>
<span class="lineno"> 4319 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the assumed length/initialization of the given argument is updated.&quot;</span></span>
<span class="lineno"> 4320 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4321 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4322 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_resize_arg&quot; &quot;FunctionSkeleton -&gt; String -&gt; Int -&gt; Bool -&gt; TopLevel FunctionSkeleton&quot;</span>
<span class="lineno"> 4323 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_resize_arg)</span></span>
<span class="lineno"> 4324 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4325 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a function skeleton, argument name, array length, and whether or&quot;</span></span>
<span class="lineno"> 4326 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;not that argument is initialized, return a new function skeleton where&quot;</span></span>
<span class="lineno"> 4327 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the assumed length/initialization of the given argument is updated.&quot;</span></span>
<span class="lineno"> 4328 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4329 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4330 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_guess_arg_sizes&quot; &quot;ModuleSkeleton -&gt; LLVMModule -&gt; [(String, [FunctionProfile])] -&gt; TopLevel ModuleSkeleton&quot;</span>
<span class="lineno"> 4331 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_guess_arg_sizes)</span></span>
<span class="lineno"> 4332 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4333 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Update the sizes of all arguments of the given module skeleton using&quot;</span></span>
<span class="lineno"> 4334 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;information obtained from 'crucible_llvm_array_size_profile'.&quot;</span></span>
<span class="lineno"> 4335 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4336 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4337 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_globals_pre&quot; &quot;ModuleSkeleton -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4338 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_globals_pre)</span></span>
<span class="lineno"> 4339 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4340 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Allocate and initialize mutable globals from the given module skeleton.&quot;</span></span>
<span class="lineno"> 4341 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4342 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4343 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_globals_post&quot; &quot;ModuleSkeleton -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4344 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_globals_post)</span></span>
<span class="lineno"> 4345 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4346 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Assert that all mutable globals from the given module skeleton are unchanged.&quot;</span></span>
<span class="lineno"> 4347 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4348 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4349 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_prestate&quot; &quot;FunctionSkeleton -&gt; LLVMSetup SkeletonState&quot;</span>
<span class="lineno"> 4350 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_prestate)</span></span>
<span class="lineno"> 4351 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4352 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Allocate and initialize the arguments of the given function skeleton.&quot;</span></span>
<span class="lineno"> 4353 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Return a 'SkeletonState' from which those arguments can be retrieved,&quot;</span></span>
<span class="lineno"> 4354 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;so that preconditions can be imposed.&quot;</span></span>
<span class="lineno"> 4355 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4356 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4357 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_poststate&quot; &quot;FunctionSkeleton -&gt; SkeletonState -&gt; LLVMSetup SkeletonState&quot;</span>
<span class="lineno"> 4358 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_poststate)</span></span>
<span class="lineno"> 4359 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4360 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Assert that pointer arguments of the given function skeleton remain&quot;</span></span>
<span class="lineno"> 4361 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;initialized. Return a 'SkeletonState' from which those arguments can&quot;</span></span>
<span class="lineno"> 4362 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;be retrieved, so that postconditions can be imposed.&quot;</span></span>
<span class="lineno"> 4363 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4364 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4365 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_arg_index&quot; &quot;SkeletonState -&gt; Int -&gt; LLVMSetup Term&quot;</span>
<span class="lineno"> 4366 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_arg_index)</span></span>
<span class="lineno"> 4367 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4368 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Retrieve the argument value at the given index from the given 'SkeletonState'.&quot;</span></span>
<span class="lineno"> 4369 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4370 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4371 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_arg&quot; &quot;SkeletonState -&gt; String -&gt; LLVMSetup Term&quot;</span>
<span class="lineno"> 4372 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_arg)</span></span>
<span class="lineno"> 4373 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4374 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Retrieve the argument value of the given name from the given 'SkeletonState'.&quot;</span></span>
<span class="lineno"> 4375 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4376 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4377 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_arg_index_pointer&quot; &quot;SkeletonState -&gt; Int -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 4378 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_arg_index_pointer)</span></span>
<span class="lineno"> 4379 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4380 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Retrieve the argument pointer at the given indexfrom the given 'SkeletonState'.&quot;</span></span>
<span class="lineno"> 4381 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Fails if the specified argument is not a pointer.&quot;</span></span>
<span class="lineno"> 4382 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4383 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4384 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_arg_pointer&quot; &quot;SkeletonState -&gt; String -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 4385 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_arg_pointer)</span></span>
<span class="lineno"> 4386 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4387 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Retrieve the argument pointer of the given name from the given 'SkeletonState'.&quot;</span></span>
<span class="lineno"> 4388 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Fails if the specified argument is not a pointer.&quot;</span></span>
<span class="lineno"> 4389 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4390 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4391 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_exec&quot; &quot;SkeletonState -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4392 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_exec)</span></span>
<span class="lineno"> 4393 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4394 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Wrapper around 'crucible_execute_func' that passes the arguments initialized&quot;</span></span>
<span class="lineno"> 4395 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in 'skeleton_prestate'.&quot;</span></span>
<span class="lineno"> 4396 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4397 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4398 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_boilerplate&quot; &quot;String -&gt; ModuleSkeleton -&gt; Bool -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4399 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_llvm_boilerplate)</span></span>
<span class="lineno"> 4400 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4401 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Generate boilerplate for the definitions in the given LLVM module skeleton.&quot;</span></span>
<span class="lineno"> 4402 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Output is written to the path passed as the first argument.&quot;</span></span>
<span class="lineno"> 4403 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The third argument controls whether skeleton builtins are emitted.&quot;</span></span>
<span class="lineno"> 4404 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4405 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4406 </span><span class="spaces">    </span><span class="istickedoff">----------------------------------------</span>
<span class="lineno"> 4407 </span><span class="spaces">    </span><span class="istickedoff">-- Some misc commands</span>
<span class="lineno"> 4408 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4409 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;caseSatResult&quot;       &quot;{b} SatResult -&gt; b -&gt; (Term -&gt; b) -&gt; b&quot;</span>
<span class="lineno"> 4410 </span><span class="spaces">    </span><span class="istickedoff">(funVal3 caseSatResultPrim)</span>
<span class="lineno"> 4411 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4412 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Branch on the result of SAT solving.&quot;</span></span>
<span class="lineno"> 4413 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4414 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Usage: caseSatResult &lt;code to run if unsat&gt; &lt;code to run if sat&gt;.&quot;</span></span>
<span class="lineno"> 4415 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4416 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;For example,&quot;</span></span>
<span class="lineno"> 4417 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4418 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  r &lt;- sat abc &lt;prop&gt;&quot;</span></span>
<span class="lineno"> 4419 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  caseSatResult r &lt;unsat&gt; &lt;sat&gt;&quot;</span></span>
<span class="lineno"> 4420 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4421 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;will run '&lt;unsat&gt;' if '&lt;prop&gt;' is unSAT and will run '&lt;sat&gt; &lt;example&gt;'&quot;</span></span>
<span class="lineno"> 4422 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;if '&lt;prop&gt;' is SAT, where '&lt;example&gt;' is a satisfying assignment.&quot;</span></span>
<span class="lineno"> 4423 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;If '&lt;prop&gt;' is a curried function, then '&lt;example&gt;' will be a tuple.&quot;</span></span>
<span class="lineno"> 4424 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;If we could not determine the satisfiability of '&lt;prop&gt;', then&quot;</span></span>
<span class="lineno"> 4425 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;this will run '&lt;sat&gt; {{ () }}'.&quot;</span></span>
<span class="lineno"> 4426 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4427 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4428 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;caseProofResult&quot;     &quot;{b} ProofResult -&gt; (Theorem -&gt; b) -&gt; (Term -&gt; b) -&gt; b&quot;</span>
<span class="lineno"> 4429 </span><span class="spaces">    </span><span class="istickedoff">(funVal3 caseProofResultPrim)</span>
<span class="lineno"> 4430 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4431 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Branch on the result of proving.&quot;</span></span>
<span class="lineno"> 4432 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4433 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Usage: caseProofResult &lt;result&gt; &lt;code to run if true&gt; &lt;code to run if false&gt;.&quot;</span></span>
<span class="lineno"> 4434 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4435 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;For example,&quot;</span></span>
<span class="lineno"> 4436 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4437 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  r &lt;- prove abc &lt;prop&gt;&quot;</span></span>
<span class="lineno"> 4438 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  caseProofResult r &lt;true&gt; &lt;false&gt;&quot;</span></span>
<span class="lineno"> 4439 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4440 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;will run '&lt;true&gt; &lt;thm&gt;' if '&lt;prop&gt;' is proved (where '&lt;thm&gt;' represents&quot;</span></span>
<span class="lineno"> 4441 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the proved theorem) and will run '&lt;false&gt; &lt;example&gt;'&quot;</span></span>
<span class="lineno"> 4442 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;if '&lt;prop&gt;' is false, where '&lt;example&gt;' is a counter example.&quot;</span></span>
<span class="lineno"> 4443 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;If '&lt;prop&gt;' is a curried function, then '&lt;example&gt;' will be a tuple.&quot;</span></span>
<span class="lineno"> 4444 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;If the proof of &lt;prop&gt; was not finished, but we did not find a counterexample,&quot;</span></span>
<span class="lineno"> 4445 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the example will run '&lt;false&gt; {{ () }}'&quot;</span></span>
<span class="lineno"> 4446 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4447 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4448 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;undefined&quot;           &quot;{a} a&quot;</span>
<span class="lineno"> 4449 </span><span class="spaces">    </span><span class="istickedoff">-- In order to work as expected this has to be &quot;error&quot; in place of</span>
<span class="lineno"> 4450 </span><span class="spaces">    </span><span class="istickedoff">-- a Value and not a Value (of whatever kind) wrapping &quot;error&quot;. So</span>
<span class="lineno"> 4451 </span><span class="spaces">    </span><span class="istickedoff">-- there must be no toValue and none of the pureVal/funVal/etc.</span>
<span class="lineno"> 4452 </span><span class="spaces">    </span><span class="istickedoff">-- ops are suitable.</span>
<span class="lineno"> 4453 </span><span class="spaces">    </span><span class="istickedoff">(\_ _ _ -&gt; error &quot;interpret: undefined&quot;)</span>
<span class="lineno"> 4454 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4455 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;An undefined value of any type. Evaluating 'undefined' makes the&quot;</span></span>
<span class="lineno"> 4456 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;program crash.&quot;</span></span>
<span class="lineno"> 4457 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4458 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4459 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;exit&quot;                &quot;Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4460 </span><span class="spaces">    </span><span class="istickedoff">(pureVal exitPrim)</span>
<span class="lineno"> 4461 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4462 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Exit SAWScript, returning the supplied exit code to the parent&quot;</span></span>
<span class="lineno"> 4463 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;process.&quot;</span></span>
<span class="lineno"> 4464 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4465 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4466 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;fail&quot; &quot;{a} String -&gt; TopLevel a&quot;</span>
<span class="lineno"> 4467 </span><span class="spaces">    </span><span class="istickedoff">(pureVal failPrim)</span>
<span class="lineno"> 4468 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4469 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Throw an exception in the top level monad.&quot; ]</span></span>
<span class="lineno"> 4470 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4471 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;fails&quot;               &quot;{a} TopLevel a -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4472 </span><span class="spaces">    </span><span class="istickedoff">(pureVal failsPrim)</span>
<span class="lineno"> 4473 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4474 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Run the given inner action and convert failure into success.  Fail&quot;</span></span>
<span class="lineno"> 4475 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;if the inner action does NOT raise an exception. This is primarily used&quot;</span></span>
<span class="lineno"> 4476 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;for unit testing purposes, to ensure that we can elicit expected&quot;</span></span>
<span class="lineno"> 4477 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;failing behaviors.&quot;</span></span>
<span class="lineno"> 4478 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4479 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Note: to catch a failure that occurs in non-monadic code, you must wrap&quot;</span></span>
<span class="lineno"> 4480 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the non-monadic code in a do-block; otherwise it will be evaluated before&quot;</span></span>
<span class="lineno"> 4481 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;fails runs.&quot;</span></span>
<span class="lineno"> 4482 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4483 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4484 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;time&quot;                &quot;{a} TopLevel a -&gt; TopLevel a&quot;</span>
<span class="lineno"> 4485 </span><span class="spaces">    </span><span class="istickedoff">(pureVal timePrim)</span>
<span class="lineno"> 4486 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4487 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the CPU time used by the given TopLevel command.&quot; ]</span></span>
<span class="lineno"> 4488 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4489 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;with_time&quot;           &quot;{a} TopLevel a -&gt; TopLevel (Int, a)&quot;</span>
<span class="lineno"> 4490 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal withTimePrim)</span></span>
<span class="lineno"> 4491 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 4492 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Run the given TopLevel command.  Return the number of milliseconds&quot;</span></span>
<span class="lineno"> 4493 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;elapsed during the execution of the command and its result.&quot;</span></span>
<span class="lineno"> 4494 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4495 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4496 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;exec&quot;               &quot;String -&gt; [String] -&gt; String -&gt; TopLevel String&quot;</span>
<span class="lineno"> 4497 </span><span class="spaces">    </span><span class="istickedoff">(pureVal exec)</span>
<span class="lineno"> 4498 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4499 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Execute an external process with the given executable&quot;</span></span>
<span class="lineno"> 4500 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;name, arguments, and standard input. Returns standard&quot;</span></span>
<span class="lineno"> 4501 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;output.&quot;</span></span>
<span class="lineno"> 4502 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4503 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4504 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;eval_bool&quot;           &quot;Term -&gt; Bool&quot;</span>
<span class="lineno"> 4505 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 eval_bool)</span>
<span class="lineno"> 4506 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4507 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Evaluate a Cryptol term of type Bit to either 'true' or 'false'.&quot;</span></span>
<span class="lineno"> 4508 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4509 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4510 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;eval_int&quot;           &quot;Term -&gt; Int&quot;</span>
<span class="lineno"> 4511 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 eval_int)</span>
<span class="lineno"> 4512 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4513 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Evaluate a Cryptol term of type [n] and convert to a SAWScript Int.&quot;</span></span>
<span class="lineno"> 4514 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4515 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4516 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;eval_size&quot;          &quot;Type -&gt; Int&quot;</span>
<span class="lineno"> 4517 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 eval_size)</span>
<span class="lineno"> 4518 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4519 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Convert a Cryptol size type to a SAWScript Int.&quot;</span></span>
<span class="lineno"> 4520 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4521 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4522 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;eval_list&quot;           &quot;Term -&gt; [Term]&quot;</span>
<span class="lineno"> 4523 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 eval_list)</span>
<span class="lineno"> 4524 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4525 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Evaluate a Cryptol term of type [n]a to a list of terms.&quot;</span></span>
<span class="lineno"> 4526 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4527 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4528 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;list_term&quot;           &quot;[Term] -&gt; Term&quot;</span>
<span class="lineno"> 4529 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 list_term)</span>
<span class="lineno"> 4530 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4531 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Make a Cryptol term of type [n]a from a list of terms of type a.&quot;</span></span>
<span class="lineno"> 4532 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Function list_term is the inverse of function eval_list.&quot;</span></span>
<span class="lineno"> 4533 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4534 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4535 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;parse_core&quot;         &quot;String -&gt; Term&quot;</span>
<span class="lineno"> 4536 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 parse_core)</span>
<span class="lineno"> 4537 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4538 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Parse a Term from a String in SAWCore syntax.&quot;</span></span>
<span class="lineno"> 4539 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4540 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4541 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;parse_core_mod&quot;      &quot;String -&gt; String -&gt; Term&quot;</span>
<span class="lineno"> 4542 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 parse_core_mod)</span>
<span class="lineno"> 4543 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4544 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Parse a Term from the second supplied String in SAWCore syntax,&quot;</span></span>
<span class="lineno"> 4545 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;relative to the module specified by the first String&quot;</span></span>
<span class="lineno"> 4546 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4547 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4548 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;prove_core&quot;         &quot;ProofScript () -&gt; String -&gt; TopLevel Theorem&quot;</span>
<span class="lineno"> 4549 </span><span class="spaces">    </span><span class="istickedoff">(pureVal prove_core)</span>
<span class="lineno"> 4550 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4551 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the given proof script to attempt to prove that a term is valid&quot;</span></span>
<span class="lineno"> 4552 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(true for all inputs). The term is specified as a String containing&quot;</span></span>
<span class="lineno"> 4553 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;saw-core syntax. Returns a Theorem if successful, and aborts if&quot;</span></span>
<span class="lineno"> 4554 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;unsuccessful.&quot;</span></span>
<span class="lineno"> 4555 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4556 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4557 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;core_axiom&quot;         &quot;String -&gt; Theorem&quot;</span>
<span class="lineno"> 4558 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 core_axiom)</span>
<span class="lineno"> 4559 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4560 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare the given core expression as an axiomatic rewrite rule.&quot;</span></span>
<span class="lineno"> 4561 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The input string contains a proof goal in saw-core syntax. The&quot;</span></span>
<span class="lineno"> 4562 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;return value is a Theorem that may be added to a Simpset.&quot;</span></span>
<span class="lineno"> 4563 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4564 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4565 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;core_thm&quot;           &quot;String -&gt; Theorem&quot;</span>
<span class="lineno"> 4566 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal1 core_thm)</span></span>
<span class="lineno"> 4567 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 4568 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a theorem from the type of the given core expression.&quot; ]</span></span>
<span class="lineno"> 4569 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4570 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;specialize_theorem&quot; &quot;Theorem -&gt; [Term] -&gt; TopLevel Theorem&quot;</span>
<span class="lineno"> 4571 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal specialize_theorem)</span></span>
<span class="lineno"> 4572 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4573 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specialize a theorem by instantiating universal quantifiers&quot;</span></span>
<span class="lineno"> 4574 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;with the given list of terms.&quot;</span></span>
<span class="lineno"> 4575 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4576 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4577 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;get_opt&quot;            &quot;Int -&gt; String&quot;</span>
<span class="lineno"> 4578 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 get_opt)</span>
<span class="lineno"> 4579 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4580 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Get the nth argument to the current script as a String. Script&quot;</span></span>
<span class="lineno"> 4581 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;arguments are collected from the SAW command line after the name of&quot;</span></span>
<span class="lineno"> 4582 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the script being run. The 0th argument is the script name. The&quot;</span></span>
<span class="lineno"> 4583 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;argument list is empty when no script was loaded, e.g. when running&quot;</span></span>
<span class="lineno"> 4584 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;interactively.&quot;</span></span>
<span class="lineno"> 4585 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4586 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4587 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;get_nopts&quot;          &quot;() -&gt; Int&quot;</span>
<span class="lineno"> 4588 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 get_nopts)</span>
<span class="lineno"> 4589 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4590 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Get the number of arguments to the current script. Since the 0th&quot;</span></span>
<span class="lineno"> 4591 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;argument is the script name, the count will normally be at least 1.&quot;</span></span>
<span class="lineno"> 4592 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;If no script was loaded, the count will be 0.&quot;</span></span>
<span class="lineno"> 4593 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4594 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4595 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;get_env&quot;            &quot;String -&gt; String&quot;</span>
<span class="lineno"> 4596 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 get_env)</span>
<span class="lineno"> 4597 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4598 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Get an environment variable (from the process environment) as a String.&quot;</span></span>
<span class="lineno"> 4599 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4600 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4601 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;show_cfg&quot;          &quot;CFG -&gt; String&quot;</span>
<span class="lineno"> 4602 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal show_cfg)</span></span>
<span class="lineno"> 4603 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 4604 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Pretty-print a control-flow graph.&quot;</span></span>
<span class="lineno"> 4605 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4606 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4607 </span><span class="spaces">    </span><span class="istickedoff">----------------------------------------</span>
<span class="lineno"> 4608 </span><span class="spaces">    </span><span class="istickedoff">-- Crucible/LLVM interface</span>
<span class="lineno"> 4609 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4610 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_cfg&quot;     &quot;LLVMModule -&gt; String -&gt; TopLevel CFG&quot;</span>
<span class="lineno"> 4611 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_cfg)</span></span>
<span class="lineno"> 4612 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 4613 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Load a function from the given LLVM module into a Crucible CFG.&quot;</span></span>
<span class="lineno"> 4614 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4615 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4616 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_extract&quot;  &quot;LLVMModule -&gt; String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 4617 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_extract)</span>
<span class="lineno"> 4618 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4619 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Translate an LLVM function directly to a Term. The parameters of the&quot;</span></span>
<span class="lineno"> 4620 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Term will be the parameters of the LLVM function, and the return&quot;</span></span>
<span class="lineno"> 4621 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;value will be the return value of the functions. Only functions with&quot;</span></span>
<span class="lineno"> 4622 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;scalar argument and return types are currently supported. For more&quot;</span></span>
<span class="lineno"> 4623 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;flexibility, see 'llvm_verify'.&quot;</span></span>
<span class="lineno"> 4624 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4625 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_llvm_extract&quot;  &quot;LLVMModule -&gt; String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 4626 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_extract)</span></span>
<span class="lineno"> 4627 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 4628 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_extract`.&quot; ]</span></span>
<span class="lineno"> 4629 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4630 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_compositional_extract&quot;</span>
<span class="lineno"> 4631 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; String -&gt; [LLVMSpec] -&gt; Bool -&gt; LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;</span>
<span class="lineno"> 4632 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_compositional_extract)</span>
<span class="lineno"> 4633 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4634 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Translate an LLVM function directly to a Term. The parameters of the&quot;</span></span>
<span class="lineno"> 4635 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Term are the input parameters of the LLVM function: the parameters&quot;</span></span>
<span class="lineno"> 4636 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;passed by value (in the order given by `llvm_exec_func`), then&quot;</span></span>
<span class="lineno"> 4637 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the parameters passed by reference (in the order given by&quot;</span></span>
<span class="lineno"> 4638 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;`llvm_points_to`). The Term is the tuple consisting of the&quot;</span></span>
<span class="lineno"> 4639 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;output parameters of the LLVM function: the return parameter, then&quot;</span></span>
<span class="lineno"> 4640 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the parameters passed by reference (in the order given by&quot;</span></span>
<span class="lineno"> 4641 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;`llvm_points_to`).&quot;</span></span>
<span class="lineno"> 4642 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4643 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;When invoking `llvm_compositional_extract mod fn_name term_name ovs&quot;</span></span>
<span class="lineno"> 4644 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;check_path_sat spec strat`, the arguments represent the following:&quot;</span></span>
<span class="lineno"> 4645 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  1. `mod`: The LLVM module containing the function to extract.&quot;</span></span>
<span class="lineno"> 4646 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  2. `fn_name`: The name of the function to extract.&quot;</span></span>
<span class="lineno"> 4647 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  3. `term_name`: The name of the `Term` to generate.&quot;</span></span>
<span class="lineno"> 4648 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  4. `ovs`: A list of overrides to use in the proof that the extracted&quot;</span></span>
<span class="lineno"> 4649 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;     function satisifies `spec`.&quot;</span></span>
<span class="lineno"> 4650 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  5. `check_path_sat`: Whether to perform path satisfiability checks.&quot;</span></span>
<span class="lineno"> 4651 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  6. `spec`: SAW specification for the extracted function.&quot;</span></span>
<span class="lineno"> 4652 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  7. `strat`: Proof strategy to use when verifying that the extracted&quot;</span></span>
<span class="lineno"> 4653 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;     function satisfies `spec`.&quot;</span></span>
<span class="lineno"> 4654 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4655 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;For more flexibility, see `llvm_verify`.&quot;</span></span>
<span class="lineno"> 4656 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4657 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_llvm_compositional_extract&quot;</span>
<span class="lineno"> 4658 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; String -&gt; [LLVMSpec] -&gt; Bool -&gt; LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;</span>
<span class="lineno"> 4659 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_compositional_extract)</span></span>
<span class="lineno"> 4660 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4661 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_compositional_extract`.&quot; ]</span></span>
<span class="lineno"> 4662 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4663 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_fresh_var&quot; &quot;String -&gt; LLVMType -&gt; LLVMSetup Term&quot;</span>
<span class="lineno"> 4664 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_fresh_var)</span>
<span class="lineno"> 4665 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4666 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a fresh symbolic variable for use within an LLVM&quot;</span></span>
<span class="lineno"> 4667 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specification. The name is used only for pretty-printing.&quot;</span></span>
<span class="lineno"> 4668 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4669 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_fresh_var&quot; &quot;String -&gt; LLVMType -&gt; LLVMSetup Term&quot;</span>
<span class="lineno"> 4670 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_fresh_var)</span>
<span class="lineno"> 4671 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4672 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_fresh_var`.&quot; ]</span></span>
<span class="lineno"> 4673 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4674 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_fresh_cryptol_var&quot; &quot;String -&gt; Type -&gt; LLVMSetup Term&quot;</span>
<span class="lineno"> 4675 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_fresh_cryptol_var)</span>
<span class="lineno"> 4676 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4677 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a fresh symbolic variable of the given Cryptol type for use&quot;</span></span>
<span class="lineno"> 4678 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;within a Crucible specification. The given name is used only for&quot;</span></span>
<span class="lineno"> 4679 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;pretty-printing. Unlike 'llvm_fresh_var', this can be used when&quot;</span></span>
<span class="lineno"> 4680 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;there isn't an appropriate LLVM type, such as the Cryptol Array type.&quot;</span></span>
<span class="lineno"> 4681 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4682 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_fresh_cryptol_var&quot; &quot;String -&gt; Type -&gt; LLVMSetup Term&quot;</span>
<span class="lineno"> 4683 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_fresh_cryptol_var)</span></span>
<span class="lineno"> 4684 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4685 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_fresh_cryptol_var`.&quot; ]</span></span>
<span class="lineno"> 4686 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4687 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_alloc&quot; &quot;LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 4688 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_alloc)</span>
<span class="lineno"> 4689 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4690 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that an object of the given type should be allocated in an&quot;</span></span>
<span class="lineno"> 4691 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;LLVM specification. Before `llvm_execute_func`, this states that&quot;</span></span>
<span class="lineno"> 4692 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the function expects the object to be allocated before it runs.&quot;</span></span>
<span class="lineno"> 4693 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;After `llvm_execute_func`, it states that the function being&quot;</span></span>
<span class="lineno"> 4694 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;verified is expected to perform the allocation.&quot;</span></span>
<span class="lineno"> 4695 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4696 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_alloc&quot; &quot;LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 4697 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_alloc)</span></span>
<span class="lineno"> 4698 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 4699 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_alloc`.&quot; ]</span></span>
<span class="lineno"> 4700 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4701 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_alloc_aligned&quot; &quot;Int -&gt; LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 4702 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_alloc_aligned)</span></span>
<span class="lineno"> 4703 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 4704 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that a memory region of the given type should be allocated in&quot;</span></span>
<span class="lineno"> 4705 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;an LLVM specification, and also specify that the start of the region&quot;</span></span>
<span class="lineno"> 4706 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;should be aligned to a multiple of the specified number of bytes (which&quot;</span></span>
<span class="lineno"> 4707 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;must be a power of 2).&quot;</span></span>
<span class="lineno"> 4708 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4709 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_alloc_aligned&quot; &quot;Int -&gt; LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 4710 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_alloc_aligned)</span></span>
<span class="lineno"> 4711 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 4712 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_alloc_aligned`.&quot; ]</span></span>
<span class="lineno"> 4713 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4714 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_alloc_readonly&quot; &quot;LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 4715 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_alloc_readonly)</span>
<span class="lineno"> 4716 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4717 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that a read-only memory region of the given type should be&quot;</span></span>
<span class="lineno"> 4718 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;allocated in an LLVM specification. The function must not attempt&quot;</span></span>
<span class="lineno"> 4719 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to write to this memory region. Unlike `llvm_alloc`, regions&quot;</span></span>
<span class="lineno"> 4720 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;allocated with `llvm_alloc_readonly` are allowed to alias other&quot;</span></span>
<span class="lineno"> 4721 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;read-only regions.&quot;</span></span>
<span class="lineno"> 4722 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4723 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_alloc_readonly&quot; &quot;LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 4724 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_alloc_readonly)</span></span>
<span class="lineno"> 4725 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 4726 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_alloc_readonly`.&quot; ]</span></span>
<span class="lineno"> 4727 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4728 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_alloc_readonly_aligned&quot; &quot;Int -&gt; LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 4729 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_alloc_readonly_aligned)</span></span>
<span class="lineno"> 4730 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 4731 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that a read-only memory region of the given type should be&quot;</span></span>
<span class="lineno"> 4732 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;allocated in an LLVM specification, and also specify that the start of&quot;</span></span>
<span class="lineno"> 4733 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the region should be aligned to a multiple of the specified number of&quot;</span></span>
<span class="lineno"> 4734 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;bytes (which must be a power of 2). The function must not attempt to&quot;</span></span>
<span class="lineno"> 4735 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;write to this memory region. Unlike `llvm_alloc`/`llvm_alloc_aligned`,&quot;</span></span>
<span class="lineno"> 4736 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;regions allocated with `llvm_alloc_readonly_aligned` are allowed to&quot;</span></span>
<span class="lineno"> 4737 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;alias other read-only regions.&quot;</span></span>
<span class="lineno"> 4738 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4739 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_alloc_readonly_aligned&quot; &quot;Int -&gt; LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 4740 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_alloc_readonly_aligned)</span></span>
<span class="lineno"> 4741 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 4742 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_alloc_readonly_aligned`.&quot; ]</span></span>
<span class="lineno"> 4743 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4744 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_alloc_with_size&quot; &quot;Int -&gt; LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 4745 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_alloc_with_size)</span>
<span class="lineno"> 4746 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4747 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Like `llvm_alloc`, but with a user-specified size (given in bytes).&quot;</span></span>
<span class="lineno"> 4748 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The specified size must be greater than the size of the LLVM type.&quot;</span></span>
<span class="lineno"> 4749 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4750 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_alloc_with_size&quot; &quot;Int -&gt; LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 4751 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_alloc_with_size)</span></span>
<span class="lineno"> 4752 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4753 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_alloc_with_size`.&quot; ]</span></span>
<span class="lineno"> 4754 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4755 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_alloc_sym_init&quot; &quot;LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 4756 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_alloc_sym_init)</span>
<span class="lineno"> 4757 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4758 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Like `llvm_alloc`, but assume that the allocation is initialized with&quot;</span></span>
<span class="lineno"> 4759 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;symbolic bytes.&quot;</span></span>
<span class="lineno"> 4760 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4761 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4762 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_symbolic_alloc&quot; &quot;Bool -&gt; Int -&gt; Term -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 4763 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_symbolic_alloc)</span>
<span class="lineno"> 4764 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4765 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Like `llvm_alloc`, but with a (symbolic) size instead of an LLVM type.&quot;</span></span>
<span class="lineno"> 4766 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The first argument specifies whether the allocation is read-only. The&quot;</span></span>
<span class="lineno"> 4767 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;second argument specifies the alignment in bytes (which must be a power&quot;</span></span>
<span class="lineno"> 4768 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of 2). The third argument specifies the size in bytes.&quot;</span></span>
<span class="lineno"> 4769 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4770 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_symbolic_alloc&quot; &quot;Bool -&gt; Int -&gt; Term -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 4771 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_symbolic_alloc)</span></span>
<span class="lineno"> 4772 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 4773 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_symbolic_alloc`.&quot; ]</span></span>
<span class="lineno"> 4774 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4775 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_alloc_global&quot; &quot;String -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4776 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_alloc_global)</span>
<span class="lineno"> 4777 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4778 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that memory for the named global should be allocated in an&quot;</span></span>
<span class="lineno"> 4779 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;LLVM specification. This is done implicitly for immutable globals.&quot;</span></span>
<span class="lineno"> 4780 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;A pointer to the allocated memory may be obtained using `llvm_global`.&quot;</span></span>
<span class="lineno"> 4781 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4782 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_alloc_global&quot; &quot;String -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4783 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_alloc_global)</span></span>
<span class="lineno"> 4784 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4785 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_alloc_global`.&quot; ]</span></span>
<span class="lineno"> 4786 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4787 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_fresh_pointer&quot; &quot;LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 4788 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_fresh_pointer)</span>
<span class="lineno"> 4789 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4790 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a fresh pointer value for use in an LLVM specification.&quot;</span></span>
<span class="lineno"> 4791 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This works like `llvm_alloc` except that the pointer is not&quot;</span></span>
<span class="lineno"> 4792 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;required to point to allocated memory.&quot;</span></span>
<span class="lineno"> 4793 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4794 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_fresh_pointer&quot; &quot;LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 4795 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_fresh_pointer)</span></span>
<span class="lineno"> 4796 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 4797 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_fresh_pointer`.&quot; ]</span></span>
<span class="lineno"> 4798 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4799 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_fresh_expanded_val&quot; &quot;LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 4800 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_fresh_expanded_val)</span>
<span class="lineno"> 4801 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4802 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a compound type entirely populated with fresh symbolic variables.&quot;</span></span>
<span class="lineno"> 4803 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Equivalent to allocating a new struct or array of the given type and&quot;</span></span>
<span class="lineno"> 4804 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;explicitly setting each field or element to contain a fresh symbolic&quot;</span></span>
<span class="lineno"> 4805 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;variable.&quot;</span></span>
<span class="lineno"> 4806 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4807 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_fresh_expanded_val&quot; &quot;LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 4808 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_fresh_expanded_val)</span></span>
<span class="lineno"> 4809 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 4810 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_fresh_expanded_val`.&quot; ]</span></span>
<span class="lineno"> 4811 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4812 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_points_to&quot; &quot;SetupValue -&gt; SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4813 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (llvm_points_to True))</span>
<span class="lineno"> 4814 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4815 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the memory location indicated by the given pointer (first&quot;</span></span>
<span class="lineno"> 4816 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;argument) contains the given value (second argument).&quot;</span></span>
<span class="lineno"> 4817 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4818 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the pre-state section (before `llvm_execute_func`) this specifies&quot;</span></span>
<span class="lineno"> 4819 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the initial memory layout before function execution. In the post-state&quot;</span></span>
<span class="lineno"> 4820 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section (after `llvm_execute_func`), this specifies an assertion&quot;</span></span>
<span class="lineno"> 4821 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;about the final memory state after running the function.&quot;</span></span>
<span class="lineno"> 4822 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4823 </span><span class="spaces">    </span><span class="istickedoff">, prim &quot;crucible_points_to&quot; &quot;SetupValue -&gt; SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4824 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (llvm_points_to True))</span></span>
<span class="lineno"> 4825 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4826 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_points_to`.&quot; ]</span></span>
<span class="lineno"> 4827 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4828 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_conditional_points_to&quot; &quot;Term -&gt; SetupValue -&gt; SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4829 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (llvm_conditional_points_to True))</span>
<span class="lineno"> 4830 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4831 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the memory location indicated by the given pointer (second&quot;</span></span>
<span class="lineno"> 4832 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;argument) contains the given value (third argument) if the given&quot;</span></span>
<span class="lineno"> 4833 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;condition (first argument) holds.&quot;</span></span>
<span class="lineno"> 4834 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4835 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the pre-state section (before `llvm_execute_func`) this specifies&quot;</span></span>
<span class="lineno"> 4836 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the initial memory layout before function execution. In the post-state&quot;</span></span>
<span class="lineno"> 4837 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section (after `llvm_execute_func`), this specifies an assertion&quot;</span></span>
<span class="lineno"> 4838 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;about the final memory state after running the function.&quot;</span></span>
<span class="lineno"> 4839 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4840 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_conditional_points_to&quot; &quot;Term -&gt; SetupValue -&gt; SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4841 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (llvm_conditional_points_to True))</span></span>
<span class="lineno"> 4842 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4843 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_conditional_points_to`.&quot; ]</span></span>
<span class="lineno"> 4844 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4845 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_points_to_at_type&quot; &quot;SetupValue -&gt; LLVMType -&gt; SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4846 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_points_to_at_type)</span>
<span class="lineno"> 4847 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4848 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A variant of `llvm_points_to` that casts the pointer to another type.&quot;</span></span>
<span class="lineno"> 4849 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This may be useful when reading or writing a prefix of larger array,&quot;</span></span>
<span class="lineno"> 4850 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;for example.&quot;</span></span>
<span class="lineno"> 4851 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4852 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4853 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_conditional_points_to_at_type&quot; &quot;Term -&gt; SetupValue -&gt; LLVMType -&gt; SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4854 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_conditional_points_to_at_type)</span></span>
<span class="lineno"> 4855 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4856 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A variant of `llvm_conditional_points_to` that casts the pointer to&quot;</span></span>
<span class="lineno"> 4857 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;another type. This may be useful when reading or writing a prefix&quot;</span></span>
<span class="lineno"> 4858 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of larger array, for example.&quot;</span></span>
<span class="lineno"> 4859 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4860 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4861 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_points_to_untyped&quot; &quot;SetupValue -&gt; SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4862 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (llvm_points_to False))</span>
<span class="lineno"> 4863 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4864 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A variant of `llvm_points_to` that does not check for compatibility&quot;</span></span>
<span class="lineno"> 4865 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;between the pointer type and the value type. This may be useful when&quot;</span></span>
<span class="lineno"> 4866 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;reading or writing a prefix of larger array, for example.&quot;</span></span>
<span class="lineno"> 4867 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4868 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_points_to_untyped&quot; &quot;SetupValue -&gt; SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4869 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (llvm_points_to False))</span></span>
<span class="lineno"> 4870 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4871 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_points_to`.&quot; ]</span></span>
<span class="lineno"> 4872 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4873 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_conditional_points_to_untyped&quot; &quot;Term -&gt; SetupValue -&gt; SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4874 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (llvm_conditional_points_to False))</span></span>
<span class="lineno"> 4875 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4876 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A variant of `llvm_conditional_points_to` that does not check for&quot;</span></span>
<span class="lineno"> 4877 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;compatibility between the pointer type and the value type. This may&quot;</span></span>
<span class="lineno"> 4878 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;be useful when reading or writing a prefix of larger array, for example.&quot;</span></span>
<span class="lineno"> 4879 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4880 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_conditional_points_to_untyped&quot; &quot;Term -&gt; SetupValue -&gt; SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4881 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (llvm_conditional_points_to False))</span></span>
<span class="lineno"> 4882 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4883 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_conditional_points_to`.&quot; ]</span></span>
<span class="lineno"> 4884 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4885 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_points_to_array_prefix&quot; &quot;SetupValue -&gt; Term -&gt; Term -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4886 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_points_to_array_prefix)</span>
<span class="lineno"> 4887 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4888 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the memory location indicated by the given pointer (first&quot;</span></span>
<span class="lineno"> 4889 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;argument) contains the prefix of the given array (second argument) of&quot;</span></span>
<span class="lineno"> 4890 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the given size (third argument).&quot;</span></span>
<span class="lineno"> 4891 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4892 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the pre-state section (before `llvm_execute_func`) this specifies&quot;</span></span>
<span class="lineno"> 4893 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the initial memory layout before function execution. In the post-state&quot;</span></span>
<span class="lineno"> 4894 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section (after `llvm_execute_func`), this specifies an assertion&quot;</span></span>
<span class="lineno"> 4895 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;about the final memory state after running the function.&quot;</span></span>
<span class="lineno"> 4896 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4897 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_points_to_array_prefix&quot; &quot;SetupValue -&gt; Term -&gt; Term -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4898 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_points_to_array_prefix)</span></span>
<span class="lineno"> 4899 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4900 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_points_to_array_prefix`.&quot; ]</span></span>
<span class="lineno"> 4901 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4902 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_points_to_bitfield&quot; &quot;SetupValue -&gt; String -&gt; SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4903 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (llvm_points_to_bitfield))</span>
<span class="lineno"> 4904 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4905 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A variant of `llvm_points_to` that is meant to be used on struct fields&quot;</span></span>
<span class="lineno"> 4906 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;that reside within bitfields. `llvm_points_to_bitfield ptr fieldName rhs`&quot;</span></span>
<span class="lineno"> 4907 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;should be used instead of `llvm_points_to (llvm_field ptr fieldName) rhs`,&quot;</span></span>
<span class="lineno"> 4908 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;as the latter will not behave as one would expect for technical reasons.&quot;</span></span>
<span class="lineno"> 4909 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4910 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This command should only be used in combination with&quot;</span></span>
<span class="lineno"> 4911 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;`enable_lax_loads_and_stores`, as this option relaxes some assumptions&quot;</span></span>
<span class="lineno"> 4912 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;about the memory model that are crucial to how `llvm_points_to_bitfield`&quot;</span></span>
<span class="lineno"> 4913 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;operates.&quot;</span></span>
<span class="lineno"> 4914 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4915 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4916 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_equal&quot; &quot;SetupValue -&gt; SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4917 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_equal)</span>
<span class="lineno"> 4918 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4919 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that two LLVM values should be equal. Can be used as either a&quot;</span></span>
<span class="lineno"> 4920 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;pre-condition or a post-condition. It is semantically equivalent to&quot;</span></span>
<span class="lineno"> 4921 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;an `llvm_precond` or `llvm_postcond` statement which is an equality&quot;</span></span>
<span class="lineno"> 4922 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;predicate, but potentially more efficient.&quot;</span></span>
<span class="lineno"> 4923 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4924 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_equal&quot; &quot;SetupValue -&gt; SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4925 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_equal)</span></span>
<span class="lineno"> 4926 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4927 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_equal`.&quot; ]</span></span>
<span class="lineno"> 4928 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4929 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_precond&quot; &quot;Term -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4930 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_precond)</span>
<span class="lineno"> 4931 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4932 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that the given predicate is a pre-condition on execution of the&quot;</span></span>
<span class="lineno"> 4933 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;function being verified.&quot;</span></span>
<span class="lineno"> 4934 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4935 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_precond&quot; &quot;Term -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4936 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_precond)</span>
<span class="lineno"> 4937 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4938 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_precond`.&quot; ]</span></span>
<span class="lineno"> 4939 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4940 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_assert&quot; &quot;Term -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4941 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_assert)</span>
<span class="lineno"> 4942 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4943 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that the given predicate must hold.  Acts as `llvm_precond`&quot;</span></span>
<span class="lineno"> 4944 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;or `llvm_postcond` depending on the phase of specification in which&quot;</span></span>
<span class="lineno"> 4945 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;it appears (i.e., before or after `llvm_execute_func`).&quot;</span></span>
<span class="lineno"> 4946 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4947 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4948 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_setup_with_tag&quot; &quot;String -&gt; LLVMSetup () -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4949 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_setup_with_tag)</span>
<span class="lineno"> 4950 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4951 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;All conditions (e.g., from points-to or assert statements) executed&quot;</span></span>
<span class="lineno"> 4952 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the scope of the given setup block will have the provieded string&quot;</span></span>
<span class="lineno"> 4953 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;attached as a tag that can later be filtered by proof tactics.&quot;</span></span>
<span class="lineno"> 4954 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4955 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4956 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_postcond&quot; &quot;Term -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4957 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_postcond)</span>
<span class="lineno"> 4958 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4959 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that the given predicate is a post-condition of execution of the&quot;</span></span>
<span class="lineno"> 4960 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;function being verified.&quot;</span></span>
<span class="lineno"> 4961 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4962 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_postcond&quot; &quot;Term -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4963 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_postcond)</span>
<span class="lineno"> 4964 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4965 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_postcond`.&quot; ]</span></span>
<span class="lineno"> 4966 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4967 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_execute_func&quot; &quot;[SetupValue] -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4968 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_execute_func)</span>
<span class="lineno"> 4969 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4970 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specify the given list of values as the arguments of the function.&quot;</span></span>
<span class="lineno"> 4971 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">,  &quot;&quot;</span></span>
<span class="lineno"> 4972 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The `llvm_execute_func` statement also serves to separate the pre-state&quot;</span></span>
<span class="lineno"> 4973 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section of the spec (before `llvm_execute_func`) from the post-state&quot;</span></span>
<span class="lineno"> 4974 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section (after `llvm_execute_func`). The effects of some LLVMSetup&quot;</span></span>
<span class="lineno"> 4975 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;statements depend on whether they occur in the pre-state or post-state&quot;</span></span>
<span class="lineno"> 4976 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section.&quot;</span></span>
<span class="lineno"> 4977 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4978 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_execute_func&quot; &quot;[SetupValue] -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4979 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_execute_func)</span></span>
<span class="lineno"> 4980 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4981 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_execute_func`.&quot; ]</span></span>
<span class="lineno"> 4982 </span><span class="spaces">  </span><span class="istickedoff">] ++</span>
<span class="lineno"> 4983 </span><span class="spaces">    </span><span class="istickedoff">let <span class="nottickedoff">unint_help =</span></span>
<span class="lineno"> 4984 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Keep the given Cryptol/SAWCore names opaque during symbolic simulation.&quot;</span></span>
<span class="lineno"> 4985 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">, &quot;The command should be used before symbolic execution begins&quot;</span></span>
<span class="lineno"> 4986 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">, &quot;(i.e., in the pre-condition of the specification).&quot;</span></span>
<span class="lineno"> 4987 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">, &quot;This command does not affect the ProofScript---to keep names&quot;</span></span>
<span class="lineno"> 4988 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">, &quot;opaque while discharging goals, you still need to provide them&quot;</span></span>
<span class="lineno"> 4989 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">, &quot;as explicit arguments to the relevant proof tactics.&quot;</span></span>
<span class="lineno"> 4990 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4991 </span><span class="spaces">    </span><span class="istickedoff">in</span>
<span class="lineno"> 4992 </span><span class="spaces">  </span><span class="istickedoff">[ prim &quot;llvm_unint&quot; &quot;[String] -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4993 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_unint) Current <span class="nottickedoff">unint_help</span></span>
<span class="lineno"> 4994 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4995 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_unint&quot; &quot;[String] -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 4996 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal jvm_unint)</span> Current <span class="nottickedoff">unint_help</span></span>
<span class="lineno"> 4997 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4998 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_unint&quot; &quot;[String] -&gt; MIRSetup ()&quot;</span>
<span class="lineno"> 4999 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal mir_unint)</span> <span class="nottickedoff">Current</span> <span class="nottickedoff">unint_help</span></span>
<span class="lineno"> 5000 </span><span class="spaces">  </span><span class="istickedoff">]</span>
<span class="lineno"> 5001 </span><span class="spaces">  </span><span class="istickedoff">++</span>
<span class="lineno"> 5002 </span><span class="spaces">  </span><span class="istickedoff">[ prim &quot;llvm_return&quot; &quot;SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 5003 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_return)</span>
<span class="lineno"> 5004 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5005 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specify the given value as the return value of the function. A&quot;</span></span>
<span class="lineno"> 5006 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;crucible_return statement is required if and only if the function&quot;</span></span>
<span class="lineno"> 5007 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;has a non-void return type.&quot; ]</span></span>
<span class="lineno"> 5008 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_return&quot; &quot;SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 5009 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_return)</span>
<span class="lineno"> 5010 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5011 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_return`.&quot; ]</span></span>
<span class="lineno"> 5012 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5013 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_cast_pointer&quot; &quot;SetupValue -&gt; LLVMType -&gt; SetupValue&quot;</span>
<span class="lineno"> 5014 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_cast_pointer)</span>
<span class="lineno"> 5015 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5016 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Cast the type of the given setup value (which must be a pointer value).&quot;</span></span>
<span class="lineno"> 5017 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The resulting setup value will be a pointer to the same location, treated&quot;</span></span>
<span class="lineno"> 5018 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;as a pointer to the provided type.&quot;</span></span>
<span class="lineno"> 5019 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5020 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5021 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_verify&quot;</span>
<span class="lineno"> 5022 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; [LLVMSpec] -&gt; Bool -&gt; LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;</span>
<span class="lineno"> 5023 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_verify)</span>
<span class="lineno"> 5024 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5025 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Verify the LLVM function named by the second parameter in the module&quot;</span></span>
<span class="lineno"> 5026 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specified by the first. The third parameter lists the LLVMSpec&quot;</span></span>
<span class="lineno"> 5027 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;values returned by previous calls to use as overrides. The fourth (Bool)&quot;</span></span>
<span class="lineno"> 5028 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;parameter enables or disables path satisfiability checking. The fifth&quot;</span></span>
<span class="lineno"> 5029 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;describes how to set up the symbolic execution engine before verification.&quot;</span></span>
<span class="lineno"> 5030 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;And the last gives the script to use to prove the validity of the resulting&quot;</span></span>
<span class="lineno"> 5031 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;verification conditions.&quot;</span></span>
<span class="lineno"> 5032 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5033 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_llvm_verify&quot;</span>
<span class="lineno"> 5034 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; [LLVMSpec] -&gt; Bool -&gt; LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;</span>
<span class="lineno"> 5035 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_verify)</span></span>
<span class="lineno"> 5036 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5037 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_verify`.&quot; ]</span></span>
<span class="lineno"> 5038 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5039 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_refine_spec&quot;</span>
<span class="lineno"> 5040 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; [LLVMSpec] -&gt; LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;</span>
<span class="lineno"> 5041 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_refine_spec)</span>
<span class="lineno"> 5042 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5043 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Verify that a given specification for a function is a refinement of one or more&quot;</span></span>
<span class="lineno"> 5044 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specifications already proved for a function. This can be useful for situations where&quot;</span></span>
<span class="lineno"> 5045 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;it is advantageous to logically restate the specification in some way, or where a more&quot;</span></span>
<span class="lineno"> 5046 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;general specification can be constructed from a collection of individual, more specific,&quot;</span></span>
<span class="lineno"> 5047 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specifications.&quot;</span></span>
<span class="lineno"> 5048 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5049 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5050 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_unsafe_assume_spec&quot;</span>
<span class="lineno"> 5051 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; LLVMSetup () -&gt; TopLevel LLVMSpec&quot;</span>
<span class="lineno"> 5052 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_unsafe_assume_spec)</span>
<span class="lineno"> 5053 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5054 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return an LLVMSpec corresponding to an LLVMSetup block,&quot;</span></span>
<span class="lineno"> 5055 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;as would be returned by crucible_llvm_verify but without performing&quot;</span></span>
<span class="lineno"> 5056 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;any verification.&quot;</span></span>
<span class="lineno"> 5057 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5058 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_llvm_unsafe_assume_spec&quot;</span>
<span class="lineno"> 5059 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; LLVMSetup () -&gt; TopLevel LLVMSpec&quot;</span>
<span class="lineno"> 5060 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_unsafe_assume_spec)</span></span>
<span class="lineno"> 5061 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5062 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_unsafe_assume_spec`.&quot; ]</span></span>
<span class="lineno"> 5063 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5064 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_array_size_profile&quot;</span>
<span class="lineno"> 5065 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; [LLVMSpec] -&gt; LLVMSetup () -&gt; TopLevel [(String, [FunctionProfile])]&quot;</span>
<span class="lineno"> 5066 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal $ llvm_array_size_profile assumeUnsat)</span></span>
<span class="lineno"> 5067 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5068 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Symbolically execute the function named by the second parameter in&quot;</span></span>
<span class="lineno"> 5069 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the module specified by the first. The fourth parameter may be used&quot;</span></span>
<span class="lineno"> 5070 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to specify arguments. Returns profiles specifying the sizes of buffers&quot;</span></span>
<span class="lineno"> 5071 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;referred to by pointer arguments for the function and all other functions&quot;</span></span>
<span class="lineno"> 5072 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;it calls (recursively), to be passed to llvm_boilerplate.&quot;</span></span>
<span class="lineno"> 5073 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5074 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_llvm_array_size_profile&quot;</span>
<span class="lineno"> 5075 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; [LLVMSpec] -&gt; LLVMSetup () -&gt; TopLevel [(String, [FunctionProfile])]&quot;</span>
<span class="lineno"> 5076 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal $ llvm_array_size_profile assumeUnsat)</span></span>
<span class="lineno"> 5077 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5078 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_array_size_profile`.&quot; ]</span></span>
<span class="lineno"> 5079 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5080 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_verify_x86&quot;</span>
<span class="lineno"> 5081 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; String -&gt; [(String, Int)] -&gt; Bool -&gt; LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;</span>
<span class="lineno"> 5082 </span><span class="spaces">    </span><span class="istickedoff">(pureVal do_llvm_verify_x86)</span>
<span class="lineno"> 5083 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5084 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Verify an x86 function from an ELF file for use as an override in an&quot;</span></span>
<span class="lineno"> 5085 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;LLVM verification. The first argument specifies the LLVM module&quot;</span></span>
<span class="lineno"> 5086 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;containing the _caller_. The second and third specify the ELF file&quot;</span></span>
<span class="lineno"> 5087 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;name and symbol name of the function to be verifier. The fourth&quot;</span></span>
<span class="lineno"> 5088 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specifies the names and sizes (in bytes) of global variables to&quot;</span></span>
<span class="lineno"> 5089 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;initialize, and the fifth whether to perform path satisfiability&quot;</span></span>
<span class="lineno"> 5090 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;checking. The last argument is the LLVM specification of the calling&quot;</span></span>
<span class="lineno"> 5091 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;context against which to verify the function. Returns a method spec&quot;</span></span>
<span class="lineno"> 5092 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;that can be used as an override when verifying other LLVM functions.&quot;</span></span>
<span class="lineno"> 5093 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5094 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_llvm_verify_x86&quot;</span>
<span class="lineno"> 5095 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; String -&gt; [(String, Int)] -&gt; Bool -&gt; LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;</span>
<span class="lineno"> 5096 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_llvm_verify_x86)</span></span>
<span class="lineno"> 5097 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5098 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_verify_x86`.&quot; ]</span></span>
<span class="lineno"> 5099 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5100 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_verify_fixpoint_x86&quot;</span>
<span class="lineno"> 5101 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; String -&gt; [(String, Int)] -&gt; Bool -&gt; Term -&gt; LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;</span>
<span class="lineno"> 5102 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_llvm_verify_fixpoint_x86)</span></span>
<span class="lineno"> 5103 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5104 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;An experimental variant of 'llvm_verify_x86'. This variant can prove some properties&quot;</span></span>
<span class="lineno"> 5105 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;involving simple loops with the help of a user-provided term that describes how&quot;</span></span>
<span class="lineno"> 5106 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the live variables in the loop evolve as the loop computes.&quot;</span></span>
<span class="lineno"> 5107 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5108 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5109 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_verify_fixpoint_chc_x86&quot;</span>
<span class="lineno"> 5110 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; String -&gt; [(String, Int)] -&gt; Bool -&gt; Term -&gt; LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;</span>
<span class="lineno"> 5111 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_llvm_verify_fixpoint_chc_x86)</span></span>
<span class="lineno"> 5112 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5113 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;An experimental variant of 'llvm_verify_x86'. This variant can prove some properties&quot;</span></span>
<span class="lineno"> 5114 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;involving simple loops with the help of a user-provided term that describes how&quot;</span></span>
<span class="lineno"> 5115 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the live variables in the loop evolve as the loop computes.&quot;</span></span>
<span class="lineno"> 5116 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5117 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This differs from 'llvm_verify_fixpoint_x86' in that it leverages Z3's&quot;</span></span>
<span class="lineno"> 5118 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;constrained horn-clause (CHC) functionality to synthesize some of the&quot;</span></span>
<span class="lineno"> 5119 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;loop's properties.&quot;</span></span>
<span class="lineno"> 5120 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5121 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5122 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_verify_x86_with_invariant&quot;</span>
<span class="lineno"> 5123 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; String -&gt; [(String, Int)] -&gt; Bool -&gt; (String, Int, Term) -&gt; LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;</span>
<span class="lineno"> 5124 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_llvm_verify_x86_with_invariant)</span></span>
<span class="lineno"> 5125 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5126 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;An experimental extension of 'llvm_verify_x86'. This extension can prove some properties&quot;</span></span>
<span class="lineno"> 5127 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;involving simple loops with the help of a user-provided loop invariant that describes&quot;</span></span>
<span class="lineno"> 5128 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;how the live variables in the loop evolve as the loop computes.&quot;</span></span>
<span class="lineno"> 5129 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5130 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The loop invariant is provided by the tuple argument, which indicates what symbol the loop&quot;</span></span>
<span class="lineno"> 5131 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;appears in (which might differ from the function the specification is for), which loop within&quot;</span></span>
<span class="lineno"> 5132 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;that function to reason about (starts counting from 0), and a term that desribes the loop invariant&quot;</span></span>
<span class="lineno"> 5133 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;itself. For this verification command to succeed, the loop in question must have a single entry-point,&quot;</span></span>
<span class="lineno"> 5134 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;must have a single back-edge, and must have a constant memory footprint.&quot;</span></span>
<span class="lineno"> 5135 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5136 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The SAWCore type expected of the loop invariant will depend on the results of an analysis done&quot;</span></span>
<span class="lineno"> 5137 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;on the indicated loop, which will attempt to discover what are all the loop-carried dependencies.&quot;</span></span>
<span class="lineno"> 5138 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The result of this analysis will be packaged into a tuple, and any relevant top-level specification&quot;</span></span>
<span class="lineno"> 5139 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;variables will be found. The expected type of the loop invariant will then be a function over all&quot;</span></span>
<span class="lineno"> 5140 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the implicit variables found, and two tuples consisting of the initial values of the loop-carried&quot;</span></span>
<span class="lineno"> 5141 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;dependencies, and the current value of the loop-carried dependencies. The function should return Bool.&quot;</span></span>
<span class="lineno"> 5142 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Some trial-and-error will generally be required to match the results of the analysis with a sutiable&quot;</span></span>
<span class="lineno"> 5143 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;function.&quot;</span></span>
<span class="lineno"> 5144 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5145 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;As part of the verification process, the loop invariant will be used in several ways. First, a proof&quot;</span></span>
<span class="lineno"> 5146 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;obligation will be issued upon first entry to the loop, establishing the loop invariant holds at the&quot;</span></span>
<span class="lineno"> 5147 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;beginning of the loop. Second, the loop invariant is used when starting execution from the loop head&quot;</span></span>
<span class="lineno"> 5148 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to make a generic assumption that the invariant holds. Finally, the invariant is used when execution&quot;</span></span>
<span class="lineno"> 5149 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;once again reaches the loop head to assert that the invariant holds inductively across the execution&quot;</span></span>
<span class="lineno"> 5150 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of the loop body. The produced proof obligations will be tagged with either the tag&quot;</span></span>
<span class="lineno"> 5151 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'initial loop invariant' or 'inductive loop invariant'.&quot;</span></span>
<span class="lineno"> 5152 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5153 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Provided all the generated verification conditions are discharged, this results in a partial&quot;</span></span>
<span class="lineno"> 5154 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;correctness proof for the indicated function. Note that termination is not proved via this procedure.&quot;</span></span>
<span class="lineno"> 5155 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5156 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5157 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_x86_what4_hash_consing&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 5158 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal enable_x86_what4_hash_consing)</span></span>
<span class="lineno"> 5159 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5160 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable hash consing for What4 expressions during x86 verification.&quot; ]</span></span>
<span class="lineno"> 5161 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5162 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_x86_what4_hash_consing&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 5163 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_x86_what4_hash_consing)</span></span>
<span class="lineno"> 5164 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 5165 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable hash consing for What4 expressions during x86 verification.&quot; ]</span></span>
<span class="lineno"> 5166 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5167 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;add_x86_preserved_reg&quot; &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 5168 </span><span class="spaces">    </span><span class="istickedoff">(pureVal add_x86_preserved_reg)</span>
<span class="lineno"> 5169 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5170 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Treat the given register as callee-saved during x86 verification.&quot; ]</span></span>
<span class="lineno"> 5171 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5172 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;default_x86_preserved_reg&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 5173 </span><span class="spaces">    </span><span class="istickedoff">(pureVal default_x86_preserved_reg)</span>
<span class="lineno"> 5174 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5175 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the default set of callee-saved registers during x86 verification.&quot; ]</span></span>
<span class="lineno"> 5176 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5177 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_what4_eval&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 5178 </span><span class="spaces">    </span><span class="istickedoff">(pureVal enable_what4_eval)</span>
<span class="lineno"> 5179 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5180 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable What4 translation for SAWCore expressions during Crucible symbolic execution.&quot; ]</span></span>
<span class="lineno"> 5181 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5182 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_what4_eval&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 5183 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_what4_eval)</span></span>
<span class="lineno"> 5184 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 5185 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable What4 translation for SAWCore expressions during Crucible symbolic execution.&quot; ]</span></span>
<span class="lineno"> 5186 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5187 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_x86_stack_base_align&quot; &quot;Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 5188 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_x86_stack_base_align)</span></span>
<span class="lineno"> 5189 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5190 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Set the alignment of the stack allocation base to 2^n during x86 verification.&quot; ]</span></span>
<span class="lineno"> 5191 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5192 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;default_x86_stack_base_align&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 5193 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal default_x86_stack_base_align)</span></span>
<span class="lineno"> 5194 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5195 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the default stack allocation base alignment during x86 verification.&quot; ]</span></span>
<span class="lineno"> 5196 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5197 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_alloc_sym_init_check&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 5198 </span><span class="spaces">    </span><span class="istickedoff">(pureVal enable_alloc_sym_init_check)</span>
<span class="lineno"> 5199 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5200 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable the allocation initialization check associated with alloc_sym_init during override application.&quot; ]</span></span>
<span class="lineno"> 5201 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5202 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_alloc_sym_init_check&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 5203 </span><span class="spaces">    </span><span class="istickedoff">(pureVal disable_alloc_sym_init_check)</span>
<span class="lineno"> 5204 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5205 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable the allocation initialization check associated with alloc_sym_init during override application.&quot;</span></span>
<span class="lineno"> 5206 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Disabling this check allows an override to apply when the memory region specified by the alloc_sym_init command&quot;</span></span>
<span class="lineno"> 5207 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the override specification is not written to in the calling context.&quot;</span></span>
<span class="lineno"> 5208 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This makes the implicit assumption that there is some unspecified byte at any valid memory address.&quot;</span></span>
<span class="lineno"> 5209 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5210 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5211 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_no_satisfying_write_fresh_constant&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 5212 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal enable_no_satisfying_write_fresh_constant)</span></span>
<span class="lineno"> 5213 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5214 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;When simulating LLVM code that performs an invalid write, make a fresh&quot;</span></span>
<span class="lineno"> 5215 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;constant as a proof obligation. This constant will always fail, but it&quot;</span></span>
<span class="lineno"> 5216 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;will also not be constant-folded away.&quot;</span></span>
<span class="lineno"> 5217 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5218 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5219 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_no_satisfying_write_fresh_constant&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 5220 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_no_satisfying_write_fresh_constant)</span></span>
<span class="lineno"> 5221 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5222 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;When simulating LLVM code that performs an invalid write, return 'false'&quot;</span></span>
<span class="lineno"> 5223 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;as a proof obligation.&quot;</span></span>
<span class="lineno"> 5224 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5225 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5226 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_what4_push_mux_ops&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 5227 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal enable_what4_push_mux_ops)</span></span>
<span class="lineno"> 5228 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5229 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Push certain What4 operations (e.g., 'zext') down to the branches of&quot;</span></span>
<span class="lineno"> 5230 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'ite' expressions as much as possible. In some (but not all) circumstances,&quot;</span></span>
<span class="lineno"> 5231 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;this can result in operations that are easier for SMT solvers to reason&quot;</span></span>
<span class="lineno"> 5232 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;about.&quot;</span></span>
<span class="lineno"> 5233 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5234 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5235 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_what4_push_mux_ops&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 5236 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_what4_push_mux_ops)</span></span>
<span class="lineno"> 5237 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5238 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Do not push certain What4 operations (e.g., 'zext') down to the branches&quot;</span></span>
<span class="lineno"> 5239 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of 'ite' expressions as much as possible.&quot;</span></span>
<span class="lineno"> 5240 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5241 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5242 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_crucible_timeout&quot; &quot;Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 5243 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_crucible_timeout)</span></span>
<span class="lineno"> 5244 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5245 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Set the timeout for the SMT solver during the LLVM and X86 Crucible symbolic execution,&quot;</span></span>
<span class="lineno"> 5246 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">,&quot;in milliseconds (0 is no timeout). The default is 10000ms (10s).&quot;</span></span>
<span class="lineno"> 5247 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">,&quot;This is used for path-sat checks, and sat checks when applying overrides.&quot;</span></span>
<span class="lineno"> 5248 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5249 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5250 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_array_value&quot;</span>
<span class="lineno"> 5251 </span><span class="spaces">    </span><span class="istickedoff">&quot;[SetupValue] -&gt; SetupValue&quot;</span>
<span class="lineno"> 5252 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CIR.anySetupArray)</span>
<span class="lineno"> 5253 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5254 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a SetupValue representing an array, with the given list of&quot;</span></span>
<span class="lineno"> 5255 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;values as elements. The list must be non-empty.&quot; ]</span></span>
<span class="lineno"> 5256 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_array&quot;</span>
<span class="lineno"> 5257 </span><span class="spaces">    </span><span class="istickedoff">&quot;[SetupValue] -&gt; SetupValue&quot;</span>
<span class="lineno"> 5258 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal CIR.anySetupArray)</span></span>
<span class="lineno"> 5259 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 5260 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_array_value`.&quot; ]</span></span>
<span class="lineno"> 5261 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5262 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_struct_type&quot;</span>
<span class="lineno"> 5263 </span><span class="spaces">    </span><span class="istickedoff">&quot;[LLVMType] -&gt; LLVMType&quot;</span>
<span class="lineno"> 5264 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_struct_type)</span>
<span class="lineno"> 5265 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5266 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of an LLVM struct with elements of the given types.&quot; ]</span></span>
<span class="lineno"> 5267 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5268 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_struct_value&quot;</span>
<span class="lineno"> 5269 </span><span class="spaces">    </span><span class="istickedoff">&quot;[SetupValue] -&gt; SetupValue&quot;</span>
<span class="lineno"> 5270 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CIR.anySetupStruct False))</span>
<span class="lineno"> 5271 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5272 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a SetupValue representing a struct, with the given list of&quot;</span></span>
<span class="lineno"> 5273 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;values as elements.&quot; ]</span></span>
<span class="lineno"> 5274 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_struct&quot;</span>
<span class="lineno"> 5275 </span><span class="spaces">    </span><span class="istickedoff">&quot;[SetupValue] -&gt; SetupValue&quot;</span>
<span class="lineno"> 5276 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (CIR.anySetupStruct False))</span></span>
<span class="lineno"> 5277 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 5278 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_struct_value`.&quot; ]</span></span>
<span class="lineno"> 5279 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5280 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_packed_struct_type&quot;</span>
<span class="lineno"> 5281 </span><span class="spaces">    </span><span class="istickedoff">&quot;[LLVMType] -&gt; LLVMType&quot;</span>
<span class="lineno"> 5282 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_packed_struct_type)</span>
<span class="lineno"> 5283 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5284 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of a packed LLVM struct with elements of the given types.&quot; ]</span></span>
<span class="lineno"> 5285 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5286 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_packed_struct_value&quot;</span>
<span class="lineno"> 5287 </span><span class="spaces">    </span><span class="istickedoff">&quot;[SetupValue] -&gt; SetupValue&quot;</span>
<span class="lineno"> 5288 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CIR.anySetupStruct True))</span>
<span class="lineno"> 5289 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5290 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a SetupValue representing a packed struct, with the given&quot;</span></span>
<span class="lineno"> 5291 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;list of values as elements.&quot; ]</span></span>
<span class="lineno"> 5292 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_packed_struct&quot;</span>
<span class="lineno"> 5293 </span><span class="spaces">    </span><span class="istickedoff">&quot;[SetupValue] -&gt; SetupValue&quot;</span>
<span class="lineno"> 5294 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (CIR.anySetupStruct True))</span></span>
<span class="lineno"> 5295 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 5296 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_packed_struct_value`.&quot; ]</span></span>
<span class="lineno"> 5297 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5298 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_elem&quot;</span>
<span class="lineno"> 5299 </span><span class="spaces">    </span><span class="istickedoff">&quot;SetupValue -&gt; Int -&gt; SetupValue&quot;</span>
<span class="lineno"> 5300 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CIR.anySetupElem)</span>
<span class="lineno"> 5301 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5302 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Turn a SetupValue representing a struct or array pointer into&quot;</span></span>
<span class="lineno"> 5303 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a pointer to an element of the struct or array by field index.&quot; ]</span></span>
<span class="lineno"> 5304 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_elem&quot;</span>
<span class="lineno"> 5305 </span><span class="spaces">    </span><span class="istickedoff">&quot;SetupValue -&gt; Int -&gt; SetupValue&quot;</span>
<span class="lineno"> 5306 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal CIR.anySetupElem)</span></span>
<span class="lineno"> 5307 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 5308 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_elem`.&quot; ]</span></span>
<span class="lineno"> 5309 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5310 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_union&quot;</span>
<span class="lineno"> 5311 </span><span class="spaces">    </span><span class="istickedoff">&quot;SetupValue -&gt; String -&gt; SetupValue&quot;</span>
<span class="lineno"> 5312 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CIR.anySetupUnion)</span>
<span class="lineno"> 5313 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5314 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Turn a SetupValue representing a union pointer into&quot;</span></span>
<span class="lineno"> 5315 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a pointer to one of the branches of the union by field name.&quot;</span></span>
<span class="lineno"> 5316 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Requires debug symbols to resolve union field names.&quot;</span></span>
<span class="lineno"> 5317 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5318 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5319 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_field&quot;</span>
<span class="lineno"> 5320 </span><span class="spaces">    </span><span class="istickedoff">&quot;SetupValue -&gt; String -&gt; SetupValue&quot;</span>
<span class="lineno"> 5321 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CIR.anySetupField)</span>
<span class="lineno"> 5322 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5323 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Turn a SetupValue representing a struct pointer into&quot;</span></span>
<span class="lineno"> 5324 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a pointer to an element of the struct by field name.&quot;</span></span>
<span class="lineno"> 5325 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Requires debug symbols to resolve struct field names.&quot;</span></span>
<span class="lineno"> 5326 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5327 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_field&quot;</span>
<span class="lineno"> 5328 </span><span class="spaces">    </span><span class="istickedoff">&quot;SetupValue -&gt; String -&gt; SetupValue&quot;</span>
<span class="lineno"> 5329 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal CIR.anySetupField)</span></span>
<span class="lineno"> 5330 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 5331 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_field`.&quot; ]</span></span>
<span class="lineno"> 5332 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5333 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_null&quot;</span>
<span class="lineno"> 5334 </span><span class="spaces">    </span><span class="istickedoff">&quot;SetupValue&quot;</span>
<span class="lineno"> 5335 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CIR.anySetupNull)</span>
<span class="lineno"> 5336 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5337 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A SetupValue representing a null pointer value.&quot; ]</span></span>
<span class="lineno"> 5338 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_null&quot;</span>
<span class="lineno"> 5339 </span><span class="spaces">    </span><span class="istickedoff">&quot;SetupValue&quot;</span>
<span class="lineno"> 5340 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal CIR.anySetupNull)</span></span>
<span class="lineno"> 5341 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 5342 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_null`.&quot; ]</span></span>
<span class="lineno"> 5343 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5344 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_global&quot;</span>
<span class="lineno"> 5345 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; SetupValue&quot;</span>
<span class="lineno"> 5346 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CIR.anySetupGlobal)</span>
<span class="lineno"> 5347 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5348 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return a SetupValue representing a pointer to the named global.&quot;</span></span>
<span class="lineno"> 5349 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The String may be either the name of a global value or a function name.&quot; ]</span></span>
<span class="lineno"> 5350 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_global&quot;</span>
<span class="lineno"> 5351 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; SetupValue&quot;</span>
<span class="lineno"> 5352 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal CIR.anySetupGlobal)</span></span>
<span class="lineno"> 5353 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 5354 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_global`.&quot; ]</span></span>
<span class="lineno"> 5355 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5356 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_global_initializer&quot;</span>
<span class="lineno"> 5357 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; SetupValue&quot;</span>
<span class="lineno"> 5358 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CIR.anySetupGlobalInitializer)</span>
<span class="lineno"> 5359 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5360 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return a SetupValue representing the value of the initializer of a named&quot;</span></span>
<span class="lineno"> 5361 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;global. The String should be the name of a global value.&quot;</span></span>
<span class="lineno"> 5362 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5363 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_global_initializer&quot;</span>
<span class="lineno"> 5364 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; SetupValue&quot;</span>
<span class="lineno"> 5365 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal CIR.anySetupGlobalInitializer)</span></span>
<span class="lineno"> 5366 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 5367 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_global_initializer`.&quot; ]</span></span>
<span class="lineno"> 5368 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5369 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_term&quot;</span>
<span class="lineno"> 5370 </span><span class="spaces">    </span><span class="istickedoff">&quot;Term -&gt; SetupValue&quot;</span>
<span class="lineno"> 5371 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CIR.anySetupTerm)</span>
<span class="lineno"> 5372 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5373 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Construct a `SetupValue` from a `Term`.&quot; ]</span></span>
<span class="lineno"> 5374 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_term&quot;</span>
<span class="lineno"> 5375 </span><span class="spaces">    </span><span class="istickedoff">&quot;Term -&gt; SetupValue&quot;</span>
<span class="lineno"> 5376 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CIR.anySetupTerm)</span>
<span class="lineno"> 5377 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5378 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_term`.&quot; ]</span></span>
<span class="lineno"> 5379 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5380 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_setup_val_to_term&quot;</span>
<span class="lineno"> 5381 </span><span class="spaces">    </span><span class="istickedoff">&quot; SetupValue -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 5382 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal crucible_setup_val_to_typed_term)</span></span>
<span class="lineno"> 5383 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">HideDeprecated</span></span>
<span class="lineno"> 5384 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Convert from a setup value to a typed term. This can only be done for a&quot;</span></span>
<span class="lineno"> 5385 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;subset of setup values. Fails if a setup value is a global, variable or null.&quot;</span></span>
<span class="lineno"> 5386 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5387 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Expected to be removed in SAW 1.5.&quot;</span></span>
<span class="lineno"> 5388 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5389 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5390 </span><span class="spaces">  </span><span class="istickedoff">-- Ghost state support</span>
<span class="lineno"> 5391 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;declare_ghost_state&quot;</span>
<span class="lineno"> 5392 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; TopLevel Ghost&quot;</span>
<span class="lineno"> 5393 </span><span class="spaces">    </span><span class="istickedoff">(pureVal declare_ghost_state)</span>
<span class="lineno"> 5394 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5395 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Allocates a unique ghost variable.&quot; ]</span></span>
<span class="lineno"> 5396 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_declare_ghost_state&quot;</span>
<span class="lineno"> 5397 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; TopLevel Ghost&quot;</span>
<span class="lineno"> 5398 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal declare_ghost_state)</span></span>
<span class="lineno"> 5399 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 5400 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `declare_ghost_state`.&quot; ]</span></span>
<span class="lineno"> 5401 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_declare_ghost_state&quot;</span>
<span class="lineno"> 5402 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; TopLevel Ghost&quot;</span>
<span class="lineno"> 5403 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal declare_ghost_state)</span></span>
<span class="lineno"> 5404 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 5405 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `declare_ghost_state`.&quot; ]</span></span>
<span class="lineno"> 5406 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5407 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_ghost_value&quot;</span>
<span class="lineno"> 5408 </span><span class="spaces">    </span><span class="istickedoff">&quot;Ghost -&gt; Term -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 5409 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_ghost_value)</span>
<span class="lineno"> 5410 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5411 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specifies the value of a ghost variable. This can be used&quot;</span></span>
<span class="lineno"> 5412 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the pre- and post- conditions of a setup block.&quot;]</span></span>
<span class="lineno"> 5413 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_ghost_value&quot;</span>
<span class="lineno"> 5414 </span><span class="spaces">    </span><span class="istickedoff">&quot;Ghost -&gt; Term -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 5415 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_ghost_value)</span></span>
<span class="lineno"> 5416 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5417 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_ghost_value`.&quot;]</span></span>
<span class="lineno"> 5418 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5419 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_ghost_value&quot;</span>
<span class="lineno"> 5420 </span><span class="spaces">    </span><span class="istickedoff">&quot;Ghost -&gt; Term -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 5421 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal jvm_ghost_value)</span></span>
<span class="lineno"> 5422 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5423 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specifies the value of a ghost variable. This can be used&quot;</span></span>
<span class="lineno"> 5424 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the pre- and post- conditions of a setup block.&quot;]</span></span>
<span class="lineno"> 5425 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5426 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_ghost_value&quot;</span>
<span class="lineno"> 5427 </span><span class="spaces">    </span><span class="istickedoff">&quot;Ghost -&gt; Term -&gt; MIRSetup ()&quot;</span>
<span class="lineno"> 5428 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_ghost_value)</span>
<span class="lineno"> 5429 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5430 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specifies the value of a ghost variable. This can be used&quot;</span></span>
<span class="lineno"> 5431 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the pre- and post- conditions of a setup block.&quot;]</span></span>
<span class="lineno"> 5432 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5433 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_spec_solvers&quot;  &quot;LLVMSpec -&gt; [String]&quot;</span>
<span class="lineno"> 5434 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_spec_solvers)</span></span>
<span class="lineno"> 5435 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5436 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Extract a list of all the solvers used when verifying the given method spec.&quot;</span></span>
<span class="lineno"> 5437 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5438 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_spec_solvers&quot;  &quot;LLVMSpec -&gt; [String]&quot;</span>
<span class="lineno"> 5439 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_spec_solvers)</span></span>
<span class="lineno"> 5440 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5441 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_spec_solvers`.&quot; ]</span></span>
<span class="lineno"> 5442 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5443 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_spec_size&quot;  &quot;LLVMSpec -&gt; Int&quot;</span>
<span class="lineno"> 5444 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_spec_size)</span></span>
<span class="lineno"> 5445 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5446 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return a count of the combined size of all verification goals proved as part of&quot;</span></span>
<span class="lineno"> 5447 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the given method spec.&quot;</span></span>
<span class="lineno"> 5448 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5449 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_spec_size&quot;  &quot;LLVMSpec -&gt; Int&quot;</span>
<span class="lineno"> 5450 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_spec_size)</span></span>
<span class="lineno"> 5451 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5452 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_spec_size`.&quot; ]</span></span>
<span class="lineno"> 5453 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5454 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_ffi_setup&quot;  &quot;Term -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 5455 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_ffi_setup)</span>
<span class="lineno"> 5456 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5457 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Generate a @LLVMSetup@ spec that can be used to verify that the given&quot;</span></span>
<span class="lineno"> 5458 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;monomorphic Cryptol term, consisting of a Cryptol foreign function&quot;</span></span>
<span class="lineno"> 5459 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;fully applied to any type arguments, has a correct foreign (LLVM)&quot;</span></span>
<span class="lineno"> 5460 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;implementation with respect to its Cryptol implementation.&quot;</span></span>
<span class="lineno"> 5461 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5462 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5463 </span><span class="spaces">    </span><span class="istickedoff">----------------------------------------</span>
<span class="lineno"> 5464 </span><span class="spaces">    </span><span class="istickedoff">-- Crucible/JVM commands</span>
<span class="lineno"> 5465 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5466 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_fresh_var&quot; &quot;String -&gt; JavaType -&gt; JVMSetup Term&quot;</span>
<span class="lineno"> 5467 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_fresh_var)</span>
<span class="lineno"> 5468 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5469 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a fresh variable for use within a JVM specification. The&quot;</span></span>
<span class="lineno"> 5470 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;name is used only for pretty-printing.&quot;</span></span>
<span class="lineno"> 5471 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5472 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5473 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_alloc_object&quot; &quot;String -&gt; JVMSetup JVMValue&quot;</span>
<span class="lineno"> 5474 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_alloc_object)</span>
<span class="lineno"> 5475 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5476 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that an instance of the given class should be allocated in a&quot;</span></span>
<span class="lineno"> 5477 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;JVM specification. Before `jvm_execute_func`, this states that the&quot;</span></span>
<span class="lineno"> 5478 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;method expects the object to be allocated before it runs. After&quot;</span></span>
<span class="lineno"> 5479 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;`jvm_execute_func`, it states that the method being verified is&quot;</span></span>
<span class="lineno"> 5480 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;expected to perform the allocation.&quot;</span></span>
<span class="lineno"> 5481 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5482 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5483 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_alloc_array&quot; &quot;Int -&gt; JavaType -&gt; JVMSetup JVMValue&quot;</span>
<span class="lineno"> 5484 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_alloc_array)</span>
<span class="lineno"> 5485 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5486 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that an array of the given size and element type should be&quot;</span></span>
<span class="lineno"> 5487 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;allocated in a JVM specification. Before `jvm_execute_func`, this&quot;</span></span>
<span class="lineno"> 5488 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;states that the method expects the array to be allocated before it&quot;</span></span>
<span class="lineno"> 5489 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;runs. After `jvm_execute_func`, it states that the method being&quot;</span></span>
<span class="lineno"> 5490 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;verified is expected to perform the allocation.&quot;</span></span>
<span class="lineno"> 5491 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5492 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5493 </span><span class="spaces">    </span><span class="istickedoff">-- TODO: jvm_alloc_multiarray</span>
<span class="lineno"> 5494 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5495 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_modifies_field&quot; &quot;JVMValue -&gt; String -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 5496 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_modifies_field)</span>
<span class="lineno"> 5497 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5498 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the indicated object (first argument) has a field&quot;</span></span>
<span class="lineno"> 5499 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(second argument) containing an unspecified value.&quot;</span></span>
<span class="lineno"> 5500 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5501 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This lets users write partial specifications of JVM methods.&quot;</span></span>
<span class="lineno"> 5502 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the post-state section (after `jvm_execute_func`), this&quot;</span></span>
<span class="lineno"> 5503 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;states that the method may modify the field, but says&quot;</span></span>
<span class="lineno"> 5504 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;nothing about the new value.&quot;</span></span>
<span class="lineno"> 5505 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5506 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5507 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_modifies_static_field&quot; &quot;String -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 5508 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_modifies_static_field)</span>
<span class="lineno"> 5509 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5510 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the named static field contains an unspecified&quot;</span></span>
<span class="lineno"> 5511 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;value.&quot;</span></span>
<span class="lineno"> 5512 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5513 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This lets users write partial specifications of JVM methods.&quot;</span></span>
<span class="lineno"> 5514 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the post-state section (after `jvm_execute_func`), it&quot;</span></span>
<span class="lineno"> 5515 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;states that the method may modify the static field, but says&quot;</span></span>
<span class="lineno"> 5516 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;nothing about the new value.&quot;</span></span>
<span class="lineno"> 5517 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5518 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5519 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_modifies_elem&quot; &quot;JVMValue -&gt; Int -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 5520 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_modifies_elem)</span>
<span class="lineno"> 5521 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5522 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the indicated array (first argument) has an element&quot;</span></span>
<span class="lineno"> 5523 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(second argument) containing an unspecified value.&quot;</span></span>
<span class="lineno"> 5524 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5525 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This lets users write partial specifications of JVM methods.&quot;</span></span>
<span class="lineno"> 5526 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the post-state section (after `jvm_execute_func`), it&quot;</span></span>
<span class="lineno"> 5527 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;states that the method may modify the array element, but says&quot;</span></span>
<span class="lineno"> 5528 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;nothing about the new value.&quot;</span></span>
<span class="lineno"> 5529 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5530 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5531 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_modifies_array&quot; &quot;JVMValue -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 5532 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_modifies_array)</span>
<span class="lineno"> 5533 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5534 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the indicated array's elements contain unspecified&quot;</span></span>
<span class="lineno"> 5535 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;values.&quot;</span></span>
<span class="lineno"> 5536 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5537 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This lets users write partial specifications of JVM methods.&quot;</span></span>
<span class="lineno"> 5538 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the post-state section (after `jvm_execute_func`), it&quot;</span></span>
<span class="lineno"> 5539 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;states that the method may modify the array elements, but says&quot;</span></span>
<span class="lineno"> 5540 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;nothing about the new values.&quot;</span></span>
<span class="lineno"> 5541 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5542 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5543 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_field_is&quot; &quot;JVMValue -&gt; String -&gt; JVMValue -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 5544 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_field_is)</span>
<span class="lineno"> 5545 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5546 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the indicated object (first argument) has a field&quot;</span></span>
<span class="lineno"> 5547 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(second argument) containing the given value (third argument).&quot;</span></span>
<span class="lineno"> 5548 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5549 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the pre-state section (before jvm_execute_func) this specifies&quot;</span></span>
<span class="lineno"> 5550 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the initial memory layout before function execution. In the post-state&quot;</span></span>
<span class="lineno"> 5551 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section (after jvm_execute_func), this specifies an assertion&quot;</span></span>
<span class="lineno"> 5552 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;about the final memory state after running the function.&quot;</span></span>
<span class="lineno"> 5553 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5554 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5555 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_static_field_is&quot; &quot;String -&gt; JVMValue -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 5556 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_static_field_is)</span>
<span class="lineno"> 5557 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5558 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the named static field contains the given value.&quot;</span></span>
<span class="lineno"> 5559 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;By default the field name is assumed to belong to the same class&quot;</span></span>
<span class="lineno"> 5560 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;as the method being specified. Static fields belonging to other&quot;</span></span>
<span class="lineno"> 5561 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;classes can be selected using the \&quot;&lt;classname&gt;.&lt;fieldname&gt;\&quot;&quot;</span></span>
<span class="lineno"> 5562 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;syntax in the string argument.&quot;</span></span>
<span class="lineno"> 5563 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5564 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the pre-state section (before jvm_execute_func) this specifies&quot;</span></span>
<span class="lineno"> 5565 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the initial memory layout before function execution. In the post-state&quot;</span></span>
<span class="lineno"> 5566 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section (after jvm_execute_func), this specifies an assertion&quot;</span></span>
<span class="lineno"> 5567 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;about the final memory state after running the function.&quot;</span></span>
<span class="lineno"> 5568 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5569 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5570 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_elem_is&quot; &quot;JVMValue -&gt; Int -&gt; JVMValue -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 5571 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_elem_is)</span>
<span class="lineno"> 5572 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5573 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the indicated array (first argument) has an element&quot;</span></span>
<span class="lineno"> 5574 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(second argument) containing the given value (third argument).&quot;</span></span>
<span class="lineno"> 5575 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5576 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the pre-state section (before jvm_execute_func) this specifies&quot;</span></span>
<span class="lineno"> 5577 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the initial memory layout before function execution. In the post-state&quot;</span></span>
<span class="lineno"> 5578 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section (after jvm_execute_func), this specifies an assertion&quot;</span></span>
<span class="lineno"> 5579 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;about the final memory state after running the function.&quot;</span></span>
<span class="lineno"> 5580 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5581 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5582 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_array_is&quot; &quot;JVMValue -&gt; Term -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 5583 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_array_is)</span>
<span class="lineno"> 5584 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5585 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the indicated array reference (first argument) contains&quot;</span></span>
<span class="lineno"> 5586 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the given sequence of values (second argument).&quot;</span></span>
<span class="lineno"> 5587 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5588 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the pre-state section (before jvm_execute_func) this specifies&quot;</span></span>
<span class="lineno"> 5589 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the initial memory layout before function execution. In the post-state&quot;</span></span>
<span class="lineno"> 5590 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section (after jvm_execute_func), this specifies an assertion&quot;</span></span>
<span class="lineno"> 5591 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;about the final memory state after running the function.&quot;</span></span>
<span class="lineno"> 5592 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5593 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5594 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_precond&quot; &quot;Term -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 5595 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_precond)</span>
<span class="lineno"> 5596 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5597 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that the given predicate is a pre-condition on execution of the&quot;</span></span>
<span class="lineno"> 5598 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;method being verified.&quot;</span></span>
<span class="lineno"> 5599 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5600 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5601 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_assert&quot; &quot;Term -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 5602 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_assert)</span>
<span class="lineno"> 5603 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5604 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that the given predicate must hold.  Acts as `jvm_precond`&quot;</span></span>
<span class="lineno"> 5605 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;or `jvm_postcond` depending on the phase of specification in which&quot;</span></span>
<span class="lineno"> 5606 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;it appears (i.e., before or after `jvm_execute_func`).&quot;</span></span>
<span class="lineno"> 5607 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5608 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5609 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_postcond&quot; &quot;Term -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 5610 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal jvm_postcond)</span></span>
<span class="lineno"> 5611 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5612 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that the given predicate is a post-condition of execution of the&quot;</span></span>
<span class="lineno"> 5613 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;method being verified.&quot;</span></span>
<span class="lineno"> 5614 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5615 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5616 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_equal&quot; &quot;JVMValue -&gt; JVMValue -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 5617 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_equal)</span>
<span class="lineno"> 5618 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5619 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that two JVM values should be equal. Can be used as either a&quot;</span></span>
<span class="lineno"> 5620 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;pre-condition or a post-condition. It is semantically equivalent to&quot;</span></span>
<span class="lineno"> 5621 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;an `jvm_precond` or `jvm_postcond` statement which is an equality&quot;</span></span>
<span class="lineno"> 5622 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;predicate, but potentially more efficient.&quot;</span></span>
<span class="lineno"> 5623 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5624 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5625 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_execute_func&quot; &quot;[JVMValue] -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 5626 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_execute_func)</span>
<span class="lineno"> 5627 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5628 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specify the given list of values as the arguments of the method.&quot;</span></span>
<span class="lineno"> 5629 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">,  &quot;&quot;</span></span>
<span class="lineno"> 5630 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The jvm_execute_func statement also serves to separate the pre-state&quot;</span></span>
<span class="lineno"> 5631 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section of the spec (before jvm_execute_func) from the post-state&quot;</span></span>
<span class="lineno"> 5632 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section (after jvm_execute_func). The effects of some JVMSetup&quot;</span></span>
<span class="lineno"> 5633 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;statements depend on whether they occur in the pre-state or post-state&quot;</span></span>
<span class="lineno"> 5634 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section.&quot;</span></span>
<span class="lineno"> 5635 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5636 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5637 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_return&quot; &quot;JVMValue -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 5638 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_return)</span>
<span class="lineno"> 5639 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5640 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specify the given value as the return value of the method. A&quot;</span></span>
<span class="lineno"> 5641 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;jvm_return statement is required if and only if the method&quot;</span></span>
<span class="lineno"> 5642 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;has a non-void return type.&quot; ]</span></span>
<span class="lineno"> 5643 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5644 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_setup_with_tag&quot; &quot;String -&gt; JVMSetup () -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 5645 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal jvm_setup_with_tag)</span></span>
<span class="lineno"> 5646 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5647 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;All conditions (e.g., from points-to or assert statements) executed&quot;</span></span>
<span class="lineno"> 5648 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the scope of the given setup block will have the provieded string&quot;</span></span>
<span class="lineno"> 5649 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;attached as a tag that can later be filtered by proof tactics.&quot;</span></span>
<span class="lineno"> 5650 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5651 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5652 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_verify&quot;</span>
<span class="lineno"> 5653 </span><span class="spaces">    </span><span class="istickedoff">&quot;JavaClass -&gt; String -&gt; [JVMSpec] -&gt; Bool -&gt; JVMSetup () -&gt; ProofScript () -&gt; TopLevel JVMSpec&quot;</span>
<span class="lineno"> 5654 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_verify)</span>
<span class="lineno"> 5655 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5656 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Verify the JVM method named by the second parameter in the class&quot;</span></span>
<span class="lineno"> 5657 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specified by the first. The third parameter lists the JVMSpec values&quot;</span></span>
<span class="lineno"> 5658 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;returned by previous calls to use as overrides. The fourth (Bool)&quot;</span></span>
<span class="lineno"> 5659 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;parameter enables or disables path satisfiability checking. The fifth&quot;</span></span>
<span class="lineno"> 5660 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;describes how to set up the symbolic execution engine before verification.&quot;</span></span>
<span class="lineno"> 5661 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;And the last gives the script to use to prove the validity of the resulting&quot;</span></span>
<span class="lineno"> 5662 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;verification conditions.&quot;</span></span>
<span class="lineno"> 5663 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5664 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5665 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_unsafe_assume_spec&quot;</span>
<span class="lineno"> 5666 </span><span class="spaces">    </span><span class="istickedoff">&quot;JavaClass -&gt; String -&gt; JVMSetup () -&gt; TopLevel JVMSpec&quot;</span>
<span class="lineno"> 5667 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_unsafe_assume_spec)</span>
<span class="lineno"> 5668 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5669 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return a JVMSpec corresponding to a JVMSetup block, as would be&quot;</span></span>
<span class="lineno"> 5670 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;returned by jvm_verify but without performing any verification.&quot;</span></span>
<span class="lineno"> 5671 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5672 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5673 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_null&quot;</span>
<span class="lineno"> 5674 </span><span class="spaces">    </span><span class="istickedoff">&quot;JVMValue&quot;</span>
<span class="lineno"> 5675 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CMS.SetupNull <span class="nottickedoff">()</span> :: CMS.SetupValue CJ.JVM))</span>
<span class="lineno"> 5676 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5677 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A JVMValue representing a null pointer value.&quot; ]</span></span>
<span class="lineno"> 5678 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5679 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_term&quot;</span>
<span class="lineno"> 5680 </span><span class="spaces">    </span><span class="istickedoff">&quot;Term -&gt; JVMValue&quot;</span>
<span class="lineno"> 5681 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CMS.SetupTerm :: TypedTerm -&gt; CMS.SetupValue CJ.JVM))</span>
<span class="lineno"> 5682 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5683 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Construct a `JVMValue` from a `Term`.&quot; ]</span></span>
<span class="lineno"> 5684 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5685 </span><span class="spaces">    </span><span class="istickedoff">----------------------------------------</span>
<span class="lineno"> 5686 </span><span class="spaces">    </span><span class="istickedoff">-- Crucible/MIR commands</span>
<span class="lineno"> 5687 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5688 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_alloc&quot; &quot;MIRType -&gt; MIRSetup MIRValue&quot;</span>
<span class="lineno"> 5689 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_alloc)</span>
<span class="lineno"> 5690 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5691 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that an immutable reference to the given type should be allocated&quot;</span></span>
<span class="lineno"> 5692 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in a MIR specification. Before `mir_execute_func`, this states that&quot;</span></span>
<span class="lineno"> 5693 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the function expects the object to be allocated before it runs.&quot;</span></span>
<span class="lineno"> 5694 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;After `mir_execute_func`, it states that the function being&quot;</span></span>
<span class="lineno"> 5695 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;verified is expected to perform the allocation.&quot;</span></span>
<span class="lineno"> 5696 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5697 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This command will raise an error if a `mir_slice` or `mir_str` type is&quot;</span></span>
<span class="lineno"> 5698 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;passed as an argument. To create slice reference, use the&quot;</span></span>
<span class="lineno"> 5699 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;`mir_slice_value` or `mir_slice_range_value` functions instead.&quot;</span></span>
<span class="lineno"> 5700 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5701 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5702 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_alloc_mut&quot; &quot;MIRType -&gt; MIRSetup MIRValue&quot;</span>
<span class="lineno"> 5703 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_alloc_mut)</span>
<span class="lineno"> 5704 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5705 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that a mutable reference to the given type should be allocated&quot;</span></span>
<span class="lineno"> 5706 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in a MIR specification. Before `mir_execute_func`, this states that&quot;</span></span>
<span class="lineno"> 5707 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the function expects the object to be allocated before it runs.&quot;</span></span>
<span class="lineno"> 5708 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;After `mir_execute_func`, it states that the function being&quot;</span></span>
<span class="lineno"> 5709 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;verified is expected to perform the allocation.&quot;</span></span>
<span class="lineno"> 5710 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5711 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This command will raise an error if a `mir_slice` or `mir_str` type is&quot;</span></span>
<span class="lineno"> 5712 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;passed as an argument. To create slice reference, use the&quot;</span></span>
<span class="lineno"> 5713 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;`mir_slice_value` or `mir_slice_range_value` functions instead.&quot;</span></span>
<span class="lineno"> 5714 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5715 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5716 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_alloc_raw_ptr_const&quot; &quot;MIRType -&gt; MIRSetup MIRValue&quot;</span>
<span class="lineno"> 5717 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_alloc_raw_ptr_const)</span>
<span class="lineno"> 5718 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5719 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that an immutable raw pointer to the given type should be allocated&quot;</span></span>
<span class="lineno"> 5720 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in a MIR specification. Before `mir_execute_func`, this states that&quot;</span></span>
<span class="lineno"> 5721 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the function expects the object to be allocated before it runs.&quot;</span></span>
<span class="lineno"> 5722 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;After `mir_execute_func`, it states that the function being&quot;</span></span>
<span class="lineno"> 5723 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;verified is expected to perform the allocation.&quot;</span></span>
<span class="lineno"> 5724 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5725 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5726 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_alloc_raw_ptr_const_multi&quot; &quot;Int -&gt; MIRType -&gt; MIRSetup MIRValue&quot;</span>
<span class="lineno"> 5727 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_alloc_raw_ptr_const_multi)</span>
<span class="lineno"> 5728 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5729 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that an immutable raw pointer to a contiguous sequence of values&quot;</span></span>
<span class="lineno"> 5730 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;should be allocated in a MIR specification. The first argument specifies&quot;</span></span>
<span class="lineno"> 5731 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the number of values and the second argument specifies the type of each&quot;</span></span>
<span class="lineno"> 5732 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;value. Before `mir_execute_func`, this states that the function expects&quot;</span></span>
<span class="lineno"> 5733 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the memory to be allocated before it runs. After `mir_execute_func`, it&quot;</span></span>
<span class="lineno"> 5734 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;states that the function being verified is expected to perform the&quot;</span></span>
<span class="lineno"> 5735 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;allocation.&quot;</span></span>
<span class="lineno"> 5736 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5737 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5738 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_alloc_raw_ptr_mut&quot; &quot;MIRType -&gt; MIRSetup MIRValue&quot;</span>
<span class="lineno"> 5739 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_alloc_raw_ptr_mut)</span>
<span class="lineno"> 5740 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5741 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that a mutable raw pointer to the given type should be allocated&quot;</span></span>
<span class="lineno"> 5742 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in a MIR specification. Before `mir_execute_func`, this states that&quot;</span></span>
<span class="lineno"> 5743 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the function expects the object to be allocated before it runs.&quot;</span></span>
<span class="lineno"> 5744 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;After `mir_execute_func`, it states that the function being&quot;</span></span>
<span class="lineno"> 5745 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;verified is expected to perform the allocation.&quot;</span></span>
<span class="lineno"> 5746 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5747 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5748 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_alloc_raw_ptr_mut_multi&quot; &quot;Int -&gt; MIRType -&gt; MIRSetup MIRValue&quot;</span>
<span class="lineno"> 5749 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal mir_alloc_raw_ptr_mut_multi)</span></span>
<span class="lineno"> 5750 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5751 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that an mutable raw pointer to a contiguous sequence of values&quot;</span></span>
<span class="lineno"> 5752 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;should be allocated in a MIR specification. The first argument specifies&quot;</span></span>
<span class="lineno"> 5753 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the number of values and the second argument specifies the type of each&quot;</span></span>
<span class="lineno"> 5754 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;value. Before `mir_execute_func`, this states that the function expects&quot;</span></span>
<span class="lineno"> 5755 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the memory to be allocated before it runs. After `mir_execute_func`, it&quot;</span></span>
<span class="lineno"> 5756 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;states that the function being verified is expected to perform the&quot;</span></span>
<span class="lineno"> 5757 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;allocation.&quot;</span></span>
<span class="lineno"> 5758 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5759 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5760 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_array_value&quot; &quot;MIRType -&gt; [MIRValue] -&gt; MIRValue&quot;</span>
<span class="lineno"> 5761 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CMS.SetupArray :: MIR.Ty -&gt; [CMS.SetupValue MIR] -&gt; CMS.SetupValue MIR))</span>
<span class="lineno"> 5762 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5763 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a SetupValue representing an array of the given type, with the&quot;</span></span>
<span class="lineno"> 5764 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of values as elements.&quot;</span></span>
<span class="lineno"> 5765 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5766 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5767 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_assert&quot; &quot;Term -&gt; MIRSetup ()&quot;</span>
<span class="lineno"> 5768 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_assert)</span>
<span class="lineno"> 5769 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5770 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that the given predicate must hold.  Acts as `mir_precond`&quot;</span></span>
<span class="lineno"> 5771 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;or `mir_postcond` depending on the phase of specification in which&quot;</span></span>
<span class="lineno"> 5772 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;it appears (i.e., before or after `mir_execute_func`).&quot;</span></span>
<span class="lineno"> 5773 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5774 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5775 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_cast_raw_ptr&quot; &quot;MIRValue -&gt; MIRType -&gt; MIRValue&quot;</span>
<span class="lineno"> 5776 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_cast_raw_ptr)</span>
<span class="lineno"> 5777 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5778 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a raw pointer, return a raw pointer to the same memory location&quot;</span></span>
<span class="lineno"> 5779 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;and with the same mutability, but with the given type as the pointee&quot;</span></span>
<span class="lineno"> 5780 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;type instead.&quot;</span></span>
<span class="lineno"> 5781 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5782 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Note that this only changes the pointee type as statically tracked by&quot;</span></span>
<span class="lineno"> 5783 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;SAWScript. It does not allow you to reinterpret the value pointed to as&quot;</span></span>
<span class="lineno"> 5784 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a type other than what it was originally allocated as with&quot;</span></span>
<span class="lineno"> 5785 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;mir_alloc_raw_ptr. Therefore, it cannot be used in the first argument to&quot;</span></span>
<span class="lineno"> 5786 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;mir_points_to.&quot;</span></span>
<span class="lineno"> 5787 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5788 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5789 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_elem_ref&quot; &quot;MIRValue -&gt; Int -&gt; MIRValue&quot;</span>
<span class="lineno"> 5790 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_elem_ref)</span>
<span class="lineno"> 5791 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5792 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a reference (or raw pointer) to a MIR array, and an index, return&quot;</span></span>
<span class="lineno"> 5793 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a reference (resp. raw pointer) to the element in that array at that&quot;</span></span>
<span class="lineno"> 5794 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;index.&quot;</span></span>
<span class="lineno"> 5795 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5796 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Note: If the given reference (or raw pointer) has been created with&quot;</span></span>
<span class="lineno"> 5797 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;`mir_alloc(_raw_ptr)`, the whole reference (resp. raw pointer) must be&quot;</span></span>
<span class="lineno"> 5798 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;initialized with mir_points_to before mir_elem_ref can be used on it.&quot;</span></span>
<span class="lineno"> 5799 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5800 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5801 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_elem_value&quot; &quot;MIRValue -&gt; Int -&gt; MIRValue&quot;</span>
<span class="lineno"> 5802 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_elem_value)</span>
<span class="lineno"> 5803 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5804 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a MIR array value and an index, return the MIR value in the array&quot;</span></span>
<span class="lineno"> 5805 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;at that index.&quot;</span></span>
<span class="lineno"> 5806 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5807 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5808 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_enum_value&quot; &quot;MIRAdt -&gt; String -&gt; [MIRValue] -&gt; MIRValue&quot;</span>
<span class="lineno"> 5809 </span><span class="spaces">    </span><span class="istickedoff">(funVal3 mir_enum_value)</span>
<span class="lineno"> 5810 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5811 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a MIRValue representing a variant of a MIR enum with the given&quot;</span></span>
<span class="lineno"> 5812 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;list of values as elements. The MIRAdt argument determines what enum&quot;</span></span>
<span class="lineno"> 5813 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;type to create; use `mir_find_adt` to retrieve a MIRAdt value. The&quot;</span></span>
<span class="lineno"> 5814 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;String argument represents the variant name.&quot;</span></span>
<span class="lineno"> 5815 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5816 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5817 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_equal&quot; &quot;MIRValue -&gt; MIRValue -&gt; MIRSetup ()&quot;</span>
<span class="lineno"> 5818 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_equal)</span>
<span class="lineno"> 5819 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5820 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that two MIR values should be equal. Can be used as either a&quot;</span></span>
<span class="lineno"> 5821 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;pre-condition or a post-condition. It is semantically equivalent to&quot;</span></span>
<span class="lineno"> 5822 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;an `mir_precond` or `mir_postcond` statement which is an equality&quot;</span></span>
<span class="lineno"> 5823 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;predicate, but potentially more efficient.&quot;</span></span>
<span class="lineno"> 5824 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5825 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5826 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_execute_func&quot; &quot;[MIRValue] -&gt; MIRSetup ()&quot;</span>
<span class="lineno"> 5827 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_execute_func)</span>
<span class="lineno"> 5828 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5829 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specify the given list of values as the arguments of the method.&quot;</span></span>
<span class="lineno"> 5830 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">,  &quot;&quot;</span></span>
<span class="lineno"> 5831 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The mir_execute_func statement also serves to separate the pre-state&quot;</span></span>
<span class="lineno"> 5832 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section of the spec (before mir_execute_func) from the post-state&quot;</span></span>
<span class="lineno"> 5833 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section (after mir_execute_func). The effects of some MIRSetup&quot;</span></span>
<span class="lineno"> 5834 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;statements depend on whether they occur in the pre-state or post-state&quot;</span></span>
<span class="lineno"> 5835 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section.&quot;</span></span>
<span class="lineno"> 5836 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5837 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5838 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_extract&quot; &quot;MIRModule -&gt; String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 5839 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_extract)</span>
<span class="lineno"> 5840 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5841 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Translate a MIR function directly to a Term. The parameters of the&quot;</span></span>
<span class="lineno"> 5842 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Term will be the parameters of the MIR function, and the return&quot;</span></span>
<span class="lineno"> 5843 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;value will be the return value of the function. Only functions with&quot;</span></span>
<span class="lineno"> 5844 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the following argument and return types are currently supported:&quot;</span></span>
<span class="lineno"> 5845 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;primitive integer types (e.g., u8 or i8), bool, char, arrays, and&quot;</span></span>
<span class="lineno"> 5846 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;tuples.&quot;</span></span>
<span class="lineno"> 5847 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5848 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5849 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_find_adt&quot; &quot;MIRModule -&gt; String -&gt; [MIRType] -&gt; MIRAdt&quot;</span>
<span class="lineno"> 5850 </span><span class="spaces">    </span><span class="istickedoff">(funVal3 mir_find_adt)</span>
<span class="lineno"> 5851 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5852 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Consult the given MIRModule to find an algebraic data type (MIRAdt)&quot;</span></span>
<span class="lineno"> 5853 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;with the given String as an identifier and the given MIRTypes as the&quot;</span></span>
<span class="lineno"> 5854 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;types used to instantiate the type parameters. If such a MIRAdt cannot&quot;</span></span>
<span class="lineno"> 5855 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;be found in the MIRModule, this will raise an error.&quot;</span></span>
<span class="lineno"> 5856 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5857 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5858 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_find_mangled_adt&quot; &quot;MIRModule -&gt; String -&gt; MIRAdt&quot;</span>
<span class="lineno"> 5859 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 mir_find_mangled_adt)</span>
<span class="lineno"> 5860 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5861 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Consult the given MIRModule to find an algebraic data type (MIRAdt)&quot;</span></span>
<span class="lineno"> 5862 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;with the given String as a mangled identifier. A mangled identifier is&quot;</span></span>
<span class="lineno"> 5863 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;one that refers to an ADT that is already instantiated with its type&quot;</span></span>
<span class="lineno"> 5864 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;arguments (e.g., foo::Bar::_adt123456789 is a mangled identifier, but&quot;</span></span>
<span class="lineno"> 5865 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;foo::Bar is not). If such a MIRAdt cannot be found in the MIRModule,&quot;</span></span>
<span class="lineno"> 5866 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;this will raise an error.&quot;</span></span>
<span class="lineno"> 5867 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5868 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Due to the fact that mangled identifiers can change easily when&quot;</span></span>
<span class="lineno"> 5869 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;recompiling Rust code, this function's use is discouraged in favor of&quot;</span></span>
<span class="lineno"> 5870 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;using mir_find_adt whenever possible.&quot;</span></span>
<span class="lineno"> 5871 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5872 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5873 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_fresh_cryptol_var&quot; &quot;String -&gt; Type -&gt; MIRSetup Term&quot;</span>
<span class="lineno"> 5874 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_fresh_cryptol_var)</span>
<span class="lineno"> 5875 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5876 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a fresh symbolic variable of the given Cryptol type for use&quot;</span></span>
<span class="lineno"> 5877 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;within a MIR specification. The given name is used only for&quot;</span></span>
<span class="lineno"> 5878 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;pretty-printing. Unlike 'mir_fresh_var', this can be used when&quot;</span></span>
<span class="lineno"> 5879 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;there isn't an appropriate MIR type, such as the Cryptol Array type.&quot;</span></span>
<span class="lineno"> 5880 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5881 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5882 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_fresh_expanded_value&quot; &quot;String -&gt; MIRType -&gt; MIRSetup MIRValue&quot;</span>
<span class="lineno"> 5883 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_fresh_expanded_value)</span>
<span class="lineno"> 5884 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5885 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a MIR value entirely populated with fresh symbolic variables.&quot;</span></span>
<span class="lineno"> 5886 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;For compound types such as structs and arrays, this will explicitly set&quot;</span></span>
<span class="lineno"> 5887 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;each field or element to contain a fresh symbolic variable. The String&quot;</span></span>
<span class="lineno"> 5888 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;argument is used as a prefix in each of the symbolic variables.&quot;</span></span>
<span class="lineno"> 5889 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5890 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5891 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_fresh_var&quot; &quot;String -&gt; MIRType -&gt; MIRSetup Term&quot;</span>
<span class="lineno"> 5892 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_fresh_var)</span>
<span class="lineno"> 5893 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5894 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a fresh symbolic variable for use within a MIR&quot;</span></span>
<span class="lineno"> 5895 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specification. The name is used only for pretty-printing.&quot;</span></span>
<span class="lineno"> 5896 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5897 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5898 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_load_module&quot; &quot;String -&gt; TopLevel MIRModule&quot;</span>
<span class="lineno"> 5899 </span><span class="spaces">    </span><span class="istickedoff">(pureVal do_mir_load_module)</span>
<span class="lineno"> 5900 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5901 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Load a MIR JSON file and return a handle to it.&quot; ]</span></span>
<span class="lineno"> 5902 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5903 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_mux_values&quot; &quot;Term -&gt; MIRValue -&gt; MIRValue -&gt; MIRValue&quot;</span>
<span class="lineno"> 5904 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_mux_values)</span>
<span class="lineno"> 5905 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5906 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Mux two MIRValues based on whether a (possibly symbolic) Term predicate&quot;</span></span>
<span class="lineno"> 5907 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;holds or not. The Term argument must have the Cryptol type Bit, and the&quot;</span></span>
<span class="lineno"> 5908 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;two MIRValue arguments must have the same type.&quot;</span></span>
<span class="lineno"> 5909 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5910 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5911 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_points_to&quot; &quot;MIRValue -&gt; MIRValue -&gt; MIRSetup ()&quot;</span>
<span class="lineno"> 5912 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_points_to)</span>
<span class="lineno"> 5913 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5914 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the memory location indicated by the given reference or raw&quot;</span></span>
<span class="lineno"> 5915 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;pointer (first argument) contains the given value (second argument).&quot;</span></span>
<span class="lineno"> 5916 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5917 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the pre-state section (before `mir_execute_func`) this specifies&quot;</span></span>
<span class="lineno"> 5918 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the initial memory layout before function execution. In the post-state&quot;</span></span>
<span class="lineno"> 5919 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section (after `mir_execute_func`), this specifies an assertion&quot;</span></span>
<span class="lineno"> 5920 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;about the final memory state after running the function.&quot;</span></span>
<span class="lineno"> 5921 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5922 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5923 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_points_to_multi&quot; &quot;MIRValue -&gt; MIRValue -&gt; MIRSetup ()&quot;</span>
<span class="lineno"> 5924 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_points_to_multi)</span>
<span class="lineno"> 5925 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5926 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the memory location indicated by the given raw pointer&quot;</span></span>
<span class="lineno"> 5927 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(first argument) contains the given contiguous sequence of values&quot;</span></span>
<span class="lineno"> 5928 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(second argument, which must have a MIR array type). If the sequence has&quot;</span></span>
<span class="lineno"> 5929 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;more than one element, then the raw pointer must be allocated with&quot;</span></span>
<span class="lineno"> 5930 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;`mir_alloc_raw_ptr_{const,mut}_multi` with at least as many elements as&quot;</span></span>
<span class="lineno"> 5931 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the sequence.&quot;</span></span>
<span class="lineno"> 5932 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5933 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Note that this is different from a raw pointer pointing to an array of&quot;</span></span>
<span class="lineno"> 5934 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;multiple values with the regular `mir_alloc_raw_ptr_{const,mut}` and&quot;</span></span>
<span class="lineno"> 5935 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;`mir_points_to` commands. Here, the pointee type of the pointer is the&quot;</span></span>
<span class="lineno"> 5936 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;type of each individual element, not an array type.&quot;</span></span>
<span class="lineno"> 5937 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5938 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the pre-state section (before `mir_execute_func`) this specifies&quot;</span></span>
<span class="lineno"> 5939 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the initial memory layout before function execution. In the post-state&quot;</span></span>
<span class="lineno"> 5940 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section (after `mir_execute_func`), this specifies an assertion&quot;</span></span>
<span class="lineno"> 5941 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;about the final memory state after running the function.&quot;</span></span>
<span class="lineno"> 5942 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5943 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5944 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_postcond&quot; &quot;Term -&gt; MIRSetup ()&quot;</span>
<span class="lineno"> 5945 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_postcond)</span>
<span class="lineno"> 5946 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5947 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that the given predicate is a post-condition of execution of the&quot;</span></span>
<span class="lineno"> 5948 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;method being verified.&quot;</span></span>
<span class="lineno"> 5949 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5950 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5951 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_precond&quot; &quot;Term -&gt; MIRSetup ()&quot;</span>
<span class="lineno"> 5952 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_precond)</span>
<span class="lineno"> 5953 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5954 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that the given predicate is a pre-condition on execution of the&quot;</span></span>
<span class="lineno"> 5955 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;method being verified.&quot;</span></span>
<span class="lineno"> 5956 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5957 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5958 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_ref_of&quot; &quot;MIRValue -&gt; MIRSetup MIRValue&quot;</span>
<span class="lineno"> 5959 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_ref_of)</span>
<span class="lineno"> 5960 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5961 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Allocates an immutable reference and initializes it to point to the given MIRValue.&quot; ]</span></span>
<span class="lineno"> 5962 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5963 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_ref_of_mut&quot; &quot;MIRValue -&gt; MIRSetup MIRValue&quot;</span>
<span class="lineno"> 5964 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_ref_of_mut)</span>
<span class="lineno"> 5965 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5966 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Allocates a mutable reference and initializes it to point to the given MIRValue.&quot; ]</span></span>
<span class="lineno"> 5967 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5968 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_return&quot; &quot;MIRValue -&gt; MIRSetup ()&quot;</span>
<span class="lineno"> 5969 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_return)</span>
<span class="lineno"> 5970 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5971 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specify the given value as the return value of the method. A&quot;</span></span>
<span class="lineno"> 5972 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;mir_return statement is required if and only if the method&quot;</span></span>
<span class="lineno"> 5973 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;has a non-() return type.&quot; ]</span></span>
<span class="lineno"> 5974 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5975 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_slice_value&quot; &quot;MIRValue -&gt; MIRValue&quot;</span>
<span class="lineno"> 5976 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_slice_value)</span>
<span class="lineno"> 5977 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5978 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a MIRValue representing a slice of type &amp;[T]. The argument must&quot;</span></span>
<span class="lineno"> 5979 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;be a reference to an array value, whose overall type must be &amp;[T; N]&quot;</span></span>
<span class="lineno"> 5980 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;for some length N.&quot;</span></span>
<span class="lineno"> 5981 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5982 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5983 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_slice_range_value&quot; &quot;MIRValue -&gt; Int -&gt; Int -&gt; MIRValue&quot;</span>
<span class="lineno"> 5984 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_slice_range_value)</span>
<span class="lineno"> 5985 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5986 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a MIRValue representing a slice of type &amp;[T] over a given range.&quot;</span></span>
<span class="lineno"> 5987 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The first argument must be a reference to an array value, whose overall&quot;</span></span>
<span class="lineno"> 5988 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;type must be &amp;[T; N] for some length N. The second and third arguments&quot;</span></span>
<span class="lineno"> 5989 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;represent the start and end of the range. The start must not&quot;</span></span>
<span class="lineno"> 5990 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;exceed the end, and the end must not exceed N.&quot;</span></span>
<span class="lineno"> 5991 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5992 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5993 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_str_slice_value&quot; &quot;MIRValue -&gt; MIRValue&quot;</span>
<span class="lineno"> 5994 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_str_slice_value)</span>
<span class="lineno"> 5995 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5996 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a MIRValue representing a slice of type &amp;str. The argument must&quot;</span></span>
<span class="lineno"> 5997 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;be a reference to an array value, whose overall type must be &amp;[u8; N]&quot;</span></span>
<span class="lineno"> 5998 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;for some length N. This array is expected to be a UTF-8-encoded sequence&quot;</span></span>
<span class="lineno"> 5999 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of bytes.&quot;</span></span>
<span class="lineno"> 6000 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6001 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6002 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_str_slice_range_value&quot; &quot;MIRValue -&gt; Int -&gt; Int -&gt; MIRValue&quot;</span>
<span class="lineno"> 6003 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_str_slice_range_value)</span>
<span class="lineno"> 6004 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6005 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a MIRValue representing a slice of type &amp;str over a given range.&quot;</span></span>
<span class="lineno"> 6006 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The first argument must be a reference to an array value, whose overall&quot;</span></span>
<span class="lineno"> 6007 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;type must be &amp;[u8; N] for some length N. This array is expected to be a&quot;</span></span>
<span class="lineno"> 6008 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;UTF-8-encoded sequence of bytes. The second and third arguments&quot;</span></span>
<span class="lineno"> 6009 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;represent the start and end of the range. The start must not&quot;</span></span>
<span class="lineno"> 6010 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;exceed the end, and the end must not exceed N.&quot;</span></span>
<span class="lineno"> 6011 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6012 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6013 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_struct_value&quot; &quot;MIRAdt -&gt; [MIRValue] -&gt; MIRValue&quot;</span>
<span class="lineno"> 6014 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CMS.SetupStruct :: MIR.Adt -&gt; [CMS.SetupValue MIR] -&gt; CMS.SetupValue MIR))</span>
<span class="lineno"> 6015 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6016 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a SetupValue representing a MIR struct with the given list of&quot;</span></span>
<span class="lineno"> 6017 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;values as elements. The MIRAdt argument determines what struct type to&quot;</span></span>
<span class="lineno"> 6018 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;create; use `mir_find_adt` to retrieve a MIRAdt value.&quot;</span></span>
<span class="lineno"> 6019 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6020 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6021 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_static&quot;</span>
<span class="lineno"> 6022 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; MIRValue&quot;</span>
<span class="lineno"> 6023 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CMS.SetupGlobal () :: Text -&gt; CMS.SetupValue MIR))</span>
<span class="lineno"> 6024 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6025 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return a MIRValue representing a reference to the named static.&quot;</span></span>
<span class="lineno"> 6026 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The String should be the name of a static value.&quot;</span></span>
<span class="lineno"> 6027 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6028 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6029 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_static_initializer&quot;</span>
<span class="lineno"> 6030 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; MIRValue&quot;</span>
<span class="lineno"> 6031 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CMS.SetupGlobalInitializer () :: Text -&gt; CMS.SetupValue MIR))</span>
<span class="lineno"> 6032 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6033 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return a MIRValue representing the value of the initializer of a named&quot;</span></span>
<span class="lineno"> 6034 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;static. The String should be the name of a static value.&quot;</span></span>
<span class="lineno"> 6035 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6036 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6037 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_term&quot;</span>
<span class="lineno"> 6038 </span><span class="spaces">    </span><span class="istickedoff">&quot;Term -&gt; MIRValue&quot;</span>
<span class="lineno"> 6039 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CMS.SetupTerm :: TypedTerm -&gt; CMS.SetupValue MIR))</span>
<span class="lineno"> 6040 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6041 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Construct a `MIRValue` from a `Term`.&quot; ]</span></span>
<span class="lineno"> 6042 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6043 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_tuple_value&quot; &quot;[MIRValue] -&gt; MIRValue&quot;</span>
<span class="lineno"> 6044 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CMS.SetupTuple () :: [CMS.SetupValue MIR] -&gt; CMS.SetupValue MIR))</span>
<span class="lineno"> 6045 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6046 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a SetupValue representing a MIR tuple with the given list of&quot;</span></span>
<span class="lineno"> 6047 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;values as elements.&quot;</span></span>
<span class="lineno"> 6048 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6049 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6050 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_unsafe_assume_spec&quot;</span>
<span class="lineno"> 6051 </span><span class="spaces">    </span><span class="istickedoff">&quot;MIRModule -&gt; String -&gt; MIRSetup () -&gt; TopLevel MIRSpec&quot;</span>
<span class="lineno"> 6052 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_unsafe_assume_spec)</span>
<span class="lineno"> 6053 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6054 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return a MIRSpec corresponding to a MIRSetup block, as would be&quot;</span></span>
<span class="lineno"> 6055 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;returned by mir_verify but without performing any verification.&quot;</span></span>
<span class="lineno"> 6056 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6057 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6058 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_vec_of&quot;</span>
<span class="lineno"> 6059 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; MIRType -&gt; MIRValue -&gt; MIRSetup MIRValue&quot;</span>
<span class="lineno"> 6060 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_vec_of)</span>
<span class="lineno"> 6061 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6062 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a MIR `Vec` value. The String argument is used as a prefix for&quot;</span></span>
<span class="lineno"> 6063 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;naming the internal symbolic variables created as part of the `Vec`&quot;</span></span>
<span class="lineno"> 6064 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;struct. The MIRType argument is the element type of the `Vec`. The&quot;</span></span>
<span class="lineno"> 6065 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;MIRValue argument is the contents of the `Vec`, which must be a MIR&quot;</span></span>
<span class="lineno"> 6066 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;array value whose element type matches the MIRType argument.&quot;</span></span>
<span class="lineno"> 6067 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6068 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6069 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_verify&quot;</span>
<span class="lineno"> 6070 </span><span class="spaces">    </span><span class="istickedoff">&quot;MIRModule -&gt; String -&gt; [MIRSpec] -&gt; Bool -&gt; MIRSetup () -&gt; ProofScript () -&gt; TopLevel MIRSpec&quot;</span>
<span class="lineno"> 6071 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_verify)</span>
<span class="lineno"> 6072 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6073 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Verify the MIR function named by the second parameter in the module&quot;</span></span>
<span class="lineno"> 6074 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specified by the first. The third parameter lists the MIRSpec&quot;</span></span>
<span class="lineno"> 6075 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;values returned by previous calls to use as overrides. The fourth (Bool)&quot;</span></span>
<span class="lineno"> 6076 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;parameter enables or disables path satisfiability checking. The fifth&quot;</span></span>
<span class="lineno"> 6077 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;describes how to set up the symbolic execution engine before verification.&quot;</span></span>
<span class="lineno"> 6078 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;And the last gives the script to use to prove the validity of the resulting&quot;</span></span>
<span class="lineno"> 6079 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;verification conditions.&quot;</span></span>
<span class="lineno"> 6080 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6081 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6082 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_adt&quot; &quot;MIRAdt -&gt; MIRType&quot;</span>
<span class="lineno"> 6083 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_adt)</span>
<span class="lineno"> 6084 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6085 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of a MIR algebraic data type (ADT), i.e., a struct or enum,&quot;</span></span>
<span class="lineno"> 6086 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;corresponding to the given MIRAdt. Use the `mir_find_adt` command to&quot;</span></span>
<span class="lineno"> 6087 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;retrieve a MIRAdt value.&quot;</span></span>
<span class="lineno"> 6088 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6089 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6090 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_array&quot; &quot;Int -&gt; MIRType -&gt; MIRType&quot;</span>
<span class="lineno"> 6091 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_array)</span>
<span class="lineno"> 6092 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6093 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR arrays with the given number of elements of the&quot;</span></span>
<span class="lineno"> 6094 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given type.&quot; ]</span></span>
<span class="lineno"> 6095 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6096 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_bool&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6097 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_bool)</span>
<span class="lineno"> 6098 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6099 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR booleans.&quot; ]</span></span>
<span class="lineno"> 6100 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6101 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_char&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6102 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal mir_char)</span></span>
<span class="lineno"> 6103 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 6104 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR characters.&quot; ]</span></span>
<span class="lineno"> 6105 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6106 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_i8&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6107 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_i8)</span>
<span class="lineno"> 6108 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6109 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 8-bit signed integers.&quot; ]</span></span>
<span class="lineno"> 6110 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6111 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_i16&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6112 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_i16)</span>
<span class="lineno"> 6113 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6114 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 16-bit signed integers.&quot; ]</span></span>
<span class="lineno"> 6115 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6116 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_i32&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6117 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_i32)</span>
<span class="lineno"> 6118 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6119 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 32-bit signed integers.&quot; ]</span></span>
<span class="lineno"> 6120 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6121 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_i64&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6122 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_i64)</span>
<span class="lineno"> 6123 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6124 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 64-bit signed integers.&quot; ]</span></span>
<span class="lineno"> 6125 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6126 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_i128&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6127 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal mir_i128)</span></span>
<span class="lineno"> 6128 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 6129 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 128-bit signed integers.&quot; ]</span></span>
<span class="lineno"> 6130 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6131 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_isize&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6132 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_isize)</span>
<span class="lineno"> 6133 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6134 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR pointer-sized signed integers.&quot; ]</span></span>
<span class="lineno"> 6135 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6136 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_f32&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6137 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal mir_f32)</span></span>
<span class="lineno"> 6138 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 6139 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR single-precision floating-point values.&quot; ]</span></span>
<span class="lineno"> 6140 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6141 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_f64&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6142 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal mir_f64)</span></span>
<span class="lineno"> 6143 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 6144 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR double-precision floating-point values.&quot; ]</span></span>
<span class="lineno"> 6145 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6146 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_lifetime&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6147 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_lifetime)</span>
<span class="lineno"> 6148 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6149 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR lifetimes.&quot; ]</span></span>
<span class="lineno"> 6150 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6151 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_raw_ptr_const&quot; &quot;MIRType -&gt; MIRType&quot;</span>
<span class="lineno"> 6152 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal mir_raw_ptr_const)</span></span>
<span class="lineno"> 6153 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6154 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR immutable raw pointers.&quot; ]</span></span>
<span class="lineno"> 6155 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6156 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_raw_ptr_mut&quot; &quot;MIRType -&gt; MIRType&quot;</span>
<span class="lineno"> 6157 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal mir_raw_ptr_mut)</span></span>
<span class="lineno"> 6158 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6159 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR mutable raw pointers.&quot; ]</span></span>
<span class="lineno"> 6160 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6161 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_ref&quot; &quot;MIRType -&gt; MIRType&quot;</span>
<span class="lineno"> 6162 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_ref)</span>
<span class="lineno"> 6163 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6164 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR immutable references.&quot; ]</span></span>
<span class="lineno"> 6165 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6166 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_ref_mut&quot; &quot;MIRType -&gt; MIRType&quot;</span>
<span class="lineno"> 6167 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_ref_mut)</span>
<span class="lineno"> 6168 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6169 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR mutable references.&quot; ]</span></span>
<span class="lineno"> 6170 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6171 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_slice&quot; &quot;MIRType -&gt; MIRType&quot;</span>
<span class="lineno"> 6172 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_slice)</span>
<span class="lineno"> 6173 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6174 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR slices, i.e., dynamically sized views into a&quot;</span></span>
<span class="lineno"> 6175 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;contiguous sequence of the given type. Currently, SAW can only&quot;</span></span>
<span class="lineno"> 6176 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;handle references to slices (&amp;[T]).&quot; ]</span></span>
<span class="lineno"> 6177 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6178 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_str&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6179 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_str)</span>
<span class="lineno"> 6180 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6181 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR strings, which are a particular kind of slice.&quot;</span></span>
<span class="lineno"> 6182 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Currently, SAW can only handle references to strings (&amp;str).&quot; ]</span></span>
<span class="lineno"> 6183 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6184 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_tuple&quot; &quot;[MIRType] -&gt; MIRType&quot;</span>
<span class="lineno"> 6185 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_tuple)</span>
<span class="lineno"> 6186 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6187 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR tuples of the given types.&quot; ]</span></span>
<span class="lineno"> 6188 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6189 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_u8&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6190 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_u8)</span>
<span class="lineno"> 6191 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6192 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 8-bit unsigned integers.&quot; ]</span></span>
<span class="lineno"> 6193 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6194 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_u16&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6195 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_u16)</span>
<span class="lineno"> 6196 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6197 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 16-bit unsigned integers.&quot; ]</span></span>
<span class="lineno"> 6198 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6199 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_u32&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6200 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_u32)</span>
<span class="lineno"> 6201 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6202 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 32-bit unsigned integers.&quot; ]</span></span>
<span class="lineno"> 6203 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6204 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_u64&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6205 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_u64)</span>
<span class="lineno"> 6206 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6207 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 64-bit unsigned integers.&quot; ]</span></span>
<span class="lineno"> 6208 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6209 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_u128&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6210 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_u128)</span>
<span class="lineno"> 6211 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6212 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 128-bit unsigned integers.&quot; ]</span></span>
<span class="lineno"> 6213 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6214 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_usize&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6215 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_usize)</span>
<span class="lineno"> 6216 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6217 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR pointer-sized unsigned integers.&quot; ]</span></span>
<span class="lineno"> 6218 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6219 </span><span class="spaces">    </span><span class="istickedoff">----------------------------------------</span>
<span class="lineno"> 6220 </span><span class="spaces">    </span><span class="istickedoff">-- Yosys commands</span>
<span class="lineno"> 6221 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6222 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;yosys_import&quot;  &quot;String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 6223 </span><span class="spaces">    </span><span class="istickedoff">(pureVal do_yosys_import)</span>
<span class="lineno"> 6224 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6225 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Produces a `Term` given the path to a JSON file produced by the Yosys `write_json` command.&quot;</span></span>
<span class="lineno"> 6226 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The resulting term is a Cryptol record, where each field corresponds to one HDL module exported by Yosys.&quot;</span></span>
<span class="lineno"> 6227 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Each HDL module is in turn represented by a function from a record of input port values to a record of output port values.&quot;</span></span>
<span class="lineno"> 6228 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6229 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6230 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;yosys_verify&quot;  &quot;Term -&gt; [Term] -&gt; Term -&gt; [YosysTheorem] -&gt; ProofScript () -&gt; TopLevel YosysTheorem&quot;</span>
<span class="lineno"> 6231 </span><span class="spaces">    </span><span class="istickedoff">(pureVal yosys_verify)</span>
<span class="lineno"> 6232 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6233 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Proves equality between a combinational HDL module and a specification.&quot;</span></span>
<span class="lineno"> 6234 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The first parameter is the HDL module - given a record m from yosys_import, this will typically look something like `{{ m.foo }}`.&quot;</span></span>
<span class="lineno"> 6235 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The second parameter is a list of preconditions for the equality.&quot;</span></span>
<span class="lineno"> 6236 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The third parameter is the specification, a term of the same type as the HDL module, which will typically be some Cryptol function or another HDL module.&quot;</span></span>
<span class="lineno"> 6237 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The fourth parameter is a list of overrides, which witness the results of previous yosys_verify proofs.&quot;</span></span>
<span class="lineno"> 6238 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;These overrides can be used to simplify terms by replacing use sites of submodules with their specifications.&quot;</span></span>
<span class="lineno"> 6239 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Note that terms derived from HDL modules are first class, and are not restricted to yosys_verify: they may also be used with SAW's typical Term infrastructure like sat, prove_print, term rewriting, etc.&quot;</span></span>
<span class="lineno"> 6240 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;yosys_verify simply provides a convenient and familiar interface, similar to llvm_verify or jvm_verify.&quot;</span></span>
<span class="lineno"> 6241 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6242 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6243 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;yosys_import_sequential&quot;  &quot;String -&gt; String -&gt; TopLevel YosysSequential&quot;</span>
<span class="lineno"> 6244 </span><span class="spaces">    </span><span class="istickedoff">(pureVal do_yosys_import_sequential)</span>
<span class="lineno"> 6245 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6246 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Imports a particular sequential HDL module.&quot;</span></span>
<span class="lineno"> 6247 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The first parameter is the module name, the second is the path to the Yosys JSON file.&quot;</span></span>
<span class="lineno"> 6248 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The resulting value is an opaque representation of the sequential circuit that can be extracted to a Term or sent to solvers in various ways.&quot;</span></span>
<span class="lineno"> 6249 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;SAW expects the sequential module to exist entirely within a single Yosys module - the Yosys \&quot;flatten\&quot; command will collapse the module hierarchy into a single module.&quot;</span></span>
<span class="lineno"> 6250 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The only supported sequential element is the basic $dff cell.&quot;</span></span>
<span class="lineno"> 6251 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Memory cells and more complex flip-flops can be translated into $dff using the \&quot;memory\&quot; and \&quot;dffunmap\&quot; Yosys commands.&quot;</span></span>
<span class="lineno"> 6252 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6253 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6254 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;yosys_extract_sequential&quot;  &quot;YosysSequential -&gt; Int -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 6255 </span><span class="spaces">    </span><span class="istickedoff">(pureVal yosys_extract_sequential)</span>
<span class="lineno"> 6256 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6257 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Extracts a term from the given sequential module with the state eliminated by iterating the term over the given concrete number of cycles.&quot;</span></span>
<span class="lineno"> 6258 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The resulting term has no state field in the inputs or outputs, and each input and output field is replaced with an array of that field's type (array length being the number of cycles).&quot;</span></span>
<span class="lineno"> 6259 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This term can be used like a normal SAW term - it may be embedded in Cryptol expressions, used in prove and sat, etc.&quot;</span></span>
<span class="lineno"> 6260 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6261 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6262 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;yosys_extract_sequential_with_state&quot;  &quot;YosysSequential -&gt; Int -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 6263 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal yosys_extract_sequential_with_state)</span></span>
<span class="lineno"> 6264 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 6265 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Like yosys_extract_sequential, but the resulting term has an additional parameter to specify the initial state.&quot;</span></span>
<span class="lineno"> 6266 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6267 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6268 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;yosys_extract_sequential_raw&quot;  &quot;YosysSequential -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 6269 </span><span class="spaces">    </span><span class="istickedoff">(pureVal yosys_extract_sequential_raw)</span>
<span class="lineno"> 6270 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6271 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Extracts a term from the given sequential module.&quot;</span></span>
<span class="lineno"> 6272 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This term has explicit fields for the state of the circuit in the input and output record types.&quot;</span></span>
<span class="lineno"> 6273 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6274 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6275 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;yosys_verify_sequential_offline_sally&quot;  &quot;YosysSequential -&gt; String -&gt; Term -&gt; [String] -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 6276 </span><span class="spaces">    </span><span class="istickedoff">(pureVal do_yosys_verify_sequential_sally)</span>
<span class="lineno"> 6277 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6278 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Export a query over the given sequential module to an input file for the Sally model checker.&quot;</span></span>
<span class="lineno"> 6279 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The first parameter is the sequential module.&quot;</span></span>
<span class="lineno"> 6280 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The second parameter is the path to write the resulting Sally input.&quot;</span></span>
<span class="lineno"> 6281 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The third parameter is the query, which should be a boolean function of three parameters: an 8-bit cycle counter, a record of \&quot;fixed\&quot; inputs, and a record of circuit outputs.&quot;</span></span>
<span class="lineno"> 6282 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The fourth parameter is a list of strings specifying certain circuit inputs as fixed - these inputs are assumed to remain unchanged across cycles, and are therefore accesible from the query function.&quot;</span></span>
<span class="lineno"> 6283 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6284 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6285 </span><span class="spaces">    </span><span class="istickedoff">----------------------------------------</span>
<span class="lineno"> 6286 </span><span class="spaces">    </span><span class="istickedoff">-- SAWCore loading command</span>
<span class="lineno"> 6287 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6288 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;load_sawcore_from_file&quot;</span>
<span class="lineno"> 6289 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 6290 </span><span class="spaces">    </span><span class="istickedoff">(bicVal do_load_sawcore_from_file)</span>
<span class="lineno"> 6291 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6292 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Load a SAW core module from a file&quot;</span></span>
<span class="lineno"> 6293 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6294 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6295 </span><span class="spaces">    </span><span class="istickedoff">----------------------------------------</span>
<span class="lineno"> 6296 </span><span class="spaces">    </span><span class="istickedoff">-- A few more misc commands</span>
<span class="lineno"> 6297 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6298 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sharpSAT&quot;  &quot;Term -&gt; TopLevel Integer&quot;</span>
<span class="lineno"> 6299 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal sharpSAT)</span></span>
<span class="lineno"> 6300 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 6301 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the sharpSAT solver to count the number of solutions to the CNF&quot;</span></span>
<span class="lineno"> 6302 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;representation of the given Term.&quot;</span></span>
<span class="lineno"> 6303 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6304 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6305 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;approxmc&quot;  &quot;Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 6306 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal approxmc)</span></span>
<span class="lineno"> 6307 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 6308 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the approxmc solver to approximate the number of solutions to the&quot;</span></span>
<span class="lineno"> 6309 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;CNF representation of the given Term.&quot;</span></span>
<span class="lineno"> 6310 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6311 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6312 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_crucible_profiling&quot; &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 6313 </span><span class="spaces">    </span><span class="istickedoff">(pureVal enable_crucible_profiling)</span>
<span class="lineno"> 6314 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6315 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Record profiling information from symbolic execution and solver&quot;</span></span>
<span class="lineno"> 6316 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;invocation to the given directory.&quot;</span></span>
<span class="lineno"> 6317 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6318 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6319 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_crucible_profiling&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 6320 </span><span class="spaces">    </span><span class="istickedoff">(pureVal disable_crucible_profiling)</span>
<span class="lineno"> 6321 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6322 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[&quot;Stop recording profiling information.&quot;]</span></span>
<span class="lineno"> 6323 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6324 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;summarize_verification&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 6325 </span><span class="spaces">    </span><span class="istickedoff">(pureVal summarize_verification)</span>
<span class="lineno"> 6326 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6327 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print a human-readable summary of all verifications performed&quot;</span></span>
<span class="lineno"> 6328 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;so far.&quot;</span></span>
<span class="lineno"> 6329 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6330 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6331 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;summarize_verification_json&quot; &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 6332 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_summarize_verification_json)</span></span>
<span class="lineno"> 6333 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 6334 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print a JSON summary of all verifications performed&quot;</span></span>
<span class="lineno"> 6335 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;so far into the named file.&quot;</span></span>
<span class="lineno"> 6336 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6337 </span><span class="spaces">  </span><span class="istickedoff">]</span>
<span class="lineno"> 6338 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6339 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 6340 </span><span class="spaces">    </span><span class="istickedoff">prim :: Text -&gt; Text -&gt; (Text -&gt; Options -&gt; BuiltinContext -&gt; Value) -&gt; PrimitiveLifecycle -&gt; [Text]</span>
<span class="lineno"> 6341 </span><span class="spaces">         </span><span class="istickedoff">-&gt; (SS.Name, Primitive)</span>
<span class="lineno"> 6342 </span><span class="spaces">    </span><span class="istickedoff">prim name ty fn lc doc = (name, Primitive</span>
<span class="lineno"> 6343 </span><span class="spaces">                                     </span><span class="istickedoff">{ primitiveType = readSchema fakeFileName ty</span>
<span class="lineno"> 6344 </span><span class="spaces">                                     </span><span class="istickedoff">, primitiveDoc  = <span class="nottickedoff">doc</span></span>
<span class="lineno"> 6345 </span><span class="spaces">                                     </span><span class="istickedoff">, primitiveFn   = fn name</span>
<span class="lineno"> 6346 </span><span class="spaces">                                     </span><span class="istickedoff">, primitiveLife = lc</span>
<span class="lineno"> 6347 </span><span class="spaces">                                     </span><span class="istickedoff">})</span>
<span class="lineno"> 6348 </span><span class="spaces">      </span><span class="istickedoff">where fakeFileName = Text.unpack $ &quot;&lt;type of &quot; &lt;&gt; name &lt;&gt; &quot;&gt;&quot;</span>
<span class="lineno"> 6349 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6350 </span><span class="spaces">    </span><span class="istickedoff">pureVal :: forall t. IsValue t =&gt; t -&gt; Text -&gt; Options -&gt; BuiltinContext -&gt; Value</span>
<span class="lineno"> 6351 </span><span class="spaces">    </span><span class="istickedoff">pureVal x name _ _ = toValue name x</span>
<span class="lineno"> 6352 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6353 </span><span class="spaces">    </span><span class="istickedoff">-- pureVal can be used for anything with an IsValue instance,</span>
<span class="lineno"> 6354 </span><span class="spaces">    </span><span class="istickedoff">-- including functions. However, functions in TopLevel need to use</span>
<span class="lineno"> 6355 </span><span class="spaces">    </span><span class="istickedoff">-- funVal* instead; the IsValue instances capture incorrectly and</span>
<span class="lineno"> 6356 </span><span class="spaces">    </span><span class="istickedoff">-- you get a function that returns a VTopLevel instead of executing</span>
<span class="lineno"> 6357 </span><span class="spaces">    </span><span class="istickedoff">-- in TopLevel. (There isn't a special-case IsValue instance for</span>
<span class="lineno"> 6358 </span><span class="spaces">    </span><span class="istickedoff">-- a -&gt; TopLevel t, because that would require overlapping instances;</span>
<span class="lineno"> 6359 </span><span class="spaces">    </span><span class="istickedoff">-- but there is an IsValue instance for TopLevel t by itself (that</span>
<span class="lineno"> 6360 </span><span class="spaces">    </span><span class="istickedoff">-- produces VTopLevel) so use of pureVal matches that and the</span>
<span class="lineno"> 6361 </span><span class="spaces">    </span><span class="istickedoff">-- generic IsValue instance for a -&gt; t.)</span>
<span class="lineno"> 6362 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno"> 6363 </span><span class="spaces">    </span><span class="istickedoff">-- XXX: rename these to e.g. monadVal1/2/3 so this is clearer?</span>
<span class="lineno"> 6364 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6365 </span><span class="spaces">    </span><span class="istickedoff">funVal1 :: forall a t. (FromValue a, IsValue t) =&gt; (a -&gt; TopLevel t)</span>
<span class="lineno"> 6366 </span><span class="spaces">               </span><span class="istickedoff">-&gt; Text -&gt; Options -&gt; BuiltinContext -&gt; Value</span>
<span class="lineno"> 6367 </span><span class="spaces">    </span><span class="istickedoff">funVal1 f name _ _ =</span>
<span class="lineno"> 6368 </span><span class="spaces">      </span><span class="istickedoff">VBuiltin name <span class="nottickedoff">Seq.empty</span> $</span>
<span class="lineno"> 6369 </span><span class="spaces">        </span><span class="istickedoff">OneMoreArg $ \a -&gt;</span>
<span class="lineno"> 6370 </span><span class="spaces">          </span><span class="istickedoff">toValue <span class="nottickedoff">name</span> &lt;$&gt; f (fromValue FromArgument a)</span>
<span class="lineno"> 6371 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6372 </span><span class="spaces">    </span><span class="istickedoff">funVal2 :: forall a b t. (FromValue a, FromValue b, IsValue t) =&gt; (a -&gt; b -&gt; TopLevel t)</span>
<span class="lineno"> 6373 </span><span class="spaces">               </span><span class="istickedoff">-&gt; Text -&gt; Options -&gt; BuiltinContext -&gt; Value</span>
<span class="lineno"> 6374 </span><span class="spaces">    </span><span class="istickedoff">funVal2 f name _ _ =</span>
<span class="lineno"> 6375 </span><span class="spaces">      </span><span class="istickedoff">VBuiltin name <span class="nottickedoff">Seq.empty</span> $</span>
<span class="lineno"> 6376 </span><span class="spaces">        </span><span class="istickedoff">ManyMoreArgs $ \a -&gt; return $</span>
<span class="lineno"> 6377 </span><span class="spaces">        </span><span class="istickedoff">OneMoreArg $ \b -&gt;</span>
<span class="lineno"> 6378 </span><span class="spaces">          </span><span class="istickedoff">toValue <span class="nottickedoff">name</span> &lt;$&gt; f (fromValue <span class="nottickedoff">FromArgument</span> a) (fromValue <span class="nottickedoff">FromArgument</span> b)</span>
<span class="lineno"> 6379 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6380 </span><span class="spaces">    </span><span class="istickedoff">funVal3 :: forall a b c t. (FromValue a, FromValue b, FromValue c, IsValue t) =&gt; (a -&gt; b -&gt; c -&gt; TopLevel t)</span>
<span class="lineno"> 6381 </span><span class="spaces">               </span><span class="istickedoff">-&gt; Text -&gt; Options -&gt; BuiltinContext -&gt; Value</span>
<span class="lineno"> 6382 </span><span class="spaces">    </span><span class="istickedoff">funVal3 f name _ _ =</span>
<span class="lineno"> 6383 </span><span class="spaces">      </span><span class="istickedoff">VBuiltin <span class="nottickedoff">name</span> <span class="nottickedoff">Seq.empty</span> $</span>
<span class="lineno"> 6384 </span><span class="spaces">        </span><span class="istickedoff">ManyMoreArgs $ \a -&gt; return $</span>
<span class="lineno"> 6385 </span><span class="spaces">        </span><span class="istickedoff">ManyMoreArgs $ \b -&gt; return $</span>
<span class="lineno"> 6386 </span><span class="spaces">        </span><span class="istickedoff">OneMoreArg $ \c -&gt;</span>
<span class="lineno"> 6387 </span><span class="spaces">          </span><span class="istickedoff">toValue <span class="nottickedoff">name</span> &lt;$&gt; f (fromValue <span class="nottickedoff">FromArgument</span> a) (fromValue <span class="nottickedoff">FromArgument</span> b) (fromValue <span class="nottickedoff">FromArgument</span> c)</span>
<span class="lineno"> 6388 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6389 </span><span class="spaces">    </span><span class="istickedoff">scVal :: forall t. IsValue t =&gt;</span>
<span class="lineno"> 6390 </span><span class="spaces">             </span><span class="istickedoff">(SharedContext -&gt; t) -&gt; Text -&gt; Options -&gt; BuiltinContext -&gt; Value</span>
<span class="lineno"> 6391 </span><span class="spaces">    </span><span class="istickedoff">scVal f name _ bic = toValue <span class="nottickedoff">name</span> (f (biSharedContext bic))</span>
<span class="lineno"> 6392 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6393 </span><span class="spaces">    </span><span class="istickedoff">scVal' :: forall t. IsValue t =&gt;</span>
<span class="lineno"> 6394 </span><span class="spaces">             </span><span class="istickedoff">(SharedContext -&gt; Options -&gt; t) -&gt; Text -&gt; Options -&gt; BuiltinContext -&gt; Value</span>
<span class="lineno"> 6395 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">scVal' f name opts bic = toValue name (f (biSharedContext bic) opts)</span></span>
<span class="lineno"> 6396 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6397 </span><span class="spaces">    </span><span class="istickedoff">bicVal :: forall t. IsValue t =&gt;</span>
<span class="lineno"> 6398 </span><span class="spaces">              </span><span class="istickedoff">(BuiltinContext -&gt; Options -&gt; t) -&gt; Text -&gt; Options -&gt; BuiltinContext -&gt; Value</span>
<span class="lineno"> 6399 </span><span class="spaces">    </span><span class="istickedoff">bicVal f name opts bic = toValue name (f <span class="nottickedoff">bic</span> opts)</span></span>
<span class="lineno"> 6400 </span>
<span class="lineno"> 6401 </span>
<span class="lineno"> 6402 </span>
<span class="lineno"> 6403 </span>-- FUTURE: extract here is now functionally a nop, so if things don't
<span class="lineno"> 6404 </span>-- change going forward we should consider simplifying so primTypes
<span class="lineno"> 6405 </span>-- uses the same type as the interpreter environment this function
<span class="lineno"> 6406 </span>-- seeds, instead of its own.
<span class="lineno"> 6407 </span>primNamedTypeEnv :: Map SS.Name (PrimitiveLifecycle, SS.NamedType)
<span class="lineno"> 6408 </span><span class="decl"><span class="istickedoff">primNamedTypeEnv = fmap extract primTypes</span>
<span class="lineno"> 6409 </span><span class="spaces">   </span><span class="istickedoff">where extract pt = (primTypeLife pt, primTypeType pt)</span></span>
<span class="lineno"> 6410 </span>
<span class="lineno"> 6411 </span>-- | Initial value environment for the interpreter.
<span class="lineno"> 6412 </span>--
<span class="lineno"> 6413 </span>--   Contains the lifecycle state, the type, the value, and the
<span class="lineno"> 6414 </span>--   documentation for each builtin.
<span class="lineno"> 6415 </span>--
<span class="lineno"> 6416 </span>--   Note: all builtins have documentation; the environment type
<span class="lineno"> 6417 </span>--   includes a Maybe for the documentation so it can also be used for
<span class="lineno"> 6418 </span>--   user definitions.
<span class="lineno"> 6419 </span>--
<span class="lineno"> 6420 </span>--   FUTURE: extract here is now functionally a nop, so we should
<span class="lineno"> 6421 </span>--   consider simplifying so `primitives` uses the same type as the
<span class="lineno"> 6422 </span>--   interpreter environment this function seeds, instead of its own.
<span class="lineno"> 6423 </span>--
<span class="lineno"> 6424 </span>primValueEnv ::
<span class="lineno"> 6425 </span>   Options -&gt;
<span class="lineno"> 6426 </span>   BuiltinContext -&gt;
<span class="lineno"> 6427 </span>   Map SS.Name (SS.Pos, PrimitiveLifecycle, SS.Rebindable, SS.Schema, Value, Maybe [Text])
<span class="lineno"> 6428 </span><span class="decl"><span class="istickedoff">primValueEnv opts bic = Map.mapWithKey extract primitives</span>
<span class="lineno"> 6429 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 6430 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">header = [</span></span>
<span class="lineno"> 6431 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;Description&quot;,</span></span>
<span class="lineno"> 6432 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;-----------&quot;,</span></span>
<span class="lineno"> 6433 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;&quot;</span></span>
<span class="lineno"> 6434 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6435 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">tag p = case primitiveLife p of</span></span>
<span class="lineno"> 6436 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">Current -&gt; []</span></span>
<span class="lineno"> 6437 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">WarnDeprecated -&gt; [&quot;DEPRECATED AND WILL WARN&quot;, &quot;&quot;]</span></span>
<span class="lineno"> 6438 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">HideDeprecated -&gt; [&quot;DEPRECATED AND UNAVAILABLE BY DEFAULT&quot;, &quot;&quot;]</span></span>
<span class="lineno"> 6439 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">Experimental -&gt; [&quot;EXPERIMENTAL&quot;, &quot;&quot;]</span></span>
<span class="lineno"> 6440 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">name n p = [</span></span>
<span class="lineno"> 6441 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;    &quot; &lt;&gt; n &lt;&gt; &quot; : &quot; &lt;&gt; PPS.pShowText (primitiveType p),</span></span>
<span class="lineno"> 6442 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;&quot;</span></span>
<span class="lineno"> 6443 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6444 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">doc n p =</span></span>
<span class="lineno"> 6445 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">header &lt;&gt; tag p &lt;&gt; name n p &lt;&gt; primitiveDoc p</span></span>
<span class="lineno"> 6446 </span><span class="spaces">      </span><span class="istickedoff">extract n p =</span>
<span class="lineno"> 6447 </span><span class="spaces">          </span><span class="istickedoff">let pos = SS.PosInternal &quot;&lt;&lt;builtin&gt;&gt;&quot; in</span>
<span class="lineno"> 6448 </span><span class="spaces">          </span><span class="istickedoff">(pos, primitiveLife p, <span class="nottickedoff">SS.ReadOnlyVar</span>, primitiveType p,</span>
<span class="lineno"> 6449 </span><span class="spaces">           </span><span class="istickedoff">(primitiveFn p) opts bic, <span class="nottickedoff">Just $ doc n p</span>)</span></span>

</pre>
</body>
</html>
