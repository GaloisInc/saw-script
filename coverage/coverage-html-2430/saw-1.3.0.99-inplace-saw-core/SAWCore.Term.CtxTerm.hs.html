<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- |
<span class="lineno">    2 </span>Module      : SAWCore.Term.CtxTerm
<span class="lineno">    3 </span>Copyright   : Galois, Inc. 2018
<span class="lineno">    4 </span>License     : BSD3
<span class="lineno">    5 </span>Stability   : experimental
<span class="lineno">    6 </span>Portability : non-portable (language extensions)
<span class="lineno">    7 </span>
<span class="lineno">    8 </span>The purpose of this module is to define a dependently-typed / GADT approach
<span class="lineno">    9 </span>to representing SAW core terms, that reflects (to some degree) the typing
<span class="lineno">   10 </span>and context information in the Haskell type of a term.
<span class="lineno">   11 </span>
<span class="lineno">   12 </span>Why are we doing this, when GADT programming can be so gross? The point of all
<span class="lineno">   13 </span>this is to get all the deBruijn indices right. Doing deBruijn index math when
<span class="lineno">   14 </span>manipulating open terms can be error prone and hard to read, and those bugs are
<span class="lineno">   15 </span>really hard to track down. Although GADT programming can be a pain sometimes,
<span class="lineno">   16 </span>this file is organized so at least you will always get the deBruijn indices
<span class="lineno">   17 </span>right when you finally get GHC to accept your code. :)
<span class="lineno">   18 </span>-}
<span class="lineno">   19 </span>
<span class="lineno">   20 </span>{-# LANGUAGE DataKinds #-}
<span class="lineno">   21 </span>{-# LANGUAGE EmptyDataDecls #-}
<span class="lineno">   22 </span>{-# LANGUAGE ExistentialQuantification #-}
<span class="lineno">   23 </span>{-# LANGUAGE FlexibleContexts #-}
<span class="lineno">   24 </span>{-# LANGUAGE FlexibleInstances #-}
<span class="lineno">   25 </span>{-# LANGUAGE GADTs #-}
<span class="lineno">   26 </span>{-# LANGUAGE KindSignatures #-}
<span class="lineno">   27 </span>{-# LANGUAGE MultiParamTypeClasses #-}
<span class="lineno">   28 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">   29 </span>{-# LANGUAGE PartialTypeSignatures #-}
<span class="lineno">   30 </span>{-# LANGUAGE PolyKinds #-}
<span class="lineno">   31 </span>{-# LANGUAGE RankNTypes #-}
<span class="lineno">   32 </span>{-# LANGUAGE RecordWildCards #-}
<span class="lineno">   33 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">   34 </span>{-# LANGUAGE TupleSections #-}
<span class="lineno">   35 </span>{-# LANGUAGE TypeFamilies #-}
<span class="lineno">   36 </span>{-# LANGUAGE TypeOperators #-}
<span class="lineno">   37 </span>{-# LANGUAGE UndecidableInstances #-}
<span class="lineno">   38 </span>
<span class="lineno">   39 </span>module SAWCore.Term.CtxTerm
<span class="lineno">   40 </span>  (
<span class="lineno">   41 </span>    -- * Re-exports from &quot;Data.Parameterized.Context&quot;
<span class="lineno">   42 </span>    -- | We use DataKinds to represent contexts of free variables at the type level.
<span class="lineno">   43 </span>    -- These contexts are &quot;inside-out&quot;, meaning that the most recently-bound
<span class="lineno">   44 </span>    -- variable is listed on the outside. We reflect this by having that most
<span class="lineno">   45 </span>    -- recently-bound variable to the right in '::&gt;'.
<span class="lineno">   46 </span>    Ctx(..), EmptyCtx, (::&gt;), type (&lt;+&gt;)
<span class="lineno">   47 </span>    -- * Contexts and Bindings
<span class="lineno">   48 </span>  , Typ
<span class="lineno">   49 </span>  , CtxInvApp, CtxInv
<span class="lineno">   50 </span>  , Bindings(..), bindingsLength, InvBindings(..), InBindings(..)
<span class="lineno">   51 </span>  , invAppendBindings, invertBindings
<span class="lineno">   52 </span>    -- * Terms in Context
<span class="lineno">   53 </span>  , Arrows
<span class="lineno">   54 </span>  , CtxTerm(..), CtxTerms(..), CtxTermsCtx(..)
<span class="lineno">   55 </span>  , mkClosedTerm, mkClosedTyp, elimClosedTerm
<span class="lineno">   56 </span>  , ExistsTp(..), ctxBindingsOfTerms
<span class="lineno">   57 </span>  , ctxTermsForBindings
<span class="lineno">   58 </span>    -- * Operations on Terms-in-Context
<span class="lineno">   59 </span>  , MonadTerm(..)
<span class="lineno">   60 </span>  , ctxLambda, ctxPi, ctxPi1
<span class="lineno">   61 </span>    -- * Generalized Lifting and Substitution
<span class="lineno">   62 </span>  , CtxLiftSubst(..), ctxLift1, ctxLiftInBindings
<span class="lineno">   63 </span>  , mkLiftedClosedTerm
<span class="lineno">   64 </span>    -- * Constructor Argument Types
<span class="lineno">   65 </span>  , CtorArg(..), CtorArgStruct(..), ctxCtorArgType, ctxCtorType
<span class="lineno">   66 </span>    -- * Computing with Eliminators
<span class="lineno">   67 </span>  , mkPRetTp
<span class="lineno">   68 </span>  , ctxCtorElimType, mkCtorElimTypeFun
<span class="lineno">   69 </span>  , ctxReduceRecursor
<span class="lineno">   70 </span>    -- * Parsing and Building Constructor Types
<span class="lineno">   71 </span>  , mkCtorArgStruct
<span class="lineno">   72 </span>  ) where
<span class="lineno">   73 </span>
<span class="lineno">   74 </span>import Data.Kind(Type)
<span class="lineno">   75 </span>import Data.Proxy
<span class="lineno">   76 </span>import Data.Type.Equality
<span class="lineno">   77 </span>import Control.Monad
<span class="lineno">   78 </span>import Control.Monad.Trans
<span class="lineno">   79 </span>
<span class="lineno">   80 </span>import Data.Parameterized.Context
<span class="lineno">   81 </span>
<span class="lineno">   82 </span>import SAWCore.Recognizer
<span class="lineno">   83 </span>import SAWCore.Term.Functor
<span class="lineno">   84 </span>
<span class="lineno">   85 </span>
<span class="lineno">   86 </span>--
<span class="lineno">   87 </span>-- * Contexts and Bindings
<span class="lineno">   88 </span>--
<span class="lineno">   89 </span>
<span class="lineno">   90 </span>-- | A representation of the type of SAW types as a Haskell type. This is
<span class="lineno">   91 </span>-- actually a singleton type, meaning that a 'CtxTerm' with type @'Typ' a@ is a
<span class="lineno">   92 </span>-- SAW type that is represented by Haskell type @a@. Of course, the Haskell type
<span class="lineno">   93 </span>-- system is not rich enough to capture SAW types in complete detail, but we do
<span class="lineno">   94 </span>-- our best, and capture at least the types and functions.
<span class="lineno">   95 </span>data Typ (a :: Type)
<span class="lineno">   96 </span>
<span class="lineno">   97 </span>-- | An identifier for a datatype that is statically associated with Haskell
<span class="lineno">   98 </span>-- type @d@. Again, we cannot capture all of the SAW type system in Haskell, so
<span class="lineno">   99 </span>-- we simplify datatypes to arbitrary Haskell types.
<span class="lineno">  100 </span>newtype DataIdent d = DataIdent (ExtCns Term)
<span class="lineno">  101 </span>  -- Invariant, the type of datatypes is always a closed term
<span class="lineno">  102 </span>
<span class="lineno">  103 </span>-- | Append a list of types to a context, i.e., &quot;invert&quot; the list of types,
<span class="lineno">  104 </span>-- putting the last type on the &quot;outside&quot;, and append it. The way to think of
<span class="lineno">  105 </span>-- this operation is that we are already &quot;inside&quot; @ctx@, and we are moving
<span class="lineno">  106 </span>-- further &quot;inside&quot; of @as@, one type at a time, to yield a combined context
<span class="lineno">  107 </span>-- where the last type of @as@ is bound last, i.e., most recently.
<span class="lineno">  108 </span>type family CtxInvApp ctx as where
<span class="lineno">  109 </span>  CtxInvApp ctx '[] = ctx
<span class="lineno">  110 </span>  CtxInvApp ctx (a ': as) = CtxInvApp (ctx ::&gt; a) as
<span class="lineno">  111 </span>
<span class="lineno">  112 </span>-- | Invert a type list to make a context
<span class="lineno">  113 </span>type CtxInv as = CtxInvApp EmptyCtx as
<span class="lineno">  114 </span>
<span class="lineno">  115 </span>-- | A sequence of bindings of pairs of a variable name and a type of some form
<span class="lineno">  116 </span>-- for that variable. These bindings are relative to ambient context @ctx@, use
<span class="lineno">  117 </span>-- @tp@ for the variable types, and bind variables whose types are listed in
<span class="lineno">  118 </span>-- @as@.
<span class="lineno">  119 </span>--
<span class="lineno">  120 </span>-- Note that each type in a bindings list has type 'Typ', but is &quot;represented&quot;
<span class="lineno">  121 </span>-- by a Haskell type @a@ in the 'Bind' constructor. There is no way to actually
<span class="lineno">  122 </span>-- related the Haskell type @a@ to the type it &quot;represents&quot;, so we do not try,
<span class="lineno">  123 </span>-- and just write &quot;represent&quot; in quotes.
<span class="lineno">  124 </span>data Bindings (tp :: Ctx Type -&gt; Type -&gt; Type) (ctx :: Ctx Type) (as :: [Type]) where
<span class="lineno">  125 </span>  NoBind :: Bindings tp ctx '[]
<span class="lineno">  126 </span>  Bind :: LocalName -&gt; tp ctx (Typ a) -&gt; Bindings tp (ctx ::&gt; a) as -&gt;
<span class="lineno">  127 </span>          Bindings tp ctx (a ': as)
<span class="lineno">  128 </span>
<span class="lineno">  129 </span>-- | Compute the number of bindings in a bindings list
<span class="lineno">  130 </span>bindingsLength :: Bindings tp ctx as -&gt; Int
<span class="lineno">  131 </span><span class="decl"><span class="istickedoff">bindingsLength NoBind = 0</span>
<span class="lineno">  132 </span><span class="spaces"></span><span class="istickedoff">bindingsLength (Bind _ _ bs) = 1 + bindingsLength bs</span></span>
<span class="lineno">  133 </span>
<span class="lineno">  134 </span>-- | An inverted list of bindings, seen from the &quot;inside out&quot;
<span class="lineno">  135 </span>data InvBindings (tp :: Ctx Type -&gt; Type -&gt; Type) (ctx :: Ctx Type) (as :: Ctx Type) where
<span class="lineno">  136 </span>  InvNoBind :: InvBindings tp ctx EmptyCtx
<span class="lineno">  137 </span>  InvBind :: InvBindings tp ctx as -&gt; LocalName -&gt; tp (ctx &lt;+&gt; as) (Typ a) -&gt;
<span class="lineno">  138 </span>             InvBindings tp ctx (as ::&gt; a)
<span class="lineno">  139 </span>
<span class="lineno">  140 </span>-- | Compute the number of bindings in an inverted bindings list
<span class="lineno">  141 </span>invBindingsLength :: InvBindings tp ctx as -&gt; Int
<span class="lineno">  142 </span><span class="decl"><span class="istickedoff">invBindingsLength InvNoBind = 0</span>
<span class="lineno">  143 </span><span class="spaces"></span><span class="istickedoff">invBindingsLength (InvBind bs _ _) = 1 + invBindingsLength bs</span></span>
<span class="lineno">  144 </span>
<span class="lineno">  145 </span>-- | Map over all types in an inverted bindings list
<span class="lineno">  146 </span>mapInvBindings :: (forall ctx a. f ctx a -&gt; g ctx a) -&gt;
<span class="lineno">  147 </span>                  InvBindings f c1 c2 -&gt; InvBindings g c1 c2
<span class="lineno">  148 </span><span class="decl"><span class="istickedoff">mapInvBindings _ InvNoBind = InvNoBind</span>
<span class="lineno">  149 </span><span class="spaces"></span><span class="istickedoff">mapInvBindings f (InvBind ctx x tp) =</span>
<span class="lineno">  150 </span><span class="spaces">  </span><span class="istickedoff">InvBind (mapInvBindings <span class="nottickedoff">f</span> ctx) <span class="nottickedoff">x</span> <span class="nottickedoff">(f tp)</span></span></span>
<span class="lineno">  151 </span>
<span class="lineno">  152 </span>-- | Typeclass for things from which we can build proofs that 'EmptyCtx' is the left
<span class="lineno">  153 </span>-- unit of '(&lt;+&gt;)', i.e., that @'EmptyCtx' '&lt;+&gt;' ctx ~ ctx@
<span class="lineno">  154 </span>class CtxAppNilEq f where
<span class="lineno">  155 </span>  ctxAppNilEq :: f ctx -&gt; EmptyCtx &lt;+&gt; ctx :~: ctx
<span class="lineno">  156 </span>
<span class="lineno">  157 </span>instance CtxAppNilEq (InvBindings tp ctx') where
<span class="lineno">  158 </span>  <span class="decl"><span class="istickedoff">ctxAppNilEq InvNoBind = Refl</span>
<span class="lineno">  159 </span><span class="spaces">  </span><span class="istickedoff">ctxAppNilEq (InvBind ctx _ _) =</span>
<span class="lineno">  160 </span><span class="spaces">    </span><span class="istickedoff">case ctxAppNilEq ctx of</span>
<span class="lineno">  161 </span><span class="spaces">      </span><span class="istickedoff">Refl -&gt; Refl</span></span>
<span class="lineno">  162 </span>
<span class="lineno">  163 </span>instance CtxAppNilEq (CtxTermsCtx ctx') where
<span class="lineno">  164 </span>  <span class="decl"><span class="nottickedoff">ctxAppNilEq CtxTermsCtxNil = Refl</span>
<span class="lineno">  165 </span><span class="spaces">  </span><span class="nottickedoff">ctxAppNilEq (CtxTermsCtxCons ts _) =</span>
<span class="lineno">  166 </span><span class="spaces">    </span><span class="nottickedoff">case ctxAppNilEq ts of</span>
<span class="lineno">  167 </span><span class="spaces">      </span><span class="nottickedoff">Refl -&gt; Refl</span></span>
<span class="lineno">  168 </span>
<span class="lineno">  169 </span>-- | Use 'ctxAppNilEq' to lift from @ctx@ to @'EmptyCtx' '&lt;+&gt;' ctx@
<span class="lineno">  170 </span>ctxLiftNil :: InvBindings tp EmptyCtx ctx -&gt; f ctx a -&gt; f (EmptyCtx &lt;+&gt; ctx) a
<span class="lineno">  171 </span><span class="decl"><span class="nottickedoff">ctxLiftNil ctx f = case ctxAppNilEq ctx of Refl -&gt; f</span></span>
<span class="lineno">  172 </span>
<span class="lineno">  173 </span>-- | Append a 'Bindings' list to an inverted 'InvBindings' list, inverting the
<span class="lineno">  174 </span>-- former as we go to yield an inverted 'InvBindings' list. Intuitively, this
<span class="lineno">  175 </span>-- means we are already &quot;inside&quot; the inverted bindings lists, and we are moving
<span class="lineno">  176 </span>-- further &quot;inside&quot; the regular bindings list; at the end we will be &quot;inside&quot;
<span class="lineno">  177 </span>-- both, meaning that we will see the combination &quot;from the inside&quot;.
<span class="lineno">  178 </span>invAppendBindings :: InvBindings tp ctx as -&gt;
<span class="lineno">  179 </span>                     Bindings tp (ctx &lt;+&gt; as) bs -&gt;
<span class="lineno">  180 </span>                     InvBindings tp ctx (CtxInvApp as bs)
<span class="lineno">  181 </span><span class="decl"><span class="istickedoff">invAppendBindings as NoBind = as</span>
<span class="lineno">  182 </span><span class="spaces"></span><span class="istickedoff">invAppendBindings as (Bind y y_tp bs) =</span>
<span class="lineno">  183 </span><span class="spaces">  </span><span class="istickedoff">(invAppendBindings (InvBind as <span class="nottickedoff">y</span> <span class="nottickedoff">y_tp</span>) bs)</span></span>
<span class="lineno">  184 </span>
<span class="lineno">  185 </span>-- | Invert a 'Bindings' list; i.e., move &quot;inside&quot; those bindings
<span class="lineno">  186 </span>invertBindings :: Bindings tp ctx as -&gt; InvBindings tp ctx (CtxInv as)
<span class="lineno">  187 </span><span class="decl"><span class="istickedoff">invertBindings = invAppendBindings InvNoBind</span></span>
<span class="lineno">  188 </span>
<span class="lineno">  189 </span>-- | Append two inverted contexts, where the first one is top-level. This
<span class="lineno">  190 </span>-- restriction allows us to avoid writing a proof of associativity of '(&lt;+&gt;)',
<span class="lineno">  191 </span>-- and instead just using 'ctxAppNilEq'
<span class="lineno">  192 </span>appendTopInvBindings :: InvBindings tp EmptyCtx ctx1 -&gt;
<span class="lineno">  193 </span>                        InvBindings tp ctx1 ctx2 -&gt;
<span class="lineno">  194 </span>                        InvBindings tp EmptyCtx (ctx1 &lt;+&gt; ctx2)
<span class="lineno">  195 </span><span class="decl"><span class="istickedoff">appendTopInvBindings ctx1 InvNoBind = ctx1</span>
<span class="lineno">  196 </span><span class="spaces"></span><span class="istickedoff">appendTopInvBindings ctx1 (InvBind ctx2 x tp) =</span>
<span class="lineno">  197 </span><span class="spaces">  </span><span class="istickedoff">let ret = appendTopInvBindings ctx1 ctx2 in</span>
<span class="lineno">  198 </span><span class="spaces">  </span><span class="istickedoff">InvBind ret <span class="nottickedoff">x</span> <span class="nottickedoff">(ctxLiftNil ret tp)</span></span></span>
<span class="lineno">  199 </span>
<span class="lineno">  200 </span>-- | A sequence of bindings bundled with something that is relative to those
<span class="lineno">  201 </span>-- bindings
<span class="lineno">  202 </span>data InBindings tp (f :: Ctx Type -&gt; k -&gt; Type) ctx (a::k) where
<span class="lineno">  203 </span>  InBindings :: Bindings tp ctx as -&gt; f (CtxInvApp ctx as) a -&gt;
<span class="lineno">  204 </span>                InBindings tp f ctx a
<span class="lineno">  205 </span>
<span class="lineno">  206 </span>
<span class="lineno">  207 </span>--
<span class="lineno">  208 </span>-- * Terms In Context
<span class="lineno">  209 </span>--
<span class="lineno">  210 </span>
<span class="lineno">  211 </span>-- | Abstract a type list using Haskell arrows. This is done &quot;outside-in&quot;, since
<span class="lineno">  212 </span>-- type-level lists represent bindings from the outside in.
<span class="lineno">  213 </span>type family Arrows as b where
<span class="lineno">  214 </span>  Arrows '[] b = b
<span class="lineno">  215 </span>  Arrows (a ': as) b = a -&gt; Arrows as b
<span class="lineno">  216 </span>
<span class="lineno">  217 </span>-- | A 'Term' with a given &quot;type&quot; relative to a given context. Since we cannot
<span class="lineno">  218 </span>-- hope to represent dependent type theory in Haskell types anyway, these
<span class="lineno">  219 </span>-- &quot;types&quot; are usually instantiated with a dummy, such as '()', but the code
<span class="lineno">  220 </span>-- that consumes them cannot know that and has to be agnostic to what type it
<span class="lineno">  221 </span>-- is.
<span class="lineno">  222 </span>newtype CtxTerm (ctx :: Ctx Type) (a :: Type) = CtxTerm Term
<span class="lineno">  223 </span>
<span class="lineno">  224 </span>-- | Convert a 'CtxTerm' to an untyped term. This is &quot;unsafe&quot; because it throws
<span class="lineno">  225 </span>-- away our typing information.
<span class="lineno">  226 </span>unCtxTermUnsafe :: CtxTerm ctx a -&gt; Term
<span class="lineno">  227 </span><span class="decl"><span class="istickedoff">unCtxTermUnsafe (CtxTerm t) = t</span></span>
<span class="lineno">  228 </span>
<span class="lineno">  229 </span>-- | Because we cannot capture the SAW type system in Haskell, sometimes we have
<span class="lineno">  230 </span>-- to cast our terms. We try not to use this very often, and we only allow
<span class="lineno">  231 </span>-- casting the output type, not the context, since the latter could screw up our
<span class="lineno">  232 </span>-- deBruijn indices.
<span class="lineno">  233 </span>castCtxTerm :: Proxy a -&gt; Proxy b -&gt; CtxTerm ctx a -&gt; CtxTerm ctx b
<span class="lineno">  234 </span><span class="decl"><span class="istickedoff">castCtxTerm _ _ (CtxTerm t) = CtxTerm t</span></span>
<span class="lineno">  235 </span>
<span class="lineno">  236 </span>-- | Build a term in the empty context
<span class="lineno">  237 </span>mkClosedTerm :: Term -&gt; CtxTerm EmptyCtx a
<span class="lineno">  238 </span><span class="decl"><span class="istickedoff">mkClosedTerm = CtxTerm</span></span>
<span class="lineno">  239 </span>
<span class="lineno">  240 </span>-- | Build a term to represent a type in the empty context
<span class="lineno">  241 </span>mkClosedTyp :: Term -&gt; CtxTerm EmptyCtx (Typ a)
<span class="lineno">  242 </span><span class="decl"><span class="nottickedoff">mkClosedTyp = mkClosedTerm</span></span>
<span class="lineno">  243 </span>
<span class="lineno">  244 </span>-- | Take a term out of the empty context
<span class="lineno">  245 </span>elimClosedTerm :: CtxTerm EmptyCtx a -&gt; Term
<span class="lineno">  246 </span><span class="decl"><span class="istickedoff">elimClosedTerm (CtxTerm t) = t</span></span>
<span class="lineno">  247 </span>
<span class="lineno">  248 </span>-- | Existentially quantify over the &quot;type&quot; of an object
<span class="lineno">  249 </span>data ExistsTp tp ctx = forall a. ExistsTp (tp ctx a)
<span class="lineno">  250 </span>
<span class="lineno">  251 </span>-- | Build a 'Bindings' list from a list of variable names and types, assuming
<span class="lineno">  252 </span>-- that each variable is free in the remaining types and that @ctx@ describes
<span class="lineno">  253 </span>-- the ambient context of the top-level type in the context. Note that nothing
<span class="lineno">  254 </span>-- here ensures that the Haskell-level types used to &quot;represent&quot; the bindings
<span class="lineno">  255 </span>-- created by this function have anything to do with the actual SAW types, but
<span class="lineno">  256 </span>-- the Haskell type system is not powerful enough to represent all the SAW types
<span class="lineno">  257 </span>-- anyway, and any code that consumes this 'Bindings' list cannot know that
<span class="lineno">  258 </span>-- anyway. See also the comments for 'CtxTerm'.
<span class="lineno">  259 </span>ctxBindingsOfTerms :: [(LocalName, Term)] -&gt; ExistsTp (Bindings CtxTerm) ctx
<span class="lineno">  260 </span><span class="decl"><span class="istickedoff">ctxBindingsOfTerms [] = ExistsTp NoBind</span>
<span class="lineno">  261 </span><span class="spaces"></span><span class="istickedoff">ctxBindingsOfTerms ((x,tp):ctx) =</span>
<span class="lineno">  262 </span><span class="spaces">  </span><span class="istickedoff">case ctxBindingsOfTerms ctx of</span>
<span class="lineno">  263 </span><span class="spaces">    </span><span class="istickedoff">ExistsTp rest -&gt; ExistsTp (Bind x (CtxTerm tp) rest)</span></span>
<span class="lineno">  264 </span>
<span class="lineno">  265 </span>-- | A dummy unit type that takes in a context
<span class="lineno">  266 </span>data CtxUnit ctx a = CtxUnit
<span class="lineno">  267 </span>
<span class="lineno">  268 </span>-- | An 'Either' type relative to a context and type
<span class="lineno">  269 </span>newtype CtxEither f g ctx a = CtxEither (Either (f ctx a) (g ctx a))
<span class="lineno">  270 </span>
<span class="lineno">  271 </span>-- | A list of terms in a given context
<span class="lineno">  272 </span>data CtxTerms ctx as where
<span class="lineno">  273 </span>  CtxTermsNil :: CtxTerms ctx '[]
<span class="lineno">  274 </span>  CtxTermsCons :: CtxTerm ctx a -&gt; CtxTerms ctx as -&gt; CtxTerms ctx (a ': as)
<span class="lineno">  275 </span>
<span class="lineno">  276 </span>-- | A list of terms in a given context, stored &quot;inside-out&quot;
<span class="lineno">  277 </span>data CtxTermsCtx ctx term_ctx where
<span class="lineno">  278 </span>  CtxTermsCtxNil :: CtxTermsCtx ctx EmptyCtx
<span class="lineno">  279 </span>  CtxTermsCtxCons :: CtxTermsCtx ctx as -&gt; CtxTerm ctx a -&gt;
<span class="lineno">  280 </span>                     CtxTermsCtx ctx (as ::&gt; a)
<span class="lineno">  281 </span>
<span class="lineno">  282 </span>{-
<span class="lineno">  283 </span>-- | Get the head and tail of a non-empty 'CtxTerms' list
<span class="lineno">  284 </span>ctxTermsHeadTail :: CtxTerms ctx (a ': as) -&gt; (CtxTerm ctx a, CtxTerms ctx as)
<span class="lineno">  285 </span>ctxTermsHeadTail (CtxTermsCons a as) = (a, as)
<span class="lineno">  286 </span>-}
<span class="lineno">  287 </span>
<span class="lineno">  288 </span>-- | Get the head and tail of a non-empty 'CtxTermsCtx' list
<span class="lineno">  289 </span>ctxTermsCtxHeadTail :: CtxTermsCtx ctx (as ::&gt; a) -&gt;
<span class="lineno">  290 </span>                       (CtxTermsCtx ctx as, CtxTerm ctx a)
<span class="lineno">  291 </span><span class="decl"><span class="istickedoff">ctxTermsCtxHeadTail (CtxTermsCtxCons as a) = (as, a)</span></span>
<span class="lineno">  292 </span>
<span class="lineno">  293 </span>-- | Convert a typed list of terms to a list of untyped terms; this is &quot;unsafe&quot;
<span class="lineno">  294 </span>-- because it throws away our typing information
<span class="lineno">  295 </span>ctxTermsToListUnsafe :: CtxTerms ctx as -&gt; [Term]
<span class="lineno">  296 </span><span class="decl"><span class="istickedoff">ctxTermsToListUnsafe CtxTermsNil = []</span>
<span class="lineno">  297 </span><span class="spaces"></span><span class="istickedoff">ctxTermsToListUnsafe (CtxTermsCons (CtxTerm t) ts) =</span>
<span class="lineno">  298 </span><span class="spaces">  </span><span class="istickedoff">t : ctxTermsToListUnsafe ts</span></span>
<span class="lineno">  299 </span>
<span class="lineno">  300 </span>-- | Convert a typed list of terms to a list of untyped terms; this is &quot;unsafe&quot;
<span class="lineno">  301 </span>-- because it throws away our typing information
<span class="lineno">  302 </span>ctxTermsCtxToListUnsafe :: CtxTermsCtx ctx as -&gt; [Term]
<span class="lineno">  303 </span><span class="decl"><span class="istickedoff">ctxTermsCtxToListUnsafe CtxTermsCtxNil = []</span>
<span class="lineno">  304 </span><span class="spaces"></span><span class="istickedoff">ctxTermsCtxToListUnsafe (CtxTermsCtxCons ts (CtxTerm t)) =</span>
<span class="lineno">  305 </span><span class="spaces">  </span><span class="istickedoff">ctxTermsCtxToListUnsafe ts ++ [t]</span></span>
<span class="lineno">  306 </span>
<span class="lineno">  307 </span>-- | Like 'ctxTermsForBindings' but can return a 'CtxTerms' in an arbitrary
<span class="lineno">  308 </span>-- context. We consider this &quot;unsafe&quot; because it associates an arbitrary context
<span class="lineno">  309 </span>-- with these terms, and so we do not export this function.
<span class="lineno">  310 </span>ctxTermsForBindingsOpen :: Bindings tp ctx_in as -&gt; [Term] -&gt;
<span class="lineno">  311 </span>                           Maybe (CtxTerms ctx as)
<span class="lineno">  312 </span><span class="decl"><span class="istickedoff">ctxTermsForBindingsOpen NoBind [] = Just CtxTermsNil</span>
<span class="lineno">  313 </span><span class="spaces"></span><span class="istickedoff">ctxTermsForBindingsOpen (Bind _ _ bs) (t : ts) =</span>
<span class="lineno">  314 </span><span class="spaces">  </span><span class="istickedoff">CtxTermsCons (CtxTerm t) &lt;$&gt; ctxTermsForBindingsOpen bs ts</span>
<span class="lineno">  315 </span><span class="spaces"></span><span class="istickedoff">ctxTermsForBindingsOpen _ _ = <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno">  316 </span>
<span class="lineno">  317 </span>-- | Take a list of terms and match them up with a sequence of bindings,
<span class="lineno">  318 </span>-- returning a structured 'CtxTerms' list. Note that the bindings themselves can
<span class="lineno">  319 </span>-- be in an arbitrary context, but the terms passed in are assumed to be closed,
<span class="lineno">  320 </span>-- i.e., in the empty context.
<span class="lineno">  321 </span>ctxTermsForBindings :: Bindings tp ctx as -&gt; [Term] -&gt; Maybe (CtxTerms EmptyCtx as)
<span class="lineno">  322 </span><span class="decl"><span class="istickedoff">ctxTermsForBindings NoBind [] = Just CtxTermsNil</span>
<span class="lineno">  323 </span><span class="spaces"></span><span class="istickedoff">ctxTermsForBindings (Bind _ _ bs) (t : ts) =</span>
<span class="lineno">  324 </span><span class="spaces">  </span><span class="istickedoff">CtxTermsCons (mkClosedTerm t) &lt;$&gt; ctxTermsForBindings bs ts</span>
<span class="lineno">  325 </span><span class="spaces"></span><span class="istickedoff">ctxTermsForBindings _ _ = <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno">  326 </span>
<span class="lineno">  327 </span>-- | Invert a 'CtxTerms' list and append it to an already-inverted 'CtxTermsCtx'
<span class="lineno">  328 </span>-- list
<span class="lineno">  329 </span>invertAppendCtxTerms :: CtxTermsCtx ctx as -&gt; CtxTerms ctx bs -&gt;
<span class="lineno">  330 </span>                        CtxTermsCtx ctx (CtxInvApp as bs)
<span class="lineno">  331 </span><span class="decl"><span class="istickedoff">invertAppendCtxTerms as CtxTermsNil = as</span>
<span class="lineno">  332 </span><span class="spaces"></span><span class="istickedoff">invertAppendCtxTerms as (CtxTermsCons b bs) =</span>
<span class="lineno">  333 </span><span class="spaces">  </span><span class="istickedoff">invertAppendCtxTerms (CtxTermsCtxCons as b) bs</span></span>
<span class="lineno">  334 </span>
<span class="lineno">  335 </span>-- | Invert a 'CtxTerms' list
<span class="lineno">  336 </span>invertCtxTerms :: CtxTerms ctx as -&gt; CtxTermsCtx ctx (CtxInv as)
<span class="lineno">  337 </span><span class="decl"><span class="istickedoff">invertCtxTerms = invertAppendCtxTerms CtxTermsCtxNil</span></span>
<span class="lineno">  338 </span>
<span class="lineno">  339 </span>splitCtxTermsCtx :: InvBindings tp any_ctx ctx2 -&gt;
<span class="lineno">  340 </span>                    CtxTermsCtx ctx (ctx1 &lt;+&gt; ctx2) -&gt;
<span class="lineno">  341 </span>                    (CtxTermsCtx ctx ctx1, CtxTermsCtx ctx ctx2)
<span class="lineno">  342 </span><span class="decl"><span class="istickedoff">splitCtxTermsCtx InvNoBind terms = (terms, CtxTermsCtxNil)</span>
<span class="lineno">  343 </span><span class="spaces"></span><span class="istickedoff">splitCtxTermsCtx (InvBind ctx _ _) (CtxTermsCtxCons ts t) =</span>
<span class="lineno">  344 </span><span class="spaces">  </span><span class="istickedoff">let (ts1, ts2) = splitCtxTermsCtx ctx ts in</span>
<span class="lineno">  345 </span><span class="spaces">  </span><span class="istickedoff">(ts1, CtxTermsCtxCons ts2 t)</span></span>
<span class="lineno">  346 </span>
<span class="lineno">  347 </span>
<span class="lineno">  348 </span>--
<span class="lineno">  349 </span>-- * Operations on Terms-in-Context
<span class="lineno">  350 </span>--
<span class="lineno">  351 </span>
<span class="lineno">  352 </span>-- | The class of monads that can build terms and substitute into them
<span class="lineno">  353 </span>class Monad m =&gt; MonadTerm m where
<span class="lineno">  354 </span>  mkTermF :: TermF Term -&gt; m Term
<span class="lineno">  355 </span>  liftTerm :: DeBruijnIndex -&gt; DeBruijnIndex -&gt; Term -&gt; m Term
<span class="lineno">  356 </span>  whnfTerm :: Term -&gt; m Term
<span class="lineno">  357 </span>  substTerm :: DeBruijnIndex -&gt; [Term] -&gt; Term -&gt; m Term
<span class="lineno">  358 </span>               -- ^ NOTE: the first term in the list is substituted for the most
<span class="lineno">  359 </span>               -- recently-bound variable, i.e., deBruijn index 0
<span class="lineno">  360 </span>
<span class="lineno">  361 </span>instance (MonadTerm m, MonadTrans t, Monad (t m)) =&gt; MonadTerm (t m) where
<span class="lineno">  362 </span>  <span class="decl"><span class="nottickedoff">mkTermF = lift . mkTermF</span></span>
<span class="lineno">  363 </span>  <span class="decl"><span class="nottickedoff">liftTerm n i t = lift $ liftTerm n i t</span></span>
<span class="lineno">  364 </span>  <span class="decl"><span class="nottickedoff">whnfTerm = lift . whnfTerm</span></span>
<span class="lineno">  365 </span>  <span class="decl"><span class="nottickedoff">substTerm n s t = lift $ substTerm n s t</span></span>
<span class="lineno">  366 </span>
<span class="lineno">  367 </span>-- | Build a 'Term' from a 'FlatTermF' in a 'MonadTerm'
<span class="lineno">  368 </span>mkFlatTermF :: MonadTerm m =&gt; FlatTermF Term -&gt; m Term
<span class="lineno">  369 </span><span class="decl"><span class="istickedoff">mkFlatTermF = mkTermF . FTermF</span></span>
<span class="lineno">  370 </span>
<span class="lineno">  371 </span>-- | Build a free variable as a 'CtxTerm'
<span class="lineno">  372 </span>ctxVar :: MonadTerm m =&gt; Bindings tp (ctx1 ::&gt; a) ctx2 -&gt;
<span class="lineno">  373 </span>          m (CtxTerm (CtxInvApp (ctx1 ::&gt; a) ctx2) a)
<span class="lineno">  374 </span><span class="decl"><span class="istickedoff">ctxVar ctx = CtxTerm &lt;$&gt; mkTermF (LocalVar $ bindingsLength ctx)</span></span>
<span class="lineno">  375 </span>
<span class="lineno">  376 </span>-- | Build a list of all the free variables as 'CtxTerm's
<span class="lineno">  377 </span>--
<span class="lineno">  378 </span>-- FIXME: there should be a nicer way to do this that does not require
<span class="lineno">  379 </span>-- ctxAppNilEq
<span class="lineno">  380 </span>ctxVars :: MonadTerm m =&gt; InvBindings tp EmptyCtx ctx -&gt; m (CtxTermsCtx ctx ctx)
<span class="lineno">  381 </span><span class="decl"><span class="istickedoff">ctxVars ctx_top =</span>
<span class="lineno">  382 </span><span class="spaces">  </span><span class="istickedoff">case ctxAppNilEq ctx_top of</span>
<span class="lineno">  383 </span><span class="spaces">    </span><span class="istickedoff">Refl -&gt; helper ctx_top NoBind</span>
<span class="lineno">  384 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  385 </span><span class="spaces">        </span><span class="istickedoff">helper :: MonadTerm m =&gt; InvBindings tp EmptyCtx ctx -&gt;</span>
<span class="lineno">  386 </span><span class="spaces">                  </span><span class="istickedoff">Bindings tp (EmptyCtx &lt;+&gt; ctx) as -&gt;</span>
<span class="lineno">  387 </span><span class="spaces">                  </span><span class="istickedoff">m (CtxTermsCtx (CtxInvApp (EmptyCtx &lt;+&gt; ctx) as) ctx)</span>
<span class="lineno">  388 </span><span class="spaces">        </span><span class="istickedoff">helper InvNoBind _ = return CtxTermsCtxNil</span>
<span class="lineno">  389 </span><span class="spaces">        </span><span class="istickedoff">helper (InvBind vars_ctx x tp) ctx =</span>
<span class="lineno">  390 </span><span class="spaces">          </span><span class="istickedoff">CtxTermsCtxCons &lt;$&gt; helper vars_ctx (Bind <span class="nottickedoff">x</span> <span class="nottickedoff">tp</span> ctx) &lt;*&gt; ctxVar ctx</span></span>
<span class="lineno">  391 </span>
<span class="lineno">  392 </span>-- | Build two lists of the free variables, split at a specific point
<span class="lineno">  393 </span>--
<span class="lineno">  394 </span>-- FIXME: there should be a nicer way to do this that does not require
<span class="lineno">  395 </span>-- splitCtxTermsCtx and appendTopInvBindings (the latter of which requires
<span class="lineno">  396 </span>-- ctxAppNilEq)
<span class="lineno">  397 </span>ctxVars2 :: MonadTerm m =&gt; InvBindings tp EmptyCtx ctx1 -&gt;
<span class="lineno">  398 </span>            InvBindings tp ctx1 ctx2 -&gt;
<span class="lineno">  399 </span>            m (CtxTermsCtx (ctx1 &lt;+&gt; ctx2) ctx1,
<span class="lineno">  400 </span>               CtxTermsCtx (ctx1 &lt;+&gt; ctx2) ctx2)
<span class="lineno">  401 </span><span class="decl"><span class="istickedoff">ctxVars2 vars1 vars2 =</span>
<span class="lineno">  402 </span><span class="spaces">  </span><span class="istickedoff">splitCtxTermsCtx vars2 &lt;$&gt; ctxVars (appendTopInvBindings vars1 vars2)</span></span>
<span class="lineno">  403 </span>
<span class="lineno">  404 </span>-- | Build a 'CtxTerm' for a 'Sort'
<span class="lineno">  405 </span>ctxSort :: MonadTerm m =&gt; Sort -&gt; m (CtxTerm ctx (Typ a))
<span class="lineno">  406 </span><span class="decl"><span class="istickedoff">ctxSort s = CtxTerm &lt;$&gt; mkFlatTermF (Sort s noFlags)</span></span>
<span class="lineno">  407 </span>
<span class="lineno">  408 </span>-- | Apply two 'CtxTerm's
<span class="lineno">  409 </span>ctxApply :: MonadTerm m =&gt; m (CtxTerm ctx (a -&gt; b)) -&gt; m (CtxTerm ctx a) -&gt;
<span class="lineno">  410 </span>            m (CtxTerm ctx b)
<span class="lineno">  411 </span><span class="decl"><span class="istickedoff">ctxApply fm argm =</span>
<span class="lineno">  412 </span><span class="spaces">  </span><span class="istickedoff">do CtxTerm f &lt;- fm</span>
<span class="lineno">  413 </span><span class="spaces">     </span><span class="istickedoff">CtxTerm arg &lt;- argm</span>
<span class="lineno">  414 </span><span class="spaces">     </span><span class="istickedoff">CtxTerm &lt;$&gt; mkTermF (App f arg)</span></span>
<span class="lineno">  415 </span>
<span class="lineno">  416 </span>-- | Apply two 'CtxTerm's, using a 'Proxy' to tell GHC the types
<span class="lineno">  417 </span>ctxApplyProxy :: MonadTerm m =&gt; Proxy a -&gt; Proxy b -&gt;
<span class="lineno">  418 </span>                 m (CtxTerm ctx (a -&gt; b)) -&gt; m (CtxTerm ctx a) -&gt;
<span class="lineno">  419 </span>                 m (CtxTerm ctx b)
<span class="lineno">  420 </span><span class="decl"><span class="istickedoff">ctxApplyProxy _ _ = ctxApply</span></span>
<span class="lineno">  421 </span>
<span class="lineno">  422 </span>-- | Apply a 'CtxTerm' to a list of arguments
<span class="lineno">  423 </span>ctxApplyMulti :: MonadTerm m =&gt;
<span class="lineno">  424 </span>                 m (CtxTerm ctx (Arrows as b)) -&gt;
<span class="lineno">  425 </span>                 m (CtxTerms ctx as) -&gt;
<span class="lineno">  426 </span>                 m (CtxTerm ctx b)
<span class="lineno">  427 </span><span class="decl"><span class="istickedoff">ctxApplyMulti fm argsm =</span>
<span class="lineno">  428 </span><span class="spaces">  </span><span class="istickedoff">fm &gt;&gt;= \f -&gt; argsm &gt;&gt;= \args -&gt; helper f args</span>
<span class="lineno">  429 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  430 </span><span class="spaces">    </span><span class="istickedoff">helper :: MonadTerm m =&gt; CtxTerm ctx (Arrows as b) -&gt;</span>
<span class="lineno">  431 </span><span class="spaces">              </span><span class="istickedoff">CtxTerms ctx as -&gt; m (CtxTerm ctx b)</span>
<span class="lineno">  432 </span><span class="spaces">    </span><span class="istickedoff">helper f CtxTermsNil = return f</span>
<span class="lineno">  433 </span><span class="spaces">    </span><span class="istickedoff">helper f (CtxTermsCons arg args) =</span>
<span class="lineno">  434 </span><span class="spaces">      </span><span class="istickedoff">do f' &lt;- ctxApply (return f) (return arg)</span>
<span class="lineno">  435 </span><span class="spaces">         </span><span class="istickedoff">helper f' args</span></span>
<span class="lineno">  436 </span>
<span class="lineno">  437 </span>-- | Form a lambda-abstraction as a 'CtxTerm'
<span class="lineno">  438 </span>ctxLambda1 :: MonadTerm m =&gt; LocalName -&gt; CtxTerm ctx (Typ a) -&gt;
<span class="lineno">  439 </span>              (CtxTerm (ctx ::&gt; a) a -&gt; m (CtxTerm (ctx ::&gt; a) b)) -&gt;
<span class="lineno">  440 </span>              m (CtxTerm ctx (a -&gt; b))
<span class="lineno">  441 </span><span class="decl"><span class="nottickedoff">ctxLambda1 x (CtxTerm tp) body_f =</span>
<span class="lineno">  442 </span><span class="spaces">  </span><span class="nottickedoff">do var &lt;- ctxVar NoBind</span>
<span class="lineno">  443 </span><span class="spaces">     </span><span class="nottickedoff">CtxTerm body &lt;- body_f var</span>
<span class="lineno">  444 </span><span class="spaces">     </span><span class="nottickedoff">CtxTerm &lt;$&gt; mkTermF (Lambda x tp body)</span></span>
<span class="lineno">  445 </span>
<span class="lineno">  446 </span>-- | Form a multi-arity lambda-abstraction as a 'CtxTerm'
<span class="lineno">  447 </span>ctxLambda :: MonadTerm m =&gt; Bindings CtxTerm ctx as -&gt;
<span class="lineno">  448 </span>             (CtxTerms (CtxInvApp ctx as) as -&gt;
<span class="lineno">  449 </span>              m (CtxTerm (CtxInvApp ctx as) a)) -&gt;
<span class="lineno">  450 </span>             m (CtxTerm ctx (Arrows as a))
<span class="lineno">  451 </span><span class="decl"><span class="istickedoff">ctxLambda NoBind body_f = body_f CtxTermsNil</span>
<span class="lineno">  452 </span><span class="spaces"></span><span class="istickedoff">ctxLambda (Bind x tp xs) body_f =</span>
<span class="lineno">  453 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">ctxLambda1 x tp $ \_ -&gt;</span></span>
<span class="lineno">  454 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">ctxLambda xs $ \vars -&gt;</span></span>
<span class="lineno">  455 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">do var &lt;- ctxVar xs</span></span>
<span class="lineno">  456 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">body_f (CtxTermsCons var vars)</span></span></span>
<span class="lineno">  457 </span>
<span class="lineno">  458 </span>-- | Form a pi-abstraction as a 'CtxTerm'
<span class="lineno">  459 </span>ctxPi1 :: MonadTerm m =&gt; LocalName -&gt; CtxTerm ctx (Typ a) -&gt;
<span class="lineno">  460 </span>          (CtxTerm (ctx ::&gt; a) a -&gt;
<span class="lineno">  461 </span>           m (CtxTerm (ctx ::&gt; a) (Typ b))) -&gt;
<span class="lineno">  462 </span>          m (CtxTerm ctx (Typ (a -&gt; b)))
<span class="lineno">  463 </span><span class="decl"><span class="istickedoff">ctxPi1 x (CtxTerm tp) body_f =</span>
<span class="lineno">  464 </span><span class="spaces">  </span><span class="istickedoff">do var &lt;- ctxVar NoBind</span>
<span class="lineno">  465 </span><span class="spaces">     </span><span class="istickedoff">CtxTerm body &lt;- body_f var</span>
<span class="lineno">  466 </span><span class="spaces">     </span><span class="istickedoff">CtxTerm &lt;$&gt; mkTermF (Pi x tp body)</span></span>
<span class="lineno">  467 </span>
<span class="lineno">  468 </span>-- | Form a multi-arity pi-abstraction as a 'CtxTerm'
<span class="lineno">  469 </span>ctxPi :: MonadTerm m =&gt; Bindings CtxTerm ctx as -&gt;
<span class="lineno">  470 </span>         (CtxTerms (CtxInvApp ctx as) as -&gt;
<span class="lineno">  471 </span>          m (CtxTerm (CtxInvApp ctx as) (Typ b))) -&gt;
<span class="lineno">  472 </span>         m (CtxTerm ctx (Typ (Arrows as b)))
<span class="lineno">  473 </span><span class="decl"><span class="istickedoff">ctxPi NoBind body_f = body_f CtxTermsNil</span>
<span class="lineno">  474 </span><span class="spaces"></span><span class="istickedoff">ctxPi (Bind x tp xs) body_f =</span>
<span class="lineno">  475 </span><span class="spaces">  </span><span class="istickedoff">ctxPi1 x tp $ \_ -&gt;</span>
<span class="lineno">  476 </span><span class="spaces">  </span><span class="istickedoff">ctxPi xs $ \vars -&gt;</span>
<span class="lineno">  477 </span><span class="spaces">  </span><span class="istickedoff">do var &lt;- ctxVar xs</span>
<span class="lineno">  478 </span><span class="spaces">     </span><span class="istickedoff">body_f (CtxTermsCons var vars)</span></span>
<span class="lineno">  479 </span>
<span class="lineno">  480 </span>-- | Form a multi-arity pi-abstraction as a 'CtxTerm', using a 'Proxy' to tell
<span class="lineno">  481 </span>-- stupid GHC what the result type should be
<span class="lineno">  482 </span>ctxPiProxy :: MonadTerm m =&gt; Proxy (Typ b) -&gt; Bindings CtxTerm ctx as -&gt;
<span class="lineno">  483 </span>              (CtxTerms (CtxInvApp ctx as) as -&gt;
<span class="lineno">  484 </span>               m (CtxTerm (CtxInvApp ctx as) (Typ b))) -&gt;
<span class="lineno">  485 </span>              m (CtxTerm ctx (Typ (Arrows as b)))
<span class="lineno">  486 </span><span class="decl"><span class="istickedoff">ctxPiProxy _ = ctxPi</span></span>
<span class="lineno">  487 </span>
<span class="lineno">  488 </span>-- | Existential return type of 'ctxAsPi'
<span class="lineno">  489 </span>data CtxPi ctx =
<span class="lineno">  490 </span>  forall b c.
<span class="lineno">  491 </span>  CtxPi LocalName (CtxTerm ctx (Typ b)) (CtxTerm (ctx ::&gt; b) (Typ c))
<span class="lineno">  492 </span>
<span class="lineno">  493 </span>-- | Test if a 'CtxTerm' is a pi-abstraction, returning its components if so.
<span class="lineno">  494 </span>-- Note that we are not returning any equality constraints on the input type,
<span class="lineno">  495 </span>-- @a@; i.e., if a term is a pi-abstraction, one would expect @a@ to have the
<span class="lineno">  496 </span>-- form @b -&gt; c@, but this would require a /lot/ more work...
<span class="lineno">  497 </span>ctxAsPi :: CtxTerm ctx (Typ a) -&gt; Maybe (CtxPi ctx)
<span class="lineno">  498 </span><span class="decl"><span class="istickedoff">ctxAsPi (CtxTerm (unwrapTermF -&gt; Pi x tp body)) =</span>
<span class="lineno">  499 </span><span class="spaces">  </span><span class="istickedoff">Just (CtxPi x (CtxTerm tp) (CtxTerm body))</span>
<span class="lineno">  500 </span><span class="spaces"></span><span class="istickedoff">ctxAsPi _ = Nothing</span></span>
<span class="lineno">  501 </span>
<span class="lineno">  502 </span>-- | Existential return type of 'ctxAsPiMulti'
<span class="lineno">  503 </span>data CtxMultiPi ctx =
<span class="lineno">  504 </span>  forall as b.
<span class="lineno">  505 </span>  CtxMultiPi (Bindings CtxTerm ctx as) (CtxTerm (CtxInvApp ctx as) (Typ b))
<span class="lineno">  506 </span>
<span class="lineno">  507 </span>-- | Repeatedly apply 'ctxAsPi', returning the 'Bindings' list of 0 or more
<span class="lineno">  508 </span>-- pi-abstraction bindings in the given term
<span class="lineno">  509 </span>ctxAsPiMulti :: CtxTerm ctx (Typ a) -&gt; CtxMultiPi ctx
<span class="lineno">  510 </span><span class="decl"><span class="istickedoff">ctxAsPiMulti (ctxAsPi -&gt; Just (CtxPi x tp body)) =</span>
<span class="lineno">  511 </span><span class="spaces">  </span><span class="istickedoff">case ctxAsPiMulti body of</span>
<span class="lineno">  512 </span><span class="spaces">    </span><span class="istickedoff">CtxMultiPi as body' -&gt; CtxMultiPi <span class="nottickedoff">(Bind x tp as)</span> body'</span>
<span class="lineno">  513 </span><span class="spaces"></span><span class="istickedoff">ctxAsPiMulti t = CtxMultiPi NoBind t</span></span>
<span class="lineno">  514 </span>
<span class="lineno">  515 </span>-- | Build an application of a datatype as a 'CtxTerm'
<span class="lineno">  516 </span>ctxDataTypeM ::
<span class="lineno">  517 </span>  forall m d ctx params ixs.
<span class="lineno">  518 </span>  MonadTerm m =&gt;
<span class="lineno">  519 </span>  DataIdent d -&gt;
<span class="lineno">  520 </span>  m (CtxTermsCtx ctx params) -&gt;
<span class="lineno">  521 </span>  m (CtxTermsCtx ctx ixs) -&gt;
<span class="lineno">  522 </span>  m (CtxTerm ctx (Typ d))
<span class="lineno">  523 </span><span class="decl"><span class="istickedoff">ctxDataTypeM (DataIdent d) paramsM ixsM =</span>
<span class="lineno">  524 </span><span class="spaces">  </span><span class="istickedoff">ctxApplyMultiInv (ctxApplyMultiInv t paramsM) ixsM</span>
<span class="lineno">  525 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  526 </span><span class="spaces">    </span><span class="istickedoff">t :: m (CtxTerm ctx (InvArrows params (InvArrows ixs (Typ d))))</span>
<span class="lineno">  527 </span><span class="spaces">    </span><span class="istickedoff">t = CtxTerm &lt;$&gt; mkTermF (Constant d)</span></span>
<span class="lineno">  528 </span>
<span class="lineno">  529 </span>-- | Test if a 'CtxTerm' is an application of a specific datatype with the
<span class="lineno">  530 </span>-- supplied context of parameters and indices
<span class="lineno">  531 </span>ctxAsDataTypeApp :: DataIdent d -&gt; Bindings tp1 EmptyCtx params -&gt;
<span class="lineno">  532 </span>                    Bindings tp2 (CtxInv params) ixs -&gt;
<span class="lineno">  533 </span>                    CtxTerm ctx (Typ a) -&gt;
<span class="lineno">  534 </span>                    Maybe (CtxTerms ctx params, CtxTerms ctx ixs)
<span class="lineno">  535 </span><span class="decl"><span class="istickedoff">ctxAsDataTypeApp (DataIdent d) params ixs (CtxTerm t) =</span>
<span class="lineno">  536 </span><span class="spaces">  </span><span class="istickedoff">do let (f, args) = asApplyAll t</span>
<span class="lineno">  537 </span><span class="spaces">     </span><span class="istickedoff">d' &lt;- asConstant f</span>
<span class="lineno">  538 </span><span class="spaces">     </span><span class="istickedoff">guard (d == d')</span>
<span class="lineno">  539 </span><span class="spaces">     </span><span class="istickedoff">guard (length args == bindingsLength params + bindingsLength ixs)</span>
<span class="lineno">  540 </span><span class="spaces">     </span><span class="istickedoff">let (params', ixs') = splitAt (bindingsLength params) args</span>
<span class="lineno">  541 </span><span class="spaces">     </span><span class="istickedoff">params_ret &lt;- ctxTermsForBindingsOpen params params'</span>
<span class="lineno">  542 </span><span class="spaces">     </span><span class="istickedoff">ixs_ret &lt;- ctxTermsForBindingsOpen ixs ixs'</span>
<span class="lineno">  543 </span><span class="spaces">     </span><span class="istickedoff">pure (params_ret, ixs_ret)</span></span>
<span class="lineno">  544 </span>
<span class="lineno">  545 </span>
<span class="lineno">  546 </span>-- | Build an application of a constructor as a 'CtxTerm'
<span class="lineno">  547 </span>ctxCtorAppM ::
<span class="lineno">  548 </span>  forall m d ctx params args.
<span class="lineno">  549 </span>  MonadTerm m =&gt;
<span class="lineno">  550 </span>  DataIdent d -&gt;
<span class="lineno">  551 </span>  ExtCns Term -&gt;
<span class="lineno">  552 </span>  m (CtxTermsCtx ctx params) -&gt;
<span class="lineno">  553 </span>  m (CtxTermsCtx ctx args) -&gt;
<span class="lineno">  554 </span>  m (CtxTerm ctx d)
<span class="lineno">  555 </span><span class="decl"><span class="istickedoff">ctxCtorAppM _d c paramsM argsM =</span>
<span class="lineno">  556 </span><span class="spaces">  </span><span class="istickedoff">ctxApplyMultiInv (ctxApplyMultiInv t paramsM) argsM</span>
<span class="lineno">  557 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  558 </span><span class="spaces">    </span><span class="istickedoff">t :: m (CtxTerm ctx (InvArrows params (InvArrows args d)))</span>
<span class="lineno">  559 </span><span class="spaces">    </span><span class="istickedoff">t = CtxTerm &lt;$&gt; mkTermF (Constant c)</span></span>
<span class="lineno">  560 </span>
<span class="lineno">  561 </span>-- | Abstract an inside-out type list using Haskell arrows. Used only
<span class="lineno">  562 </span>-- to define 'ctxDataTypeM' and 'ctxCtorAppM'.
<span class="lineno">  563 </span>type family InvArrows as b where
<span class="lineno">  564 </span>  InvArrows EmptyCtx b = b
<span class="lineno">  565 </span>  InvArrows (as ::&gt; a) b = InvArrows as (a -&gt; b)
<span class="lineno">  566 </span>
<span class="lineno">  567 </span>-- | Apply a 'CtxTerm' to an inside-out list of arguments. Used only
<span class="lineno">  568 </span>-- to define 'ctxDataTypeM' and 'ctxCtorAppM`.
<span class="lineno">  569 </span>ctxApplyMultiInv ::
<span class="lineno">  570 </span>  MonadTerm m =&gt;
<span class="lineno">  571 </span>  m (CtxTerm ctx (InvArrows as b)) -&gt;
<span class="lineno">  572 </span>  m (CtxTermsCtx ctx as) -&gt;
<span class="lineno">  573 </span>  m (CtxTerm ctx b)
<span class="lineno">  574 </span><span class="decl"><span class="istickedoff">ctxApplyMultiInv fm argsm =</span>
<span class="lineno">  575 </span><span class="spaces">  </span><span class="istickedoff">do f &lt;- fm</span>
<span class="lineno">  576 </span><span class="spaces">     </span><span class="istickedoff">args &lt;- argsm</span>
<span class="lineno">  577 </span><span class="spaces">     </span><span class="istickedoff">helper f args</span>
<span class="lineno">  578 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  579 </span><span class="spaces">    </span><span class="istickedoff">helper :: MonadTerm m =&gt; CtxTerm ctx (InvArrows as b) -&gt;</span>
<span class="lineno">  580 </span><span class="spaces">              </span><span class="istickedoff">CtxTermsCtx ctx as -&gt; m (CtxTerm ctx b)</span>
<span class="lineno">  581 </span><span class="spaces">    </span><span class="istickedoff">helper f CtxTermsCtxNil = pure f</span>
<span class="lineno">  582 </span><span class="spaces">    </span><span class="istickedoff">helper f (CtxTermsCtxCons args arg) = ctxApply (helper f args) (pure arg)</span></span>
<span class="lineno">  583 </span>
<span class="lineno">  584 </span>data Rec d
<span class="lineno">  585 </span>
<span class="lineno">  586 </span>ctxRecursorAppM :: MonadTerm m =&gt;
<span class="lineno">  587 </span>  m (CtxTerm ctx (Rec d)) -&gt;
<span class="lineno">  588 </span>  m (CtxTermsCtx ctx ixs) -&gt;
<span class="lineno">  589 </span>  m (CtxTerm ctx d) -&gt;
<span class="lineno">  590 </span>  m (CtxTerm ctx a)
<span class="lineno">  591 </span><span class="decl"><span class="istickedoff">ctxRecursorAppM recM ixsM argM =</span>
<span class="lineno">  592 </span><span class="spaces">  </span><span class="istickedoff">do app &lt;- RecursorApp &lt;$&gt;</span>
<span class="lineno">  593 </span><span class="spaces">              </span><span class="istickedoff">(unCtxTermUnsafe &lt;$&gt; recM) &lt;*&gt;</span>
<span class="lineno">  594 </span><span class="spaces">              </span><span class="istickedoff">(ctxTermsCtxToListUnsafe &lt;$&gt; ixsM) &lt;*&gt;</span>
<span class="lineno">  595 </span><span class="spaces">              </span><span class="istickedoff">(unCtxTermUnsafe &lt;$&gt; argM)</span>
<span class="lineno">  596 </span><span class="spaces">     </span><span class="istickedoff">CtxTerm &lt;$&gt; mkFlatTermF app</span></span>
<span class="lineno">  597 </span>
<span class="lineno">  598 </span>--
<span class="lineno">  599 </span>-- * Generalized Lifting and Substitution
<span class="lineno">  600 </span>--
<span class="lineno">  601 </span>
<span class="lineno">  602 </span>-- | The class of &quot;in-context&quot; types that support lifting and substitution
<span class="lineno">  603 </span>class Monad m =&gt; CtxLiftSubst f m where
<span class="lineno">  604 </span>  -- | Lift an @f@ into an extended context
<span class="lineno">  605 </span>  ctxLift :: InvBindings tp1 ctx ctx' -&gt; Bindings tp2 ctx as -&gt;
<span class="lineno">  606 </span>             f (ctx &lt;+&gt; ctx') a -&gt;
<span class="lineno">  607 </span>             m (f (CtxInvApp ctx as &lt;+&gt; ctx') a)
<span class="lineno">  608 </span>  -- | Substitute a list of terms into an @f@
<span class="lineno">  609 </span>  ctxSubst :: CtxTermsCtx ctx1 subst -&gt;
<span class="lineno">  610 </span>              InvBindings tp (ctx1 &lt;+&gt; subst) ctx2 -&gt;
<span class="lineno">  611 </span>              f ((ctx1 &lt;+&gt; subst) &lt;+&gt; ctx2) a -&gt;
<span class="lineno">  612 </span>              m (f (ctx1 &lt;+&gt; ctx2) a)
<span class="lineno">  613 </span>
<span class="lineno">  614 </span>-- | Lift an @f@ into a context extended with one type
<span class="lineno">  615 </span>ctxLift1 :: CtxLiftSubst f m =&gt; f ctx b -&gt; m (f (ctx ::&gt; a) b)
<span class="lineno">  616 </span><span class="decl"><span class="nottickedoff">ctxLift1 = ctxLift InvNoBind (Bind &quot;_&quot; CtxUnit NoBind)</span></span>
<span class="lineno">  617 </span>
<span class="lineno">  618 </span>-- | Lift an @f@ that is in an extended list of 'Bindings'
<span class="lineno">  619 </span>ctxLiftInBindings :: CtxLiftSubst f m =&gt; InvBindings tp1 ctx ctx1 -&gt;
<span class="lineno">  620 </span>                     Bindings tp2 (ctx &lt;+&gt; ctx1) ctx2 -&gt;
<span class="lineno">  621 </span>                     Bindings tp3 ctx as -&gt;
<span class="lineno">  622 </span>                     f (CtxInvApp (ctx &lt;+&gt; ctx1) ctx2) a -&gt;
<span class="lineno">  623 </span>                     m (f (CtxInvApp (CtxInvApp ctx as &lt;+&gt; ctx1) ctx2) a)
<span class="lineno">  624 </span><span class="decl"><span class="istickedoff">ctxLiftInBindings = helper . mapInvBindings <span class="nottickedoff">(CtxEither . Left)</span></span>
<span class="lineno">  625 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  626 </span><span class="spaces">    </span><span class="istickedoff">helper :: CtxLiftSubst f m =&gt; InvBindings (CtxEither tp1 tp2) ctx ctx1 -&gt;</span>
<span class="lineno">  627 </span><span class="spaces">              </span><span class="istickedoff">Bindings tp2 (ctx &lt;+&gt; ctx1) ctx2 -&gt;</span>
<span class="lineno">  628 </span><span class="spaces">              </span><span class="istickedoff">Bindings tp3 ctx as -&gt;</span>
<span class="lineno">  629 </span><span class="spaces">              </span><span class="istickedoff">f (CtxInvApp (ctx &lt;+&gt; ctx1) ctx2) a -&gt;</span>
<span class="lineno">  630 </span><span class="spaces">              </span><span class="istickedoff">m (f (CtxInvApp (CtxInvApp ctx as &lt;+&gt; ctx1) ctx2) a)</span>
<span class="lineno">  631 </span><span class="spaces">    </span><span class="istickedoff">helper ctx1 NoBind as = ctxLift ctx1 as</span>
<span class="lineno">  632 </span><span class="spaces">    </span><span class="istickedoff">helper ctx1 (Bind str tp ctx2) as =</span>
<span class="lineno">  633 </span><span class="spaces">      </span><span class="istickedoff">helper (InvBind ctx1 <span class="nottickedoff">str</span> <span class="nottickedoff">(CtxEither $ Right tp)</span>) ctx2 as</span></span>
<span class="lineno">  634 </span>
<span class="lineno">  635 </span>-- | Substitute into an @f@ that is in an extended list of 'Bindings'
<span class="lineno">  636 </span>ctxSubstInBindings :: CtxLiftSubst f m =&gt; CtxTermsCtx ctx1 subst -&gt;
<span class="lineno">  637 </span>                      InvBindings tp1 (ctx1 &lt;+&gt; subst) ctx2 -&gt;
<span class="lineno">  638 </span>                      Bindings tp2 ((ctx1 &lt;+&gt; subst) &lt;+&gt; ctx2) ctx3 -&gt;
<span class="lineno">  639 </span>                      f (CtxInvApp ((ctx1 &lt;+&gt; subst) &lt;+&gt; ctx2) ctx3) a -&gt;
<span class="lineno">  640 </span>                      m (f (CtxInvApp (ctx1 &lt;+&gt; ctx2) ctx3) a)
<span class="lineno">  641 </span><span class="decl"><span class="istickedoff">ctxSubstInBindings subst =</span>
<span class="lineno">  642 </span><span class="spaces">  </span><span class="istickedoff">helper subst . mapInvBindings <span class="nottickedoff">(CtxEither . Left)</span> where</span>
<span class="lineno">  643 </span><span class="spaces">  </span><span class="istickedoff">helper :: CtxLiftSubst f m =&gt; CtxTermsCtx ctx1 s -&gt;</span>
<span class="lineno">  644 </span><span class="spaces">            </span><span class="istickedoff">InvBindings (CtxEither tp1 tp2) (ctx1 &lt;+&gt; s) ctx2 -&gt;</span>
<span class="lineno">  645 </span><span class="spaces">            </span><span class="istickedoff">Bindings tp2 ((ctx1 &lt;+&gt; s) &lt;+&gt; ctx2) ctx3 -&gt;</span>
<span class="lineno">  646 </span><span class="spaces">            </span><span class="istickedoff">f (CtxInvApp ((ctx1 &lt;+&gt; s) &lt;+&gt; ctx2) ctx3) a -&gt;</span>
<span class="lineno">  647 </span><span class="spaces">            </span><span class="istickedoff">m (f (CtxInvApp (ctx1 &lt;+&gt; ctx2) ctx3) a)</span>
<span class="lineno">  648 </span><span class="spaces">  </span><span class="istickedoff">helper s ctx2 NoBind f = ctxSubst s ctx2 f</span>
<span class="lineno">  649 </span><span class="spaces">  </span><span class="istickedoff">helper s ctx2 (Bind x tp ctx3) f =</span>
<span class="lineno">  650 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">helper s (InvBind ctx2 x (CtxEither $ Right tp)) ctx3 f</span></span></span>
<span class="lineno">  651 </span>
<span class="lineno">  652 </span>instance MonadTerm m =&gt; CtxLiftSubst CtxTerm m where
<span class="lineno">  653 </span>  <span class="decl"><span class="istickedoff">ctxLift ctx1 ctx2 (CtxTerm t) =</span>
<span class="lineno">  654 </span><span class="spaces">    </span><span class="istickedoff">CtxTerm &lt;$&gt; liftTerm (invBindingsLength ctx1) (bindingsLength ctx2) t</span></span>
<span class="lineno">  655 </span>  <span class="decl"><span class="istickedoff">ctxSubst subst ctx (CtxTerm t) =</span>
<span class="lineno">  656 </span><span class="spaces">    </span><span class="istickedoff">-- NOTE: our term lists put the least recently-bound variable first, so we</span>
<span class="lineno">  657 </span><span class="spaces">    </span><span class="istickedoff">-- have to reverse here to call substTerm, which wants the term for the most</span>
<span class="lineno">  658 </span><span class="spaces">    </span><span class="istickedoff">-- recently-bound variable first</span>
<span class="lineno">  659 </span><span class="spaces">    </span><span class="istickedoff">CtxTerm &lt;$&gt;</span>
<span class="lineno">  660 </span><span class="spaces">    </span><span class="istickedoff">substTerm (invBindingsLength ctx) (reverse (ctxTermsCtxToListUnsafe subst)) t</span></span>
<span class="lineno">  661 </span>
<span class="lineno">  662 </span>instance MonadTerm m =&gt; CtxLiftSubst CtxTerms m where
<span class="lineno">  663 </span>  <span class="decl"><span class="istickedoff">ctxLift _ _ CtxTermsNil = return CtxTermsNil</span>
<span class="lineno">  664 </span><span class="spaces">  </span><span class="istickedoff">ctxLift ctx1 ctx2 (CtxTermsCons t ts) =</span>
<span class="lineno">  665 </span><span class="spaces">    </span><span class="istickedoff">CtxTermsCons &lt;$&gt; ctxLift ctx1 ctx2 t &lt;*&gt; ctxLift ctx1 ctx2 ts</span></span>
<span class="lineno">  666 </span>  <span class="decl"><span class="istickedoff">ctxSubst _ _ CtxTermsNil = return CtxTermsNil</span>
<span class="lineno">  667 </span><span class="spaces">  </span><span class="istickedoff">ctxSubst subst ctx (CtxTermsCons t ts) =</span>
<span class="lineno">  668 </span><span class="spaces">    </span><span class="istickedoff">CtxTermsCons &lt;$&gt; ctxSubst subst ctx t &lt;*&gt;</span>
<span class="lineno">  669 </span><span class="spaces">    </span><span class="istickedoff">ctxSubst <span class="nottickedoff">subst</span> <span class="nottickedoff">ctx</span> ts</span></span>
<span class="lineno">  670 </span>
<span class="lineno">  671 </span>instance MonadTerm m =&gt; CtxLiftSubst CtxTermsCtx m where
<span class="lineno">  672 </span>  <span class="decl"><span class="istickedoff">ctxLift _ _ CtxTermsCtxNil = return CtxTermsCtxNil</span>
<span class="lineno">  673 </span><span class="spaces">  </span><span class="istickedoff">ctxLift ctx1 ctx2 (CtxTermsCtxCons ts t) =</span>
<span class="lineno">  674 </span><span class="spaces">    </span><span class="istickedoff">CtxTermsCtxCons &lt;$&gt; ctxLift ctx1 ctx2 ts &lt;*&gt; ctxLift ctx1 ctx2 t</span></span>
<span class="lineno">  675 </span>  <span class="decl"><span class="nottickedoff">ctxSubst _ _ CtxTermsCtxNil = return CtxTermsCtxNil</span>
<span class="lineno">  676 </span><span class="spaces">  </span><span class="nottickedoff">ctxSubst subst ctx (CtxTermsCtxCons ts t) =</span>
<span class="lineno">  677 </span><span class="spaces">    </span><span class="nottickedoff">CtxTermsCtxCons &lt;$&gt; ctxSubst subst ctx ts &lt;*&gt;</span>
<span class="lineno">  678 </span><span class="spaces">    </span><span class="nottickedoff">ctxSubst subst ctx t</span></span>
<span class="lineno">  679 </span>
<span class="lineno">  680 </span>instance CtxLiftSubst tp m =&gt; CtxLiftSubst (Bindings tp) m where
<span class="lineno">  681 </span>  <span class="decl"><span class="istickedoff">ctxLift _ _ NoBind = return NoBind</span>
<span class="lineno">  682 </span><span class="spaces">  </span><span class="istickedoff">ctxLift ctx1 ctx2 (Bind x x_tp bs) =</span>
<span class="lineno">  683 </span><span class="spaces">    </span><span class="istickedoff">Bind x &lt;$&gt; ctxLift ctx1 ctx2 x_tp &lt;*&gt;</span>
<span class="lineno">  684 </span><span class="spaces">    </span><span class="istickedoff">ctxLift (InvBind ctx1 <span class="nottickedoff">x</span> <span class="nottickedoff">(error &quot;Unused&quot;)</span>) ctx2 bs</span></span>
<span class="lineno">  685 </span>  <span class="decl"><span class="istickedoff">ctxSubst _ _ NoBind = return NoBind</span>
<span class="lineno">  686 </span><span class="spaces">  </span><span class="istickedoff">ctxSubst subst ctx (Bind x x_tp bs) =</span>
<span class="lineno">  687 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Bind x &lt;$&gt; ctxSubst subst ctx x_tp &lt;*&gt;</span></span>
<span class="lineno">  688 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">ctxSubst subst (InvBind ctx x (error &quot;Unused&quot;)) bs</span></span></span>
<span class="lineno">  689 </span>
<span class="lineno">  690 </span>instance MonadTerm m =&gt; CtxLiftSubst (CtorArg d ixs) m where
<span class="lineno">  691 </span>  <span class="decl"><span class="istickedoff">ctxLift ctx1 ctx2 (ConstArg tp) = ConstArg &lt;$&gt; ctxLift ctx1 ctx2 tp</span>
<span class="lineno">  692 </span><span class="spaces">  </span><span class="istickedoff">ctxLift ctx1 ctx2 (RecursiveArg zs ixs) =</span>
<span class="lineno">  693 </span><span class="spaces">    </span><span class="istickedoff">RecursiveArg &lt;$&gt; ctxLift <span class="nottickedoff">ctx1</span> <span class="nottickedoff">ctx2</span> zs &lt;*&gt;</span>
<span class="lineno">  694 </span><span class="spaces">    </span><span class="istickedoff">ctxLiftInBindings ctx1 zs ctx2 ixs</span></span>
<span class="lineno">  695 </span>  <span class="decl"><span class="nottickedoff">ctxSubst subst ctx (ConstArg tp) = ConstArg &lt;$&gt; ctxSubst subst ctx tp</span>
<span class="lineno">  696 </span><span class="spaces">  </span><span class="nottickedoff">ctxSubst subst ctx (RecursiveArg zs ixs) =</span>
<span class="lineno">  697 </span><span class="spaces">    </span><span class="nottickedoff">RecursiveArg &lt;$&gt; ctxSubst subst ctx zs &lt;*&gt;</span>
<span class="lineno">  698 </span><span class="spaces">    </span><span class="nottickedoff">ctxSubstInBindings subst ctx zs ixs</span></span>
<span class="lineno">  699 </span>
<span class="lineno">  700 </span>-- | Make a closed term and then lift it into a context
<span class="lineno">  701 </span>mkLiftedClosedTerm :: MonadTerm m =&gt; Bindings tp EmptyCtx as -&gt; Term -&gt;
<span class="lineno">  702 </span>                      m (CtxTerm (CtxInv as) a)
<span class="lineno">  703 </span><span class="decl"><span class="nottickedoff">mkLiftedClosedTerm inners t = ctxLift InvNoBind inners $ mkClosedTerm t</span></span>
<span class="lineno">  704 </span>
<span class="lineno">  705 </span>
<span class="lineno">  706 </span>--
<span class="lineno">  707 </span>-- * Constructor Argument Types
<span class="lineno">  708 </span>--
<span class="lineno">  709 </span>
<span class="lineno">  710 </span>-- | A specification of the type of an argument for a constructor of datatype
<span class="lineno">  711 </span>-- @d@, that has a specified list @ixs@ of indices, inside a context @ctx@ of
<span class="lineno">  712 </span>-- parameters and earlier arguments
<span class="lineno">  713 </span>data CtorArg d ixs ctx a where
<span class="lineno">  714 </span>  -- | A fixed, constant type
<span class="lineno">  715 </span>  ConstArg :: CtxTerm ctx (Typ a) -&gt; CtorArg d ixs ctx (Typ a)
<span class="lineno">  716 </span>  -- | The construct @'RecursiveArg [(z1,tp1),..,(zn,tpn)] [e1,..,ek]'@
<span class="lineno">  717 </span>  -- specifies a recursive argument type of the form
<span class="lineno">  718 </span>  --
<span class="lineno">  719 </span>  -- &gt; (z1::tp1) -&gt; .. -&gt; (zn::tpn) -&gt; d p1 .. pm e1 .. ek
<span class="lineno">  720 </span>  --
<span class="lineno">  721 </span>  -- where @d@ is the datatype, the @zi::tpi@ are the elements of the Pi
<span class="lineno">  722 </span>  -- context (the first argument to 'RecursiveArgType'), the @pi@ are the
<span class="lineno">  723 </span>  -- parameters of @d@ (not given here), and the @ei@ are the type indices of
<span class="lineno">  724 </span>  -- @d@.
<span class="lineno">  725 </span>  RecursiveArg ::
<span class="lineno">  726 </span>    Bindings CtxTerm ctx zs -&gt;
<span class="lineno">  727 </span>    CtxTerms (CtxInvApp ctx zs) ixs -&gt;
<span class="lineno">  728 </span>    CtorArg d ixs ctx (Typ (Arrows zs d))
<span class="lineno">  729 </span>
<span class="lineno">  730 </span>-- | A structure that defines the parameters, arguments, and return type indices
<span class="lineno">  731 </span>-- of a constructor, using 'CtxTerm' and friends to get the bindings right
<span class="lineno">  732 </span>data CtorArgStruct d params ixs =
<span class="lineno">  733 </span>  forall args.
<span class="lineno">  734 </span>  CtorArgStruct
<span class="lineno">  735 </span>  {
<span class="lineno">  736 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">ctorParams</span></span></span> :: Bindings CtxTerm EmptyCtx params,
<span class="lineno">  737 </span>    <span class="decl"><span class="nottickedoff">ctorArgs</span></span> :: Bindings (CtorArg d ixs) (CtxInv params) args,
<span class="lineno">  738 </span>    <span class="decl"><span class="nottickedoff">ctorIndices</span></span> :: CtxTerms (CtxInvApp (CtxInv params) args) ixs,
<span class="lineno">  739 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">dataTypeIndices</span></span></span> :: Bindings CtxTerm (CtxInv params) ixs
<span class="lineno">  740 </span>  }
<span class="lineno">  741 </span>
<span class="lineno">  742 </span>
<span class="lineno">  743 </span>-- | Convert a 'CtorArg' into the type that it represents, given a context of
<span class="lineno">  744 </span>-- the parameters and of the previous arguments
<span class="lineno">  745 </span>ctxCtorArgType :: MonadTerm m =&gt; DataIdent d -&gt;
<span class="lineno">  746 </span>                  InvBindings CtxTerm EmptyCtx params -&gt;
<span class="lineno">  747 </span>                  InvBindings CtxTerm params prevs -&gt;
<span class="lineno">  748 </span>                  CtorArg d ixs (params &lt;+&gt; prevs) a -&gt;
<span class="lineno">  749 </span>                  m (CtxTerm (params &lt;+&gt; prevs) a)
<span class="lineno">  750 </span><span class="decl"><span class="istickedoff">ctxCtorArgType _ _ _ (ConstArg tp) = return tp</span>
<span class="lineno">  751 </span><span class="spaces"></span><span class="istickedoff">ctxCtorArgType d params prevs (RecursiveArg zs_ctx ixs) =</span>
<span class="lineno">  752 </span><span class="spaces">  </span><span class="istickedoff">ctxPi zs_ctx $ \_ -&gt;</span>
<span class="lineno">  753 </span><span class="spaces">  </span><span class="istickedoff">ctxDataTypeM d ((fst &lt;$&gt; ctxVars2 params prevs) &gt;&gt;= ctxLift <span class="nottickedoff">InvNoBind</span> zs_ctx)</span>
<span class="lineno">  754 </span><span class="spaces">  </span><span class="istickedoff">(return $ invertCtxTerms ixs)</span></span>
<span class="lineno">  755 </span>
<span class="lineno">  756 </span>-- | Convert a bindings list of 'CtorArg's to a binding list of types
<span class="lineno">  757 </span>ctxCtorArgBindings :: MonadTerm m =&gt; DataIdent d -&gt;
<span class="lineno">  758 </span>                      InvBindings CtxTerm EmptyCtx params -&gt;
<span class="lineno">  759 </span>                      InvBindings CtxTerm params prevs -&gt;
<span class="lineno">  760 </span>                      Bindings (CtorArg d ixs) (params &lt;+&gt; prevs) args -&gt;
<span class="lineno">  761 </span>                      m (Bindings CtxTerm (params &lt;+&gt; prevs) args)
<span class="lineno">  762 </span><span class="decl"><span class="istickedoff">ctxCtorArgBindings _ _ _ NoBind = return NoBind</span>
<span class="lineno">  763 </span><span class="spaces"></span><span class="istickedoff">ctxCtorArgBindings d params prevs (Bind x arg args) =</span>
<span class="lineno">  764 </span><span class="spaces">  </span><span class="istickedoff">do tp &lt;- ctxCtorArgType d params prevs arg</span>
<span class="lineno">  765 </span><span class="spaces">     </span><span class="istickedoff">rest &lt;- ctxCtorArgBindings d params (InvBind prevs <span class="nottickedoff">x</span> <span class="nottickedoff">tp</span>) args</span>
<span class="lineno">  766 </span><span class="spaces">     </span><span class="istickedoff">return (Bind x tp rest)</span></span>
<span class="lineno">  767 </span>
<span class="lineno">  768 </span>-- | Compute the type of a constructor from the name of its datatype and its
<span class="lineno">  769 </span>-- 'CtorArgStruct'
<span class="lineno">  770 </span>ctxCtorType :: MonadTerm m =&gt; ExtCns Term -&gt; CtorArgStruct d params ixs -&gt; m Term
<span class="lineno">  771 </span><span class="decl"><span class="istickedoff">ctxCtorType d (CtorArgStruct{..}) =</span>
<span class="lineno">  772 </span><span class="spaces">  </span><span class="istickedoff">elimClosedTerm &lt;$&gt;</span>
<span class="lineno">  773 </span><span class="spaces">  </span><span class="istickedoff">(ctxPi ctorParams $ \params -&gt;</span>
<span class="lineno">  774 </span><span class="spaces">    </span><span class="istickedoff">do bs &lt;-</span>
<span class="lineno">  775 </span><span class="spaces">         </span><span class="istickedoff">ctxCtorArgBindings (DataIdent d) (invertBindings ctorParams)</span>
<span class="lineno">  776 </span><span class="spaces">         </span><span class="istickedoff">InvNoBind ctorArgs</span>
<span class="lineno">  777 </span><span class="spaces">       </span><span class="istickedoff">ctxPi bs $ \_ -&gt;</span>
<span class="lineno">  778 </span><span class="spaces">         </span><span class="istickedoff">ctxDataTypeM (DataIdent d)</span>
<span class="lineno">  779 </span><span class="spaces">         </span><span class="istickedoff">(ctxLift InvNoBind bs $ invertCtxTerms params)</span>
<span class="lineno">  780 </span><span class="spaces">         </span><span class="istickedoff">(return $ invertCtxTerms ctorIndices))</span></span>
<span class="lineno">  781 </span>
<span class="lineno">  782 </span>
<span class="lineno">  783 </span>--
<span class="lineno">  784 </span>-- * Computing with Eliminators
<span class="lineno">  785 </span>--
<span class="lineno">  786 </span>
<span class="lineno">  787 </span>-- | Build the type of the @p_ret@ function, also known as the &quot;motive&quot;
<span class="lineno">  788 </span>-- function, of a recursor on datatype @d@. This type has the form
<span class="lineno">  789 </span>--
<span class="lineno">  790 </span>-- &gt; (i1::ix1) -&gt; .. -&gt; (im::ixm) -&gt; d p1 .. pn i1 .. im -&gt; s
<span class="lineno">  791 </span>--
<span class="lineno">  792 </span>-- where the @pi@ are free variables for the parameters of @d@, the @ixj@
<span class="lineno">  793 </span>-- are the indices of @d@, and @s@ is any sort supplied as an argument.
<span class="lineno">  794 </span>ctxPRetTp :: MonadTerm m =&gt; Proxy (Typ a) -&gt; DataIdent d -&gt;
<span class="lineno">  795 </span>             InvBindings CtxTerm EmptyCtx ps -&gt;
<span class="lineno">  796 </span>             Bindings CtxTerm ps ixs -&gt; Sort -&gt;
<span class="lineno">  797 </span>             m (CtxTerm ps (Typ (Arrows ixs (d -&gt; Typ a))))
<span class="lineno">  798 </span><span class="decl"><span class="istickedoff">ctxPRetTp (_ :: Proxy (Typ a)) (d :: DataIdent d) params ixs s =</span>
<span class="lineno">  799 </span><span class="spaces">  </span><span class="istickedoff">ctxPiProxy <span class="nottickedoff">(Proxy :: Proxy (Typ (d -&gt; Typ a)))</span> ixs $ \ix_vars -&gt;</span>
<span class="lineno">  800 </span><span class="spaces">  </span><span class="istickedoff">do param_vars &lt;- ctxVars params</span>
<span class="lineno">  801 </span><span class="spaces">     </span><span class="istickedoff">dt &lt;- ctxDataTypeM d (ctxLift InvNoBind ixs param_vars)</span>
<span class="lineno">  802 </span><span class="spaces">       </span><span class="istickedoff">(return $ invertCtxTerms ix_vars)</span>
<span class="lineno">  803 </span><span class="spaces">     </span><span class="istickedoff">ctxPi1 &quot;_&quot; dt $ \_ -&gt; ctxSort s</span></span>
<span class="lineno">  804 </span>
<span class="lineno">  805 </span>-- | Like 'ctxPRetTp', but also take in a list of parameters and substitute them
<span class="lineno">  806 </span>-- for the parameter variables returned by that function
<span class="lineno">  807 </span>mkPRetTp :: MonadTerm m =&gt;
<span class="lineno">  808 </span>  ExtCns Term -&gt;
<span class="lineno">  809 </span>  [(LocalName, Term)] -&gt;
<span class="lineno">  810 </span>  [(LocalName, Term)] -&gt;
<span class="lineno">  811 </span>  [Term] -&gt;
<span class="lineno">  812 </span>  Sort -&gt;
<span class="lineno">  813 </span>  m Term
<span class="lineno">  814 </span><span class="decl"><span class="istickedoff">mkPRetTp d untyped_p_ctx untyped_ix_ctx untyped_params s =</span>
<span class="lineno">  815 </span><span class="spaces">  </span><span class="istickedoff">case ctxBindingsOfTerms untyped_p_ctx of</span>
<span class="lineno">  816 </span><span class="spaces">    </span><span class="istickedoff">ExistsTp p_ctx -&gt;</span>
<span class="lineno">  817 </span><span class="spaces">      </span><span class="istickedoff">case (ctxBindingsOfTerms untyped_ix_ctx,</span>
<span class="lineno">  818 </span><span class="spaces">            </span><span class="istickedoff">ctxTermsForBindings p_ctx untyped_params) of</span>
<span class="lineno">  819 </span><span class="spaces">        </span><span class="istickedoff">(ExistsTp ix_ctx, Just params) -&gt;</span>
<span class="lineno">  820 </span><span class="spaces">          </span><span class="istickedoff">do p_ret &lt;- (ctxPRetTp <span class="nottickedoff">Proxy</span> (DataIdent d)</span>
<span class="lineno">  821 </span><span class="spaces">                       </span><span class="istickedoff">(invertBindings p_ctx) ix_ctx s)</span>
<span class="lineno">  822 </span><span class="spaces">             </span><span class="istickedoff">elimClosedTerm &lt;$&gt;</span>
<span class="lineno">  823 </span><span class="spaces">               </span><span class="istickedoff">ctxSubst (invertCtxTerms params) InvNoBind</span>
<span class="lineno">  824 </span><span class="spaces">               </span><span class="istickedoff">(castPRet (invertBindings p_ctx) p_ret)</span>
<span class="lineno">  825 </span><span class="spaces">        </span><span class="istickedoff">(_, Nothing) -&gt;</span>
<span class="lineno">  826 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">error &quot;mkPRetTp: incorrect number of parameters&quot;</span></span>
<span class="lineno">  827 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  828 </span><span class="spaces">    </span><span class="istickedoff">castPRet :: InvBindings tp ctx1 ctx -&gt; CtxTerm ctx a -&gt;</span>
<span class="lineno">  829 </span><span class="spaces">                </span><span class="istickedoff">CtxTerm (EmptyCtx &lt;+&gt; ctx) a</span>
<span class="lineno">  830 </span><span class="spaces">    </span><span class="istickedoff">castPRet ctx =</span>
<span class="lineno">  831 </span><span class="spaces">      </span><span class="istickedoff">case ctxAppNilEq ctx of</span>
<span class="lineno">  832 </span><span class="spaces">        </span><span class="istickedoff">Refl -&gt; id</span></span>
<span class="lineno">  833 </span>
<span class="lineno">  834 </span>
<span class="lineno">  835 </span>-- | Compute the type of an eliminator function for a constructor from the name
<span class="lineno">  836 </span>-- of its datatype, its name, and its 'CtorArgStruct'. This type has, as free
<span class="lineno">  837 </span>-- variables, both the parameters of the datatype and a &quot;motive&quot; function from
<span class="lineno">  838 </span>-- indices of the datatype to a return type. It is of the form
<span class="lineno">  839 </span>--
<span class="lineno">  840 </span>-- &gt; (x1::arg1) -&gt; maybe (rec1::rec_tp1) -&gt; .. -&gt;
<span class="lineno">  841 </span>-- &gt; (xn::argn) -&gt; maybe (recn::rec_tpn) -&gt;
<span class="lineno">  842 </span>-- &gt;   p_ret ix_1 .. ix_k (ctor params x1 .. xn)
<span class="lineno">  843 </span>--
<span class="lineno">  844 </span>-- where the ixs are the type indices of the return type for the constructor,
<span class="lineno">  845 </span>-- the (xi::argi) are the arguments of the constructor, and the @maybe@s
<span class="lineno">  846 </span>-- indicate additional arguments that are present only for arguments of
<span class="lineno">  847 </span>-- recursive type, that is, where @argi@ has the form
<span class="lineno">  848 </span>--
<span class="lineno">  849 </span>-- &gt; (z1::Z1) -&gt; .. -&gt; (zm::Zm) -&gt; d params t1 .. tk
<span class="lineno">  850 </span>--
<span class="lineno">  851 </span>-- In this case, @rec_tpi@ has the form
<span class="lineno">  852 </span>--
<span class="lineno">  853 </span>-- &gt; (z1::Z1) -&gt; .. -&gt; (zm::Zm) -&gt; p_ret t1 .. tk (f z1 .. zm)
<span class="lineno">  854 </span>--
<span class="lineno">  855 </span>-- Note that the output type cannot be expressed in the type of this function,
<span class="lineno">  856 </span>-- since it depends on fields of the 'CtorArgStruct', so, instead, the result is
<span class="lineno">  857 </span>-- just casted to whatever type the caller specifies.
<span class="lineno">  858 </span>ctxCtorElimType :: MonadTerm m =&gt;
<span class="lineno">  859 </span>  Proxy (Typ ret) -&gt;
<span class="lineno">  860 </span>  Proxy (Typ a) -&gt;
<span class="lineno">  861 </span>  DataIdent d -&gt;
<span class="lineno">  862 </span>  ExtCns Term -&gt;
<span class="lineno">  863 </span>  CtorArgStruct d params ixs -&gt;
<span class="lineno">  864 </span>  m (CtxTerm (CtxInv params ::&gt;(Arrows ixs (d -&gt; Typ a))) (Typ ret))
<span class="lineno">  865 </span><span class="decl"><span class="istickedoff">ctxCtorElimType ret (a_top :: Proxy (Typ a)) (d_top :: DataIdent d) c</span>
<span class="lineno">  866 </span><span class="spaces">  </span><span class="istickedoff">(CtorArgStruct{..}) =</span>
<span class="lineno">  867 </span><span class="spaces">  </span><span class="istickedoff">(do let params = invertBindings ctorParams</span>
<span class="lineno">  868 </span><span class="spaces">      </span><span class="istickedoff">-- NOTE: we use propSort for the type of p_ret just as arbitrary sort, but</span>
<span class="lineno">  869 </span><span class="spaces">      </span><span class="istickedoff">-- it doesn't matter because p_ret_tp is only actually used to form</span>
<span class="lineno">  870 </span><span class="spaces">      </span><span class="istickedoff">-- contexts, and is never actually used directly in the output</span>
<span class="lineno">  871 </span><span class="spaces">      </span><span class="istickedoff">p_ret_tp &lt;- ctxPRetTp <span class="nottickedoff">a_top</span> d_top params dataTypeIndices propSort</span>
<span class="lineno">  872 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  873 </span><span class="spaces">      </span><span class="istickedoff">-- Lift the argument and return indices into the context of p_ret</span>
<span class="lineno">  874 </span><span class="spaces">      </span><span class="istickedoff">args &lt;- ctxLift InvNoBind (Bind <span class="nottickedoff">&quot;_&quot;</span> <span class="nottickedoff">p_ret_tp</span> NoBind) ctorArgs</span>
<span class="lineno">  875 </span><span class="spaces">      </span><span class="istickedoff">ixs &lt;-</span>
<span class="lineno">  876 </span><span class="spaces">        </span><span class="istickedoff">ctxLiftInBindings InvNoBind ctorArgs (Bind <span class="nottickedoff">&quot;_&quot;</span> <span class="nottickedoff">p_ret_tp</span> NoBind)</span>
<span class="lineno">  877 </span><span class="spaces">        </span><span class="istickedoff">ctorIndices</span>
<span class="lineno">  878 </span><span class="spaces">      </span><span class="istickedoff">-- Form the context (params ::&gt; p_ret)</span>
<span class="lineno">  879 </span><span class="spaces">      </span><span class="istickedoff">let params_pret = InvBind params <span class="nottickedoff">&quot;_&quot;</span> <span class="nottickedoff">(ctxLiftNil params p_ret_tp)</span></span>
<span class="lineno">  880 </span><span class="spaces">      </span><span class="istickedoff">-- Call the helper and cast the result to (Typ ret)</span>
<span class="lineno">  881 </span><span class="spaces">      </span><span class="istickedoff">castCtxTerm <span class="nottickedoff">Proxy</span> <span class="nottickedoff">ret</span> &lt;$&gt;</span>
<span class="lineno">  882 </span><span class="spaces">        </span><span class="istickedoff">helper <span class="nottickedoff">a_top</span> d_top params_pret InvNoBind args ixs</span>
<span class="lineno">  883 </span><span class="spaces">  </span><span class="istickedoff">) where</span>
<span class="lineno">  884 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  885 </span><span class="spaces">  </span><span class="istickedoff">-- Iterate through the argument types of the constructor, building up a</span>
<span class="lineno">  886 </span><span class="spaces">  </span><span class="istickedoff">-- function from those arguments to the result type of the p_ret function.</span>
<span class="lineno">  887 </span><span class="spaces">  </span><span class="istickedoff">-- Note that, technically, this function also takes in recursive calls, so has</span>
<span class="lineno">  888 </span><span class="spaces">  </span><span class="istickedoff">-- a slightly richer type, but we are not going to try to compute this richer</span>
<span class="lineno">  889 </span><span class="spaces">  </span><span class="istickedoff">-- type in Haskell land.</span>
<span class="lineno">  890 </span><span class="spaces">  </span><span class="istickedoff">helper :: MonadTerm m =&gt;</span>
<span class="lineno">  891 </span><span class="spaces">    </span><span class="istickedoff">Proxy (Typ a) -&gt;</span>
<span class="lineno">  892 </span><span class="spaces">    </span><span class="istickedoff">DataIdent d -&gt;</span>
<span class="lineno">  893 </span><span class="spaces">    </span><span class="istickedoff">InvBindings CtxTerm EmptyCtx (ps ::&gt; Arrows ixs (d -&gt; Typ a)) -&gt;</span>
<span class="lineno">  894 </span><span class="spaces">    </span><span class="istickedoff">InvBindings CtxTerm (ps ::&gt; Arrows ixs (d -&gt; Typ a)) prevs -&gt;</span>
<span class="lineno">  895 </span><span class="spaces">    </span><span class="istickedoff">Bindings (CtorArg d ixs) ((ps ::&gt; Arrows ixs (d -&gt; Typ a)) &lt;+&gt; prevs) args -&gt;</span>
<span class="lineno">  896 </span><span class="spaces">    </span><span class="istickedoff">CtxTerms (CtxInvApp ((ps ::&gt; Arrows ixs (d -&gt; Typ a)) &lt;+&gt; prevs) args) ixs -&gt;</span>
<span class="lineno">  897 </span><span class="spaces">    </span><span class="istickedoff">m (CtxTerm ((ps ::&gt; Arrows ixs (d -&gt; Typ a)) &lt;+&gt; prevs) (Typ (Arrows args a)))</span>
<span class="lineno">  898 </span><span class="spaces">  </span><span class="istickedoff">helper _a d params_pret prevs NoBind ret_ixs =</span>
<span class="lineno">  899 </span><span class="spaces">    </span><span class="istickedoff">-- If we are finished with our arguments, construct the final result type</span>
<span class="lineno">  900 </span><span class="spaces">    </span><span class="istickedoff">-- (p_ret ret_ixs (c params prevs))</span>
<span class="lineno">  901 </span><span class="spaces">    </span><span class="istickedoff">do (vars, prev_vars) &lt;- ctxVars2 params_pret prevs</span>
<span class="lineno">  902 </span><span class="spaces">       </span><span class="istickedoff">let (param_terms, p_ret) = ctxTermsCtxHeadTail vars</span>
<span class="lineno">  903 </span><span class="spaces">       </span><span class="istickedoff">ctxApply (ctxApplyMulti (return p_ret) (return ret_ixs)) $</span>
<span class="lineno">  904 </span><span class="spaces">         </span><span class="istickedoff">ctxCtorAppM <span class="nottickedoff">d</span> c (return param_terms) (return prev_vars)</span>
<span class="lineno">  905 </span><span class="spaces">  </span><span class="istickedoff">helper a d params_pret prevs (Bind str (ConstArg tp) args) ixs =</span>
<span class="lineno">  906 </span><span class="spaces">    </span><span class="istickedoff">-- For a constant argument type, just abstract it and continue</span>
<span class="lineno">  907 </span><span class="spaces">    </span><span class="istickedoff">(ctxPi (Bind str tp NoBind) $ \_ -&gt;</span>
<span class="lineno">  908 </span><span class="spaces">      </span><span class="istickedoff">helper <span class="nottickedoff">a</span> d params_pret (InvBind prevs <span class="nottickedoff">str</span> <span class="nottickedoff">tp</span>) args ixs)</span>
<span class="lineno">  909 </span><span class="spaces">  </span><span class="istickedoff">helper (a :: Proxy (Typ a)) (d::DataIdent d) params_pret</span>
<span class="lineno">  910 </span><span class="spaces">    </span><span class="istickedoff">prevs (Bind str (RecursiveArg zs ts) args) ixs =</span>
<span class="lineno">  911 </span><span class="spaces">    </span><span class="istickedoff">-- For a recursive argument type of the form</span>
<span class="lineno">  912 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno">  913 </span><span class="spaces">    </span><span class="istickedoff">-- (z1::Z1) -&gt; .. -&gt; (zm::Zm) -&gt; d params t1 .. tk</span>
<span class="lineno">  914 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno">  915 </span><span class="spaces">    </span><span class="istickedoff">-- form the type abstraction</span>
<span class="lineno">  916 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno">  917 </span><span class="spaces">    </span><span class="istickedoff">-- (arg:: (z1::Z1) -&gt; .. -&gt; (zm::Zm) -&gt; d params t1 .. tk) -&gt;</span>
<span class="lineno">  918 </span><span class="spaces">    </span><span class="istickedoff">-- (ih :: (z1::Z1) -&gt; .. -&gt; (zm::Zm) -&gt; p_ret t1 .. tk (arg z1 .. zm)) -&gt;</span>
<span class="lineno">  919 </span><span class="spaces">    </span><span class="istickedoff">-- rest</span>
<span class="lineno">  920 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno">  921 </span><span class="spaces">    </span><span class="istickedoff">-- where rest is the result of a recursive call</span>
<span class="lineno">  922 </span><span class="spaces">    </span><span class="istickedoff">do</span>
<span class="lineno">  923 </span><span class="spaces">      </span><span class="istickedoff">-- Build terms for the params and p_ret variables</span>
<span class="lineno">  924 </span><span class="spaces">      </span><span class="istickedoff">(param_vars, p_ret) &lt;-</span>
<span class="lineno">  925 </span><span class="spaces">        </span><span class="istickedoff">ctxTermsCtxHeadTail &lt;$&gt; fst &lt;$&gt; ctxVars2 params_pret prevs</span>
<span class="lineno">  926 </span><span class="spaces">      </span><span class="istickedoff">-- Build the type of the argument arg</span>
<span class="lineno">  927 </span><span class="spaces">      </span><span class="istickedoff">arg_tp &lt;- ctxPi zs (\_ -&gt; ctxDataTypeM d</span>
<span class="lineno">  928 </span><span class="spaces">                                </span><span class="istickedoff">(ctxLift <span class="nottickedoff">InvNoBind</span> zs param_vars)</span>
<span class="lineno">  929 </span><span class="spaces">                                </span><span class="istickedoff">(return $ invertCtxTerms ts))</span>
<span class="lineno">  930 </span><span class="spaces">      </span><span class="istickedoff">-- Lift zs and ts into the context of arg</span>
<span class="lineno">  931 </span><span class="spaces">      </span><span class="istickedoff">let arg_ctx = Bind <span class="nottickedoff">&quot;_&quot;</span> <span class="nottickedoff">arg_tp</span> NoBind</span>
<span class="lineno">  932 </span><span class="spaces">      </span><span class="istickedoff">zs' &lt;- ctxLift <span class="nottickedoff">InvNoBind</span> <span class="nottickedoff">arg_ctx</span> zs</span>
<span class="lineno">  933 </span><span class="spaces">      </span><span class="istickedoff">ts' &lt;- ctxLiftInBindings InvNoBind zs arg_ctx ts</span>
<span class="lineno">  934 </span><span class="spaces">      </span><span class="istickedoff">-- Build the pi-abstraction for arg</span>
<span class="lineno">  935 </span><span class="spaces">      </span><span class="istickedoff">ctxPi1 str arg_tp $ \arg -&gt;</span>
<span class="lineno">  936 </span><span class="spaces">        </span><span class="istickedoff">do rest &lt;-</span>
<span class="lineno">  937 </span><span class="spaces">             </span><span class="istickedoff">helper <span class="nottickedoff">a</span> d params_pret (InvBind prevs <span class="nottickedoff">str</span> <span class="nottickedoff">arg_tp</span>) args ixs</span>
<span class="lineno">  938 </span><span class="spaces">           </span><span class="istickedoff">-- Build the type of ih, in the context of arg</span>
<span class="lineno">  939 </span><span class="spaces">           </span><span class="istickedoff">ih_tp &lt;- ctxPi zs' $ \z_vars -&gt;</span>
<span class="lineno">  940 </span><span class="spaces">             </span><span class="istickedoff">ctxApplyProxy <span class="nottickedoff">(Proxy :: Proxy d)</span> <span class="nottickedoff">(Proxy :: Proxy (Typ a))</span></span>
<span class="lineno">  941 </span><span class="spaces">             </span><span class="istickedoff">(ctxApplyMulti</span>
<span class="lineno">  942 </span><span class="spaces">              </span><span class="istickedoff">(ctxLift InvNoBind (Bind <span class="nottickedoff">&quot;_&quot;</span> <span class="nottickedoff">arg_tp</span> zs') p_ret) (return ts'))</span>
<span class="lineno">  943 </span><span class="spaces">             </span><span class="istickedoff">(ctxApplyMulti (ctxLift <span class="nottickedoff">InvNoBind</span> zs' arg) (return z_vars))</span>
<span class="lineno">  944 </span><span class="spaces">           </span><span class="istickedoff">-- Finally, build the pi-abstraction for ih around the rest</span>
<span class="lineno">  945 </span><span class="spaces">           </span><span class="istickedoff">--</span>
<span class="lineno">  946 </span><span class="spaces">           </span><span class="istickedoff">-- NOTE: we cast away the IH argument, because that is a type that is</span>
<span class="lineno">  947 </span><span class="spaces">           </span><span class="istickedoff">-- computed from the argument structure, and we cannot (well, we</span>
<span class="lineno">  948 </span><span class="spaces">           </span><span class="istickedoff">-- could, but it would be much more work to) express that computation</span>
<span class="lineno">  949 </span><span class="spaces">           </span><span class="istickedoff">-- in the Haskell type system</span>
<span class="lineno">  950 </span><span class="spaces">           </span><span class="istickedoff">castCtxTerm <span class="nottickedoff">Proxy</span> <span class="nottickedoff">Proxy</span> &lt;$&gt;</span>
<span class="lineno">  951 </span><span class="spaces">             </span><span class="istickedoff">(ctxPi1 &quot;_&quot; ih_tp $ \_ -&gt;</span>
<span class="lineno">  952 </span><span class="spaces">               </span><span class="istickedoff">ctxLift InvNoBind (Bind <span class="nottickedoff">&quot;_&quot;</span> <span class="nottickedoff">ih_tp</span> NoBind) rest)</span></span>
<span class="lineno">  953 </span>
<span class="lineno">  954 </span>-- | Build a function that substitutes parameters and a @p_ret@ return type
<span class="lineno">  955 </span>-- function into the type of an eliminator, as returned by 'ctxCtorElimType',
<span class="lineno">  956 </span>-- for the given constructor. We return the substitution function in the monad
<span class="lineno">  957 </span>-- so that we only call 'ctxCtorElimType' once but can call the function many
<span class="lineno">  958 </span>-- times, in order to amortize the overhead of 'ctxCtorElimType'.
<span class="lineno">  959 </span>mkCtorElimTypeFun :: MonadTerm m =&gt;
<span class="lineno">  960 </span>  ExtCns Term {- ^ data type -} -&gt;
<span class="lineno">  961 </span>  ExtCns Term {- ^ constructor type -} -&gt;
<span class="lineno">  962 </span>  CtorArgStruct d params ixs -&gt;
<span class="lineno">  963 </span>  m ([Term] -&gt; Term -&gt; m Term)
<span class="lineno">  964 </span><span class="decl"><span class="istickedoff">mkCtorElimTypeFun d c argStruct@(CtorArgStruct {..}) =</span>
<span class="lineno">  965 </span><span class="spaces">  </span><span class="istickedoff">do ctxElimType &lt;- ctxCtorElimType <span class="nottickedoff">Proxy</span> <span class="nottickedoff">Proxy</span> (DataIdent d) c argStruct</span>
<span class="lineno">  966 </span><span class="spaces">     </span><span class="istickedoff">case ctxAppNilEq (invertBindings ctorParams) of</span>
<span class="lineno">  967 </span><span class="spaces">       </span><span class="istickedoff">Refl -&gt;</span>
<span class="lineno">  968 </span><span class="spaces">         </span><span class="istickedoff">return $ \params p_ret -&gt;</span>
<span class="lineno">  969 </span><span class="spaces">         </span><span class="istickedoff">whnfTerm =&lt;&lt;</span>
<span class="lineno">  970 </span><span class="spaces">         </span><span class="istickedoff">case ctxTermsForBindings ctorParams params of</span>
<span class="lineno">  971 </span><span class="spaces">           </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">error &quot;ctorElimTypeFun: wrong number of parameters!&quot;</span></span>
<span class="lineno">  972 </span><span class="spaces">           </span><span class="istickedoff">Just paramsCtx -&gt;</span>
<span class="lineno">  973 </span><span class="spaces">             </span><span class="istickedoff">elimClosedTerm &lt;$&gt;</span>
<span class="lineno">  974 </span><span class="spaces">             </span><span class="istickedoff">ctxSubstInBindings</span>
<span class="lineno">  975 </span><span class="spaces">             </span><span class="istickedoff">(CtxTermsCtxCons (invertCtxTerms paramsCtx) (mkClosedTerm p_ret))</span>
<span class="lineno">  976 </span><span class="spaces">             </span><span class="istickedoff">InvNoBind NoBind ctxElimType</span></span>
<span class="lineno">  977 </span>
<span class="lineno">  978 </span>
<span class="lineno">  979 </span>-- | Reduce an application of a recursor to a particular constructor.
<span class="lineno">  980 </span>-- This is known in the Coq literature as an iota reduction. More specifically,
<span class="lineno">  981 </span>-- the call
<span class="lineno">  982 </span>--
<span class="lineno">  983 </span>-- &gt; ctxReduceRecursor rec f_c [x1, .., xk]
<span class="lineno">  984 </span>--
<span class="lineno">  985 </span>-- reduces the term @(RecursorApp rec ixs (CtorApp c ps xs))@ to
<span class="lineno">  986 </span>--
<span class="lineno">  987 </span>-- &gt; f_c x1 (maybe rec_tm_1) .. xk (maybe rec_tm_k)
<span class="lineno">  988 </span>--
<span class="lineno">  989 </span>-- where @f_c@ is the eliminator function associated to the constructor @c@ by the
<span class="lineno">  990 </span>-- recursor value @rec@.  Here @maybe rec_tm_i@ indicates an optional recursive call
<span class="lineno">  991 </span>-- of the recursor on one of the @xi@. These recursive calls only exist for those
<span class="lineno">  992 </span>-- arguments @xi@ that are recursive arguments, i.e., that are specified with
<span class="lineno">  993 </span>-- 'RecursiveArg', and are omitted for non-recursive arguments specified by 'ConstArg'.
<span class="lineno">  994 </span>--
<span class="lineno">  995 </span>-- Specifically, for a @'RecursiveArg' zs ixs@ argument @xi@, which has type
<span class="lineno">  996 </span>-- @\(z1::Z1) -&gt; .. -&gt; d p1 .. pn ix1 .. ixp@, we build the recursive call
<span class="lineno">  997 </span>--
<span class="lineno">  998 </span>-- &gt; \(z1::[xs/args]Z1) -&gt; .. -&gt;
<span class="lineno">  999 </span>-- &gt;   RecursorApp rec [xs/args]ixs (xi z1 ... zn)
<span class="lineno"> 1000 </span>--
<span class="lineno"> 1001 </span>-- where @[xs/args]@ substitutes the concrete values for the earlier
<span class="lineno"> 1002 </span>-- constructor arguments @xs@ for the remaining free variables.
<span class="lineno"> 1003 </span>
<span class="lineno"> 1004 </span>ctxReduceRecursor :: forall m d params ixs.
<span class="lineno"> 1005 </span>  MonadTerm m =&gt;
<span class="lineno"> 1006 </span>  Term {- ^ abstracted recursor -} -&gt;
<span class="lineno"> 1007 </span>  Term {- ^ constructor elimnator function -} -&gt;
<span class="lineno"> 1008 </span>  [Term] {- ^ constructor arguments -} -&gt;
<span class="lineno"> 1009 </span>  CtorArgStruct d params ixs {- ^ constructor formal argument descriptor -} -&gt;
<span class="lineno"> 1010 </span>  m Term
<span class="lineno"> 1011 </span><span class="decl"><span class="istickedoff">ctxReduceRecursor rec elimf c_args CtorArgStruct{..} =</span>
<span class="lineno"> 1012 </span><span class="spaces">  </span><span class="istickedoff">let inctx :: Term -&gt; CtxTerm (CtxInv params) tp</span>
<span class="lineno"> 1013 </span><span class="spaces">      </span><span class="istickedoff">inctx = CtxTerm</span>
<span class="lineno"> 1014 </span><span class="spaces">   </span><span class="istickedoff">in</span>
<span class="lineno"> 1015 </span><span class="spaces">  </span><span class="istickedoff">case ctxTermsForBindingsOpen ctorArgs c_args of</span>
<span class="lineno"> 1016 </span><span class="spaces">     </span><span class="istickedoff">Just argsCtx -&gt;</span>
<span class="lineno"> 1017 </span><span class="spaces">       </span><span class="istickedoff">ctxReduceRecursor_ (inctx rec) (inctx elimf) argsCtx ctorArgs</span>
<span class="lineno"> 1018 </span><span class="spaces">     </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1019 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">error &quot;ctxReduceRecursorRaw: wrong number of constructor arguments!&quot;</span></span></span>
<span class="lineno"> 1020 </span>
<span class="lineno"> 1021 </span>
<span class="lineno"> 1022 </span>-- | This operation does the real work of building the
<span class="lineno"> 1023 </span>--   iota reduction for @ctxReduceRecursor@.  We assume
<span class="lineno"> 1024 </span>--   the input terms we are given live in an ambient
<span class="lineno"> 1025 </span>--   context @amb@.
<span class="lineno"> 1026 </span>ctxReduceRecursor_ :: forall m amb d ixs elim args.
<span class="lineno"> 1027 </span>  MonadTerm m =&gt;
<span class="lineno"> 1028 </span>  CtxTerm  amb (Rec d) {- ^ recursor value eliminatiting data type d -}-&gt;
<span class="lineno"> 1029 </span>  CtxTerm  amb elim    {- ^ eliminator function for the constructor -} -&gt;
<span class="lineno"> 1030 </span>  CtxTerms amb args    {- ^ constructor actual arguments -} -&gt;
<span class="lineno"> 1031 </span>  Bindings (CtorArg d ixs) amb args
<span class="lineno"> 1032 </span>    {- ^ telescope describing the constructor arguments -} -&gt;
<span class="lineno"> 1033 </span>  m Term
<span class="lineno"> 1034 </span><span class="decl"><span class="istickedoff">ctxReduceRecursor_ rec fi args0 argCtx =</span>
<span class="lineno"> 1035 </span><span class="spaces">  </span><span class="istickedoff">do args &lt;- mk_args CtxTermsCtxNil args0 argCtx</span>
<span class="lineno"> 1036 </span><span class="spaces">     </span><span class="istickedoff">whnfTerm =&lt;&lt; foldM (\f arg -&gt; mkTermF $ App f arg) (unAmb fi) args</span>
<span class="lineno"> 1037 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1038 </span><span class="spaces"> </span><span class="istickedoff">where</span>
<span class="lineno"> 1039 </span><span class="spaces">   </span><span class="istickedoff">-- extract a raw term into the ambient context</span>
<span class="lineno"> 1040 </span><span class="spaces">    </span><span class="istickedoff">unAmb :: forall tp. CtxTerm amb tp -&gt; Term</span>
<span class="lineno"> 1041 </span><span class="spaces">    </span><span class="istickedoff">unAmb (CtxTerm t) = t</span>
<span class="lineno"> 1042 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1043 </span><span class="spaces">    </span><span class="istickedoff">mk_args :: forall ctx xs.</span>
<span class="lineno"> 1044 </span><span class="spaces">               </span><span class="istickedoff">CtxTermsCtx amb ctx -&gt;  -- already processed parameters/arguments</span>
<span class="lineno"> 1045 </span><span class="spaces">               </span><span class="istickedoff">CtxTerms    amb xs -&gt;   -- remaining actual arguments to process</span>
<span class="lineno"> 1046 </span><span class="spaces">               </span><span class="istickedoff">Bindings (CtorArg d ixs) (amb&lt;+&gt;ctx) xs -&gt;</span>
<span class="lineno"> 1047 </span><span class="spaces">                 </span><span class="istickedoff">-- telescope for typing the actual arguments</span>
<span class="lineno"> 1048 </span><span class="spaces">               </span><span class="istickedoff">m [Term]</span>
<span class="lineno"> 1049 </span><span class="spaces">    </span><span class="istickedoff">-- no more arguments to process</span>
<span class="lineno"> 1050 </span><span class="spaces">    </span><span class="istickedoff">mk_args _ _ NoBind = return []</span>
<span class="lineno"> 1051 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1052 </span><span class="spaces">    </span><span class="istickedoff">-- process an argument that is not a recursive call</span>
<span class="lineno"> 1053 </span><span class="spaces">    </span><span class="istickedoff">mk_args pre_xs (CtxTermsCons x xs) (Bind _ (ConstArg _) args) =</span>
<span class="lineno"> 1054 </span><span class="spaces">      </span><span class="istickedoff">do tl &lt;- mk_args (CtxTermsCtxCons pre_xs x) xs args</span>
<span class="lineno"> 1055 </span><span class="spaces">         </span><span class="istickedoff">pure (unAmb x : tl)</span>
<span class="lineno"> 1056 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1057 </span><span class="spaces">    </span><span class="istickedoff">-- process an argument that is a recursive call</span>
<span class="lineno"> 1058 </span><span class="spaces">    </span><span class="istickedoff">mk_args pre_xs (CtxTermsCons x xs) (Bind _ (RecursiveArg zs ixs) args) =</span>
<span class="lineno"> 1059 </span><span class="spaces">      </span><span class="istickedoff">do zs'  &lt;- ctxSubstInBindings <span class="nottickedoff">pre_xs</span> <span class="nottickedoff">InvNoBind</span> NoBind zs</span>
<span class="lineno"> 1060 </span><span class="spaces">         </span><span class="istickedoff">ixs' &lt;- ctxSubstInBindings pre_xs InvNoBind zs ixs</span>
<span class="lineno"> 1061 </span><span class="spaces">         </span><span class="istickedoff">recx &lt;- mk_rec_arg zs' ixs' x</span>
<span class="lineno"> 1062 </span><span class="spaces">         </span><span class="istickedoff">tl   &lt;- mk_args (CtxTermsCtxCons pre_xs <span class="nottickedoff">x</span>) xs args</span>
<span class="lineno"> 1063 </span><span class="spaces">         </span><span class="istickedoff">pure (unAmb x : recx : tl)</span>
<span class="lineno"> 1064 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1065 </span><span class="spaces">    </span><span class="istickedoff">-- Build an individual recursive call, given the parameters, the bindings</span>
<span class="lineno"> 1066 </span><span class="spaces">    </span><span class="istickedoff">-- for the RecursiveArg, and the argument we are going to recurse on</span>
<span class="lineno"> 1067 </span><span class="spaces">    </span><span class="istickedoff">mk_rec_arg :: forall zs.</span>
<span class="lineno"> 1068 </span><span class="spaces">      </span><span class="istickedoff">Bindings CtxTerm amb zs -&gt;         -- telescope describing the zs</span>
<span class="lineno"> 1069 </span><span class="spaces">      </span><span class="istickedoff">CtxTerms (CtxInvApp amb zs) ixs -&gt; -- actual values for the indicies, shifted under zs</span>
<span class="lineno"> 1070 </span><span class="spaces">      </span><span class="istickedoff">CtxTerm amb (Arrows zs d) -&gt;       -- actual value in recursive position</span>
<span class="lineno"> 1071 </span><span class="spaces">      </span><span class="istickedoff">m Term</span>
<span class="lineno"> 1072 </span><span class="spaces">    </span><span class="istickedoff">mk_rec_arg zs_ctx ixs x = unAmb &lt;$&gt;</span>
<span class="lineno"> 1073 </span><span class="spaces">      </span><span class="istickedoff">-- eta expand over the zs and apply the RecursorApp form</span>
<span class="lineno"> 1074 </span><span class="spaces">      </span><span class="istickedoff">ctxLambda zs_ctx (\zs -&gt;</span>
<span class="lineno"> 1075 </span><span class="spaces">        </span><span class="istickedoff">ctxRecursorAppM</span>
<span class="lineno"> 1076 </span><span class="spaces">          </span><span class="istickedoff">(ctxLift <span class="nottickedoff">InvNoBind</span> zs_ctx rec)</span>
<span class="lineno"> 1077 </span><span class="spaces">          </span><span class="istickedoff">(return (invertCtxTerms ixs))</span>
<span class="lineno"> 1078 </span><span class="spaces">          </span><span class="istickedoff">(ctxApplyMulti</span>
<span class="lineno"> 1079 </span><span class="spaces">            </span><span class="istickedoff">(ctxLift <span class="nottickedoff">InvNoBind</span> zs_ctx x)</span>
<span class="lineno"> 1080 </span><span class="spaces">            </span><span class="istickedoff">(return zs)))</span></span>
<span class="lineno"> 1081 </span>
<span class="lineno"> 1082 </span>
<span class="lineno"> 1083 </span>--
<span class="lineno"> 1084 </span>-- * Parsing and Building Constructor Types
<span class="lineno"> 1085 </span>--
<span class="lineno"> 1086 </span>
<span class="lineno"> 1087 </span>-- | Generic method for testing whether a datatype occurs in an object
<span class="lineno"> 1088 </span>class UsesDataType a where
<span class="lineno"> 1089 </span>  usesDataType :: DataIdent d -&gt; a -&gt; Bool
<span class="lineno"> 1090 </span>
<span class="lineno"> 1091 </span>instance UsesDataType (TermF Term) where
<span class="lineno"> 1092 </span>  <span class="decl"><span class="istickedoff">usesDataType (DataIdent d) (Constant d')</span>
<span class="lineno"> 1093 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">d' == d</span> = <span class="nottickedoff">True</span></span>
<span class="lineno"> 1094 </span><span class="spaces"></span><span class="istickedoff">--  usesDataType (DataIdent d) (FTermF (DataTypeApp d' _ _))</span>
<span class="lineno"> 1095 </span><span class="spaces"></span><span class="istickedoff">--    | d' == d = True</span>
<span class="lineno"> 1096 </span><span class="spaces">  </span><span class="istickedoff">usesDataType (DataIdent d) (FTermF (RecursorType d' _ _ _))</span>
<span class="lineno"> 1097 </span><span class="spaces">    </span><span class="istickedoff">| <span class="nottickedoff">d' == d</span> = <span class="nottickedoff">True</span></span>
<span class="lineno"> 1098 </span><span class="spaces">  </span><span class="istickedoff">usesDataType (DataIdent d) (FTermF (Recursor rec))</span>
<span class="lineno"> 1099 </span><span class="spaces">    </span><span class="istickedoff">| <span class="nottickedoff">recursorDataType rec == d</span> = <span class="nottickedoff">True</span></span>
<span class="lineno"> 1100 </span><span class="spaces">  </span><span class="istickedoff">usesDataType d tf = any (usesDataType d) tf</span></span>
<span class="lineno"> 1101 </span>
<span class="lineno"> 1102 </span>instance UsesDataType Term where
<span class="lineno"> 1103 </span>  <span class="decl"><span class="istickedoff">usesDataType d = usesDataType d . unwrapTermF</span></span>
<span class="lineno"> 1104 </span>
<span class="lineno"> 1105 </span>instance UsesDataType (CtxTerm ctx a) where
<span class="lineno"> 1106 </span>  <span class="decl"><span class="istickedoff">usesDataType d (CtxTerm t) = usesDataType d t</span></span>
<span class="lineno"> 1107 </span>
<span class="lineno"> 1108 </span>instance UsesDataType (Bindings CtxTerm ctx as) where
<span class="lineno"> 1109 </span>  <span class="decl"><span class="istickedoff">usesDataType _ NoBind = False</span>
<span class="lineno"> 1110 </span><span class="spaces">  </span><span class="istickedoff">usesDataType d (Bind _ tp tps) = <span class="nottickedoff">usesDataType d tp || usesDataType d tps</span></span></span>
<span class="lineno"> 1111 </span>
<span class="lineno"> 1112 </span>
<span class="lineno"> 1113 </span>-- | Check that a type is a valid application of datatype @d@ for use in
<span class="lineno"> 1114 </span>-- specific ways in the type of a constructor for @d@. This requires that this
<span class="lineno"> 1115 </span>-- application of @d@ be of the form
<span class="lineno"> 1116 </span>--
<span class="lineno"> 1117 </span>-- &gt; d p1 .. pn x1 .. xm
<span class="lineno"> 1118 </span>--
<span class="lineno"> 1119 </span>-- where the @pi@ are the distinct bound variables bound in the @params@
<span class="lineno"> 1120 </span>-- context, given as argument, and that the @xj@ have no occurrences of @d@. If
<span class="lineno"> 1121 </span>-- the given type is of this form, return the @xj@.
<span class="lineno"> 1122 </span>asCtorDTApp :: DataIdent d -&gt; Bindings CtxTerm EmptyCtx params -&gt;
<span class="lineno"> 1123 </span>               Bindings CtxTerm (CtxInv params) ixs -&gt;
<span class="lineno"> 1124 </span>               InvBindings tp1 (CtxInv params) ctx1 -&gt;
<span class="lineno"> 1125 </span>               Bindings tp2 (CtxInv params &lt;+&gt; ctx1) ctx2 -&gt;
<span class="lineno"> 1126 </span>               CtxTerm (CtxInvApp (CtxInv params &lt;+&gt; ctx1) ctx2) (Typ a) -&gt;
<span class="lineno"> 1127 </span>               Maybe (CtxTerms (CtxInvApp (CtxInv params &lt;+&gt; ctx1) ctx2) ixs)
<span class="lineno"> 1128 </span><span class="decl"><span class="istickedoff">asCtorDTApp d params dt_ixs ctx1 ctx2 (ctxAsDataTypeApp d params dt_ixs -&gt;</span>
<span class="lineno"> 1129 </span><span class="spaces">                                       </span><span class="istickedoff">Just (param_vars, ixs))</span>
<span class="lineno"> 1130 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">isVarList <span class="nottickedoff">Proxy</span> params ctx1 ctx2 param_vars &amp;&amp;</span></span>
<span class="lineno"> 1131 </span><span class="spaces">    </span><span class="istickedoff"><span class="tickonlytrue">not (any (usesDataType d) $ ctxTermsToListUnsafe ixs)</span></span>
<span class="lineno"> 1132 </span><span class="spaces">  </span><span class="istickedoff">= Just ixs</span>
<span class="lineno"> 1133 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1134 </span><span class="spaces">    </span><span class="istickedoff">-- Check that the given list of terms is a list of bound variables, one for</span>
<span class="lineno"> 1135 </span><span class="spaces">    </span><span class="istickedoff">-- each parameter, in the context extended by the given arguments</span>
<span class="lineno"> 1136 </span><span class="spaces">    </span><span class="istickedoff">isVarList :: Proxy prev_params -&gt;</span>
<span class="lineno"> 1137 </span><span class="spaces">                 </span><span class="istickedoff">Bindings tp1 prev_params params -&gt;</span>
<span class="lineno"> 1138 </span><span class="spaces">                 </span><span class="istickedoff">InvBindings tp2 (CtxInvApp prev_params params) ctx1 -&gt;</span>
<span class="lineno"> 1139 </span><span class="spaces">                 </span><span class="istickedoff">Bindings tp3 (CtxInvApp prev_params params &lt;+&gt; ctx1) ctx2 -&gt;</span>
<span class="lineno"> 1140 </span><span class="spaces">                 </span><span class="istickedoff">CtxTerms (CtxInvApp</span>
<span class="lineno"> 1141 </span><span class="spaces">                           </span><span class="istickedoff">(CtxInvApp prev_params params &lt;+&gt; ctx1) ctx2) params -&gt;</span>
<span class="lineno"> 1142 </span><span class="spaces">                 </span><span class="istickedoff">Bool</span>
<span class="lineno"> 1143 </span><span class="spaces">    </span><span class="istickedoff">isVarList _ _ _ _ CtxTermsNil = True</span>
<span class="lineno"> 1144 </span><span class="spaces">    </span><span class="istickedoff">isVarList _ (Bind _ _ ps) c1 c2 (CtxTermsCons</span>
<span class="lineno"> 1145 </span><span class="spaces">                                     </span><span class="istickedoff">(CtxTerm (unwrapTermF -&gt; LocalVar i)) ts) =</span>
<span class="lineno"> 1146 </span><span class="spaces">      </span><span class="istickedoff">i == bindingsLength ps + invBindingsLength c1 + bindingsLength c2 &amp;&amp;</span>
<span class="lineno"> 1147 </span><span class="spaces">      </span><span class="istickedoff">isVarList <span class="nottickedoff">Proxy</span> ps c1 c2 ts</span>
<span class="lineno"> 1148 </span><span class="spaces">    </span><span class="istickedoff">isVarList _ _ _ _ _ = <span class="nottickedoff">False</span></span>
<span class="lineno"> 1149 </span><span class="spaces"></span><span class="istickedoff">asCtorDTApp _ _ _ _ _ _ = Nothing</span></span>
<span class="lineno"> 1150 </span>
<span class="lineno"> 1151 </span>
<span class="lineno"> 1152 </span>-- | Existential return type for 'asCtorArg'
<span class="lineno"> 1153 </span>data ExCtorArg d ixs ctx =
<span class="lineno"> 1154 </span>  forall a. ExCtorArg (CtorArg d ixs ctx (Typ a))
<span class="lineno"> 1155 </span>
<span class="lineno"> 1156 </span>-- | Check that an argument for a constructor has one of the allowed forms
<span class="lineno"> 1157 </span>asCtorArg :: DataIdent d -&gt; Bindings CtxTerm EmptyCtx params -&gt;
<span class="lineno"> 1158 </span>             Bindings CtxTerm (CtxInv params) ixs -&gt;
<span class="lineno"> 1159 </span>             InvBindings tp (CtxInv params) prevs -&gt;
<span class="lineno"> 1160 </span>             CtxTerm (CtxInv params &lt;+&gt; prevs) (Typ a) -&gt;
<span class="lineno"> 1161 </span>             Maybe (ExCtorArg d ixs (CtxInv params &lt;+&gt; prevs))
<span class="lineno"> 1162 </span><span class="decl"><span class="istickedoff">asCtorArg d params dt_ixs prevs (ctxAsPiMulti -&gt;</span>
<span class="lineno"> 1163 </span><span class="spaces">                                 </span><span class="istickedoff">CtxMultiPi zs</span>
<span class="lineno"> 1164 </span><span class="spaces">                                 </span><span class="istickedoff">(asCtorDTApp d params dt_ixs prevs zs -&gt;</span>
<span class="lineno"> 1165 </span><span class="spaces">                                  </span><span class="istickedoff">Just ixs))</span>
<span class="lineno"> 1166 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">not (usesDataType <span class="nottickedoff">d</span> zs)</span></span>
<span class="lineno"> 1167 </span><span class="spaces">  </span><span class="istickedoff">= Just (ExCtorArg $ RecursiveArg zs ixs)</span>
<span class="lineno"> 1168 </span><span class="spaces"></span><span class="istickedoff">asCtorArg d _ _ _ tp</span>
<span class="lineno"> 1169 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">not (usesDataType d tp)</span></span>
<span class="lineno"> 1170 </span><span class="spaces">  </span><span class="istickedoff">= Just (ExCtorArg $ ConstArg tp)</span>
<span class="lineno"> 1171 </span><span class="spaces"></span><span class="istickedoff">asCtorArg _ _ _ _ _ = <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno"> 1172 </span>
<span class="lineno"> 1173 </span>-- | Existential return type of 'asPiCtorArg'
<span class="lineno"> 1174 </span>data CtxPiCtorArg d ixs ctx =
<span class="lineno"> 1175 </span>  forall a b .
<span class="lineno"> 1176 </span>  CtxPiCtorArg LocalName (CtorArg d ixs ctx (Typ a))
<span class="lineno"> 1177 </span>  (CtxTerm (ctx ::&gt; a) (Typ b))
<span class="lineno"> 1178 </span>
<span class="lineno"> 1179 </span>-- | Check that a constructor type is a pi-abstraction that takes as input an
<span class="lineno"> 1180 </span>-- argument of one of the allowed forms described by 'CtorArg'
<span class="lineno"> 1181 </span>asPiCtorArg :: DataIdent d -&gt; Bindings CtxTerm EmptyCtx params -&gt;
<span class="lineno"> 1182 </span>               Bindings CtxTerm (CtxInv params) ixs -&gt;
<span class="lineno"> 1183 </span>               InvBindings tp (CtxInv params) prevs -&gt;
<span class="lineno"> 1184 </span>               CtxTerm (CtxInv params &lt;+&gt; prevs) (Typ a) -&gt;
<span class="lineno"> 1185 </span>               Maybe (CtxPiCtorArg d ixs (CtxInv params &lt;+&gt; prevs))
<span class="lineno"> 1186 </span><span class="decl"><span class="istickedoff">asPiCtorArg d params dt_ixs prevs (ctxAsPi -&gt;</span>
<span class="lineno"> 1187 </span><span class="spaces">                                   </span><span class="istickedoff">Just (CtxPi x</span>
<span class="lineno"> 1188 </span><span class="spaces">                                         </span><span class="istickedoff">(asCtorArg d params dt_ixs prevs -&gt;</span>
<span class="lineno"> 1189 </span><span class="spaces">                                          </span><span class="istickedoff">Just (ExCtorArg arg)) rest)) =</span>
<span class="lineno"> 1190 </span><span class="spaces">  </span><span class="istickedoff">Just $ CtxPiCtorArg x arg (castTopCtxElem rest)</span>
<span class="lineno"> 1191 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1192 </span><span class="spaces">    </span><span class="istickedoff">castTopCtxElem :: CtxTerm (ctx ::&gt; a1) b -&gt; CtxTerm (ctx ::&gt; a2) b</span>
<span class="lineno"> 1193 </span><span class="spaces">    </span><span class="istickedoff">castTopCtxElem (CtxTerm t) = CtxTerm t</span>
<span class="lineno"> 1194 </span><span class="spaces"></span><span class="istickedoff">asPiCtorArg _ _ _ _ _ = Nothing</span></span>
<span class="lineno"> 1195 </span>
<span class="lineno"> 1196 </span>-- | Existential return type of 'mkCtorArgsIxs'
<span class="lineno"> 1197 </span>data CtorArgsIxs d ixs prevs =
<span class="lineno"> 1198 </span>  forall args.
<span class="lineno"> 1199 </span>  CtorArgsIxs (Bindings (CtorArg d ixs) prevs args)
<span class="lineno"> 1200 </span>  (CtxTerms (CtxInvApp prevs args) ixs)
<span class="lineno"> 1201 </span>
<span class="lineno"> 1202 </span>-- | Helper function for 'mkCtorArgStruct'
<span class="lineno"> 1203 </span>mkCtorArgsIxs :: DataIdent d -&gt; Bindings CtxTerm EmptyCtx params -&gt;
<span class="lineno"> 1204 </span>                 Bindings CtxTerm (CtxInv params) ixs -&gt;
<span class="lineno"> 1205 </span>                 InvBindings (CtorArg d ixs) (CtxInv params) prevs -&gt;
<span class="lineno"> 1206 </span>                 CtxTerm (CtxInv params &lt;+&gt; prevs) (Typ a) -&gt;
<span class="lineno"> 1207 </span>                 Maybe (CtorArgsIxs d ixs (CtxInv params &lt;+&gt; prevs))
<span class="lineno"> 1208 </span><span class="decl"><span class="istickedoff">mkCtorArgsIxs d params dt_ixs prevs (asPiCtorArg d params dt_ixs prevs -&gt;</span>
<span class="lineno"> 1209 </span><span class="spaces">                                     </span><span class="istickedoff">Just (CtxPiCtorArg x arg rest)) =</span>
<span class="lineno"> 1210 </span><span class="spaces">  </span><span class="istickedoff">case mkCtorArgsIxs d params dt_ixs (InvBind prevs <span class="nottickedoff">x</span> <span class="nottickedoff">arg</span>) rest of</span>
<span class="lineno"> 1211 </span><span class="spaces">    </span><span class="istickedoff">Just (CtorArgsIxs args ixs) -&gt; Just (CtorArgsIxs (Bind x arg args) ixs)</span>
<span class="lineno"> 1212 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 1213 </span><span class="spaces"></span><span class="istickedoff">mkCtorArgsIxs d params dt_ixs prevs (asCtorDTApp d params dt_ixs prevs NoBind -&gt;</span>
<span class="lineno"> 1214 </span><span class="spaces">                                     </span><span class="istickedoff">Just ixs) =</span>
<span class="lineno"> 1215 </span><span class="spaces">  </span><span class="istickedoff">Just (CtorArgsIxs NoBind ixs)</span>
<span class="lineno"> 1216 </span><span class="spaces"></span><span class="istickedoff">mkCtorArgsIxs _ _ _ _ _ = <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno"> 1217 </span>
<span class="lineno"> 1218 </span>
<span class="lineno"> 1219 </span>-- | Take in a datatype and 'Bindings' lists for its parameters and indices, and
<span class="lineno"> 1220 </span>-- also a prospective type of a constructor for that datatype, where the
<span class="lineno"> 1221 </span>-- constructor type is allowed to have the parameters but not the indices free.
<span class="lineno"> 1222 </span>-- Test that the constructor type is an allowed type for a constructor of this
<span class="lineno"> 1223 </span>-- datatype, and, if so, build a 'CtorArgStruct' for it.
<span class="lineno"> 1224 </span>mkCtorArgStruct ::
<span class="lineno"> 1225 </span>  ExtCns Term -&gt;
<span class="lineno"> 1226 </span>  Bindings CtxTerm EmptyCtx params -&gt;
<span class="lineno"> 1227 </span>  Bindings CtxTerm (CtxInv params) ixs -&gt;
<span class="lineno"> 1228 </span>  Term -&gt;
<span class="lineno"> 1229 </span>  Maybe (CtorArgStruct d params ixs)
<span class="lineno"> 1230 </span><span class="decl"><span class="istickedoff">mkCtorArgStruct d params dt_ixs ctor_tp =</span>
<span class="lineno"> 1231 </span><span class="spaces">  </span><span class="istickedoff">case mkCtorArgsIxs (DataIdent d) params dt_ixs InvNoBind (CtxTerm ctor_tp) of</span>
<span class="lineno"> 1232 </span><span class="spaces">    </span><span class="istickedoff">Just (CtorArgsIxs args ctor_ixs) -&gt;</span>
<span class="lineno"> 1233 </span><span class="spaces">      </span><span class="istickedoff">Just (CtorArgStruct params args ctor_ixs dt_ixs)</span>
<span class="lineno"> 1234 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">Nothing</span></span></span>

</pre>
</body>
</html>
