<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- |
<span class="lineno">    2 </span>Module      : SAWCentral.Crucible.JVM.Builtins
<span class="lineno">    3 </span>Description : Implementations of crucible-jvm-related SAW-Script primitives.
<span class="lineno">    4 </span>License     : BSD3
<span class="lineno">    5 </span>Maintainer  : atomb
<span class="lineno">    6 </span>Stability   : provisional
<span class="lineno">    7 </span>-}
<span class="lineno">    8 </span>{-# LANGUAGE FlexibleContexts, FlexibleInstances, TypeSynonymInstances, MultiParamTypeClasses#-}
<span class="lineno">    9 </span>{-# LANGUAGE TypeFamilies #-}
<span class="lineno">   10 </span>{-# LANGUAGE ImplicitParams #-}
<span class="lineno">   11 </span>{-# LANGUAGE EmptyCase #-}
<span class="lineno">   12 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">   13 </span>{-# LANGUAGE DataKinds #-}
<span class="lineno">   14 </span>{-# LANGUAGE GADTs #-}
<span class="lineno">   15 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">   16 </span>{-# LANGUAGE ParallelListComp #-}
<span class="lineno">   17 </span>{-# LANGUAGE PatternGuards #-}
<span class="lineno">   18 </span>{-# LANGUAGE PolyKinds #-}
<span class="lineno">   19 </span>{-# LANGUAGE RankNTypes #-}
<span class="lineno">   20 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">   21 </span>{-# LANGUAGE TupleSections #-}
<span class="lineno">   22 </span>{-# LANGUAGE TypeApplications #-}
<span class="lineno">   23 </span>{-# LANGUAGE TypeOperators #-}
<span class="lineno">   24 </span>
<span class="lineno">   25 </span>{-# OPTIONS_GHC -Wno-orphans #-}
<span class="lineno">   26 </span>
<span class="lineno">   27 </span>module SAWCentral.Crucible.JVM.Builtins
<span class="lineno">   28 </span>    ( jvm_verify
<span class="lineno">   29 </span>    , jvm_unsafe_assume_spec
<span class="lineno">   30 </span>    , jvm_return
<span class="lineno">   31 </span>    , jvm_execute_func
<span class="lineno">   32 </span>    , jvm_postcond
<span class="lineno">   33 </span>    , jvm_precond
<span class="lineno">   34 </span>    , jvm_assert
<span class="lineno">   35 </span>    , jvm_modifies_field
<span class="lineno">   36 </span>    , jvm_modifies_static_field
<span class="lineno">   37 </span>    , jvm_modifies_elem
<span class="lineno">   38 </span>    , jvm_modifies_array
<span class="lineno">   39 </span>    , jvm_field_is
<span class="lineno">   40 </span>    , jvm_static_field_is
<span class="lineno">   41 </span>    , jvm_elem_is
<span class="lineno">   42 </span>    , jvm_array_is
<span class="lineno">   43 </span>    , jvm_fresh_var
<span class="lineno">   44 </span>    , jvm_alloc_object
<span class="lineno">   45 </span>    , jvm_alloc_array
<span class="lineno">   46 </span>    , jvm_setup_with_tag
<span class="lineno">   47 </span>    , jvm_ghost_value
<span class="lineno">   48 </span>    , jvm_equal
<span class="lineno">   49 </span>    , jvm_unint
<span class="lineno">   50 </span>    ) where
<span class="lineno">   51 </span>
<span class="lineno">   52 </span>import           Control.Lens
<span class="lineno">   53 </span>
<span class="lineno">   54 </span>import qualified Control.Monad.Catch as X
<span class="lineno">   55 </span>import           Control.Monad (foldM, forM, forM_, guard, unless, when)
<span class="lineno">   56 </span>import           Control.Monad.IO.Class (MonadIO(..))
<span class="lineno">   57 </span>import           Control.Monad.Reader (runReaderT)
<span class="lineno">   58 </span>import           Control.Monad.State (MonadState(..), StateT(..), execStateT, gets)
<span class="lineno">   59 </span>import qualified Control.Monad.State.Strict as Strict
<span class="lineno">   60 </span>import           Control.Monad.Trans.Class (MonadTrans(..))
<span class="lineno">   61 </span>import           Control.Monad.Trans.Except (runExceptT)
<span class="lineno">   62 </span>import qualified Data.BitVector.Sized as BV
<span class="lineno">   63 </span>import           Data.Foldable (for_)
<span class="lineno">   64 </span>import           Data.Function
<span class="lineno">   65 </span>import qualified Data.IntMap as IntMap
<span class="lineno">   66 </span>import           Data.IORef
<span class="lineno">   67 </span>import           Data.List (isPrefixOf, sortBy)
<span class="lineno">   68 </span>import           Data.List.NonEmpty (NonEmpty)
<span class="lineno">   69 </span>import qualified Data.List.NonEmpty as NE
<span class="lineno">   70 </span>import           Data.Map (Map)
<span class="lineno">   71 </span>import qualified Data.Map as Map
<span class="lineno">   72 </span>import           Data.Maybe (fromMaybe, isNothing)
<span class="lineno">   73 </span>import           Data.Set (Set)
<span class="lineno">   74 </span>import qualified Data.Set as Set
<span class="lineno">   75 </span>import           Data.Text (Text)
<span class="lineno">   76 </span>import qualified Data.Text as Text
<span class="lineno">   77 </span>import           Data.Time.Clock (getCurrentTime, diffUTCTime)
<span class="lineno">   78 </span>import qualified Data.Vector as V
<span class="lineno">   79 </span>import           Prettyprinter
<span class="lineno">   80 </span>import           System.IO
<span class="lineno">   81 </span>
<span class="lineno">   82 </span>-- cryptol
<span class="lineno">   83 </span>import qualified Cryptol.Eval.Type as Cryptol (evalValType)
<span class="lineno">   84 </span>import qualified Cryptol.TypeCheck.Type as Cryptol
<span class="lineno">   85 </span>import qualified Cryptol.Utils.PP as Cryptol (pp)
<span class="lineno">   86 </span>
<span class="lineno">   87 </span>-- what4
<span class="lineno">   88 </span>import qualified What4.Partial as W4
<span class="lineno">   89 </span>import qualified What4.ProgramLoc as W4
<span class="lineno">   90 </span>import qualified What4.Interface as W4
<span class="lineno">   91 </span>import qualified What4.Utils.StringLiteral as W4S
<span class="lineno">   92 </span>
<span class="lineno">   93 </span>-- jvm-parser
<span class="lineno">   94 </span>import qualified Language.JVM.Parser as J
<span class="lineno">   95 </span>import qualified Language.JVM.Common as J (dotsToSlashes)
<span class="lineno">   96 </span>
<span class="lineno">   97 </span>-- crucible
<span class="lineno">   98 </span>import qualified Lang.Crucible.Backend as Crucible
<span class="lineno">   99 </span>import qualified Lang.Crucible.CFG.Core as Crucible (TypeRepr(..))
<span class="lineno">  100 </span>import qualified Lang.Crucible.FunctionHandle as Crucible
<span class="lineno">  101 </span>import qualified Lang.Crucible.Simulator as Crucible
<span class="lineno">  102 </span>import qualified Lang.Crucible.Simulator.GlobalState as Crucible
<span class="lineno">  103 </span>import qualified Lang.Crucible.Simulator.SimError as Crucible
<span class="lineno">  104 </span>
<span class="lineno">  105 </span>-- crucible-jvm
<span class="lineno">  106 </span>import qualified Lang.JVM.Codebase as CB
<span class="lineno">  107 </span>import qualified Lang.Crucible.JVM as CJ
<span class="lineno">  108 </span>
<span class="lineno">  109 </span>-- parameterized-utils
<span class="lineno">  110 </span>import           Data.Parameterized.Classes
<span class="lineno">  111 </span>import qualified Data.Parameterized.Context as Ctx
<span class="lineno">  112 </span>
<span class="lineno">  113 </span>import SAWCore.FiniteValue (ppFirstOrderValue)
<span class="lineno">  114 </span>import SAWCore.Name (VarName(..))
<span class="lineno">  115 </span>import SAWCore.SharedTerm
<span class="lineno">  116 </span>import CryptolSAWCore.TypedTerm
<span class="lineno">  117 </span>
<span class="lineno">  118 </span>import SAWCoreWhat4.ReturnTrip
<span class="lineno">  119 </span>
<span class="lineno">  120 </span>import SAWCentral.Builtins (ghost_value)
<span class="lineno">  121 </span>import SAWCentral.Exceptions
<span class="lineno">  122 </span>import SAWCentral.Panic
<span class="lineno">  123 </span>import SAWCentral.Proof
<span class="lineno">  124 </span>import SAWCentral.Prover.SolverStats
<span class="lineno">  125 </span>import SAWCentral.TopLevel
<span class="lineno">  126 </span>import SAWCentral.Value
<span class="lineno">  127 </span>import SAWCentral.Utils as SS
<span class="lineno">  128 </span>import qualified SAWCentral.Position as SS
<span class="lineno">  129 </span>import SAWCentral.Options
<span class="lineno">  130 </span>import SAWCentral.Crucible.JVM.BuiltinsJVM (prepareClassTopLevel)
<span class="lineno">  131 </span>
<span class="lineno">  132 </span>import SAWCentral.JavaExpr (JavaType(..))
<span class="lineno">  133 </span>
<span class="lineno">  134 </span>import qualified SAWCentral.Crucible.Common as Common
<span class="lineno">  135 </span>import           SAWCentral.Crucible.Common
<span class="lineno">  136 </span>import           SAWCentral.Crucible.Common.Override (MetadataMap)
<span class="lineno">  137 </span>import           SAWCentral.Crucible.Common.MethodSpec (AllocIndex(..), nextAllocIndex, PrePost(..))
<span class="lineno">  138 </span>import qualified SAWCentral.Crucible.Common.Vacuity as Vacuity
<span class="lineno">  139 </span>
<span class="lineno">  140 </span>import qualified SAWCentral.Crucible.Common.MethodSpec as MS
<span class="lineno">  141 </span>import qualified SAWCentral.Crucible.Common.Setup.Type as Setup
<span class="lineno">  142 </span>import qualified SAWCentral.Crucible.Common.Setup.Builtins as Setup
<span class="lineno">  143 </span>import SAWCentral.Crucible.JVM.Setup.Value(jccUninterp)
<span class="lineno">  144 </span>import SAWCentral.Crucible.JVM.MethodSpecIR
<span class="lineno">  145 </span>import SAWCentral.Crucible.JVM.Override
<span class="lineno">  146 </span>import SAWCentral.Crucible.JVM.ResolveSetupValue
<span class="lineno">  147 </span>import SAWCentral.Crucible.JVM.BuiltinsJVM ()
<span class="lineno">  148 </span>
<span class="lineno">  149 </span>type AssumptionReason = (MS.ConditionMetadata, String)
<span class="lineno">  150 </span>type SetupValue = MS.SetupValue CJ.JVM
<span class="lineno">  151 </span>type Lemma = MS.ProvedSpec CJ.JVM
<span class="lineno">  152 </span>type MethodSpec = MS.CrucibleMethodSpecIR CJ.JVM
<span class="lineno">  153 </span>type SetupCondition = MS.SetupCondition CJ.JVM
<span class="lineno">  154 </span>
<span class="lineno">  155 </span>-- TODO: something useful with the global pair?
<span class="lineno">  156 </span>ppJVMAbortedResult :: JVMCrucibleContext
<span class="lineno">  157 </span>                -&gt; Crucible.AbortedResult Sym a
<span class="lineno">  158 </span>                -&gt; Doc ann
<span class="lineno">  159 </span><span class="decl"><span class="istickedoff">ppJVMAbortedResult _cc = Common.ppAbortedResult (\_gp -&gt; mempty)</span></span>
<span class="lineno">  160 </span>
<span class="lineno">  161 </span>-- FIXME: We need a better way to identify a set of class names to
<span class="lineno">  162 </span>-- load. This function has two problems: First, unless we put in a
<span class="lineno">  163 </span>-- bunch of hard-wired exclusions, we often end up trying to load
<span class="lineno">  164 </span>-- classes for which we don't have any parseable bytecode. Second, the
<span class="lineno">  165 </span>-- number of classes we load is way too large, and the classes take a
<span class="lineno">  166 </span>-- long time to parse and translate.
<span class="lineno">  167 </span>
<span class="lineno">  168 </span>allClassRefs :: CB.Codebase -&gt; J.ClassName -&gt; IO (Set J.ClassName)
<span class="lineno">  169 </span><span class="decl"><span class="istickedoff">allClassRefs cb c0 = go seen0 [c0]</span>
<span class="lineno">  170 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  171 </span><span class="spaces">    </span><span class="istickedoff">seen0 = Set.fromList CJ.initClasses</span>
<span class="lineno">  172 </span><span class="spaces">    </span><span class="istickedoff">go seen [] = return seen</span>
<span class="lineno">  173 </span><span class="spaces">    </span><span class="istickedoff">go seen (c : cs) =</span>
<span class="lineno">  174 </span><span class="spaces">      </span><span class="istickedoff">do -- putStrLn $ &quot;allClassRefs: &quot; ++ show (J.unClassName c)</span>
<span class="lineno">  175 </span><span class="spaces">         </span><span class="istickedoff">cls &lt;- CJ.findClass cb (J.unClassName c)</span>
<span class="lineno">  176 </span><span class="spaces">         </span><span class="istickedoff">let refs = Set.filter (not . excludedClassName) (CJ.classRefs cls)</span>
<span class="lineno">  177 </span><span class="spaces">         </span><span class="istickedoff">-- putStrLn $ &quot; -&gt; &quot; ++ show (Set.toList refs)</span>
<span class="lineno">  178 </span><span class="spaces">         </span><span class="istickedoff">let seen' = Set.union seen refs</span>
<span class="lineno">  179 </span><span class="spaces">         </span><span class="istickedoff">let next = Set.toList (Set.difference refs seen)</span>
<span class="lineno">  180 </span><span class="spaces">         </span><span class="istickedoff">go seen' (next ++ cs)</span></span>
<span class="lineno">  181 </span>
<span class="lineno">  182 </span>excludedClassName :: J.ClassName -&gt; Bool
<span class="lineno">  183 </span><span class="decl"><span class="istickedoff">excludedClassName cname</span>
<span class="lineno">  184 </span><span class="spaces">  </span><span class="istickedoff">| &quot;java/time/&quot;             `isPrefixOf` s = True</span>
<span class="lineno">  185 </span><span class="spaces">  </span><span class="istickedoff">| &quot;javax/&quot;                 `isPrefixOf` s = True</span>
<span class="lineno">  186 </span><span class="spaces">  </span><span class="istickedoff">| &quot;java/lang/invoke/&quot;      `isPrefixOf` s = True</span>
<span class="lineno">  187 </span><span class="spaces">  </span><span class="istickedoff">| &quot;java/util/stream/&quot;      `isPrefixOf` s = True</span>
<span class="lineno">  188 </span><span class="spaces">  </span><span class="istickedoff">| &quot;java/util/Collections$&quot; `isPrefixOf` s = True</span>
<span class="lineno">  189 </span><span class="spaces">  </span><span class="istickedoff">| &quot;sun/&quot;                   `isPrefixOf` s = True</span>
<span class="lineno">  190 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = Set.member cname excludedRefs</span>
<span class="lineno">  191 </span><span class="spaces">  </span><span class="istickedoff">where s = J.unClassName cname</span></span>
<span class="lineno">  192 </span>
<span class="lineno">  193 </span>-- hack to fix ecdsa proof
<span class="lineno">  194 </span>excludedRefs :: Set J.ClassName
<span class="lineno">  195 </span><span class="decl"><span class="istickedoff">excludedRefs = Set.fromList</span>
<span class="lineno">  196 </span><span class="spaces">  </span><span class="istickedoff">[ &quot;java/util/Comparator&quot;</span>
<span class="lineno">  197 </span><span class="spaces">  </span><span class="istickedoff">, &quot;java/lang/reflect/AccessibleObject&quot;</span>
<span class="lineno">  198 </span><span class="spaces">  </span><span class="istickedoff">, &quot;java/lang/reflect/AnnotatedElement&quot;</span>
<span class="lineno">  199 </span><span class="spaces">  </span><span class="istickedoff">, &quot;java/lang/invoke/SerializedLambda&quot;</span>
<span class="lineno">  200 </span><span class="spaces">  </span><span class="istickedoff">, &quot;java/lang/Package&quot;</span>
<span class="lineno">  201 </span><span class="spaces">  </span><span class="istickedoff">, &quot;java/util/TreeMap$EntrySpliterator&quot;</span>
<span class="lineno">  202 </span><span class="spaces">  </span><span class="istickedoff">, &quot;java/lang/invoke/MethodHandleInfo&quot;</span>
<span class="lineno">  203 </span><span class="spaces">  </span><span class="istickedoff">]</span></span>
<span class="lineno">  204 </span>
<span class="lineno">  205 </span>jvm_verify ::
<span class="lineno">  206 </span>  J.Class -&gt;
<span class="lineno">  207 </span>  Text {- ^ method name -} -&gt;
<span class="lineno">  208 </span>  [Lemma] {- ^ overrides -} -&gt;
<span class="lineno">  209 </span>  Bool {- ^ path sat checking -} -&gt;
<span class="lineno">  210 </span>  JVMSetupM () -&gt;
<span class="lineno">  211 </span>  ProofScript () -&gt;
<span class="lineno">  212 </span>  TopLevel Lemma
<span class="lineno">  213 </span><span class="decl"><span class="istickedoff">jvm_verify cls nm lemmas checkSat setup tactic =</span>
<span class="lineno">  214 </span><span class="spaces">  </span><span class="istickedoff">do start &lt;- io getCurrentTime</span>
<span class="lineno">  215 </span><span class="spaces">     </span><span class="istickedoff">cb &lt;- getJavaCodebase</span>
<span class="lineno">  216 </span><span class="spaces">     </span><span class="istickedoff">opts &lt;- getOptions</span>
<span class="lineno">  217 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  218 </span><span class="spaces">     </span><span class="istickedoff">-- set up the metadata map for tracking proof obligation metadata</span>
<span class="lineno">  219 </span><span class="spaces">     </span><span class="istickedoff">mdMap &lt;- io $ newIORef <span class="nottickedoff">mempty</span></span>
<span class="lineno">  220 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  221 </span><span class="spaces">     </span><span class="istickedoff">-- allocate all of the handles/static vars that are referenced</span>
<span class="lineno">  222 </span><span class="spaces">     </span><span class="istickedoff">-- (directly or indirectly) by this class</span>
<span class="lineno">  223 </span><span class="spaces">     </span><span class="istickedoff">allRefs &lt;- io $ Set.toList &lt;$&gt; allClassRefs cb (J.className cls)</span>
<span class="lineno">  224 </span><span class="spaces">     </span><span class="istickedoff">let refs = CJ.initClasses ++ allRefs -- ++ superRefs</span>
<span class="lineno">  225 </span><span class="spaces">     </span><span class="istickedoff">mapM_ (prepareClassTopLevel . Text.pack . J.unClassName) refs</span>
<span class="lineno">  226 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  227 </span><span class="spaces">     </span><span class="istickedoff">cc &lt;- setupCrucibleContext cls</span>
<span class="lineno">  228 </span><span class="spaces">     </span><span class="istickedoff">SomeOnlineBackend bak &lt;- pure (cc^.jccBackend)</span>
<span class="lineno">  229 </span><span class="spaces">     </span><span class="istickedoff">let sym = cc^.jccSym</span>
<span class="lineno">  230 </span><span class="spaces">     </span><span class="istickedoff">let jc = cc^.jccJVMContext</span>
<span class="lineno">  231 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  232 </span><span class="spaces">     </span><span class="istickedoff">pos &lt;- getPosition</span>
<span class="lineno">  233 </span><span class="spaces">     </span><span class="istickedoff">let loc = SS.toW4Loc &quot;_SAW_jvm_verify&quot; pos</span>
<span class="lineno">  234 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  235 </span><span class="spaces">     </span><span class="istickedoff">profFile &lt;- rwProfilingFile &lt;$&gt; getTopLevelRW</span>
<span class="lineno">  236 </span><span class="spaces">     </span><span class="istickedoff">(writeFinalProfile, pfs) &lt;- io $ setupProfiling <span class="nottickedoff">sym</span> <span class="nottickedoff">&quot;jvm_verify&quot;</span> profFile</span>
<span class="lineno">  237 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  238 </span><span class="spaces">     </span><span class="istickedoff">(cls', method) &lt;- io $ findMethod cb pos (Text.unpack nm) cls -- TODO: switch to crucible-jvm version</span>
<span class="lineno">  239 </span><span class="spaces">     </span><span class="istickedoff">let st0 = initialCrucibleSetupState cc (cls', method) loc</span>
<span class="lineno">  240 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  241 </span><span class="spaces">     </span><span class="istickedoff">-- execute commands of the method spec</span>
<span class="lineno">  242 </span><span class="spaces">     </span><span class="istickedoff">io $ W4.setCurrentProgramLoc sym loc</span>
<span class="lineno">  243 </span><span class="spaces">     </span><span class="istickedoff">methodSpec &lt;- view Setup.csMethodSpec &lt;$&gt;</span>
<span class="lineno">  244 </span><span class="spaces">                     </span><span class="istickedoff">execStateT</span>
<span class="lineno">  245 </span><span class="spaces">                       </span><span class="istickedoff">(runReaderT (runJVMSetupM setup) Setup.makeCrucibleSetupRO)</span>
<span class="lineno">  246 </span><span class="spaces">                     </span><span class="istickedoff">st0</span>
<span class="lineno">  247 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  248 </span><span class="spaces">     </span><span class="istickedoff">-- construct the dynamic class table and declare static fields</span>
<span class="lineno">  249 </span><span class="spaces">     </span><span class="istickedoff">globals1 &lt;- liftIO $ setupGlobalState sym jc</span>
<span class="lineno">  250 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  251 </span><span class="spaces">     </span><span class="istickedoff">-- construct the initial state for verifications</span>
<span class="lineno">  252 </span><span class="spaces">     </span><span class="istickedoff">(args, assumes, env, globals2) &lt;- io $ verifyPrestate cc methodSpec globals1</span>
<span class="lineno">  253 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  254 </span><span class="spaces">     </span><span class="istickedoff">-- check for contradictory preconditions</span>
<span class="lineno">  255 </span><span class="spaces">     </span><span class="istickedoff">when (detectVacuity opts) $</span>
<span class="lineno">  256 </span><span class="spaces">       </span><span class="istickedoff">Vacuity.checkAssumptionsForContradictions</span>
<span class="lineno">  257 </span><span class="spaces">         </span><span class="istickedoff">sym</span>
<span class="lineno">  258 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">methodSpec</span></span>
<span class="lineno">  259 </span><span class="spaces">         </span><span class="istickedoff">tactic</span>
<span class="lineno">  260 </span><span class="spaces">         </span><span class="istickedoff">assumes</span>
<span class="lineno">  261 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  262 </span><span class="spaces">     </span><span class="istickedoff">-- save initial path conditions</span>
<span class="lineno">  263 </span><span class="spaces">     </span><span class="istickedoff">frameIdent &lt;- io $ Crucible.pushAssumptionFrame bak</span>
<span class="lineno">  264 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  265 </span><span class="spaces">     </span><span class="istickedoff">-- run the symbolic execution</span>
<span class="lineno">  266 </span><span class="spaces">     </span><span class="istickedoff">top_loc &lt;- <span class="nottickedoff">SS.toW4Loc &quot;jvm_verify&quot;</span> &lt;$&gt; getPosition</span>
<span class="lineno">  267 </span><span class="spaces">     </span><span class="istickedoff">(ret, globals3) &lt;-</span>
<span class="lineno">  268 </span><span class="spaces">       </span><span class="istickedoff">io $ verifySimulate opts cc pfs methodSpec args assumes <span class="nottickedoff">top_loc</span> lemmas globals2 <span class="nottickedoff">checkSat</span> <span class="nottickedoff">mdMap</span></span>
<span class="lineno">  269 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  270 </span><span class="spaces">     </span><span class="istickedoff">-- collect the proof obligations</span>
<span class="lineno">  271 </span><span class="spaces">     </span><span class="istickedoff">asserts &lt;- verifyPoststate cc</span>
<span class="lineno">  272 </span><span class="spaces">                    </span><span class="istickedoff">methodSpec env globals3 ret mdMap</span>
<span class="lineno">  273 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  274 </span><span class="spaces">     </span><span class="istickedoff">-- restore previous assumption state</span>
<span class="lineno">  275 </span><span class="spaces">     </span><span class="istickedoff">_ &lt;- io $ Crucible.popAssumptionFrame bak frameIdent</span>
<span class="lineno">  276 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  277 </span><span class="spaces">     </span><span class="istickedoff">-- attempt to verify the proof obligations</span>
<span class="lineno">  278 </span><span class="spaces">     </span><span class="istickedoff">(stats,vcstats) &lt;- verifyObligations cc methodSpec tactic assumes asserts</span>
<span class="lineno">  279 </span><span class="spaces">     </span><span class="istickedoff">io $ writeFinalProfile</span>
<span class="lineno">  280 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  281 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">lemmaSet = Set.fromList (map (view MS.psSpecIdent) lemmas)</span></span>
<span class="lineno">  282 </span><span class="spaces">     </span><span class="istickedoff">end &lt;- io getCurrentTime</span>
<span class="lineno">  283 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">diff = diffUTCTime end start</span></span>
<span class="lineno">  284 </span><span class="spaces">     </span><span class="istickedoff">ps &lt;- io (MS.mkProvedSpec <span class="nottickedoff">MS.SpecProved</span> methodSpec <span class="nottickedoff">stats</span> <span class="nottickedoff">vcstats</span> <span class="nottickedoff">lemmaSet</span> <span class="nottickedoff">diff</span>)</span>
<span class="lineno">  285 </span><span class="spaces">     </span><span class="istickedoff">returnJVMProof ps</span></span>
<span class="lineno">  286 </span>
<span class="lineno">  287 </span>
<span class="lineno">  288 </span>jvm_unsafe_assume_spec ::
<span class="lineno">  289 </span>  J.Class          -&gt;
<span class="lineno">  290 </span>  Text         {- ^ Name of the method -} -&gt;
<span class="lineno">  291 </span>  JVMSetupM () {- ^ Boundary specification -} -&gt;
<span class="lineno">  292 </span>  TopLevel Lemma
<span class="lineno">  293 </span><span class="decl"><span class="istickedoff">jvm_unsafe_assume_spec cls nm setup =</span>
<span class="lineno">  294 </span><span class="spaces">  </span><span class="istickedoff">do cc &lt;- setupCrucibleContext cls</span>
<span class="lineno">  295 </span><span class="spaces">     </span><span class="istickedoff">cb &lt;- getJavaCodebase</span>
<span class="lineno">  296 </span><span class="spaces">     </span><span class="istickedoff">pos &lt;- getPosition</span>
<span class="lineno">  297 </span><span class="spaces">     </span><span class="istickedoff">-- cls' is either cls or a (transitive) superclass of cls</span>
<span class="lineno">  298 </span><span class="spaces">     </span><span class="istickedoff">(cls', method) &lt;- io $ findMethod <span class="nottickedoff">cb</span> <span class="nottickedoff">pos</span> (Text.unpack nm) cls -- TODO: switch to crucible-jvm version</span>
<span class="lineno">  299 </span><span class="spaces">     </span><span class="istickedoff">let loc = SS.toW4Loc &quot;_SAW_JVM_unsafe_assume_spec&quot; pos</span>
<span class="lineno">  300 </span><span class="spaces">     </span><span class="istickedoff">let st0 = initialCrucibleSetupState cc (cls', method) loc</span>
<span class="lineno">  301 </span><span class="spaces">     </span><span class="istickedoff">ms &lt;- (view Setup.csMethodSpec) &lt;$&gt;</span>
<span class="lineno">  302 </span><span class="spaces">             </span><span class="istickedoff">execStateT (runReaderT (runJVMSetupM setup) <span class="nottickedoff">Setup.makeCrucibleSetupRO</span>) st0</span>
<span class="lineno">  303 </span><span class="spaces">     </span><span class="istickedoff">ps &lt;- io (MS.mkProvedSpec <span class="nottickedoff">MS.SpecAdmitted</span> ms <span class="nottickedoff">mempty</span> <span class="nottickedoff">mempty</span> <span class="nottickedoff">mempty</span> <span class="nottickedoff">0</span>)</span>
<span class="lineno">  304 </span><span class="spaces">     </span><span class="istickedoff">returnJVMProof ps</span></span>
<span class="lineno">  305 </span>
<span class="lineno">  306 </span>verifyObligations ::
<span class="lineno">  307 </span>  JVMCrucibleContext -&gt;
<span class="lineno">  308 </span>  MethodSpec -&gt;
<span class="lineno">  309 </span>  ProofScript () -&gt;
<span class="lineno">  310 </span>  [Crucible.LabeledPred Term AssumptionReason] -&gt;
<span class="lineno">  311 </span>  [(String, MS.ConditionMetadata, Term)] -&gt;
<span class="lineno">  312 </span>  TopLevel (SolverStats, [MS.VCStats])
<span class="lineno">  313 </span><span class="decl"><span class="istickedoff">verifyObligations cc mspec tactic assumes asserts =</span>
<span class="lineno">  314 </span><span class="spaces">  </span><span class="istickedoff">do let sym = cc^.jccSym</span>
<span class="lineno">  315 </span><span class="spaces">     </span><span class="istickedoff">st &lt;- io $ sawCoreState sym</span>
<span class="lineno">  316 </span><span class="spaces">     </span><span class="istickedoff">let sc = saw_ctx st</span>
<span class="lineno">  317 </span><span class="spaces">     </span><span class="istickedoff">assume &lt;- io $ scAndList sc (toListOf (folded . Crucible.labeledPred) assumes)</span>
<span class="lineno">  318 </span><span class="spaces">     </span><span class="istickedoff">let nm = mspec ^. csMethodName</span>
<span class="lineno">  319 </span><span class="spaces">     </span><span class="istickedoff">outs &lt;- forM (zip [(0::Int)..] asserts) $ \(n, (msg, md, assert)) -&gt; do</span>
<span class="lineno">  320 </span><span class="spaces">       </span><span class="istickedoff">goal   &lt;- io $ scImplies sc assume assert</span>
<span class="lineno">  321 </span><span class="spaces">       </span><span class="istickedoff">goal'  &lt;- io $ boolToProp sc [] goal -- TODO, generalize over inputs</span>
<span class="lineno">  322 </span><span class="spaces">       </span><span class="istickedoff">let <span class="nottickedoff">ploc = MS.conditionLoc md</span></span>
<span class="lineno">  323 </span><span class="spaces">       </span><span class="istickedoff">let <span class="nottickedoff">gloc = (unwords [show (W4.plSourceLoc ploc)</span></span>
<span class="lineno">  324 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">,&quot;in&quot;</span></span>
<span class="lineno">  325 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">, show (W4.plFunction ploc)]) ++</span></span>
<span class="lineno">  326 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">(if Prelude.null (MS.conditionContext md) then [] else</span></span>
<span class="lineno">  327 </span><span class="spaces">                     </span><span class="istickedoff"><span class="nottickedoff">&quot;\n&quot; ++ MS.conditionContext md)</span></span>
<span class="lineno">  328 </span><span class="spaces">       </span><span class="istickedoff">let <span class="nottickedoff">goalname = concat [nm, &quot; (&quot;, takeWhile (/= '\n') msg, &quot;)&quot;]</span></span>
<span class="lineno">  329 </span><span class="spaces">       </span><span class="istickedoff">let proofgoal = ProofGoal</span>
<span class="lineno">  330 </span><span class="spaces">                       </span><span class="istickedoff">{ goalNum  = <span class="nottickedoff">n</span></span>
<span class="lineno">  331 </span><span class="spaces">                       </span><span class="istickedoff">, goalType = <span class="nottickedoff">MS.conditionType md</span></span>
<span class="lineno">  332 </span><span class="spaces">                       </span><span class="istickedoff">, goalName = <span class="nottickedoff">nm</span></span>
<span class="lineno">  333 </span><span class="spaces">                       </span><span class="istickedoff">, goalLoc  = <span class="nottickedoff">gloc</span></span>
<span class="lineno">  334 </span><span class="spaces">                       </span><span class="istickedoff">, goalDesc = <span class="nottickedoff">msg</span></span>
<span class="lineno">  335 </span><span class="spaces">                       </span><span class="istickedoff">, goalSequent = propToSequent goal'</span>
<span class="lineno">  336 </span><span class="spaces">                       </span><span class="istickedoff">, goalTags = <span class="nottickedoff">MS.conditionTags md</span></span>
<span class="lineno">  337 </span><span class="spaces">                       </span><span class="istickedoff">}</span>
<span class="lineno">  338 </span><span class="spaces">       </span><span class="istickedoff">res &lt;- runProofScript tactic goal' proofgoal <span class="nottickedoff">(Just ploc)</span></span>
<span class="lineno">  339 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">(Text.unwords</span></span>
<span class="lineno">  340 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">[&quot;JVM verification condition:&quot;, Text.pack (show n), Text.pack goalname])</span></span>
<span class="lineno">  341 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">False</span> -- do not record in the theorem database</span>
<span class="lineno">  342 </span><span class="spaces">                </span><span class="istickedoff">False -- TODO, useSequentGoals...</span>
<span class="lineno">  343 </span><span class="spaces">       </span><span class="istickedoff">case res of</span>
<span class="lineno">  344 </span><span class="spaces">         </span><span class="istickedoff">ValidProof stats thm -&gt;</span>
<span class="lineno">  345 </span><span class="spaces">           </span><span class="istickedoff">return <span class="nottickedoff">(stats, MS.VCStats md stats (thmSummary thm) (thmNonce thm) (thmDepends thm) (thmElapsedTime thm))</span></span>
<span class="lineno">  346 </span><span class="spaces">         </span><span class="istickedoff">InvalidProof stats vals _pst -&gt; do</span>
<span class="lineno">  347 </span><span class="spaces">           </span><span class="istickedoff">printOutLnTop Info $ unwords [&quot;Subgoal failed:&quot;, nm, msg]</span>
<span class="lineno">  348 </span><span class="spaces">           </span><span class="istickedoff">printOutLnTop Info (show stats)</span>
<span class="lineno">  349 </span><span class="spaces">           </span><span class="istickedoff">printOutLnTop OnlyCounterExamples &quot;----------Counterexample----------&quot;</span>
<span class="lineno">  350 </span><span class="spaces">           </span><span class="istickedoff">opts &lt;- rwPPOpts &lt;$&gt; getTopLevelRW</span>
<span class="lineno">  351 </span><span class="spaces">           </span><span class="istickedoff">let showVar x = Text.unpack (vnName x)</span>
<span class="lineno">  352 </span><span class="spaces">           </span><span class="istickedoff">let showAssignment (name, val) = &quot;  &quot; ++ showVar name ++ &quot;: &quot; ++ show (ppFirstOrderValue opts val)</span>
<span class="lineno">  353 </span><span class="spaces">           </span><span class="istickedoff">mapM_ (printOutLnTop OnlyCounterExamples . showAssignment) vals</span>
<span class="lineno">  354 </span><span class="spaces">           </span><span class="istickedoff">io $ fail &quot;Proof failed.&quot; -- Mirroring behavior of llvm_verify</span>
<span class="lineno">  355 </span><span class="spaces">         </span><span class="istickedoff">UnfinishedProof pst -&gt;</span>
<span class="lineno">  356 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">io $ fail $ &quot;Proof failed &quot; ++ show (length (psGoals pst)) ++ &quot; goals remaining.&quot;</span></span>
<span class="lineno">  357 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  358 </span><span class="spaces">     </span><span class="istickedoff">printOutLnTop Info $ unwords [&quot;Proof succeeded!&quot;, nm]</span>
<span class="lineno">  359 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  360 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">stats = mconcat (map fst outs)</span></span>
<span class="lineno">  361 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">vcstats = map snd outs</span></span>
<span class="lineno">  362 </span><span class="spaces">     </span><span class="istickedoff">return (<span class="nottickedoff">stats</span>, <span class="nottickedoff">vcstats</span>)</span></span>
<span class="lineno">  363 </span>
<span class="lineno">  364 </span>-- | Evaluate the precondition part of a Crucible method spec:
<span class="lineno">  365 </span>--
<span class="lineno">  366 </span>-- * Allocate heap space for each 'jvm_alloc' statement.
<span class="lineno">  367 </span>--
<span class="lineno">  368 </span>-- * Record an equality precondition for each 'jvm_equal'
<span class="lineno">  369 </span>-- statement.
<span class="lineno">  370 </span>--
<span class="lineno">  371 </span>-- * Write to memory for each 'jvm_points_to' statement. (Writes
<span class="lineno">  372 </span>-- to already-initialized locations are transformed into equality
<span class="lineno">  373 </span>-- preconditions.)
<span class="lineno">  374 </span>--
<span class="lineno">  375 </span>-- * Evaluate the function arguments from the 'jvm_execute_func'
<span class="lineno">  376 </span>-- statement.
<span class="lineno">  377 </span>--
<span class="lineno">  378 </span>-- Returns a tuple of (arguments, preconditions, pointer values,
<span class="lineno">  379 </span>-- memory).
<span class="lineno">  380 </span>verifyPrestate ::
<span class="lineno">  381 </span>  JVMCrucibleContext -&gt;
<span class="lineno">  382 </span>  MethodSpec -&gt;
<span class="lineno">  383 </span>  Crucible.SymGlobalState Sym -&gt;
<span class="lineno">  384 </span>  IO ([(J.Type, JVMVal)],
<span class="lineno">  385 </span>      [Crucible.LabeledPred Term AssumptionReason],
<span class="lineno">  386 </span>      Map AllocIndex JVMRefVal,
<span class="lineno">  387 </span>      Crucible.SymGlobalState Sym)
<span class="lineno">  388 </span><span class="decl"><span class="istickedoff">verifyPrestate cc mspec globals0 =</span>
<span class="lineno">  389 </span><span class="spaces">  </span><span class="istickedoff">jccWithBackend cc $ \bak -&gt;</span>
<span class="lineno">  390 </span><span class="spaces">  </span><span class="istickedoff">do let sym = cc^.jccSym</span>
<span class="lineno">  391 </span><span class="spaces">     </span><span class="istickedoff">let jc = cc^.jccJVMContext</span>
<span class="lineno">  392 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">halloc = cc^.jccHandleAllocator</span></span>
<span class="lineno">  393 </span><span class="spaces">     </span><span class="istickedoff">let preallocs = mspec ^. MS.csPreState . MS.csAllocs</span>
<span class="lineno">  394 </span><span class="spaces">     </span><span class="istickedoff">let tyenv = MS.csAllocations mspec</span>
<span class="lineno">  395 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">nameEnv = mspec ^. MS.csPreState . MS.csVarTypeNames</span></span>
<span class="lineno">  396 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  397 </span><span class="spaces">     </span><span class="istickedoff">let prestateLoc = W4.mkProgramLoc &quot;_SAW_JVM_verifyPrestate&quot; W4.InternalPos</span>
<span class="lineno">  398 </span><span class="spaces">     </span><span class="istickedoff">W4.setCurrentProgramLoc sym prestateLoc</span>
<span class="lineno">  399 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  400 </span><span class="spaces">     </span><span class="istickedoff">--let cvar = CJ.dynamicClassTable (cc^.jccJVMContext)</span>
<span class="lineno">  401 </span><span class="spaces">     </span><span class="istickedoff">--let Just mem = Crucible.lookupGlobal lvar globals</span>
<span class="lineno">  402 </span><span class="spaces">     </span><span class="istickedoff">let postPointsTos = mspec ^. MS.csPostState . MS.csPointsTos</span>
<span class="lineno">  403 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  404 </span><span class="spaces">     </span><span class="istickedoff">-- make static fields mentioned in post-state section writable</span>
<span class="lineno">  405 </span><span class="spaces">     </span><span class="istickedoff">let updatedStaticFields = [ fid | JVMPointsToStatic _ fid _ &lt;- postPointsTos ]</span>
<span class="lineno">  406 </span><span class="spaces">     </span><span class="istickedoff">let makeWritable gs fid = CJ.doStaticFieldWritable <span class="nottickedoff">bak</span> jc gs fid (W4.truePred sym)</span>
<span class="lineno">  407 </span><span class="spaces">     </span><span class="istickedoff">globals0' &lt;- liftIO $ foldM makeWritable globals0 updatedStaticFields</span>
<span class="lineno">  408 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  409 </span><span class="spaces">     </span><span class="istickedoff">-- determine which arrays and instance fields need to be writable</span>
<span class="lineno">  410 </span><span class="spaces">     </span><span class="istickedoff">let addUpdates pt (as, es, fs) =</span>
<span class="lineno">  411 </span><span class="spaces">           </span><span class="istickedoff">case pt of</span>
<span class="lineno">  412 </span><span class="spaces">             </span><span class="istickedoff">JVMPointsToField _ a fid _ -&gt; (<span class="nottickedoff">as</span>, <span class="nottickedoff">es</span>, Map.insertWith <span class="nottickedoff">(++)</span> a [fid] fs)</span>
<span class="lineno">  413 </span><span class="spaces">             </span><span class="istickedoff">JVMPointsToStatic{} -&gt; (<span class="nottickedoff">as</span>, <span class="nottickedoff">es</span>, fs)</span>
<span class="lineno">  414 </span><span class="spaces">             </span><span class="istickedoff">JVMPointsToElem _ a i _ -&gt; (as, Map.insertWith <span class="nottickedoff">(++)</span> a [i] es, fs)</span>
<span class="lineno">  415 </span><span class="spaces">             </span><span class="istickedoff">JVMPointsToArray _ a _ -&gt; (Set.insert a as, es, fs)</span>
<span class="lineno">  416 </span><span class="spaces">     </span><span class="istickedoff">let (updatedArrays, updatedElems, updatedFields) =</span>
<span class="lineno">  417 </span><span class="spaces">           </span><span class="istickedoff">foldr addUpdates (Set.empty, Map.empty, Map.empty) postPointsTos</span>
<span class="lineno">  418 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  419 </span><span class="spaces">     </span><span class="istickedoff">-- Allocate objects in memory for each 'jvm_alloc'</span>
<span class="lineno">  420 </span><span class="spaces">     </span><span class="istickedoff">let doAlloc a (_loc, alloc) =</span>
<span class="lineno">  421 </span><span class="spaces">           </span><span class="istickedoff">case alloc of</span>
<span class="lineno">  422 </span><span class="spaces">             </span><span class="istickedoff">AllocObject cname -&gt;</span>
<span class="lineno">  423 </span><span class="spaces">               </span><span class="istickedoff">StateT (CJ.doAllocateObject bak <span class="nottickedoff">halloc</span> jc cname (flip elem fids))</span>
<span class="lineno">  424 </span><span class="spaces">               </span><span class="istickedoff">where fids = fromMaybe [] (Map.lookup a updatedFields)</span>
<span class="lineno">  425 </span><span class="spaces">             </span><span class="istickedoff">AllocArray len ty -&gt;</span>
<span class="lineno">  426 </span><span class="spaces">               </span><span class="istickedoff">StateT (CJ.doAllocateArray bak <span class="nottickedoff">halloc</span> <span class="nottickedoff">jc</span> len ty writable)</span>
<span class="lineno">  427 </span><span class="spaces">               </span><span class="istickedoff">where</span>
<span class="lineno">  428 </span><span class="spaces">                 </span><span class="istickedoff">writable</span>
<span class="lineno">  429 </span><span class="spaces">                   </span><span class="istickedoff">| Set.member a updatedArrays = const True</span>
<span class="lineno">  430 </span><span class="spaces">                   </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = maybe (const False) (flip elem) (Map.lookup a updatedElems)</span>
<span class="lineno">  431 </span><span class="spaces">     </span><span class="istickedoff">(env, globals1) &lt;- runStateT (Map.traverseWithKey doAlloc preallocs) globals0'</span>
<span class="lineno">  432 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  433 </span><span class="spaces">     </span><span class="istickedoff">globals2 &lt;- setupPrePointsTos <span class="nottickedoff">mspec</span> cc env (mspec ^. MS.csPreState . MS.csPointsTos) globals1</span>
<span class="lineno">  434 </span><span class="spaces">     </span><span class="istickedoff">(globals3, cs) &lt;-</span>
<span class="lineno">  435 </span><span class="spaces">       </span><span class="istickedoff">setupPrestateConditions <span class="nottickedoff">mspec</span> cc <span class="nottickedoff">env</span> globals2 (mspec ^. MS.csPreState . MS.csConditions)</span>
<span class="lineno">  436 </span><span class="spaces">     </span><span class="istickedoff">args &lt;- resolveArguments cc mspec env</span>
<span class="lineno">  437 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  438 </span><span class="spaces">     </span><span class="istickedoff">-- Check the type of the return setup value</span>
<span class="lineno">  439 </span><span class="spaces">     </span><span class="istickedoff">case (mspec ^. MS.csRetValue, mspec ^. MS.csRet) of</span>
<span class="lineno">  440 </span><span class="spaces">       </span><span class="istickedoff">(Just _, Nothing) -&gt;</span>
<span class="lineno">  441 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno">  442 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return value specified, but method &quot; ++ mspec ^. csMethodName ++</span></span>
<span class="lineno">  443 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">&quot; has void return type&quot;</span></span>
<span class="lineno">  444 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  445 </span><span class="spaces">       </span><span class="istickedoff">(Just sv, Just retTy) -&gt;</span>
<span class="lineno">  446 </span><span class="spaces">         </span><span class="istickedoff">do retTy' &lt;- typeOfSetupValue <span class="nottickedoff">cc</span> tyenv <span class="nottickedoff">nameEnv</span> sv</span>
<span class="lineno">  447 </span><span class="spaces">            </span><span class="istickedoff">unless (registerCompatible retTy retTy') $</span>
<span class="lineno">  448 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno">  449 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Incompatible types for return value when verifying &quot; ++ mspec ^. csMethodName</span></span>
<span class="lineno">  450 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, &quot;Expected: &quot; ++ show retTy</span></span>
<span class="lineno">  451 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, &quot;but given value of type: &quot; ++ show retTy'</span></span>
<span class="lineno">  452 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  453 </span><span class="spaces">       </span><span class="istickedoff">(Nothing, _) -&gt; return <span class="nottickedoff">()</span></span>
<span class="lineno">  454 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  455 </span><span class="spaces">     </span><span class="istickedoff">return (args, cs, env, globals3)</span></span>
<span class="lineno">  456 </span>
<span class="lineno">  457 </span>-- | Check two Types for register compatibility.
<span class="lineno">  458 </span>registerCompatible :: J.Type -&gt; J.Type -&gt; Bool
<span class="lineno">  459 </span><span class="decl"><span class="istickedoff">registerCompatible mt mt' = storageType mt == storageType mt'</span></span>
<span class="lineno">  460 </span>
<span class="lineno">  461 </span>data StorageType = STInt | STLong | STFloat | STDouble | STRef
<span class="lineno">  462 </span>  deriving <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>
<span class="lineno">  463 </span>
<span class="lineno">  464 </span>storageType :: J.Type -&gt; StorageType
<span class="lineno">  465 </span><span class="decl"><span class="istickedoff">storageType ty =</span>
<span class="lineno">  466 </span><span class="spaces">  </span><span class="istickedoff">case ty of</span>
<span class="lineno">  467 </span><span class="spaces">    </span><span class="istickedoff">J.BooleanType -&gt; STInt</span>
<span class="lineno">  468 </span><span class="spaces">    </span><span class="istickedoff">J.ByteType    -&gt; STInt</span>
<span class="lineno">  469 </span><span class="spaces">    </span><span class="istickedoff">J.CharType    -&gt; STInt</span>
<span class="lineno">  470 </span><span class="spaces">    </span><span class="istickedoff">J.ShortType   -&gt; STInt</span>
<span class="lineno">  471 </span><span class="spaces">    </span><span class="istickedoff">J.IntType     -&gt; STInt</span>
<span class="lineno">  472 </span><span class="spaces">    </span><span class="istickedoff">J.LongType    -&gt; STLong</span>
<span class="lineno">  473 </span><span class="spaces">    </span><span class="istickedoff">J.FloatType   -&gt; <span class="nottickedoff">STFloat</span></span>
<span class="lineno">  474 </span><span class="spaces">    </span><span class="istickedoff">J.DoubleType  -&gt; <span class="nottickedoff">STDouble</span></span>
<span class="lineno">  475 </span><span class="spaces">    </span><span class="istickedoff">J.ArrayType{} -&gt; STRef</span>
<span class="lineno">  476 </span><span class="spaces">    </span><span class="istickedoff">J.ClassType{} -&gt; STRef</span></span>
<span class="lineno">  477 </span>
<span class="lineno">  478 </span>resolveArguments ::
<span class="lineno">  479 </span>  JVMCrucibleContext -&gt;
<span class="lineno">  480 </span>  MethodSpec -&gt;
<span class="lineno">  481 </span>  Map AllocIndex JVMRefVal -&gt;
<span class="lineno">  482 </span>  IO [(J.Type, JVMVal)]
<span class="lineno">  483 </span><span class="decl"><span class="istickedoff">resolveArguments cc mspec env = mapM resolveArg [0..(nArgs-1)]</span>
<span class="lineno">  484 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  485 </span><span class="spaces">    </span><span class="istickedoff">nArgs = toInteger (length (mspec ^. MS.csArgs))</span>
<span class="lineno">  486 </span><span class="spaces">    </span><span class="istickedoff">tyenv = MS.csAllocations mspec</span>
<span class="lineno">  487 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">nameEnv = mspec ^. MS.csPreState . MS.csVarTypeNames</span></span>
<span class="lineno">  488 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">nm = mspec ^. csMethodName</span></span>
<span class="lineno">  489 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  490 </span><span class="spaces">    </span><span class="istickedoff">checkArgTy i mt mt' =</span>
<span class="lineno">  491 </span><span class="spaces">      </span><span class="istickedoff">unless (registerCompatible mt mt') $</span>
<span class="lineno">  492 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">fail $ unlines [ &quot;Type mismatch in argument &quot; ++ show i ++ &quot; when verifying &quot; ++ show nm</span></span>
<span class="lineno">  493 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">, &quot;Argument is declared with type: &quot; ++ show mt</span></span>
<span class="lineno">  494 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">, &quot;but provided argument has incompatible type: &quot; ++ show mt'</span></span>
<span class="lineno">  495 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">, &quot;Note: this may be because the signature of your &quot; ++</span></span>
<span class="lineno">  496 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">&quot;function changed during compilation. If using &quot; ++</span></span>
<span class="lineno">  497 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">&quot;Clang, check the signature in the disassembled &quot; ++</span></span>
<span class="lineno">  498 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">&quot;.ll file.&quot;</span></span>
<span class="lineno">  499 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  500 </span><span class="spaces">    </span><span class="istickedoff">resolveArg i =</span>
<span class="lineno">  501 </span><span class="spaces">      </span><span class="istickedoff">case Map.lookup i (mspec ^. MS.csArgBindings) of</span>
<span class="lineno">  502 </span><span class="spaces">        </span><span class="istickedoff">Just (mt, sv) -&gt; do</span>
<span class="lineno">  503 </span><span class="spaces">          </span><span class="istickedoff">mt' &lt;- typeOfSetupValue <span class="nottickedoff">cc</span> tyenv <span class="nottickedoff">nameEnv</span> sv</span>
<span class="lineno">  504 </span><span class="spaces">          </span><span class="istickedoff">checkArgTy <span class="nottickedoff">i</span> mt mt'</span>
<span class="lineno">  505 </span><span class="spaces">          </span><span class="istickedoff">v &lt;- resolveSetupVal cc env <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span> sv</span>
<span class="lineno">  506 </span><span class="spaces">          </span><span class="istickedoff">return (<span class="nottickedoff">mt</span>, v)</span>
<span class="lineno">  507 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail $ unwords [&quot;Argument&quot;, show i, &quot;unspecified when verifying&quot;, show nm]</span></span></span>
<span class="lineno">  508 </span>
<span class="lineno">  509 </span>--------------------------------------------------------------------------------
<span class="lineno">  510 </span>
<span class="lineno">  511 </span>-- | For each points-to constraint in the pre-state section of the
<span class="lineno">  512 </span>-- function spec, write the given value to the address of the given
<span class="lineno">  513 </span>-- pointer.
<span class="lineno">  514 </span>setupPrePointsTos ::
<span class="lineno">  515 </span>  MethodSpec -&gt;
<span class="lineno">  516 </span>  JVMCrucibleContext -&gt;
<span class="lineno">  517 </span>  Map AllocIndex JVMRefVal -&gt;
<span class="lineno">  518 </span>  [JVMPointsTo] -&gt;
<span class="lineno">  519 </span>  Crucible.SymGlobalState Sym -&gt;
<span class="lineno">  520 </span>  IO (Crucible.SymGlobalState Sym)
<span class="lineno">  521 </span><span class="decl"><span class="istickedoff">setupPrePointsTos mspec cc env pts mem0 = foldM doPointsTo mem0 pts</span>
<span class="lineno">  522 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  523 </span><span class="spaces">    </span><span class="istickedoff">sym = cc^.jccSym</span>
<span class="lineno">  524 </span><span class="spaces">    </span><span class="istickedoff">jc = cc ^. jccJVMContext</span>
<span class="lineno">  525 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">tyenv = MS.csAllocations mspec</span></span>
<span class="lineno">  526 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">nameEnv = mspec ^. MS.csPreState . MS.csVarTypeNames</span></span>
<span class="lineno">  527 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  528 </span><span class="spaces">    </span><span class="istickedoff">injectSetupVal :: SetupValue -&gt; IO (Crucible.RegValue Sym CJ.JVMValueType)</span>
<span class="lineno">  529 </span><span class="spaces">    </span><span class="istickedoff">injectSetupVal rhs =</span>
<span class="lineno">  530 </span><span class="spaces">      </span><span class="istickedoff">injectJVMVal sym &lt;$&gt; resolveSetupVal cc env <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span> rhs</span>
<span class="lineno">  531 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  532 </span><span class="spaces">    </span><span class="istickedoff">doPointsTo :: Crucible.SymGlobalState Sym -&gt; JVMPointsTo -&gt; IO (Crucible.SymGlobalState Sym)</span>
<span class="lineno">  533 </span><span class="spaces">    </span><span class="istickedoff">doPointsTo mem pt =</span>
<span class="lineno">  534 </span><span class="spaces">      </span><span class="istickedoff">jccWithBackend cc $ \bak -&gt;</span>
<span class="lineno">  535 </span><span class="spaces">      </span><span class="istickedoff">case pt of</span>
<span class="lineno">  536 </span><span class="spaces">        </span><span class="istickedoff">JVMPointsToField _loc lhs fid (Just rhs) -&gt;</span>
<span class="lineno">  537 </span><span class="spaces">          </span><span class="istickedoff">do let lhs' = lookupAllocIndex env lhs</span>
<span class="lineno">  538 </span><span class="spaces">             </span><span class="istickedoff">rhs' &lt;- injectSetupVal rhs</span>
<span class="lineno">  539 </span><span class="spaces">             </span><span class="istickedoff">CJ.doFieldStore bak mem lhs' fid rhs'</span>
<span class="lineno">  540 </span><span class="spaces">        </span><span class="istickedoff">JVMPointsToStatic _loc fid (Just rhs) -&gt;</span>
<span class="lineno">  541 </span><span class="spaces">          </span><span class="istickedoff">do rhs' &lt;- injectSetupVal rhs</span>
<span class="lineno">  542 </span><span class="spaces">             </span><span class="istickedoff">CJ.doStaticFieldStore <span class="nottickedoff">bak</span> jc mem fid rhs'</span>
<span class="lineno">  543 </span><span class="spaces">        </span><span class="istickedoff">JVMPointsToElem _loc lhs idx (Just rhs) -&gt;</span>
<span class="lineno">  544 </span><span class="spaces">          </span><span class="istickedoff">do let lhs' = lookupAllocIndex env lhs</span>
<span class="lineno">  545 </span><span class="spaces">             </span><span class="istickedoff">rhs' &lt;- injectSetupVal rhs</span>
<span class="lineno">  546 </span><span class="spaces">             </span><span class="istickedoff">CJ.doArrayStore bak mem lhs' idx rhs'</span>
<span class="lineno">  547 </span><span class="spaces">        </span><span class="istickedoff">JVMPointsToArray _loc lhs (Just rhs) -&gt;</span>
<span class="lineno">  548 </span><span class="spaces">          </span><span class="istickedoff">do sc &lt;- saw_ctx &lt;$&gt; sawCoreState sym</span>
<span class="lineno">  549 </span><span class="spaces">             </span><span class="istickedoff">let lhs' = lookupAllocIndex env lhs</span>
<span class="lineno">  550 </span><span class="spaces">             </span><span class="istickedoff">(_ety, tts) &lt;-</span>
<span class="lineno">  551 </span><span class="spaces">               </span><span class="istickedoff">destVecTypedTerm sc rhs &gt;&gt;=</span>
<span class="lineno">  552 </span><span class="spaces">               </span><span class="istickedoff">\case</span>
<span class="lineno">  553 </span><span class="spaces">                 </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail &quot;setupPrePointsTos: not a monomorphic sequence type&quot;</span></span>
<span class="lineno">  554 </span><span class="spaces">                 </span><span class="istickedoff">Just x -&gt; pure x</span>
<span class="lineno">  555 </span><span class="spaces">             </span><span class="istickedoff">rhs' &lt;- traverse (injectSetupVal . MS.SetupTerm) tts</span>
<span class="lineno">  556 </span><span class="spaces">             </span><span class="istickedoff">doEntireArrayStore bak mem lhs' rhs'</span>
<span class="lineno">  557 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  558 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">panic &quot;setupPrePointsTo&quot; [&quot;invalid invariant&quot;, &quot;jvm_modifies in pre-state&quot;]</span></span></span>
<span class="lineno">  559 </span>
<span class="lineno">  560 </span>-- | Sets up globals (ghost variable), and collects boolean terms
<span class="lineno">  561 </span>-- that should be assumed to be true.
<span class="lineno">  562 </span>setupPrestateConditions ::
<span class="lineno">  563 </span>  MethodSpec -&gt;
<span class="lineno">  564 </span>  JVMCrucibleContext -&gt;
<span class="lineno">  565 </span>  Map AllocIndex JVMRefVal -&gt;
<span class="lineno">  566 </span>  Crucible.SymGlobalState Sym -&gt;
<span class="lineno">  567 </span>  [SetupCondition] -&gt;
<span class="lineno">  568 </span>  IO ( Crucible.SymGlobalState Sym, [Crucible.LabeledPred Term AssumptionReason]
<span class="lineno">  569 </span>     )
<span class="lineno">  570 </span><span class="decl"><span class="istickedoff">setupPrestateConditions mspec cc env = aux []</span>
<span class="lineno">  571 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  572 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">tyenv   = MS.csAllocations mspec</span></span>
<span class="lineno">  573 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">nameEnv = mspec ^. MS.csPreState . MS.csVarTypeNames</span></span>
<span class="lineno">  574 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  575 </span><span class="spaces">    </span><span class="istickedoff">aux acc globals [] = return (globals, acc)</span>
<span class="lineno">  576 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  577 </span><span class="spaces">    </span><span class="istickedoff">aux acc globals (MS.SetupCond_Equal loc val1 val2 : xs) =</span>
<span class="lineno">  578 </span><span class="spaces">      </span><span class="istickedoff">do val1' &lt;- resolveSetupVal cc <span class="nottickedoff">env</span> <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span> val1</span>
<span class="lineno">  579 </span><span class="spaces">         </span><span class="istickedoff">val2' &lt;- resolveSetupVal cc <span class="nottickedoff">env</span> <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span> val2</span>
<span class="lineno">  580 </span><span class="spaces">         </span><span class="istickedoff">t     &lt;- assertEqualVals cc val1' val2'</span>
<span class="lineno">  581 </span><span class="spaces">         </span><span class="istickedoff">let lp = Crucible.LabeledPred t (<span class="nottickedoff">loc</span>, <span class="nottickedoff">&quot;equality precondition&quot;</span>)</span>
<span class="lineno">  582 </span><span class="spaces">         </span><span class="istickedoff">aux (lp:acc) globals xs</span>
<span class="lineno">  583 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  584 </span><span class="spaces">    </span><span class="istickedoff">aux acc globals (MS.SetupCond_Pred loc tm : xs) =</span>
<span class="lineno">  585 </span><span class="spaces">      </span><span class="istickedoff">let lp = Crucible.LabeledPred (ttTerm tm) (loc, &quot;precondition&quot;) in</span>
<span class="lineno">  586 </span><span class="spaces">      </span><span class="istickedoff">aux (lp:acc) globals xs</span>
<span class="lineno">  587 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  588 </span><span class="spaces">    </span><span class="istickedoff">aux acc globals (MS.SetupCond_Ghost _md var val : xs) =</span>
<span class="lineno">  589 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">case val of</span></span>
<span class="lineno">  590 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">TypedTerm (TypedTermSchema sch) tm -&gt;</span></span>
<span class="lineno">  591 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">aux acc (Crucible.insertGlobal var (sch,tm) globals) xs</span></span>
<span class="lineno">  592 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">TypedTerm tp _ -&gt;</span></span>
<span class="lineno">  593 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno">  594 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Setup term for global variable expected to have Cryptol schema type, but got&quot;</span></span>
<span class="lineno">  595 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">, show (ppTypedTermType tp)</span></span>
<span class="lineno">  596 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno">  597 </span>
<span class="lineno">  598 </span>--------------------------------------------------------------------------------
<span class="lineno">  599 </span>
<span class="lineno">  600 </span>-- | Create a SAWCore formula asserting that two 'JVMVal's are equal.
<span class="lineno">  601 </span>assertEqualVals ::
<span class="lineno">  602 </span>  JVMCrucibleContext -&gt;
<span class="lineno">  603 </span>  JVMVal -&gt;
<span class="lineno">  604 </span>  JVMVal -&gt;
<span class="lineno">  605 </span>  IO Term
<span class="lineno">  606 </span><span class="decl"><span class="istickedoff">assertEqualVals cc v1 v2 =</span>
<span class="lineno">  607 </span><span class="spaces">  </span><span class="istickedoff">do let sym = cc^.jccSym</span>
<span class="lineno">  608 </span><span class="spaces">     </span><span class="istickedoff">st &lt;- sawCoreState sym</span>
<span class="lineno">  609 </span><span class="spaces">     </span><span class="istickedoff">toSC <span class="nottickedoff">sym</span> st =&lt;&lt; equalValsPred cc v1 v2</span></span>
<span class="lineno">  610 </span>
<span class="lineno">  611 </span>--------------------------------------------------------------------------------
<span class="lineno">  612 </span>
<span class="lineno">  613 </span>getMethodHandle :: CJ.JVMContext -&gt; JVMMethodId -&gt; IO CJ.JVMHandleInfo
<span class="lineno">  614 </span><span class="decl"><span class="istickedoff">getMethodHandle jc (JVMMethodId mkey cname) =</span>
<span class="lineno">  615 </span><span class="spaces">  </span><span class="istickedoff">case Map.lookup (cname, mkey) (CJ.methodHandles jc) of</span>
<span class="lineno">  616 </span><span class="spaces">    </span><span class="istickedoff">Just handle -&gt; return handle</span>
<span class="lineno">  617 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  618 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">fail $</span></span>
<span class="lineno">  619 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">&quot;BUG: cannot find handle for &quot; ++ J.unClassName cname ++</span></span>
<span class="lineno">  620 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">&quot;/&quot; ++ J.methodKeyName mkey</span></span></span>
<span class="lineno">  621 </span>
<span class="lineno">  622 </span>registerOverride ::
<span class="lineno">  623 </span>  Options -&gt;
<span class="lineno">  624 </span>  JVMCrucibleContext -&gt;
<span class="lineno">  625 </span>  Crucible.SimContext (SAWCruciblePersonality Sym) Sym CJ.JVM -&gt;
<span class="lineno">  626 </span>  W4.ProgramLoc -&gt;
<span class="lineno">  627 </span>  IORef MetadataMap {- ^ metadata map -} -&gt;
<span class="lineno">  628 </span>  NonEmpty MethodSpec -&gt;
<span class="lineno">  629 </span>  Crucible.OverrideSim (SAWCruciblePersonality Sym) Sym CJ.JVM rtp args ret ()
<span class="lineno">  630 </span><span class="decl"><span class="istickedoff">registerOverride opts cc _ctx top_loc mdMap cs =</span>
<span class="lineno">  631 </span><span class="spaces">  </span><span class="istickedoff">do let sym = cc^.jccSym</span>
<span class="lineno">  632 </span><span class="spaces">     </span><span class="istickedoff">let jc = cc^.jccJVMContext</span>
<span class="lineno">  633 </span><span class="spaces">     </span><span class="istickedoff">let c0 = NE.head cs</span>
<span class="lineno">  634 </span><span class="spaces">     </span><span class="istickedoff">let method = c0 ^. MS.csMethod</span>
<span class="lineno">  635 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  636 </span><span class="spaces">     </span><span class="istickedoff">sc &lt;- saw_ctx &lt;$&gt; liftIO (sawCoreState sym)</span>
<span class="lineno">  637 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  638 </span><span class="spaces">     </span><span class="istickedoff">mhandle &lt;- liftIO $ getMethodHandle jc method</span>
<span class="lineno">  639 </span><span class="spaces">     </span><span class="istickedoff">case mhandle of</span>
<span class="lineno">  640 </span><span class="spaces">       </span><span class="istickedoff">-- LLVMHandleInfo constructor has two existential type arguments,</span>
<span class="lineno">  641 </span><span class="spaces">       </span><span class="istickedoff">-- which are bound here. h :: FnHandle args' ret'</span>
<span class="lineno">  642 </span><span class="spaces">       </span><span class="istickedoff">CJ.JVMHandleInfo _ h -&gt;</span>
<span class="lineno">  643 </span><span class="spaces">         </span><span class="istickedoff">do let retType = Crucible.handleReturnType h</span>
<span class="lineno">  644 </span><span class="spaces">            </span><span class="istickedoff">Crucible.bindFnHandle h</span>
<span class="lineno">  645 </span><span class="spaces">              </span><span class="istickedoff">$ Crucible.UseOverride</span>
<span class="lineno">  646 </span><span class="spaces">              </span><span class="istickedoff">$ Crucible.mkOverride'</span>
<span class="lineno">  647 </span><span class="spaces">                  </span><span class="istickedoff">(Crucible.handleName h)</span>
<span class="lineno">  648 </span><span class="spaces">                  </span><span class="istickedoff">retType</span>
<span class="lineno">  649 </span><span class="spaces">                  </span><span class="istickedoff">(methodSpecHandler opts sc cc <span class="nottickedoff">top_loc</span> <span class="nottickedoff">mdMap</span> cs h)</span></span>
<span class="lineno">  650 </span>
<span class="lineno">  651 </span>
<span class="lineno">  652 </span>--------------------------------------------------------------------------------
<span class="lineno">  653 </span>
<span class="lineno">  654 </span>-- | Simulate a JVM function with Crucible as part of a 'jvm_verify' command,
<span class="lineno">  655 </span>-- making sure to install any overrides that the user supplies.
<span class="lineno">  656 </span>verifySimulate ::
<span class="lineno">  657 </span>  Options -&gt;
<span class="lineno">  658 </span>  JVMCrucibleContext -&gt;
<span class="lineno">  659 </span>  [Crucible.GenericExecutionFeature Sym] -&gt;
<span class="lineno">  660 </span>  MethodSpec -&gt;
<span class="lineno">  661 </span>  [(a, JVMVal)] -&gt;
<span class="lineno">  662 </span>  [Crucible.LabeledPred Term AssumptionReason] -&gt;
<span class="lineno">  663 </span>  W4.ProgramLoc -&gt;
<span class="lineno">  664 </span>  [Lemma] -&gt;
<span class="lineno">  665 </span>  Crucible.SymGlobalState Sym -&gt;
<span class="lineno">  666 </span>  Bool {- ^ path sat checking -} -&gt;
<span class="lineno">  667 </span>  IORef MetadataMap {- ^ metadata map -} -&gt;
<span class="lineno">  668 </span>  IO (Maybe (J.Type, JVMVal), Crucible.SymGlobalState Sym)
<span class="lineno">  669 </span><span class="decl"><span class="istickedoff">verifySimulate opts cc pfs mspec args assumes top_loc lemmas globals _checkSat mdMap =</span>
<span class="lineno">  670 </span><span class="spaces">  </span><span class="istickedoff">jccWithBackend cc $ \bak -&gt;</span>
<span class="lineno">  671 </span><span class="spaces">  </span><span class="istickedoff">do let jc = cc^.jccJVMContext</span>
<span class="lineno">  672 </span><span class="spaces">     </span><span class="istickedoff">let sym = cc^.jccSym</span>
<span class="lineno">  673 </span><span class="spaces">     </span><span class="istickedoff">let method = mspec ^. MS.csMethod</span>
<span class="lineno">  674 </span><span class="spaces">     </span><span class="istickedoff">let verbosity = simVerbose opts</span>
<span class="lineno">  675 </span><span class="spaces">     </span><span class="istickedoff">let halloc = cc^.jccHandleAllocator</span>
<span class="lineno">  676 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  677 </span><span class="spaces">     </span><span class="istickedoff">-- executeCrucibleJVM</span>
<span class="lineno">  678 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  679 </span><span class="spaces">     </span><span class="istickedoff">when (verbosity &gt; 2) $</span>
<span class="lineno">  680 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">putStrLn &quot;starting executeCrucibleJVM&quot;</span></span>
<span class="lineno">  681 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  682 </span><span class="spaces">     </span><span class="istickedoff">CJ.setSimulatorVerbosity verbosity sym</span>
<span class="lineno">  683 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  684 </span><span class="spaces">     </span><span class="istickedoff">--when (not (J.methodIsStatic meth)) $ do</span>
<span class="lineno">  685 </span><span class="spaces">     </span><span class="istickedoff">--  fail $ unlines [ &quot;Crucible can only extract static methods&quot; ]</span>
<span class="lineno">  686 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  687 </span><span class="spaces">     </span><span class="istickedoff">(CJ.JVMHandleInfo _ h) &lt;- getMethodHandle jc method</span>
<span class="lineno">  688 </span><span class="spaces">     </span><span class="istickedoff">regmap &lt;- prepareArgs (Crucible.handleArgTypes h) (map snd args)</span>
<span class="lineno">  689 </span><span class="spaces">     </span><span class="istickedoff">res &lt;-</span>
<span class="lineno">  690 </span><span class="spaces">       </span><span class="istickedoff">do let feats = pfs</span>
<span class="lineno">  691 </span><span class="spaces">          </span><span class="istickedoff">-- TODO: Use crucible-jvm's jvmSimContext here (instead of manually</span>
<span class="lineno">  692 </span><span class="spaces">          </span><span class="istickedoff">-- calling mkDelayedBindings/initSimContext), once</span>
<span class="lineno">  693 </span><span class="spaces">          </span><span class="istickedoff">-- https://github.com/GaloisInc/crucible/issues/1128 has been fixed</span>
<span class="lineno">  694 </span><span class="spaces">          </span><span class="istickedoff">-- upstream.</span>
<span class="lineno">  695 </span><span class="spaces">          </span><span class="istickedoff">let bindings = CJ.mkDelayedBindings jc verbosity</span>
<span class="lineno">  696 </span><span class="spaces">          </span><span class="istickedoff">let simctx = Crucible.initSimContext bak intrinsics halloc stdout</span>
<span class="lineno">  697 </span><span class="spaces">                         </span><span class="istickedoff">bindings <span class="nottickedoff">CJ.jvmExtensionImpl</span> SAWCruciblePersonality</span>
<span class="lineno">  698 </span><span class="spaces">          </span><span class="istickedoff">let simSt = Crucible.InitialState simctx globals Crucible.defaultAbortHandler (Crucible.handleReturnType h)</span>
<span class="lineno">  699 </span><span class="spaces">          </span><span class="istickedoff">let fnCall = Crucible.regValue &lt;$&gt; Crucible.callFnVal (Crucible.HandleFnVal h) regmap</span>
<span class="lineno">  700 </span><span class="spaces">          </span><span class="istickedoff">let overrideSim =</span>
<span class="lineno">  701 </span><span class="spaces">                </span><span class="istickedoff">do liftIO $ putStrLn &quot;registering standard overrides&quot;</span>
<span class="lineno">  702 </span><span class="spaces">                   </span><span class="istickedoff">_ &lt;- Strict.runStateT (mapM_ CJ.register_jvm_override CJ.stdOverrides) jc</span>
<span class="lineno">  703 </span><span class="spaces">                   </span><span class="istickedoff">liftIO $ putStrLn &quot;registering user-provided overrides&quot;</span>
<span class="lineno">  704 </span><span class="spaces">                   </span><span class="istickedoff">mapM_ (registerOverride opts cc <span class="nottickedoff">simctx</span> <span class="nottickedoff">top_loc</span> <span class="nottickedoff">mdMap</span>)</span>
<span class="lineno">  705 </span><span class="spaces">                           </span><span class="istickedoff">(groupOn <span class="nottickedoff">(view csMethodName)</span> (map (view MS.psSpec) lemmas))</span>
<span class="lineno">  706 </span><span class="spaces">                   </span><span class="istickedoff">liftIO $ putStrLn &quot;registering assumptions&quot;</span>
<span class="lineno">  707 </span><span class="spaces">                   </span><span class="istickedoff">liftIO $</span>
<span class="lineno">  708 </span><span class="spaces">                     </span><span class="istickedoff">for_ assumes $ \(Crucible.LabeledPred p (md, reason)) -&gt;</span>
<span class="lineno">  709 </span><span class="spaces">                       </span><span class="istickedoff">do expr &lt;- resolveSAWPred cc p</span>
<span class="lineno">  710 </span><span class="spaces">                          </span><span class="istickedoff">let <span class="nottickedoff">loc = MS.conditionLoc md</span></span>
<span class="lineno">  711 </span><span class="spaces">                          </span><span class="istickedoff">Crucible.addAssumption bak (Crucible.GenericAssumption <span class="nottickedoff">loc</span> <span class="nottickedoff">reason</span> expr)</span>
<span class="lineno">  712 </span><span class="spaces">                   </span><span class="istickedoff">liftIO $ putStrLn &quot;simulating function&quot;</span>
<span class="lineno">  713 </span><span class="spaces">                   </span><span class="istickedoff">fnCall</span>
<span class="lineno">  714 </span><span class="spaces">          </span><span class="istickedoff">Crucible.executeCrucible (map <span class="nottickedoff">Crucible.genericToExecutionFeature</span> feats)</span>
<span class="lineno">  715 </span><span class="spaces">            </span><span class="istickedoff">(simSt (Crucible.runOverrideSim (Crucible.handleReturnType h) overrideSim))</span>
<span class="lineno">  716 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  717 </span><span class="spaces">     </span><span class="istickedoff">case res of</span>
<span class="lineno">  718 </span><span class="spaces">       </span><span class="istickedoff">Crucible.FinishedResult _ pr -&gt;</span>
<span class="lineno">  719 </span><span class="spaces">         </span><span class="istickedoff">do Crucible.GlobalPair retval globals1 &lt;- getGlobalPair <span class="nottickedoff">opts</span> pr</span>
<span class="lineno">  720 </span><span class="spaces">            </span><span class="istickedoff">let ret_ty = mspec ^. MS.csRet</span>
<span class="lineno">  721 </span><span class="spaces">            </span><span class="istickedoff">retval' &lt;-</span>
<span class="lineno">  722 </span><span class="spaces">              </span><span class="istickedoff">case ret_ty of</span>
<span class="lineno">  723 </span><span class="spaces">                </span><span class="istickedoff">Nothing -&gt; return Nothing</span>
<span class="lineno">  724 </span><span class="spaces">                </span><span class="istickedoff">Just ret_mt -&gt;</span>
<span class="lineno">  725 </span><span class="spaces">                  </span><span class="istickedoff">case retval of</span>
<span class="lineno">  726 </span><span class="spaces">                    </span><span class="istickedoff">Crucible.RegEntry ty val -&gt;</span>
<span class="lineno">  727 </span><span class="spaces">                      </span><span class="istickedoff">case decodeJVMVal ret_mt (Crucible.AnyValue ty val) of</span>
<span class="lineno">  728 </span><span class="spaces">                        </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">error $ &quot;FIXME: Unsupported return type: &quot; ++ show ret_ty</span></span>
<span class="lineno">  729 </span><span class="spaces">                        </span><span class="istickedoff">Just v -&gt; return (Just (<span class="nottickedoff">ret_mt</span>, v))</span>
<span class="lineno">  730 </span><span class="spaces">            </span><span class="istickedoff">return (retval', globals1)</span>
<span class="lineno">  731 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  732 </span><span class="spaces">       </span><span class="istickedoff">Crucible.AbortedResult _ ar -&gt;</span>
<span class="lineno">  733 </span><span class="spaces">         </span><span class="istickedoff">do let resultDoc = ppJVMAbortedResult <span class="nottickedoff">cc</span> ar</span>
<span class="lineno">  734 </span><span class="spaces">            </span><span class="istickedoff">fail $ unlines [ &quot;Symbolic execution failed.&quot;</span>
<span class="lineno">  735 </span><span class="spaces">                           </span><span class="istickedoff">, show resultDoc</span>
<span class="lineno">  736 </span><span class="spaces">                           </span><span class="istickedoff">]</span>
<span class="lineno">  737 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  738 </span><span class="spaces">       </span><span class="istickedoff">Crucible.TimeoutResult _cxt -&gt; <span class="nottickedoff">fail &quot;Symbolic execution timed out.&quot;</span></span>
<span class="lineno">  739 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  740 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  741 </span><span class="spaces">    </span><span class="istickedoff">prepareArg :: forall tp. Crucible.TypeRepr tp -&gt; JVMVal -&gt; IO (Crucible.RegValue Sym tp)</span>
<span class="lineno">  742 </span><span class="spaces">    </span><span class="istickedoff">prepareArg ty v =</span>
<span class="lineno">  743 </span><span class="spaces">      </span><span class="istickedoff">case v of</span>
<span class="lineno">  744 </span><span class="spaces">        </span><span class="istickedoff">RVal x -&gt; case testEquality ty CJ.refRepr  of Just Refl -&gt; return x; _ -&gt; <span class="nottickedoff">fail &quot;argument type mismatch&quot;</span></span>
<span class="lineno">  745 </span><span class="spaces">        </span><span class="istickedoff">IVal x -&gt; case testEquality ty CJ.intRepr  of Just Refl -&gt; return x; _ -&gt; <span class="nottickedoff">fail &quot;argument type mismatch&quot;</span></span>
<span class="lineno">  746 </span><span class="spaces">        </span><span class="istickedoff">LVal x -&gt; case testEquality ty CJ.longRepr of Just Refl -&gt; return x; _ -&gt; <span class="nottickedoff">fail &quot;argument type mismatch&quot;</span></span>
<span class="lineno">  747 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  748 </span><span class="spaces">    </span><span class="istickedoff">prepareArgs ::</span>
<span class="lineno">  749 </span><span class="spaces">      </span><span class="istickedoff">forall xs.</span>
<span class="lineno">  750 </span><span class="spaces">      </span><span class="istickedoff">Ctx.Assignment Crucible.TypeRepr xs -&gt;</span>
<span class="lineno">  751 </span><span class="spaces">      </span><span class="istickedoff">[JVMVal] -&gt;</span>
<span class="lineno">  752 </span><span class="spaces">      </span><span class="istickedoff">IO (Crucible.RegMap Sym xs)</span>
<span class="lineno">  753 </span><span class="spaces">    </span><span class="istickedoff">prepareArgs ctx xs | <span class="tickonlyfalse">length xs /= Ctx.sizeInt (Ctx.size ctx)</span> =</span>
<span class="lineno">  754 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">fail $ &quot;Wrong number of arguments: found &quot; ++ show xs ++ &quot;, expected &quot; ++ show ctx</span> --(Ctx.sizeInt (Ctx.size ctx))</span>
<span class="lineno">  755 </span><span class="spaces">    </span><span class="istickedoff">prepareArgs ctx xs =</span>
<span class="lineno">  756 </span><span class="spaces">      </span><span class="istickedoff">Crucible.RegMap &lt;$&gt;</span>
<span class="lineno">  757 </span><span class="spaces">      </span><span class="istickedoff">Ctx.traverseWithIndex (\idx tr -&gt;</span>
<span class="lineno">  758 </span><span class="spaces">        </span><span class="istickedoff">do v &lt;- prepareArg tr (xs !! Ctx.indexVal idx)</span>
<span class="lineno">  759 </span><span class="spaces">           </span><span class="istickedoff">return (Crucible.RegEntry tr v))</span>
<span class="lineno">  760 </span><span class="spaces">      </span><span class="istickedoff">ctx</span></span>
<span class="lineno">  761 </span>
<span class="lineno">  762 </span>--------------------------------------------------------------------------------
<span class="lineno">  763 </span>
<span class="lineno">  764 </span>verifyPoststate ::
<span class="lineno">  765 </span>  JVMCrucibleContext                {- ^ crucible context                             -} -&gt;
<span class="lineno">  766 </span>  MethodSpec                        {- ^ specification                                -} -&gt;
<span class="lineno">  767 </span>  Map AllocIndex JVMRefVal          {- ^ allocation substitution                      -} -&gt;
<span class="lineno">  768 </span>  Crucible.SymGlobalState Sym       {- ^ global variables                             -} -&gt;
<span class="lineno">  769 </span>  Maybe (J.Type, JVMVal)            {- ^ optional return value                        -} -&gt;
<span class="lineno">  770 </span>  IORef MetadataMap {- ^ metadata map -} -&gt;
<span class="lineno">  771 </span>  TopLevel [(String, MS.ConditionMetadata, Term)] {- ^ generated labels and verification conditions -}
<span class="lineno">  772 </span><span class="decl"><span class="istickedoff">verifyPoststate cc mspec env0 globals ret mdMap =</span>
<span class="lineno">  773 </span><span class="spaces">  </span><span class="istickedoff">jccWithBackend cc $ \bak -&gt;</span>
<span class="lineno">  774 </span><span class="spaces">  </span><span class="istickedoff">do opts &lt;- getOptions</span>
<span class="lineno">  775 </span><span class="spaces">     </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  776 </span><span class="spaces">     </span><span class="istickedoff">poststateLoc &lt;- SS.toW4Loc &quot;_SAW_JVM_verifyPoststate&quot; &lt;$&gt; getPosition</span>
<span class="lineno">  777 </span><span class="spaces">     </span><span class="istickedoff">io $ W4.setCurrentProgramLoc sym poststateLoc</span>
<span class="lineno">  778 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  779 </span><span class="spaces">     </span><span class="istickedoff">-- This discards all the obligations generated during</span>
<span class="lineno">  780 </span><span class="spaces">     </span><span class="istickedoff">-- symbolic execution itself, i.e., which are not directly</span>
<span class="lineno">  781 </span><span class="spaces">     </span><span class="istickedoff">-- generated from specification postconditions. This</span>
<span class="lineno">  782 </span><span class="spaces">     </span><span class="istickedoff">-- is, in general, unsound.</span>
<span class="lineno">  783 </span><span class="spaces">     </span><span class="istickedoff">skipSafetyProofs &lt;- gets rwSkipSafetyProofs</span>
<span class="lineno">  784 </span><span class="spaces">     </span><span class="istickedoff">when skipSafetyProofs <span class="nottickedoff">(io (Crucible.clearProofObligations bak))</span></span>
<span class="lineno">  785 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  786 </span><span class="spaces">     </span><span class="istickedoff">let ecs0 = IntMap.fromList</span>
<span class="lineno">  787 </span><span class="spaces">           </span><span class="istickedoff">[ (ecVarIndex ec, ec)</span>
<span class="lineno">  788 </span><span class="spaces">           </span><span class="istickedoff">| tt &lt;- mspec ^. MS.csPreState . MS.csFreshVars</span>
<span class="lineno">  789 </span><span class="spaces">           </span><span class="istickedoff">, let ec = EC (tvName tt) (tvType tt) ]</span>
<span class="lineno">  790 </span><span class="spaces">     </span><span class="istickedoff">terms0 &lt;- io $ traverse (scVariable sc) ecs0</span>
<span class="lineno">  791 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  792 </span><span class="spaces">     </span><span class="istickedoff">let initialFree = Set.fromList (map <span class="nottickedoff">(vnIndex . tvName)</span></span>
<span class="lineno">  793 </span><span class="spaces">                                    </span><span class="istickedoff">(view (MS.csPostState . MS.csFreshVars) mspec))</span>
<span class="lineno">  794 </span><span class="spaces">     </span><span class="istickedoff">matchPost &lt;- io $</span>
<span class="lineno">  795 </span><span class="spaces">          </span><span class="istickedoff">runOverrideMatcher sym globals env0 terms0 initialFree <span class="nottickedoff">poststateLoc</span> $</span>
<span class="lineno">  796 </span><span class="spaces">           </span><span class="istickedoff">do matchResult <span class="nottickedoff">opts</span> sc</span>
<span class="lineno">  797 </span><span class="spaces">              </span><span class="istickedoff">learnCond <span class="nottickedoff">opts</span> sc cc mspec <span class="nottickedoff">PostState</span> (mspec ^. MS.csPostState)</span>
<span class="lineno">  798 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  799 </span><span class="spaces">     </span><span class="istickedoff">st &lt;- case matchPost of</span>
<span class="lineno">  800 </span><span class="spaces">             </span><span class="istickedoff">Left err      -&gt; <span class="nottickedoff">fail (show err)</span></span>
<span class="lineno">  801 </span><span class="spaces">             </span><span class="istickedoff">Right (_, st) -&gt; return st</span>
<span class="lineno">  802 </span><span class="spaces">     </span><span class="istickedoff">io $ forM_ (view osAsserts st) $ \(md, Crucible.LabeledPred p r) -&gt;</span>
<span class="lineno">  803 </span><span class="spaces">       </span><span class="istickedoff">do (ann,p') &lt;- W4.annotateTerm sym p</span>
<span class="lineno">  804 </span><span class="spaces">          </span><span class="istickedoff">modifyIORef mdMap <span class="nottickedoff">(Map.insert ann md)</span></span>
<span class="lineno">  805 </span><span class="spaces">          </span><span class="istickedoff">Crucible.addAssertion bak (Crucible.LabeledPred p' r)</span>
<span class="lineno">  806 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  807 </span><span class="spaces">     </span><span class="istickedoff">finalMdMap &lt;- io $ readIORef mdMap</span>
<span class="lineno">  808 </span><span class="spaces">     </span><span class="istickedoff">obligations &lt;- io $ Crucible.getProofObligations bak</span>
<span class="lineno">  809 </span><span class="spaces">     </span><span class="istickedoff">io $ Crucible.clearProofObligations bak</span>
<span class="lineno">  810 </span><span class="spaces">     </span><span class="istickedoff">io $ mapM (verifyObligation sc <span class="nottickedoff">finalMdMap</span>) (maybe [] Crucible.goalsToList obligations)</span>
<span class="lineno">  811 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  812 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  813 </span><span class="spaces">    </span><span class="istickedoff">sym = cc^.jccSym</span>
<span class="lineno">  814 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  815 </span><span class="spaces">    </span><span class="istickedoff">verifyObligation sc finalMdMap</span>
<span class="lineno">  816 </span><span class="spaces">      </span><span class="istickedoff">(Crucible.ProofGoal hyps (Crucible.LabeledPred concl (Crucible.SimError loc err))) =</span>
<span class="lineno">  817 </span><span class="spaces">      </span><span class="istickedoff">do st         &lt;- sawCoreState sym</span>
<span class="lineno">  818 </span><span class="spaces">         </span><span class="istickedoff">hypTerm &lt;- toSC <span class="nottickedoff">sym</span> st =&lt;&lt; Crucible.assumptionsPred sym hyps</span>
<span class="lineno">  819 </span><span class="spaces">         </span><span class="istickedoff">conclTerm  &lt;- toSC <span class="nottickedoff">sym</span> st concl</span>
<span class="lineno">  820 </span><span class="spaces">         </span><span class="istickedoff">obligation &lt;- scImplies sc hypTerm conclTerm</span>
<span class="lineno">  821 </span><span class="spaces">         </span><span class="istickedoff">let <span class="nottickedoff">defaultMd = MS.ConditionMetadata</span></span>
<span class="lineno">  822 </span><span class="spaces">                         </span><span class="istickedoff"><span class="nottickedoff">{ MS.conditionLoc = loc</span></span>
<span class="lineno">  823 </span><span class="spaces">                         </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionTags = mempty</span></span>
<span class="lineno">  824 </span><span class="spaces">                         </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionType = &quot;safety assertion&quot;</span></span>
<span class="lineno">  825 </span><span class="spaces">                         </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionContext = &quot;&quot;</span></span>
<span class="lineno">  826 </span><span class="spaces">                         </span><span class="istickedoff"><span class="nottickedoff">}</span></span>
<span class="lineno">  827 </span><span class="spaces">         </span><span class="istickedoff">let <span class="nottickedoff">md = fromMaybe defaultMd $</span></span>
<span class="lineno">  828 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">do ann &lt;- W4.getAnnotation sym concl</span></span>
<span class="lineno">  829 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">Map.lookup ann finalMdMap</span></span>
<span class="lineno">  830 </span><span class="spaces">         </span><span class="istickedoff">return (Crucible.simErrorReasonMsg err, <span class="nottickedoff">md</span>, obligation)</span>
<span class="lineno">  831 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  832 </span><span class="spaces">    </span><span class="istickedoff">matchResult opts sc =</span>
<span class="lineno">  833 </span><span class="spaces">      </span><span class="istickedoff">case (ret, mspec ^. MS.csRetValue) of</span>
<span class="lineno">  834 </span><span class="spaces">        </span><span class="istickedoff">(Just (rty,r), Just expect) -&gt;</span>
<span class="lineno">  835 </span><span class="spaces">            </span><span class="istickedoff">let md = MS.ConditionMetadata</span>
<span class="lineno">  836 </span><span class="spaces">                     </span><span class="istickedoff">{ MS.conditionLoc = mspec ^. MS.csLoc</span>
<span class="lineno">  837 </span><span class="spaces">                     </span><span class="istickedoff">, MS.conditionTags = <span class="nottickedoff">mempty</span></span>
<span class="lineno">  838 </span><span class="spaces">                     </span><span class="istickedoff">, MS.conditionType = <span class="nottickedoff">&quot;return value matching&quot;</span></span>
<span class="lineno">  839 </span><span class="spaces">                     </span><span class="istickedoff">, MS.conditionContext = <span class="nottickedoff">&quot;&quot;</span></span>
<span class="lineno">  840 </span><span class="spaces">                     </span><span class="istickedoff">} in</span>
<span class="lineno">  841 </span><span class="spaces">            </span><span class="istickedoff">matchArg <span class="nottickedoff">opts</span> sc cc <span class="nottickedoff">mspec</span> PostState md r <span class="nottickedoff">rty</span> expect</span>
<span class="lineno">  842 </span><span class="spaces">        </span><span class="istickedoff">(Nothing     , Just _ )     -&gt; <span class="nottickedoff">fail &quot;verifyPoststate: unexpected jvm_return specification&quot;</span></span>
<span class="lineno">  843 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; return <span class="nottickedoff">()</span></span></span>
<span class="lineno">  844 </span>
<span class="lineno">  845 </span>--------------------------------------------------------------------------------
<span class="lineno">  846 </span>
<span class="lineno">  847 </span>setupCrucibleContext :: J.Class -&gt; TopLevel JVMCrucibleContext
<span class="lineno">  848 </span><span class="decl"><span class="istickedoff">setupCrucibleContext jclass =</span>
<span class="lineno">  849 </span><span class="spaces">  </span><span class="istickedoff">do halloc &lt;- getHandleAlloc</span>
<span class="lineno">  850 </span><span class="spaces">     </span><span class="istickedoff">jc &lt;- getJVMTrans</span>
<span class="lineno">  851 </span><span class="spaces">     </span><span class="istickedoff">cb &lt;- getJavaCodebase</span>
<span class="lineno">  852 </span><span class="spaces">     </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  853 </span><span class="spaces">     </span><span class="istickedoff">pathSatSolver &lt;- gets rwPathSatSolver</span>
<span class="lineno">  854 </span><span class="spaces">     </span><span class="istickedoff">sym &lt;- io $ newSAWCoreExprBuilder sc False</span>
<span class="lineno">  855 </span><span class="spaces">     </span><span class="istickedoff">bak &lt;- io $ newSAWCoreBackend pathSatSolver sym</span>
<span class="lineno">  856 </span><span class="spaces">     </span><span class="istickedoff">opts &lt;- getOptions</span>
<span class="lineno">  857 </span><span class="spaces">     </span><span class="istickedoff">io $ CJ.setSimulatorVerbosity <span class="nottickedoff">(simVerbose opts)</span> sym</span>
<span class="lineno">  858 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  859 </span><span class="spaces">     </span><span class="istickedoff">-- TODO! there's a lot of options setup we need to replicate</span>
<span class="lineno">  860 </span><span class="spaces">     </span><span class="istickedoff">--  from SAWCentral.Crucible.LLVM.Builtins</span>
<span class="lineno">  861 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  862 </span><span class="spaces">     </span><span class="istickedoff">return JVMCrucibleContext { _jccJVMClass = jclass</span>
<span class="lineno">  863 </span><span class="spaces">                               </span><span class="istickedoff">, _jccCodebase = cb</span>
<span class="lineno">  864 </span><span class="spaces">                               </span><span class="istickedoff">, _jccBackend = bak</span>
<span class="lineno">  865 </span><span class="spaces">                               </span><span class="istickedoff">, _jccJVMContext = jc</span>
<span class="lineno">  866 </span><span class="spaces">                               </span><span class="istickedoff">, _jccHandleAllocator = halloc</span>
<span class="lineno">  867 </span><span class="spaces">                               </span><span class="istickedoff">, _jccUninterp = mempty</span>
<span class="lineno">  868 </span><span class="spaces">                               </span><span class="istickedoff">}</span></span>
<span class="lineno">  869 </span>
<span class="lineno">  870 </span>--------------------------------------------------------------------------------
<span class="lineno">  871 </span>
<span class="lineno">  872 </span>-- | Construct the dynamic class table, and also declare all static
<span class="lineno">  873 </span>-- fields (leaving them with uninitialized contents).
<span class="lineno">  874 </span>setupGlobalState :: Sym -&gt; CJ.JVMContext -&gt; IO (Crucible.SymGlobalState Sym)
<span class="lineno">  875 </span><span class="decl"><span class="istickedoff">setupGlobalState sym jc =</span>
<span class="lineno">  876 </span><span class="spaces">  </span><span class="istickedoff">do classTab &lt;- setupDynamicClassTable sym jc</span>
<span class="lineno">  877 </span><span class="spaces">     </span><span class="istickedoff">let classTabVar = CJ.dynamicClassTable jc</span>
<span class="lineno">  878 </span><span class="spaces">     </span><span class="istickedoff">let globals0 = Crucible.insertGlobal classTabVar classTab Crucible.emptyGlobals</span>
<span class="lineno">  879 </span><span class="spaces">     </span><span class="istickedoff">let writable = W4.falsePred sym -- static fields default to read-only</span>
<span class="lineno">  880 </span><span class="spaces">     </span><span class="istickedoff">let declareGlobal info =</span>
<span class="lineno">  881 </span><span class="spaces">           </span><span class="istickedoff">Crucible.insertGlobal (CJ.staticFieldWritable info) writable .</span>
<span class="lineno">  882 </span><span class="spaces">           </span><span class="istickedoff">Crucible.insertGlobal (CJ.staticFieldValue info) CJ.unassignedJVMValue</span>
<span class="lineno">  883 </span><span class="spaces">     </span><span class="istickedoff">return $ foldr declareGlobal globals0 (Map.elems (CJ.staticFields jc))</span></span>
<span class="lineno">  884 </span>
<span class="lineno">  885 </span>setupDynamicClassTable :: Sym -&gt; CJ.JVMContext -&gt; IO (Crucible.RegValue Sym CJ.JVMClassTableType)
<span class="lineno">  886 </span><span class="decl"><span class="istickedoff">setupDynamicClassTable sym jc = foldM addClass Map.empty (Map.assocs (CJ.classTable jc))</span>
<span class="lineno">  887 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  888 </span><span class="spaces">    </span><span class="istickedoff">addClass ::</span>
<span class="lineno">  889 </span><span class="spaces">      </span><span class="istickedoff">Crucible.RegValue Sym CJ.JVMClassTableType -&gt;</span>
<span class="lineno">  890 </span><span class="spaces">      </span><span class="istickedoff">(J.ClassName, J.Class) -&gt;</span>
<span class="lineno">  891 </span><span class="spaces">      </span><span class="istickedoff">IO (Crucible.RegValue Sym CJ.JVMClassTableType)</span>
<span class="lineno">  892 </span><span class="spaces">    </span><span class="istickedoff">addClass tab (cname, cls) =</span>
<span class="lineno">  893 </span><span class="spaces">      </span><span class="istickedoff">do cls' &lt;- setupClass cls</span>
<span class="lineno">  894 </span><span class="spaces">         </span><span class="istickedoff">return $ Map.insert (CJ.classNameText cname) (W4.justPartExpr sym cls') tab</span>
<span class="lineno">  895 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  896 </span><span class="spaces">    </span><span class="istickedoff">setupClass :: J.Class -&gt; IO (Crucible.RegValue Sym CJ.JVMClassType)</span>
<span class="lineno">  897 </span><span class="spaces">    </span><span class="istickedoff">setupClass cls =</span>
<span class="lineno">  898 </span><span class="spaces">      </span><span class="istickedoff">do let cname = J.className cls</span>
<span class="lineno">  899 </span><span class="spaces">         </span><span class="istickedoff">name &lt;- W4.stringLit sym (W4S.UnicodeLiteral $ CJ.classNameText (J.className cls))</span>
<span class="lineno">  900 </span><span class="spaces">         </span><span class="istickedoff">-- Set every class to status 2 (initialized). In the absence</span>
<span class="lineno">  901 </span><span class="spaces">         </span><span class="istickedoff">-- of JVMSetup commands for specifying initialization status,</span>
<span class="lineno">  902 </span><span class="spaces">         </span><span class="istickedoff">-- this will allow verifications to proceed without the</span>
<span class="lineno">  903 </span><span class="spaces">         </span><span class="istickedoff">-- interference of any static initializers.</span>
<span class="lineno">  904 </span><span class="spaces">         </span><span class="istickedoff">status &lt;- W4.bvLit sym knownRepr (BV.mkBV knownRepr 2)</span>
<span class="lineno">  905 </span><span class="spaces">         </span><span class="istickedoff">super &lt;-</span>
<span class="lineno">  906 </span><span class="spaces">           </span><span class="istickedoff">case J.superClass cls of</span>
<span class="lineno">  907 </span><span class="spaces">             </span><span class="istickedoff">Nothing -&gt; return W4.Unassigned</span>
<span class="lineno">  908 </span><span class="spaces">             </span><span class="istickedoff">Just cname' -&gt;</span>
<span class="lineno">  909 </span><span class="spaces">               </span><span class="istickedoff">case Map.lookup cname' (CJ.classTable jc) of</span>
<span class="lineno">  910 </span><span class="spaces">                 </span><span class="istickedoff">Nothing -&gt; return <span class="nottickedoff">W4.Unassigned</span> -- this should never happen</span>
<span class="lineno">  911 </span><span class="spaces">                 </span><span class="istickedoff">Just cls' -&gt; W4.justPartExpr sym &lt;$&gt; setupClass cls'</span>
<span class="lineno">  912 </span><span class="spaces">         </span><span class="istickedoff">let methods = foldr (addMethod cname) Map.empty (J.classMethods cls)</span>
<span class="lineno">  913 </span><span class="spaces">         </span><span class="istickedoff">interfaces &lt;- V.fromList &lt;$&gt; traverse (W4.stringLit sym . W4S.UnicodeLiteral . CJ.classNameText) (J.classInterfaces cls)</span>
<span class="lineno">  914 </span><span class="spaces">         </span><span class="istickedoff">return $</span>
<span class="lineno">  915 </span><span class="spaces">           </span><span class="istickedoff">Crucible.RolledType $</span>
<span class="lineno">  916 </span><span class="spaces">           </span><span class="istickedoff">Ctx.Empty</span>
<span class="lineno">  917 </span><span class="spaces">           </span><span class="istickedoff">Ctx.:&gt; Crucible.RV name</span>
<span class="lineno">  918 </span><span class="spaces">           </span><span class="istickedoff">Ctx.:&gt; Crucible.RV status</span>
<span class="lineno">  919 </span><span class="spaces">           </span><span class="istickedoff">Ctx.:&gt; Crucible.RV super</span>
<span class="lineno">  920 </span><span class="spaces">           </span><span class="istickedoff">Ctx.:&gt; Crucible.RV methods</span>
<span class="lineno">  921 </span><span class="spaces">           </span><span class="istickedoff">Ctx.:&gt; Crucible.RV interfaces</span>
<span class="lineno">  922 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  923 </span><span class="spaces">    </span><span class="istickedoff">addMethod ::</span>
<span class="lineno">  924 </span><span class="spaces">      </span><span class="istickedoff">J.ClassName -&gt;</span>
<span class="lineno">  925 </span><span class="spaces">      </span><span class="istickedoff">J.Method -&gt;</span>
<span class="lineno">  926 </span><span class="spaces">      </span><span class="istickedoff">Crucible.RegValue Sym CJ.JVMMethodTableType -&gt;</span>
<span class="lineno">  927 </span><span class="spaces">      </span><span class="istickedoff">Crucible.RegValue Sym CJ.JVMMethodTableType</span>
<span class="lineno">  928 </span><span class="spaces">    </span><span class="istickedoff">addMethod cname m tab =</span>
<span class="lineno">  929 </span><span class="spaces">      </span><span class="istickedoff">case Map.lookup (cname, J.methodKey m) (CJ.methodHandles jc) of</span>
<span class="lineno">  930 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">tab</span> -- should never happen</span>
<span class="lineno">  931 </span><span class="spaces">        </span><span class="istickedoff">Just (CJ.JVMHandleInfo key handle) -&gt;</span>
<span class="lineno">  932 </span><span class="spaces">          </span><span class="istickedoff">Map.insert (CJ.methodKeyText key) (W4.justPartExpr sym v) tab</span>
<span class="lineno">  933 </span><span class="spaces">          </span><span class="istickedoff">where v = Crucible.AnyValue (Crucible.handleType handle) (Crucible.HandleFnVal handle)</span></span>
<span class="lineno">  934 </span>
<span class="lineno">  935 </span>--------------------------------------------------------------------------------
<span class="lineno">  936 </span>-- Setup builtins
<span class="lineno">  937 </span>
<span class="lineno">  938 </span>data JVMSetupError
<span class="lineno">  939 </span>  = JVMFreshVarInvalidType JavaType
<span class="lineno">  940 </span>  | JVMFieldNonReference SetupValue Text
<span class="lineno">  941 </span>  | JVMFieldMultiple AllocIndex J.FieldId
<span class="lineno">  942 </span>  | JVMFieldFailure String -- TODO: switch to a more structured type
<span class="lineno">  943 </span>  | JVMFieldTypeMismatch J.FieldId J.Type
<span class="lineno">  944 </span>  | JVMFieldModifyPrestate AllocIndex J.FieldId
<span class="lineno">  945 </span>  | JVMStaticMultiple J.FieldId
<span class="lineno">  946 </span>  | JVMStaticFailure String -- TODO: switch to a more structured type
<span class="lineno">  947 </span>  | JVMStaticTypeMismatch J.FieldId J.Type
<span class="lineno">  948 </span>  | JVMStaticModifyPrestate J.FieldId
<span class="lineno">  949 </span>  | JVMElemNonReference SetupValue Int
<span class="lineno">  950 </span>  | JVMElemNonArray J.Type
<span class="lineno">  951 </span>  | JVMElemInvalidIndex J.Type Int Int -- element type, length, index
<span class="lineno">  952 </span>  | JVMElemTypeMismatch Int J.Type J.Type -- index, expected, found
<span class="lineno">  953 </span>  | JVMElemMultiple AllocIndex Int -- reference and array index
<span class="lineno">  954 </span>  | JVMElemModifyPrestate AllocIndex Int
<span class="lineno">  955 </span>  | JVMArrayNonReference SetupValue
<span class="lineno">  956 </span>  | JVMArrayTypeMismatch Int J.Type Cryptol.Schema
<span class="lineno">  957 </span>  | JVMArrayMultiple AllocIndex
<span class="lineno">  958 </span>  | JVMArrayModifyPrestate AllocIndex
<span class="lineno">  959 </span>  | JVMArgTypeMismatch Int J.Type J.Type -- argument position, expected, found
<span class="lineno">  960 </span>  | JVMArgNumberWrong Int Int -- number expected, number found
<span class="lineno">  961 </span>  | JVMReturnUnexpected J.Type -- found
<span class="lineno">  962 </span>  | JVMReturnTypeMismatch J.Type J.Type -- expected, found
<span class="lineno">  963 </span>  | JVMNonValueType TypedTermType
<span class="lineno">  964 </span>
<span class="lineno">  965 </span>instance <span class="decl"><span class="nottickedoff">X.Exception JVMSetupError</span></span> where
<span class="lineno">  966 </span>  <span class="decl"><span class="istickedoff">toException = topLevelExceptionToException</span></span>
<span class="lineno">  967 </span>  <span class="decl"><span class="nottickedoff">fromException = topLevelExceptionFromException</span></span>
<span class="lineno">  968 </span>
<span class="lineno">  969 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show JVMSetupError</span></span></span></span> where
<span class="lineno">  970 </span>  <span class="decl"><span class="istickedoff">show err =</span>
<span class="lineno">  971 </span><span class="spaces">    </span><span class="istickedoff">case err of</span>
<span class="lineno">  972 </span><span class="spaces">      </span><span class="istickedoff">JVMFreshVarInvalidType jty -&gt;</span>
<span class="lineno">  973 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">&quot;jvm_fresh_var: Invalid type: &quot; ++ show jty</span></span>
<span class="lineno">  974 </span><span class="spaces">      </span><span class="istickedoff">JVMFieldNonReference ptr fname -&gt;</span>
<span class="lineno">  975 </span><span class="spaces">        </span><span class="istickedoff">unlines</span>
<span class="lineno">  976 </span><span class="spaces">        </span><span class="istickedoff">[ &quot;jvm_field_is: Left-hand side is not a valid object reference&quot;</span>
<span class="lineno">  977 </span><span class="spaces">        </span><span class="istickedoff">, &quot;Left-hand side: &quot; ++ show (MS.ppSetupValue ptr)</span>
<span class="lineno">  978 </span><span class="spaces">        </span><span class="istickedoff">, &quot;Field name: &quot; ++ Text.unpack fname</span>
<span class="lineno">  979 </span><span class="spaces">        </span><span class="istickedoff">]</span>
<span class="lineno">  980 </span><span class="spaces">      </span><span class="istickedoff">JVMFieldMultiple _ptr fid -&gt;</span>
<span class="lineno">  981 </span><span class="spaces">        </span><span class="istickedoff">&quot;jvm_field_is: Multiple specifications for the same instance field (&quot; ++ J.fieldIdName fid ++ &quot;)&quot;</span>
<span class="lineno">  982 </span><span class="spaces">      </span><span class="istickedoff">JVMFieldFailure msg -&gt;</span>
<span class="lineno">  983 </span><span class="spaces">        </span><span class="istickedoff">&quot;jvm_field_is: JVM field resolution failed:\n&quot; ++ msg</span>
<span class="lineno">  984 </span><span class="spaces">      </span><span class="istickedoff">JVMFieldTypeMismatch fid found -&gt;</span>
<span class="lineno">  985 </span><span class="spaces">         </span><span class="istickedoff">-- FIXME: use a pretty printing function for J.Type instead of show</span>
<span class="lineno">  986 </span><span class="spaces">        </span><span class="istickedoff">unlines</span>
<span class="lineno">  987 </span><span class="spaces">        </span><span class="istickedoff">[ &quot;jvm_field_is: Incompatible types for field &quot; ++ show (J.fieldIdName fid)</span>
<span class="lineno">  988 </span><span class="spaces">        </span><span class="istickedoff">, &quot;Expected type: &quot; ++ show (J.fieldIdType fid)</span>
<span class="lineno">  989 </span><span class="spaces">        </span><span class="istickedoff">, &quot;Given type: &quot; ++ show found</span>
<span class="lineno">  990 </span><span class="spaces">        </span><span class="istickedoff">]</span>
<span class="lineno">  991 </span><span class="spaces">      </span><span class="istickedoff">JVMFieldModifyPrestate _ptr fid -&gt;</span>
<span class="lineno">  992 </span><span class="spaces">        </span><span class="istickedoff">&quot;jvm_modifies_field: Invalid use before jvm_execute_func (&quot; ++ J.fieldIdName fid ++ &quot;)&quot;</span>
<span class="lineno">  993 </span><span class="spaces">      </span><span class="istickedoff">JVMStaticMultiple fid -&gt;</span>
<span class="lineno">  994 </span><span class="spaces">        </span><span class="istickedoff">&quot;jvm_static_field_is: Multiple specifications for the same static field (&quot; ++ J.fieldIdName fid ++ &quot;)&quot;</span>
<span class="lineno">  995 </span><span class="spaces">      </span><span class="istickedoff">JVMStaticFailure msg -&gt;</span>
<span class="lineno">  996 </span><span class="spaces">        </span><span class="istickedoff">&quot;jvm_static_field_is: JVM field resolution failed:\n&quot; ++ msg</span>
<span class="lineno">  997 </span><span class="spaces">      </span><span class="istickedoff">JVMStaticTypeMismatch fid found -&gt;</span>
<span class="lineno">  998 </span><span class="spaces">         </span><span class="istickedoff">-- FIXME: use a pretty printing function for J.Type instead of show</span>
<span class="lineno">  999 </span><span class="spaces">        </span><span class="istickedoff">unlines</span>
<span class="lineno"> 1000 </span><span class="spaces">        </span><span class="istickedoff">[ &quot;jvm_static_field_is: Incompatible types for field &quot; ++ show (J.fieldIdName fid)</span>
<span class="lineno"> 1001 </span><span class="spaces">        </span><span class="istickedoff">, &quot;Expected type: &quot; ++ show (J.fieldIdType fid)</span>
<span class="lineno"> 1002 </span><span class="spaces">        </span><span class="istickedoff">, &quot;Given type: &quot; ++ show found</span>
<span class="lineno"> 1003 </span><span class="spaces">        </span><span class="istickedoff">]</span>
<span class="lineno"> 1004 </span><span class="spaces">      </span><span class="istickedoff">JVMStaticModifyPrestate fid -&gt;</span>
<span class="lineno"> 1005 </span><span class="spaces">        </span><span class="istickedoff">&quot;jvm_modifies_static_field: Invalid use before jvm_execute_func (&quot; ++ J.fieldIdName fid ++ &quot;)&quot;</span>
<span class="lineno"> 1006 </span><span class="spaces">      </span><span class="istickedoff">JVMElemNonReference ptr idx -&gt;</span>
<span class="lineno"> 1007 </span><span class="spaces">        </span><span class="istickedoff">unlines</span>
<span class="lineno"> 1008 </span><span class="spaces">        </span><span class="istickedoff">[ &quot;jvm_elem_is: Left-hand side is not a valid object reference&quot;</span>
<span class="lineno"> 1009 </span><span class="spaces">        </span><span class="istickedoff">, &quot;Left-hand side: &quot; ++ show (MS.ppSetupValue ptr)</span>
<span class="lineno"> 1010 </span><span class="spaces">        </span><span class="istickedoff">, &quot;Index: &quot; ++ show idx</span>
<span class="lineno"> 1011 </span><span class="spaces">        </span><span class="istickedoff">]</span>
<span class="lineno"> 1012 </span><span class="spaces">      </span><span class="istickedoff">JVMElemNonArray jty -&gt;</span>
<span class="lineno"> 1013 </span><span class="spaces">        </span><span class="istickedoff">&quot;jvm_elem_is: Not an array type: &quot; ++ show jty</span>
<span class="lineno"> 1014 </span><span class="spaces">      </span><span class="istickedoff">JVMElemInvalidIndex ty len idx -&gt;</span>
<span class="lineno"> 1015 </span><span class="spaces">        </span><span class="istickedoff">unlines</span>
<span class="lineno"> 1016 </span><span class="spaces">        </span><span class="istickedoff">[ &quot;jvm_elem_is: Array index out of bounds&quot;</span>
<span class="lineno"> 1017 </span><span class="spaces">        </span><span class="istickedoff">, &quot;Element type: &quot; ++ show ty</span>
<span class="lineno"> 1018 </span><span class="spaces">        </span><span class="istickedoff">, &quot;Array length: &quot; ++ show len</span>
<span class="lineno"> 1019 </span><span class="spaces">        </span><span class="istickedoff">, &quot;Given index: &quot; ++ show idx</span>
<span class="lineno"> 1020 </span><span class="spaces">        </span><span class="istickedoff">]</span>
<span class="lineno"> 1021 </span><span class="spaces">      </span><span class="istickedoff">JVMElemTypeMismatch idx expected found -&gt;</span>
<span class="lineno"> 1022 </span><span class="spaces">        </span><span class="istickedoff">unlines</span>
<span class="lineno"> 1023 </span><span class="spaces">        </span><span class="istickedoff">[ &quot;jvm_elem_is: Incompatible types for array index &quot; ++ show idx</span>
<span class="lineno"> 1024 </span><span class="spaces">        </span><span class="istickedoff">, &quot;Expected type: &quot; ++ show expected</span>
<span class="lineno"> 1025 </span><span class="spaces">        </span><span class="istickedoff">, &quot;Given type: &quot; ++ show found</span>
<span class="lineno"> 1026 </span><span class="spaces">        </span><span class="istickedoff">]</span>
<span class="lineno"> 1027 </span><span class="spaces">      </span><span class="istickedoff">JVMElemMultiple _ptr idx -&gt;</span>
<span class="lineno"> 1028 </span><span class="spaces">        </span><span class="istickedoff">&quot;jvm_elem_is: Multiple specifications for the same array index (&quot; ++ show idx ++ &quot;)&quot;</span>
<span class="lineno"> 1029 </span><span class="spaces">      </span><span class="istickedoff">JVMElemModifyPrestate _ptr idx -&gt;</span>
<span class="lineno"> 1030 </span><span class="spaces">        </span><span class="istickedoff">&quot;jvm_modifies_elem: Invalid use before jvm_execute_func (&quot; ++ show idx ++ &quot;)&quot;</span>
<span class="lineno"> 1031 </span><span class="spaces">      </span><span class="istickedoff">JVMArrayNonReference ptr -&gt;</span>
<span class="lineno"> 1032 </span><span class="spaces">        </span><span class="istickedoff">unlines</span>
<span class="lineno"> 1033 </span><span class="spaces">        </span><span class="istickedoff">[ &quot;jvm_array_is: Left-hand side is not a valid object reference&quot;</span>
<span class="lineno"> 1034 </span><span class="spaces">        </span><span class="istickedoff">, &quot;Left-hand side: &quot; ++ show (MS.ppSetupValue ptr)</span>
<span class="lineno"> 1035 </span><span class="spaces">        </span><span class="istickedoff">]</span>
<span class="lineno"> 1036 </span><span class="spaces">      </span><span class="istickedoff">JVMArrayTypeMismatch len ty schema -&gt;</span>
<span class="lineno"> 1037 </span><span class="spaces">        </span><span class="istickedoff">unlines</span>
<span class="lineno"> 1038 </span><span class="spaces">        </span><span class="istickedoff">[ &quot;jvm_array_is: Specified value does not have the expected type&quot;</span>
<span class="lineno"> 1039 </span><span class="spaces">        </span><span class="istickedoff">, &quot;Expected array length: &quot; ++ show len</span>
<span class="lineno"> 1040 </span><span class="spaces">        </span><span class="istickedoff">, &quot;Expected element type: &quot; ++ show ty</span>
<span class="lineno"> 1041 </span><span class="spaces">        </span><span class="istickedoff">, &quot;Given type: &quot; ++ show (Cryptol.pp schema)</span>
<span class="lineno"> 1042 </span><span class="spaces">        </span><span class="istickedoff">]</span>
<span class="lineno"> 1043 </span><span class="spaces">      </span><span class="istickedoff">JVMArrayMultiple _ptr -&gt;</span>
<span class="lineno"> 1044 </span><span class="spaces">        </span><span class="istickedoff">&quot;jvm_array_is: Multiple specifications for the same array reference&quot;</span>
<span class="lineno"> 1045 </span><span class="spaces">      </span><span class="istickedoff">JVMArrayModifyPrestate _ptr -&gt;</span>
<span class="lineno"> 1046 </span><span class="spaces">        </span><span class="istickedoff">&quot;jvm_modifies_array: Invalid use before jvm_execute_func&quot;</span>
<span class="lineno"> 1047 </span><span class="spaces">      </span><span class="istickedoff">JVMArgTypeMismatch i expected found -&gt;</span>
<span class="lineno"> 1048 </span><span class="spaces">        </span><span class="istickedoff">unlines</span>
<span class="lineno"> 1049 </span><span class="spaces">        </span><span class="istickedoff">[ &quot;jvm_execute_func: Argument type mismatch&quot;</span>
<span class="lineno"> 1050 </span><span class="spaces">        </span><span class="istickedoff">, &quot;Argument position: &quot; ++ show i</span>
<span class="lineno"> 1051 </span><span class="spaces">        </span><span class="istickedoff">, &quot;Expected type: &quot; ++ show expected</span>
<span class="lineno"> 1052 </span><span class="spaces">        </span><span class="istickedoff">, &quot;Given type: &quot; ++ show found</span>
<span class="lineno"> 1053 </span><span class="spaces">        </span><span class="istickedoff">]</span>
<span class="lineno"> 1054 </span><span class="spaces">      </span><span class="istickedoff">JVMArgNumberWrong expected found -&gt;</span>
<span class="lineno"> 1055 </span><span class="spaces">        </span><span class="istickedoff">unlines</span>
<span class="lineno"> 1056 </span><span class="spaces">        </span><span class="istickedoff">[ &quot;jvm_execute_func: Wrong number of arguments&quot;</span>
<span class="lineno"> 1057 </span><span class="spaces">        </span><span class="istickedoff">, &quot;Expected: &quot; ++ show expected</span>
<span class="lineno"> 1058 </span><span class="spaces">        </span><span class="istickedoff">, &quot;Given: &quot; ++ show found</span>
<span class="lineno"> 1059 </span><span class="spaces">        </span><span class="istickedoff">]</span>
<span class="lineno"> 1060 </span><span class="spaces">      </span><span class="istickedoff">JVMReturnUnexpected found -&gt;</span>
<span class="lineno"> 1061 </span><span class="spaces">        </span><span class="istickedoff">unlines</span>
<span class="lineno"> 1062 </span><span class="spaces">        </span><span class="istickedoff">[ &quot;jvm_return: Unexpected return value for void method&quot;</span>
<span class="lineno"> 1063 </span><span class="spaces">        </span><span class="istickedoff">, &quot;Given type: &quot; ++ show found</span>
<span class="lineno"> 1064 </span><span class="spaces">        </span><span class="istickedoff">]</span>
<span class="lineno"> 1065 </span><span class="spaces">      </span><span class="istickedoff">JVMReturnTypeMismatch expected found -&gt;</span>
<span class="lineno"> 1066 </span><span class="spaces">        </span><span class="istickedoff">unlines</span>
<span class="lineno"> 1067 </span><span class="spaces">        </span><span class="istickedoff">[ &quot;jvm_return: Return type mismatch&quot;</span>
<span class="lineno"> 1068 </span><span class="spaces">        </span><span class="istickedoff">, &quot;Expected type: &quot; ++ show expected</span>
<span class="lineno"> 1069 </span><span class="spaces">        </span><span class="istickedoff">, &quot;Given type: &quot; ++ show found</span>
<span class="lineno"> 1070 </span><span class="spaces">        </span><span class="istickedoff">]</span>
<span class="lineno"> 1071 </span><span class="spaces">      </span><span class="istickedoff">JVMNonValueType tp -&gt;</span>
<span class="lineno"> 1072 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">unlines</span></span>
<span class="lineno"> 1073 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Expected term with value type, but got&quot;</span></span>
<span class="lineno"> 1074 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">, show (ppTypedTermType tp)</span></span>
<span class="lineno"> 1075 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno"> 1076 </span>
<span class="lineno"> 1077 </span>-- | Returns Cryptol type of actual type if it is an array or
<span class="lineno"> 1078 </span>-- primitive type.
<span class="lineno"> 1079 </span>cryptolTypeOfActual :: JavaType -&gt; Maybe Cryptol.Type
<span class="lineno"> 1080 </span><span class="decl"><span class="istickedoff">cryptolTypeOfActual jty =</span>
<span class="lineno"> 1081 </span><span class="spaces">  </span><span class="istickedoff">case jty of</span>
<span class="lineno"> 1082 </span><span class="spaces">    </span><span class="istickedoff">JavaBoolean   -&gt; Just Cryptol.tBit</span>
<span class="lineno"> 1083 </span><span class="spaces">    </span><span class="istickedoff">JavaByte      -&gt; Just $ Cryptol.tWord (Cryptol.tNum (8 :: Integer))</span>
<span class="lineno"> 1084 </span><span class="spaces">    </span><span class="istickedoff">JavaChar      -&gt; Just $ Cryptol.tWord (Cryptol.tNum (16 :: Integer))</span>
<span class="lineno"> 1085 </span><span class="spaces">    </span><span class="istickedoff">JavaShort     -&gt; Just $ Cryptol.tWord (Cryptol.tNum (16 :: Integer))</span>
<span class="lineno"> 1086 </span><span class="spaces">    </span><span class="istickedoff">JavaInt       -&gt; Just $ Cryptol.tWord (Cryptol.tNum (32 :: Integer))</span>
<span class="lineno"> 1087 </span><span class="spaces">    </span><span class="istickedoff">JavaLong      -&gt; Just $ Cryptol.tWord (Cryptol.tNum (64 :: Integer))</span>
<span class="lineno"> 1088 </span><span class="spaces">    </span><span class="istickedoff">JavaFloat     -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 1089 </span><span class="spaces">    </span><span class="istickedoff">JavaDouble    -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 1090 </span><span class="spaces">    </span><span class="istickedoff">JavaArray n t -&gt; Cryptol.tSeq (Cryptol.tNum n) &lt;$&gt; cryptolTypeOfActual t</span>
<span class="lineno"> 1091 </span><span class="spaces">    </span><span class="istickedoff">JavaClass _   -&gt; <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno"> 1092 </span>
<span class="lineno"> 1093 </span>parseClassName :: Text -&gt; J.ClassName
<span class="lineno"> 1094 </span><span class="decl"><span class="istickedoff">parseClassName cname = J.mkClassName (J.dotsToSlashes $ Text.unpack cname)</span></span>
<span class="lineno"> 1095 </span>
<span class="lineno"> 1096 </span>typeOfJavaType :: JavaType -&gt; J.Type
<span class="lineno"> 1097 </span><span class="decl"><span class="istickedoff">typeOfJavaType jty =</span>
<span class="lineno"> 1098 </span><span class="spaces">  </span><span class="istickedoff">case jty of</span>
<span class="lineno"> 1099 </span><span class="spaces">    </span><span class="istickedoff">JavaBoolean   -&gt; J.BooleanType</span>
<span class="lineno"> 1100 </span><span class="spaces">    </span><span class="istickedoff">JavaByte      -&gt; J.ByteType</span>
<span class="lineno"> 1101 </span><span class="spaces">    </span><span class="istickedoff">JavaChar      -&gt; J.CharType</span>
<span class="lineno"> 1102 </span><span class="spaces">    </span><span class="istickedoff">JavaShort     -&gt; J.ShortType</span>
<span class="lineno"> 1103 </span><span class="spaces">    </span><span class="istickedoff">JavaInt       -&gt; J.IntType</span>
<span class="lineno"> 1104 </span><span class="spaces">    </span><span class="istickedoff">JavaLong      -&gt; J.LongType</span>
<span class="lineno"> 1105 </span><span class="spaces">    </span><span class="istickedoff">JavaFloat     -&gt; <span class="nottickedoff">J.FloatType</span></span>
<span class="lineno"> 1106 </span><span class="spaces">    </span><span class="istickedoff">JavaDouble    -&gt; <span class="nottickedoff">J.DoubleType</span></span>
<span class="lineno"> 1107 </span><span class="spaces">    </span><span class="istickedoff">JavaArray _ t -&gt; <span class="nottickedoff">J.ArrayType (typeOfJavaType t)</span></span>
<span class="lineno"> 1108 </span><span class="spaces">    </span><span class="istickedoff">JavaClass c   -&gt; <span class="nottickedoff">J.ClassType (parseClassName c)</span></span></span>
<span class="lineno"> 1109 </span>
<span class="lineno"> 1110 </span>-- | Generate a fresh variable term. The name will be used when
<span class="lineno"> 1111 </span>-- pretty-printing the variable in debug output.
<span class="lineno"> 1112 </span>jvm_fresh_var ::
<span class="lineno"> 1113 </span>  Text                {- ^ variable name    -} -&gt;
<span class="lineno"> 1114 </span>  JavaType            {- ^ variable type    -} -&gt;
<span class="lineno"> 1115 </span>  JVMSetupM TypedTerm {- ^ fresh typed term -}
<span class="lineno"> 1116 </span><span class="decl"><span class="istickedoff">jvm_fresh_var name jty =</span>
<span class="lineno"> 1117 </span><span class="spaces">  </span><span class="istickedoff">JVMSetupM $</span>
<span class="lineno"> 1118 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- lift $ lift getSharedContext</span>
<span class="lineno"> 1119 </span><span class="spaces">     </span><span class="istickedoff">case cryptolTypeOfActual jty of</span>
<span class="lineno"> 1120 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">X.throwM $ JVMFreshVarInvalidType jty</span></span>
<span class="lineno"> 1121 </span><span class="spaces">       </span><span class="istickedoff">Just cty -&gt; Setup.freshVariable sc name cty</span></span>
<span class="lineno"> 1122 </span>
<span class="lineno"> 1123 </span>jvm_alloc_object ::
<span class="lineno"> 1124 </span>  Text {- ^ class name -} -&gt;
<span class="lineno"> 1125 </span>  JVMSetupM SetupValue
<span class="lineno"> 1126 </span><span class="decl"><span class="istickedoff">jvm_alloc_object cname =</span>
<span class="lineno"> 1127 </span><span class="spaces">  </span><span class="istickedoff">JVMSetupM $</span>
<span class="lineno"> 1128 </span><span class="spaces">  </span><span class="istickedoff">do loc &lt;- <span class="nottickedoff">SS.toW4Loc &quot;jvm_alloc_object&quot;</span> &lt;$&gt; lift (lift getPosition)</span>
<span class="lineno"> 1129 </span><span class="spaces">     </span><span class="istickedoff">tags &lt;- view <span class="nottickedoff">Setup.croTags</span></span>
<span class="lineno"> 1130 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">md = MS.ConditionMetadata</span></span>
<span class="lineno"> 1131 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">{ MS.conditionLoc = loc</span></span>
<span class="lineno"> 1132 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionTags = tags</span></span>
<span class="lineno"> 1133 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionType = &quot;object allocation&quot;</span></span>
<span class="lineno"> 1134 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionContext = &quot;&quot;</span></span>
<span class="lineno"> 1135 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">}</span></span>
<span class="lineno"> 1136 </span><span class="spaces">     </span><span class="istickedoff">n &lt;- Setup.csVarCounter &lt;&lt;%= nextAllocIndex</span>
<span class="lineno"> 1137 </span><span class="spaces">     </span><span class="istickedoff">Setup.currentState . MS.csAllocs . at n ?=</span>
<span class="lineno"> 1138 </span><span class="spaces">       </span><span class="istickedoff">(<span class="nottickedoff">md</span>, AllocObject (parseClassName cname))</span>
<span class="lineno"> 1139 </span><span class="spaces">     </span><span class="istickedoff">return (MS.SetupVar n)</span></span>
<span class="lineno"> 1140 </span>
<span class="lineno"> 1141 </span>jvm_alloc_array ::
<span class="lineno"> 1142 </span>  Int {- array size -} -&gt;
<span class="lineno"> 1143 </span>  JavaType             -&gt;
<span class="lineno"> 1144 </span>  JVMSetupM SetupValue
<span class="lineno"> 1145 </span><span class="decl"><span class="istickedoff">jvm_alloc_array len ety =</span>
<span class="lineno"> 1146 </span><span class="spaces">  </span><span class="istickedoff">JVMSetupM $</span>
<span class="lineno"> 1147 </span><span class="spaces">  </span><span class="istickedoff">do loc &lt;- <span class="nottickedoff">SS.toW4Loc &quot;jvm_alloc_array&quot;</span> &lt;$&gt; lift (lift getPosition)</span>
<span class="lineno"> 1148 </span><span class="spaces">     </span><span class="istickedoff">tags &lt;- view <span class="nottickedoff">Setup.croTags</span></span>
<span class="lineno"> 1149 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">md = MS.ConditionMetadata</span></span>
<span class="lineno"> 1150 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">{ MS.conditionLoc = loc</span></span>
<span class="lineno"> 1151 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionTags = tags</span></span>
<span class="lineno"> 1152 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionType = &quot;array allocation&quot;</span></span>
<span class="lineno"> 1153 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionContext = &quot;&quot;</span></span>
<span class="lineno"> 1154 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">}</span></span>
<span class="lineno"> 1155 </span><span class="spaces">     </span><span class="istickedoff">n &lt;- Setup.csVarCounter &lt;&lt;%= nextAllocIndex</span>
<span class="lineno"> 1156 </span><span class="spaces">     </span><span class="istickedoff">Setup.currentState . MS.csAllocs . at n ?= (<span class="nottickedoff">md</span>, AllocArray len (typeOfJavaType ety))</span>
<span class="lineno"> 1157 </span><span class="spaces">     </span><span class="istickedoff">return (MS.SetupVar n)</span></span>
<span class="lineno"> 1158 </span>
<span class="lineno"> 1159 </span>jvm_modifies_field ::
<span class="lineno"> 1160 </span>  SetupValue {- ^ object -} -&gt;
<span class="lineno"> 1161 </span>  Text       {- ^ field name -} -&gt;
<span class="lineno"> 1162 </span>  JVMSetupM ()
<span class="lineno"> 1163 </span><span class="decl"><span class="istickedoff">jvm_modifies_field ptr fname = generic_field_is ptr fname Nothing</span></span>
<span class="lineno"> 1164 </span>
<span class="lineno"> 1165 </span>jvm_field_is ::
<span class="lineno"> 1166 </span>  SetupValue {- ^ object -} -&gt;
<span class="lineno"> 1167 </span>  Text       {- ^ field name -} -&gt;
<span class="lineno"> 1168 </span>  SetupValue {- ^ field value -} -&gt;
<span class="lineno"> 1169 </span>  JVMSetupM ()
<span class="lineno"> 1170 </span><span class="decl"><span class="istickedoff">jvm_field_is ptr fname val = generic_field_is ptr fname (Just val)</span></span>
<span class="lineno"> 1171 </span>
<span class="lineno"> 1172 </span>generic_field_is ::
<span class="lineno"> 1173 </span>  SetupValue {- ^ object -} -&gt;
<span class="lineno"> 1174 </span>  Text {- ^ field name -} -&gt;
<span class="lineno"> 1175 </span>  Maybe SetupValue {- ^ field value -} -&gt;
<span class="lineno"> 1176 </span>  JVMSetupM ()
<span class="lineno"> 1177 </span><span class="decl"><span class="istickedoff">generic_field_is ptr fname mval =</span>
<span class="lineno"> 1178 </span><span class="spaces">  </span><span class="istickedoff">JVMSetupM $</span>
<span class="lineno"> 1179 </span><span class="spaces">  </span><span class="istickedoff">do pos &lt;- lift (lift getPosition)</span>
<span class="lineno"> 1180 </span><span class="spaces">     </span><span class="istickedoff">let loc = SS.toW4Loc &quot;jvm_field_is&quot; pos</span>
<span class="lineno"> 1181 </span><span class="spaces">     </span><span class="istickedoff">ptr' &lt;-</span>
<span class="lineno"> 1182 </span><span class="spaces">       </span><span class="istickedoff">case ptr of</span>
<span class="lineno"> 1183 </span><span class="spaces">         </span><span class="istickedoff">MS.SetupVar ptr' -&gt; pure ptr'</span>
<span class="lineno"> 1184 </span><span class="spaces">         </span><span class="istickedoff">_ -&gt; X.throwM $ JVMFieldNonReference ptr fname</span>
<span class="lineno"> 1185 </span><span class="spaces">     </span><span class="istickedoff">st &lt;- get</span>
<span class="lineno"> 1186 </span><span class="spaces">     </span><span class="istickedoff">let cc = st ^. Setup.csCrucibleContext</span>
<span class="lineno"> 1187 </span><span class="spaces">     </span><span class="istickedoff">let cb = cc ^. jccCodebase</span>
<span class="lineno"> 1188 </span><span class="spaces">     </span><span class="istickedoff">let env = MS.csAllocations (st ^. Setup.csMethodSpec)</span>
<span class="lineno"> 1189 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">nameEnv = MS.csTypeNames (st ^. Setup.csMethodSpec)</span></span>
<span class="lineno"> 1190 </span><span class="spaces">     </span><span class="istickedoff">ptrTy &lt;- typeOfSetupValue <span class="nottickedoff">cc</span> env <span class="nottickedoff">nameEnv</span> ptr</span>
<span class="lineno"> 1191 </span><span class="spaces">     </span><span class="istickedoff">fid &lt;- either (X.throwM . JVMFieldFailure) pure =&lt;&lt; (liftIO $ runExceptT $ findField cb <span class="nottickedoff">pos</span> ptrTy (Text.unpack fname))</span>
<span class="lineno"> 1192 </span><span class="spaces">     </span><span class="istickedoff">case mval of</span>
<span class="lineno"> 1193 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt; pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 1194 </span><span class="spaces">       </span><span class="istickedoff">Just val -&gt;</span>
<span class="lineno"> 1195 </span><span class="spaces">         </span><span class="istickedoff">do valTy &lt;- typeOfSetupValue <span class="nottickedoff">cc</span> env <span class="nottickedoff">nameEnv</span> val</span>
<span class="lineno"> 1196 </span><span class="spaces">            </span><span class="istickedoff">unless (registerCompatible (J.fieldIdType fid) valTy) $</span>
<span class="lineno"> 1197 </span><span class="spaces">              </span><span class="istickedoff">X.throwM $ JVMFieldTypeMismatch fid valTy</span>
<span class="lineno"> 1198 </span><span class="spaces">     </span><span class="istickedoff">tags &lt;- view <span class="nottickedoff">Setup.croTags</span></span>
<span class="lineno"> 1199 </span><span class="spaces">     </span><span class="istickedoff">let md = MS.ConditionMetadata</span>
<span class="lineno"> 1200 </span><span class="spaces">              </span><span class="istickedoff">{ MS.conditionLoc = loc</span>
<span class="lineno"> 1201 </span><span class="spaces">              </span><span class="istickedoff">, MS.conditionTags = <span class="nottickedoff">tags</span></span>
<span class="lineno"> 1202 </span><span class="spaces">              </span><span class="istickedoff">, MS.conditionType = <span class="nottickedoff">&quot;JVM field-is&quot;</span></span>
<span class="lineno"> 1203 </span><span class="spaces">              </span><span class="istickedoff">, MS.conditionContext = <span class="nottickedoff">&quot;&quot;</span></span>
<span class="lineno"> 1204 </span><span class="spaces">              </span><span class="istickedoff">}</span>
<span class="lineno"> 1205 </span><span class="spaces">     </span><span class="istickedoff">let pt = JVMPointsToField md ptr' fid mval</span>
<span class="lineno"> 1206 </span><span class="spaces">     </span><span class="istickedoff">let pts = st ^. Setup.csMethodSpec . MS.csPreState . MS.csPointsTos</span>
<span class="lineno"> 1207 </span><span class="spaces">     </span><span class="istickedoff">when (st ^. Setup.csPrePost == PreState &amp;&amp; any (overlapPointsTo pt) pts) $</span>
<span class="lineno"> 1208 </span><span class="spaces">       </span><span class="istickedoff">X.throwM $ JVMFieldMultiple <span class="nottickedoff">ptr'</span> fid</span>
<span class="lineno"> 1209 </span><span class="spaces">     </span><span class="istickedoff">when (st ^. Setup.csPrePost == PreState &amp;&amp; isNothing mval) $</span>
<span class="lineno"> 1210 </span><span class="spaces">       </span><span class="istickedoff">X.throwM $ JVMFieldModifyPrestate <span class="nottickedoff">ptr'</span> fid</span>
<span class="lineno"> 1211 </span><span class="spaces">     </span><span class="istickedoff">Setup.addPointsTo pt</span></span>
<span class="lineno"> 1212 </span>
<span class="lineno"> 1213 </span>jvm_modifies_static_field ::
<span class="lineno"> 1214 </span>  Text {- ^ field name -} -&gt;
<span class="lineno"> 1215 </span>  JVMSetupM ()
<span class="lineno"> 1216 </span><span class="decl"><span class="istickedoff">jvm_modifies_static_field fname = generic_static_field_is fname Nothing</span></span>
<span class="lineno"> 1217 </span>
<span class="lineno"> 1218 </span>jvm_static_field_is ::
<span class="lineno"> 1219 </span>  Text       {- ^ field name -} -&gt;
<span class="lineno"> 1220 </span>  SetupValue {- ^ field value -} -&gt;
<span class="lineno"> 1221 </span>  JVMSetupM ()
<span class="lineno"> 1222 </span><span class="decl"><span class="istickedoff">jvm_static_field_is fname val = generic_static_field_is fname (Just val)</span></span>
<span class="lineno"> 1223 </span>
<span class="lineno"> 1224 </span>generic_static_field_is ::
<span class="lineno"> 1225 </span>  Text {- ^ field name -} -&gt;
<span class="lineno"> 1226 </span>  Maybe SetupValue {- ^ field value -} -&gt;
<span class="lineno"> 1227 </span>  JVMSetupM ()
<span class="lineno"> 1228 </span><span class="decl"><span class="istickedoff">generic_static_field_is fname mval =</span>
<span class="lineno"> 1229 </span><span class="spaces">  </span><span class="istickedoff">JVMSetupM $</span>
<span class="lineno"> 1230 </span><span class="spaces">  </span><span class="istickedoff">do pos &lt;- lift (lift getPosition)</span>
<span class="lineno"> 1231 </span><span class="spaces">     </span><span class="istickedoff">let loc = SS.toW4Loc &quot;jvm_static_field_is&quot; pos</span>
<span class="lineno"> 1232 </span><span class="spaces">     </span><span class="istickedoff">st &lt;- get</span>
<span class="lineno"> 1233 </span><span class="spaces">     </span><span class="istickedoff">let cc = st ^. Setup.csCrucibleContext</span>
<span class="lineno"> 1234 </span><span class="spaces">     </span><span class="istickedoff">let cb = cc ^. jccCodebase</span>
<span class="lineno"> 1235 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">env = MS.csAllocations (st ^. Setup.csMethodSpec)</span></span>
<span class="lineno"> 1236 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">nameEnv = MS.csTypeNames (st ^. Setup.csMethodSpec)</span></span>
<span class="lineno"> 1237 </span><span class="spaces">     </span><span class="istickedoff">let cname =</span>
<span class="lineno"> 1238 </span><span class="spaces">           </span><span class="istickedoff">case Text.unsnoc $ Text.dropWhileEnd (/= '.') fname of</span>
<span class="lineno"> 1239 </span><span class="spaces">               </span><span class="istickedoff">Nothing -&gt; J.className (cc ^. jccJVMClass)</span>
<span class="lineno"> 1240 </span><span class="spaces">               </span><span class="istickedoff">Just (fname', _) -&gt; J.mkClassName (Text.unpack fname')</span>
<span class="lineno"> 1241 </span><span class="spaces">     </span><span class="istickedoff">-- liftIO $ putStrLn $ &quot;jvm_static_field_is &quot; ++ J.unClassName cname ++ &quot; &quot; ++ fname</span>
<span class="lineno"> 1242 </span><span class="spaces">     </span><span class="istickedoff">let ptrTy = J.ClassType cname</span>
<span class="lineno"> 1243 </span><span class="spaces">     </span><span class="istickedoff">fid &lt;- either (X.throwM . JVMStaticFailure) pure =&lt;&lt; (liftIO $ runExceptT $ findField cb <span class="nottickedoff">pos</span> ptrTy (Text.unpack fname))</span>
<span class="lineno"> 1244 </span><span class="spaces">     </span><span class="istickedoff">case mval of</span>
<span class="lineno"> 1245 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt; pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 1246 </span><span class="spaces">       </span><span class="istickedoff">Just val -&gt;</span>
<span class="lineno"> 1247 </span><span class="spaces">         </span><span class="istickedoff">do valTy &lt;- typeOfSetupValue <span class="nottickedoff">cc</span> <span class="nottickedoff">env</span> <span class="nottickedoff">nameEnv</span> val</span>
<span class="lineno"> 1248 </span><span class="spaces">            </span><span class="istickedoff">unless (registerCompatible (J.fieldIdType fid) valTy) $</span>
<span class="lineno"> 1249 </span><span class="spaces">              </span><span class="istickedoff">X.throwM $ JVMStaticTypeMismatch fid valTy</span>
<span class="lineno"> 1250 </span><span class="spaces">     </span><span class="istickedoff">-- let name = J.unClassName (J.fieldIdClass fid) ++ &quot;.&quot; ++ J.fieldIdName fid</span>
<span class="lineno"> 1251 </span><span class="spaces">     </span><span class="istickedoff">-- liftIO $ putStrLn $ &quot;resolved to: &quot; ++ name</span>
<span class="lineno"> 1252 </span><span class="spaces">     </span><span class="istickedoff">tags &lt;- view <span class="nottickedoff">Setup.croTags</span></span>
<span class="lineno"> 1253 </span><span class="spaces">     </span><span class="istickedoff">let md = MS.ConditionMetadata</span>
<span class="lineno"> 1254 </span><span class="spaces">              </span><span class="istickedoff">{ MS.conditionLoc = loc</span>
<span class="lineno"> 1255 </span><span class="spaces">              </span><span class="istickedoff">, MS.conditionTags = <span class="nottickedoff">tags</span></span>
<span class="lineno"> 1256 </span><span class="spaces">              </span><span class="istickedoff">, MS.conditionType = <span class="nottickedoff">&quot;JVM field-is (static)&quot;</span></span>
<span class="lineno"> 1257 </span><span class="spaces">              </span><span class="istickedoff">, MS.conditionContext = <span class="nottickedoff">&quot;&quot;</span></span>
<span class="lineno"> 1258 </span><span class="spaces">              </span><span class="istickedoff">}</span>
<span class="lineno"> 1259 </span><span class="spaces">     </span><span class="istickedoff">let pt = JVMPointsToStatic md fid mval</span>
<span class="lineno"> 1260 </span><span class="spaces">     </span><span class="istickedoff">let pts = st ^. Setup.csMethodSpec . MS.csPreState . MS.csPointsTos</span>
<span class="lineno"> 1261 </span><span class="spaces">     </span><span class="istickedoff">when (st ^. Setup.csPrePost == PreState &amp;&amp; any (overlapPointsTo pt) pts) $</span>
<span class="lineno"> 1262 </span><span class="spaces">       </span><span class="istickedoff">X.throwM $ JVMStaticMultiple fid</span>
<span class="lineno"> 1263 </span><span class="spaces">     </span><span class="istickedoff">when (st ^. Setup.csPrePost == PreState &amp;&amp; isNothing mval) $</span>
<span class="lineno"> 1264 </span><span class="spaces">       </span><span class="istickedoff">X.throwM $ JVMStaticModifyPrestate fid</span>
<span class="lineno"> 1265 </span><span class="spaces">     </span><span class="istickedoff">Setup.addPointsTo pt</span></span>
<span class="lineno"> 1266 </span>
<span class="lineno"> 1267 </span>jvm_modifies_elem ::
<span class="lineno"> 1268 </span>  SetupValue {- ^ array -} -&gt;
<span class="lineno"> 1269 </span>  Int        {- ^ index -} -&gt;
<span class="lineno"> 1270 </span>  JVMSetupM ()
<span class="lineno"> 1271 </span><span class="decl"><span class="istickedoff">jvm_modifies_elem ptr idx = generic_elem_is ptr idx Nothing</span></span>
<span class="lineno"> 1272 </span>
<span class="lineno"> 1273 </span>jvm_elem_is ::
<span class="lineno"> 1274 </span>  SetupValue {- ^ array -} -&gt;
<span class="lineno"> 1275 </span>  Int        {- ^ index -} -&gt;
<span class="lineno"> 1276 </span>  SetupValue {- ^ element value -} -&gt;
<span class="lineno"> 1277 </span>  JVMSetupM ()
<span class="lineno"> 1278 </span><span class="decl"><span class="istickedoff">jvm_elem_is ptr idx val = generic_elem_is ptr idx (Just val)</span></span>
<span class="lineno"> 1279 </span>
<span class="lineno"> 1280 </span>generic_elem_is ::
<span class="lineno"> 1281 </span>  SetupValue {- ^ array -} -&gt;
<span class="lineno"> 1282 </span>  Int {- ^ index -} -&gt;
<span class="lineno"> 1283 </span>  Maybe SetupValue {- ^ element value -} -&gt;
<span class="lineno"> 1284 </span>  JVMSetupM ()
<span class="lineno"> 1285 </span><span class="decl"><span class="istickedoff">generic_elem_is ptr idx mval =</span>
<span class="lineno"> 1286 </span><span class="spaces">  </span><span class="istickedoff">JVMSetupM $</span>
<span class="lineno"> 1287 </span><span class="spaces">  </span><span class="istickedoff">do loc &lt;- SS.toW4Loc &quot;jvm_elem_is&quot; &lt;$&gt; lift (lift getPosition)</span>
<span class="lineno"> 1288 </span><span class="spaces">     </span><span class="istickedoff">ptr' &lt;-</span>
<span class="lineno"> 1289 </span><span class="spaces">       </span><span class="istickedoff">case ptr of</span>
<span class="lineno"> 1290 </span><span class="spaces">         </span><span class="istickedoff">MS.SetupVar ptr' -&gt; pure ptr'</span>
<span class="lineno"> 1291 </span><span class="spaces">         </span><span class="istickedoff">_ -&gt; X.throwM $ JVMElemNonReference ptr idx</span>
<span class="lineno"> 1292 </span><span class="spaces">     </span><span class="istickedoff">st &lt;- get</span>
<span class="lineno"> 1293 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">cc = st ^. Setup.csCrucibleContext</span></span>
<span class="lineno"> 1294 </span><span class="spaces">     </span><span class="istickedoff">let env = MS.csAllocations (st ^. Setup.csMethodSpec)</span>
<span class="lineno"> 1295 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">nameEnv = MS.csTypeNames (st ^. Setup.csMethodSpec)</span></span>
<span class="lineno"> 1296 </span><span class="spaces">     </span><span class="istickedoff">(len, elTy) &lt;-</span>
<span class="lineno"> 1297 </span><span class="spaces">       </span><span class="istickedoff">case snd (lookupAllocIndex env ptr') of</span>
<span class="lineno"> 1298 </span><span class="spaces">         </span><span class="istickedoff">AllocObject cname -&gt; X.throwM $ JVMElemNonArray (J.ClassType cname)</span>
<span class="lineno"> 1299 </span><span class="spaces">         </span><span class="istickedoff">AllocArray len elTy -&gt; pure (len, elTy)</span>
<span class="lineno"> 1300 </span><span class="spaces">     </span><span class="istickedoff">unless (0 &lt;= idx &amp;&amp; idx &lt; len) $</span>
<span class="lineno"> 1301 </span><span class="spaces">       </span><span class="istickedoff">X.throwM $ JVMElemInvalidIndex elTy len idx</span>
<span class="lineno"> 1302 </span><span class="spaces">     </span><span class="istickedoff">case mval of</span>
<span class="lineno"> 1303 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt; pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 1304 </span><span class="spaces">       </span><span class="istickedoff">Just val -&gt;</span>
<span class="lineno"> 1305 </span><span class="spaces">         </span><span class="istickedoff">do valTy &lt;- typeOfSetupValue <span class="nottickedoff">cc</span> <span class="nottickedoff">env</span> <span class="nottickedoff">nameEnv</span> val</span>
<span class="lineno"> 1306 </span><span class="spaces">            </span><span class="istickedoff">unless (registerCompatible elTy valTy) $</span>
<span class="lineno"> 1307 </span><span class="spaces">              </span><span class="istickedoff">X.throwM $ JVMElemTypeMismatch idx elTy valTy</span>
<span class="lineno"> 1308 </span><span class="spaces">     </span><span class="istickedoff">tags &lt;- view <span class="nottickedoff">Setup.croTags</span></span>
<span class="lineno"> 1309 </span><span class="spaces">     </span><span class="istickedoff">let md = MS.ConditionMetadata</span>
<span class="lineno"> 1310 </span><span class="spaces">              </span><span class="istickedoff">{ MS.conditionLoc = loc</span>
<span class="lineno"> 1311 </span><span class="spaces">              </span><span class="istickedoff">, MS.conditionTags = <span class="nottickedoff">tags</span></span>
<span class="lineno"> 1312 </span><span class="spaces">              </span><span class="istickedoff">, MS.conditionType = <span class="nottickedoff">&quot;JVM elem-is&quot;</span></span>
<span class="lineno"> 1313 </span><span class="spaces">              </span><span class="istickedoff">, MS.conditionContext = <span class="nottickedoff">&quot;&quot;</span></span>
<span class="lineno"> 1314 </span><span class="spaces">              </span><span class="istickedoff">}</span>
<span class="lineno"> 1315 </span><span class="spaces">     </span><span class="istickedoff">let pt = JVMPointsToElem md ptr' idx mval</span>
<span class="lineno"> 1316 </span><span class="spaces">     </span><span class="istickedoff">let pts = st ^. Setup.csMethodSpec . MS.csPreState . MS.csPointsTos</span>
<span class="lineno"> 1317 </span><span class="spaces">     </span><span class="istickedoff">when (st ^. Setup.csPrePost == PreState &amp;&amp; any (overlapPointsTo pt) pts) $</span>
<span class="lineno"> 1318 </span><span class="spaces">       </span><span class="istickedoff">X.throwM $ JVMElemMultiple <span class="nottickedoff">ptr'</span> idx</span>
<span class="lineno"> 1319 </span><span class="spaces">     </span><span class="istickedoff">when (st ^. Setup.csPrePost == PreState &amp;&amp; isNothing mval) $</span>
<span class="lineno"> 1320 </span><span class="spaces">       </span><span class="istickedoff">X.throwM $ JVMElemModifyPrestate <span class="nottickedoff">ptr'</span> idx</span>
<span class="lineno"> 1321 </span><span class="spaces">     </span><span class="istickedoff">Setup.addPointsTo pt</span></span>
<span class="lineno"> 1322 </span>
<span class="lineno"> 1323 </span>jvm_modifies_array ::
<span class="lineno"> 1324 </span>  SetupValue {- ^ array reference -} -&gt;
<span class="lineno"> 1325 </span>  JVMSetupM ()
<span class="lineno"> 1326 </span><span class="decl"><span class="istickedoff">jvm_modifies_array ptr = generic_array_is ptr Nothing</span></span>
<span class="lineno"> 1327 </span>
<span class="lineno"> 1328 </span>jvm_array_is ::
<span class="lineno"> 1329 </span>  SetupValue {- ^ array reference -} -&gt;
<span class="lineno"> 1330 </span>  TypedTerm {- ^ array value -} -&gt;
<span class="lineno"> 1331 </span>  JVMSetupM ()
<span class="lineno"> 1332 </span><span class="decl"><span class="istickedoff">jvm_array_is ptr val = generic_array_is ptr (Just val)</span></span>
<span class="lineno"> 1333 </span>
<span class="lineno"> 1334 </span>generic_array_is ::
<span class="lineno"> 1335 </span>  SetupValue {- ^ array reference -} -&gt;
<span class="lineno"> 1336 </span>  Maybe TypedTerm {- ^ array value -} -&gt;
<span class="lineno"> 1337 </span>  JVMSetupM ()
<span class="lineno"> 1338 </span><span class="decl"><span class="istickedoff">generic_array_is ptr mval =</span>
<span class="lineno"> 1339 </span><span class="spaces">  </span><span class="istickedoff">JVMSetupM $</span>
<span class="lineno"> 1340 </span><span class="spaces">  </span><span class="istickedoff">do loc &lt;- SS.toW4Loc &quot;jvm_array_is&quot; &lt;$&gt; lift (lift getPosition)</span>
<span class="lineno"> 1341 </span><span class="spaces">     </span><span class="istickedoff">ptr' &lt;-</span>
<span class="lineno"> 1342 </span><span class="spaces">       </span><span class="istickedoff">case ptr of</span>
<span class="lineno"> 1343 </span><span class="spaces">         </span><span class="istickedoff">MS.SetupVar ptr' -&gt; pure ptr'</span>
<span class="lineno"> 1344 </span><span class="spaces">         </span><span class="istickedoff">_ -&gt; X.throwM $ JVMArrayNonReference ptr</span>
<span class="lineno"> 1345 </span><span class="spaces">     </span><span class="istickedoff">st &lt;- get</span>
<span class="lineno"> 1346 </span><span class="spaces">     </span><span class="istickedoff">let env = MS.csAllocations (st ^. Setup.csMethodSpec)</span>
<span class="lineno"> 1347 </span><span class="spaces">     </span><span class="istickedoff">(len, elTy) &lt;-</span>
<span class="lineno"> 1348 </span><span class="spaces">       </span><span class="istickedoff">case snd (lookupAllocIndex env ptr') of</span>
<span class="lineno"> 1349 </span><span class="spaces">         </span><span class="istickedoff">AllocObject cname -&gt; X.throwM $ JVMElemNonArray (J.ClassType cname)</span>
<span class="lineno"> 1350 </span><span class="spaces">         </span><span class="istickedoff">AllocArray len elTy -&gt; pure (len, elTy)</span>
<span class="lineno"> 1351 </span><span class="spaces">     </span><span class="istickedoff">case mval of</span>
<span class="lineno"> 1352 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt; pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 1353 </span><span class="spaces">       </span><span class="istickedoff">Just val -&gt;</span>
<span class="lineno"> 1354 </span><span class="spaces">         </span><span class="istickedoff">do schema &lt;- case ttType val of</span>
<span class="lineno"> 1355 </span><span class="spaces">              </span><span class="istickedoff">TypedTermSchema sch -&gt; pure sch</span>
<span class="lineno"> 1356 </span><span class="spaces">              </span><span class="istickedoff">tp -&gt; <span class="nottickedoff">X.throwM (JVMNonValueType tp)</span></span>
<span class="lineno"> 1357 </span><span class="spaces">            </span><span class="istickedoff">let checkVal =</span>
<span class="lineno"> 1358 </span><span class="spaces">                  </span><span class="istickedoff">do ty &lt;- Cryptol.isMono schema</span>
<span class="lineno"> 1359 </span><span class="spaces">                     </span><span class="istickedoff">(n, a) &lt;- Cryptol.tIsSeq ty</span>
<span class="lineno"> 1360 </span><span class="spaces">                     </span><span class="istickedoff">guard (Cryptol.tIsNum n == Just (toInteger len))</span>
<span class="lineno"> 1361 </span><span class="spaces">                     </span><span class="istickedoff">jty &lt;- toJVMType (Cryptol.evalValType <span class="nottickedoff">mempty</span> a)</span>
<span class="lineno"> 1362 </span><span class="spaces">                     </span><span class="istickedoff">guard (registerCompatible elTy jty)</span>
<span class="lineno"> 1363 </span><span class="spaces">            </span><span class="istickedoff">case checkVal of</span>
<span class="lineno"> 1364 </span><span class="spaces">              </span><span class="istickedoff">Nothing -&gt; X.throwM (JVMArrayTypeMismatch len elTy schema)</span>
<span class="lineno"> 1365 </span><span class="spaces">              </span><span class="istickedoff">Just () -&gt; pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 1366 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1367 </span><span class="spaces">     </span><span class="istickedoff">tags &lt;- view <span class="nottickedoff">Setup.croTags</span></span>
<span class="lineno"> 1368 </span><span class="spaces">     </span><span class="istickedoff">let md = MS.ConditionMetadata</span>
<span class="lineno"> 1369 </span><span class="spaces">              </span><span class="istickedoff">{ MS.conditionLoc = loc</span>
<span class="lineno"> 1370 </span><span class="spaces">              </span><span class="istickedoff">, MS.conditionTags = <span class="nottickedoff">tags</span></span>
<span class="lineno"> 1371 </span><span class="spaces">              </span><span class="istickedoff">, MS.conditionType = <span class="nottickedoff">&quot;JVM array-is&quot;</span></span>
<span class="lineno"> 1372 </span><span class="spaces">              </span><span class="istickedoff">, MS.conditionContext = <span class="nottickedoff">&quot;&quot;</span></span>
<span class="lineno"> 1373 </span><span class="spaces">              </span><span class="istickedoff">}</span>
<span class="lineno"> 1374 </span><span class="spaces">     </span><span class="istickedoff">let pt = JVMPointsToArray md ptr' mval</span>
<span class="lineno"> 1375 </span><span class="spaces">     </span><span class="istickedoff">let pts = st ^. Setup.csMethodSpec . MS.csPreState . MS.csPointsTos</span>
<span class="lineno"> 1376 </span><span class="spaces">     </span><span class="istickedoff">when (st ^. Setup.csPrePost == PreState &amp;&amp; any (overlapPointsTo pt) pts) $</span>
<span class="lineno"> 1377 </span><span class="spaces">       </span><span class="istickedoff">X.throwM $ JVMArrayMultiple <span class="nottickedoff">ptr'</span></span>
<span class="lineno"> 1378 </span><span class="spaces">     </span><span class="istickedoff">when (st ^. Setup.csPrePost == PreState &amp;&amp; isNothing mval) $</span>
<span class="lineno"> 1379 </span><span class="spaces">       </span><span class="istickedoff">X.throwM $ JVMArrayModifyPrestate <span class="nottickedoff">ptr'</span></span>
<span class="lineno"> 1380 </span><span class="spaces">     </span><span class="istickedoff">Setup.addPointsTo pt</span></span>
<span class="lineno"> 1381 </span>
<span class="lineno"> 1382 </span>jvm_assert :: TypedTerm -&gt; JVMSetupM ()
<span class="lineno"> 1383 </span><span class="decl"><span class="istickedoff">jvm_assert term = JVMSetupM $ do</span>
<span class="lineno"> 1384 </span><span class="spaces">  </span><span class="istickedoff">loc &lt;- <span class="nottickedoff">SS.toW4Loc &quot;jvm_assert&quot;</span> &lt;$&gt; lift (lift getPosition)</span>
<span class="lineno"> 1385 </span><span class="spaces">  </span><span class="istickedoff">tags &lt;- view <span class="nottickedoff">Setup.croTags</span></span>
<span class="lineno"> 1386 </span><span class="spaces">  </span><span class="istickedoff">let <span class="nottickedoff">md = MS.ConditionMetadata</span></span>
<span class="lineno"> 1387 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">{ MS.conditionLoc = loc</span></span>
<span class="lineno"> 1388 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionTags = tags</span></span>
<span class="lineno"> 1389 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionType = &quot;specification assertion&quot;</span></span>
<span class="lineno"> 1390 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionContext = &quot;&quot;</span></span>
<span class="lineno"> 1391 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">}</span></span>
<span class="lineno"> 1392 </span><span class="spaces">  </span><span class="istickedoff">Setup.addCondition (MS.SetupCond_Pred <span class="nottickedoff">md</span> term)</span></span>
<span class="lineno"> 1393 </span>
<span class="lineno"> 1394 </span>jvm_precond :: TypedTerm -&gt; JVMSetupM ()
<span class="lineno"> 1395 </span><span class="decl"><span class="istickedoff">jvm_precond term = JVMSetupM $ do</span>
<span class="lineno"> 1396 </span><span class="spaces">  </span><span class="istickedoff">loc &lt;- SS.toW4Loc &quot;jvm_precond&quot; &lt;$&gt; lift (lift getPosition)</span>
<span class="lineno"> 1397 </span><span class="spaces">  </span><span class="istickedoff">Setup.crucible_precond loc term</span></span>
<span class="lineno"> 1398 </span>
<span class="lineno"> 1399 </span>jvm_postcond :: TypedTerm -&gt; JVMSetupM ()
<span class="lineno"> 1400 </span><span class="decl"><span class="nottickedoff">jvm_postcond term = JVMSetupM $ do</span>
<span class="lineno"> 1401 </span><span class="spaces">  </span><span class="nottickedoff">loc &lt;- SS.toW4Loc &quot;jvm_postcond&quot; &lt;$&gt; lift (lift getPosition)</span>
<span class="lineno"> 1402 </span><span class="spaces">  </span><span class="nottickedoff">Setup.crucible_postcond loc term</span></span>
<span class="lineno"> 1403 </span>
<span class="lineno"> 1404 </span>jvm_execute_func :: [SetupValue] -&gt; JVMSetupM ()
<span class="lineno"> 1405 </span><span class="decl"><span class="istickedoff">jvm_execute_func args =</span>
<span class="lineno"> 1406 </span><span class="spaces">  </span><span class="istickedoff">JVMSetupM $</span>
<span class="lineno"> 1407 </span><span class="spaces">  </span><span class="istickedoff">do st &lt;- get</span>
<span class="lineno"> 1408 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">cc = st ^. Setup.csCrucibleContext</span></span>
<span class="lineno"> 1409 </span><span class="spaces">     </span><span class="istickedoff">let mspec = st ^. Setup.csMethodSpec</span>
<span class="lineno"> 1410 </span><span class="spaces">     </span><span class="istickedoff">let env = MS.csAllocations mspec</span>
<span class="lineno"> 1411 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">nameEnv = MS.csTypeNames mspec</span></span>
<span class="lineno"> 1412 </span><span class="spaces">     </span><span class="istickedoff">let argTys = mspec ^. MS.csArgs</span>
<span class="lineno"> 1413 </span><span class="spaces">     </span><span class="istickedoff">let</span>
<span class="lineno"> 1414 </span><span class="spaces">       </span><span class="istickedoff">checkArg i expectedTy val =</span>
<span class="lineno"> 1415 </span><span class="spaces">         </span><span class="istickedoff">do valTy &lt;- typeOfSetupValue <span class="nottickedoff">cc</span> env <span class="nottickedoff">nameEnv</span> val</span>
<span class="lineno"> 1416 </span><span class="spaces">            </span><span class="istickedoff">unless (registerCompatible expectedTy valTy) $</span>
<span class="lineno"> 1417 </span><span class="spaces">              </span><span class="istickedoff">X.throwM (JVMArgTypeMismatch i expectedTy valTy)</span>
<span class="lineno"> 1418 </span><span class="spaces">     </span><span class="istickedoff">let</span>
<span class="lineno"> 1419 </span><span class="spaces">       </span><span class="istickedoff">checkArgs _ [] [] = pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 1420 </span><span class="spaces">       </span><span class="istickedoff">checkArgs i [] vals =</span>
<span class="lineno"> 1421 </span><span class="spaces">         </span><span class="istickedoff">X.throwM (JVMArgNumberWrong i (i + length vals))</span>
<span class="lineno"> 1422 </span><span class="spaces">       </span><span class="istickedoff">checkArgs i tys [] =</span>
<span class="lineno"> 1423 </span><span class="spaces">         </span><span class="istickedoff">X.throwM (JVMArgNumberWrong (i + length tys) i)</span>
<span class="lineno"> 1424 </span><span class="spaces">       </span><span class="istickedoff">checkArgs i (ty : tys) (val : vals) =</span>
<span class="lineno"> 1425 </span><span class="spaces">         </span><span class="istickedoff">do checkArg i ty val</span>
<span class="lineno"> 1426 </span><span class="spaces">            </span><span class="istickedoff">checkArgs (i + 1) tys vals</span>
<span class="lineno"> 1427 </span><span class="spaces">     </span><span class="istickedoff">checkArgs 0 argTys args</span>
<span class="lineno"> 1428 </span><span class="spaces">     </span><span class="istickedoff">Setup.crucible_execute_func args</span></span>
<span class="lineno"> 1429 </span>
<span class="lineno"> 1430 </span>jvm_return :: SetupValue -&gt; JVMSetupM ()
<span class="lineno"> 1431 </span><span class="decl"><span class="istickedoff">jvm_return retVal =</span>
<span class="lineno"> 1432 </span><span class="spaces">  </span><span class="istickedoff">JVMSetupM $</span>
<span class="lineno"> 1433 </span><span class="spaces">  </span><span class="istickedoff">do st &lt;- get</span>
<span class="lineno"> 1434 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">cc = st ^. Setup.csCrucibleContext</span></span>
<span class="lineno"> 1435 </span><span class="spaces">     </span><span class="istickedoff">let mspec = st ^. Setup.csMethodSpec</span>
<span class="lineno"> 1436 </span><span class="spaces">     </span><span class="istickedoff">let env = MS.csAllocations mspec</span>
<span class="lineno"> 1437 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">nameEnv = MS.csTypeNames mspec</span></span>
<span class="lineno"> 1438 </span><span class="spaces">     </span><span class="istickedoff">valTy &lt;- typeOfSetupValue <span class="nottickedoff">cc</span> env <span class="nottickedoff">nameEnv</span> retVal</span>
<span class="lineno"> 1439 </span><span class="spaces">     </span><span class="istickedoff">case mspec ^. MS.csRet of</span>
<span class="lineno"> 1440 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1441 </span><span class="spaces">         </span><span class="istickedoff">X.throwM (JVMReturnUnexpected valTy)</span>
<span class="lineno"> 1442 </span><span class="spaces">       </span><span class="istickedoff">Just retTy -&gt;</span>
<span class="lineno"> 1443 </span><span class="spaces">         </span><span class="istickedoff">unless (registerCompatible retTy valTy) $</span>
<span class="lineno"> 1444 </span><span class="spaces">         </span><span class="istickedoff">X.throwM (JVMReturnTypeMismatch retTy valTy)</span>
<span class="lineno"> 1445 </span><span class="spaces">     </span><span class="istickedoff">Setup.crucible_return retVal</span></span>
<span class="lineno"> 1446 </span>
<span class="lineno"> 1447 </span>jvm_setup_with_tag ::
<span class="lineno"> 1448 </span>  Text -&gt;
<span class="lineno"> 1449 </span>  JVMSetupM () -&gt;
<span class="lineno"> 1450 </span>  JVMSetupM ()
<span class="lineno"> 1451 </span><span class="decl"><span class="nottickedoff">jvm_setup_with_tag tag m =</span>
<span class="lineno"> 1452 </span><span class="spaces">  </span><span class="nottickedoff">JVMSetupM (Setup.setupWithTag tag (runJVMSetupM m))</span></span>
<span class="lineno"> 1453 </span>
<span class="lineno"> 1454 </span>jvm_ghost_value ::
<span class="lineno"> 1455 </span>  MS.GhostGlobal -&gt;
<span class="lineno"> 1456 </span>  TypedTerm -&gt;
<span class="lineno"> 1457 </span>  JVMSetupM ()
<span class="lineno"> 1458 </span><span class="decl"><span class="nottickedoff">jvm_ghost_value ghost val = JVMSetupM $</span>
<span class="lineno"> 1459 </span><span class="spaces">  </span><span class="nottickedoff">ghost_value ghost val</span></span>
<span class="lineno"> 1460 </span>
<span class="lineno"> 1461 </span>jvm_equal :: SetupValue -&gt; SetupValue -&gt; JVMSetupM ()
<span class="lineno"> 1462 </span><span class="decl"><span class="istickedoff">jvm_equal val1 val2 =</span>
<span class="lineno"> 1463 </span><span class="spaces">  </span><span class="istickedoff">JVMSetupM $</span>
<span class="lineno"> 1464 </span><span class="spaces">  </span><span class="istickedoff">do loc &lt;- getW4Position <span class="nottickedoff">&quot;jvm_equal&quot;</span></span>
<span class="lineno"> 1465 </span><span class="spaces">     </span><span class="istickedoff">st &lt;- get</span>
<span class="lineno"> 1466 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">cc = st ^. Setup.csCrucibleContext</span></span>
<span class="lineno"> 1467 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">env = MS.csAllocations (st ^. Setup.csMethodSpec)</span></span>
<span class="lineno"> 1468 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">nameEnv = MS.csTypeNames (st ^. Setup.csMethodSpec)</span></span>
<span class="lineno"> 1469 </span><span class="spaces">     </span><span class="istickedoff">ty1 &lt;- typeOfSetupValue <span class="nottickedoff">cc</span> <span class="nottickedoff">env</span> <span class="nottickedoff">nameEnv</span> val1</span>
<span class="lineno"> 1470 </span><span class="spaces">     </span><span class="istickedoff">ty2 &lt;- typeOfSetupValue <span class="nottickedoff">cc</span> <span class="nottickedoff">env</span> <span class="nottickedoff">nameEnv</span> val2</span>
<span class="lineno"> 1471 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1472 </span><span class="spaces">     </span><span class="istickedoff">let b = registerCompatible ty1 ty2</span>
<span class="lineno"> 1473 </span><span class="spaces">     </span><span class="istickedoff">unless b $ <span class="nottickedoff">throwCrucibleSetup loc $ unlines</span></span>
<span class="lineno"> 1474 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Incompatible types when asserting equality:&quot;</span></span>
<span class="lineno"> 1475 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">, show ty1</span></span>
<span class="lineno"> 1476 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">, show ty2</span></span>
<span class="lineno"> 1477 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1478 </span><span class="spaces">     </span><span class="istickedoff">Setup.crucible_equal <span class="nottickedoff">loc</span> val1 val2</span></span>
<span class="lineno"> 1479 </span>
<span class="lineno"> 1480 </span>jvm_unint :: [Text] -&gt; JVMSetupM ()
<span class="lineno"> 1481 </span><span class="decl"><span class="nottickedoff">jvm_unint term = JVMSetupM (Setup.declare_unint &quot;jvm_unint&quot; jccUninterp term)</span></span>
<span class="lineno"> 1482 </span>
<span class="lineno"> 1483 </span>--------------------------------------------------------------------------------
<span class="lineno"> 1484 </span>
<span class="lineno"> 1485 </span>-- | Sort a list of things and group them into equivalence classes.
<span class="lineno"> 1486 </span>groupOn ::
<span class="lineno"> 1487 </span>  Ord b =&gt;
<span class="lineno"> 1488 </span>  (a -&gt; b) {- ^ equivalence class projection -} -&gt;
<span class="lineno"> 1489 </span>  [a] -&gt; [NonEmpty a]
<span class="lineno"> 1490 </span><span class="decl"><span class="istickedoff">groupOn f = NE.groupBy <span class="nottickedoff">((==) `on` f)</span> . sortBy <span class="nottickedoff">(compare `on` f)</span></span></span>

</pre>
</body>
</html>
