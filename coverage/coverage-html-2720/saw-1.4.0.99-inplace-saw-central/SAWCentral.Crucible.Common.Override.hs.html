<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- |
<span class="lineno">    2 </span>Module      : SAWCentral.Crucible.Common.Override
<span class="lineno">    3 </span>Description : Language-neutral overrides
<span class="lineno">    4 </span>License     : BSD3
<span class="lineno">    5 </span>Maintainer  : langston
<span class="lineno">    6 </span>Stability   : provisional
<span class="lineno">    7 </span>-}
<span class="lineno">    8 </span>
<span class="lineno">    9 </span>{-# LANGUAGE DataKinds #-}
<span class="lineno">   10 </span>{-# LANGUAGE DeriveGeneric #-}
<span class="lineno">   11 </span>{-# LANGUAGE FlexibleContexts #-}
<span class="lineno">   12 </span>{-# LANGUAGE GADTs #-}
<span class="lineno">   13 </span>{-# LANGUAGE GeneralizedNewtypeDeriving #-}
<span class="lineno">   14 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">   15 </span>{-# LANGUAGE MultiParamTypeClasses #-}
<span class="lineno">   16 </span>{-# LANGUAGE RankNTypes #-}
<span class="lineno">   17 </span>{-# LANGUAGE StandaloneDeriving #-}
<span class="lineno">   18 </span>{-# LANGUAGE TemplateHaskell #-}
<span class="lineno">   19 </span>{-# LANGUAGE TypeFamilies #-}
<span class="lineno">   20 </span>{-# LANGUAGE UndecidableInstances #-}
<span class="lineno">   21 </span>
<span class="lineno">   22 </span>module SAWCentral.Crucible.Common.Override
<span class="lineno">   23 </span>  ( Pointer
<span class="lineno">   24 </span>  , MS.Pointer'
<span class="lineno">   25 </span>  , OverrideState
<span class="lineno">   26 </span>  , OverrideState'(..)
<span class="lineno">   27 </span>  , osAsserts
<span class="lineno">   28 </span>  , osAssumes
<span class="lineno">   29 </span>  , osFree
<span class="lineno">   30 </span>  , osLocation
<span class="lineno">   31 </span>  , overrideGlobals
<span class="lineno">   32 </span>  , syminterface
<span class="lineno">   33 </span>  , setupValueSub
<span class="lineno">   34 </span>  , termSub
<span class="lineno">   35 </span>  , termEqs
<span class="lineno">   36 </span>  --
<span class="lineno">   37 </span>  , OverrideEnv
<span class="lineno">   38 </span>  , OverrideEnv'(..)
<span class="lineno">   39 </span>  , oeConditionalPred
<span class="lineno">   40 </span>  --
<span class="lineno">   41 </span>  , OverrideFailureReason(..)
<span class="lineno">   42 </span>  , ppOverrideFailureReason
<span class="lineno">   43 </span>  , OverrideFailure(..)
<span class="lineno">   44 </span>  , ppOverrideFailure
<span class="lineno">   45 </span>  --
<span class="lineno">   46 </span>  , OverrideMatcher
<span class="lineno">   47 </span>  , OverrideMatcher'(..)
<span class="lineno">   48 </span>  , throwOverrideMatcher
<span class="lineno">   49 </span>  , runOverrideMatcher
<span class="lineno">   50 </span>  , RO
<span class="lineno">   51 </span>  , RW
<span class="lineno">   52 </span>  , addTermEq
<span class="lineno">   53 </span>  , addAssert
<span class="lineno">   54 </span>  , addAssume
<span class="lineno">   55 </span>  , withConditionalPred
<span class="lineno">   56 </span>  , readGlobal
<span class="lineno">   57 </span>  , writeGlobal
<span class="lineno">   58 </span>  , failure
<span class="lineno">   59 </span>  , getSymInterface
<span class="lineno">   60 </span>  , enforceCompleteSubstitution
<span class="lineno">   61 </span>  , refreshTerms
<span class="lineno">   62 </span>  , OverrideWithPreconditions(..)
<span class="lineno">   63 </span>  , owpPreconditions
<span class="lineno">   64 </span>  , owpMethodSpec
<span class="lineno">   65 </span>  , partitionOWPsConcrete
<span class="lineno">   66 </span>  , partitionBySymbolicPreds
<span class="lineno">   67 </span>  , findFalsePreconditions
<span class="lineno">   68 </span>  , unsatPreconditions
<span class="lineno">   69 </span>  , ppConcreteFailure
<span class="lineno">   70 </span>  --
<span class="lineno">   71 </span>  , assignmentToList
<span class="lineno">   72 </span>  , MetadataMap
<span class="lineno">   73 </span>  --
<span class="lineno">   74 </span>  , learnGhost
<span class="lineno">   75 </span>  , executeGhost
<span class="lineno">   76 </span>  , instantiateExtMatchTerm
<span class="lineno">   77 </span>  , matchTerm
<span class="lineno">   78 </span>  ) where
<span class="lineno">   79 </span>
<span class="lineno">   80 </span>import qualified Control.Exception as X
<span class="lineno">   81 </span>import           Control.Lens
<span class="lineno">   82 </span>import           Control.Monad (foldM, unless, when)
<span class="lineno">   83 </span>import           Control.Monad.Reader (MonadReader(..), ReaderT(..))
<span class="lineno">   84 </span>import           Control.Monad.Trans.State hiding (get, put)
<span class="lineno">   85 </span>import           Control.Monad.State.Class (MonadState(..))
<span class="lineno">   86 </span>import           Control.Monad.Error.Class (MonadError)
<span class="lineno">   87 </span>import           Control.Monad.Catch (MonadThrow)
<span class="lineno">   88 </span>import qualified Control.Monad.Fail as Fail
<span class="lineno">   89 </span>import           Control.Monad.Trans.Except
<span class="lineno">   90 </span>import           Control.Monad.Trans.Class
<span class="lineno">   91 </span>import           Control.Monad.IO.Class
<span class="lineno">   92 </span>import qualified Data.IntMap as IntMap
<span class="lineno">   93 </span>import           Data.IntMap (IntMap)
<span class="lineno">   94 </span>import qualified Data.Map as Map
<span class="lineno">   95 </span>import           Data.Map (Map)
<span class="lineno">   96 </span>import           Data.Maybe (fromMaybe)
<span class="lineno">   97 </span>import           Data.Proxy (Proxy(..))
<span class="lineno">   98 </span>import qualified Data.Set as Set
<span class="lineno">   99 </span>import           Data.Set (Set)
<span class="lineno">  100 </span>import           Data.Typeable (Typeable)
<span class="lineno">  101 </span>import           Data.Void
<span class="lineno">  102 </span>import           GHC.Generics (Generic, Generic1)
<span class="lineno">  103 </span>import qualified Prettyprinter as PP
<span class="lineno">  104 </span>
<span class="lineno">  105 </span>import qualified Data.Parameterized.Context as Ctx
<span class="lineno">  106 </span>import           Data.Parameterized.Some (Some)
<span class="lineno">  107 </span>import           Data.Parameterized.TraversableFC (toListFC)
<span class="lineno">  108 </span>
<span class="lineno">  109 </span>import qualified SAWSupport.Pretty as PPS (defaultOpts, limitMaxDepth)
<span class="lineno">  110 </span>
<span class="lineno">  111 </span>import           SAWCore.Name (VarName(..))
<span class="lineno">  112 </span>import           SAWCore.Prelude as SAWVerifier (scEq)
<span class="lineno">  113 </span>import           SAWCore.SharedTerm as SAWVerifier
<span class="lineno">  114 </span>import           SAWCore.Term.Pretty (ppTerm, scPrettyTerm)
<span class="lineno">  115 </span>import           SAWCore.Term.Raw (unwrapTermF)
<span class="lineno">  116 </span>import           CryptolSAWCore.TypedTerm as SAWVerifier
<span class="lineno">  117 </span>
<span class="lineno">  118 </span>import qualified Cryptol.Utils.PP as Cryptol (pp)
<span class="lineno">  119 </span>
<span class="lineno">  120 </span>import qualified Lang.Crucible.Backend as Crucible
<span class="lineno">  121 </span>import qualified Lang.Crucible.Backend.Online as Crucible
<span class="lineno">  122 </span>import qualified Lang.Crucible.CFG.Core as Crucible (TypeRepr, GlobalVar)
<span class="lineno">  123 </span>import qualified Lang.Crucible.Simulator.GlobalState as Crucible
<span class="lineno">  124 </span>import qualified Lang.Crucible.Simulator.RegMap as Crucible
<span class="lineno">  125 </span>import qualified Lang.Crucible.Simulator.SimError as Crucible
<span class="lineno">  126 </span>
<span class="lineno">  127 </span>import qualified What4.Interface as W4
<span class="lineno">  128 </span>import qualified What4.LabeledPred as W4
<span class="lineno">  129 </span>import qualified What4.ProgramLoc as W4
<span class="lineno">  130 </span>
<span class="lineno">  131 </span>import           SAWCentral.Exceptions
<span class="lineno">  132 </span>import           SAWCentral.Crucible.Common (Backend, OnlineSolver, Sym)
<span class="lineno">  133 </span>import           SAWCentral.Crucible.Common.MethodSpec as MS
<span class="lineno">  134 </span>import           SAWCentral.Crucible.Common.Setup.Value as MS
<span class="lineno">  135 </span>import           SAWCentral.Utils (bullets)
<span class="lineno">  136 </span>
<span class="lineno">  137 </span>-- TODO, not sure this is the best place for this definition
<span class="lineno">  138 </span>type MetadataMap =
<span class="lineno">  139 </span>  Map (W4.SymAnnotation Sym W4.BaseBoolType) MS.ConditionMetadata
<span class="lineno">  140 </span>
<span class="lineno">  141 </span>--------------------------------------------------------------------------------
<span class="lineno">  142 </span>-- ** OverrideState
<span class="lineno">  143 </span>
<span class="lineno">  144 </span>type LabeledPred sym = W4.LabeledPred (W4.Pred sym) Crucible.SimError
<span class="lineno">  145 </span>
<span class="lineno">  146 </span>type Pointer ext = MS.Pointer' ext Sym
<span class="lineno">  147 </span>
<span class="lineno">  148 </span>data OverrideState' sym ext = OverrideState
<span class="lineno">  149 </span>  { -- | Substitution for memory allocations
<span class="lineno">  150 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_setupValueSub</span></span></span> :: Map AllocIndex (MS.Pointer' ext sym)
<span class="lineno">  151 </span>
<span class="lineno">  152 </span>    -- | Substitution for SAW Core external constants, keyed by 'VarIndex'
<span class="lineno">  153 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_termSub</span></span></span> :: IntMap Term
<span class="lineno">  154 </span>
<span class="lineno">  155 </span>    -- | Equalities of SAW Core terms. The four elements of each tuple are:
<span class="lineno">  156 </span>    --
<span class="lineno">  157 </span>    -- * A 'W4.Pred' representing the path condition for the part of the
<span class="lineno">  158 </span>    --   program in which the term equality occurs.
<span class="lineno">  159 </span>    --   See @Note [oeConditionalPred]@.
<span class="lineno">  160 </span>    --
<span class="lineno">  161 </span>    -- * A 'Term' representing the term equality.
<span class="lineno">  162 </span>    --
<span class="lineno">  163 </span>    -- * A 'ConditionMetadata' value describing the term equality.
<span class="lineno">  164 </span>    --
<span class="lineno">  165 </span>    -- * A 'Crucible.SimError' to report in the event that the term equality
<span class="lineno">  166 </span>    --   fails to hold.
<span class="lineno">  167 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_termEqs</span></span></span> :: [(W4.Pred sym, Term, ConditionMetadata, Crucible.SimError)]
<span class="lineno">  168 </span>
<span class="lineno">  169 </span>    -- | Free variables available for unification
<span class="lineno">  170 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_osFree</span></span></span> :: Set VarIndex
<span class="lineno">  171 </span>
<span class="lineno">  172 </span>    -- | Accumulated assertions
<span class="lineno">  173 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_osAsserts</span></span></span> :: [(ConditionMetadata, LabeledPred sym)]
<span class="lineno">  174 </span>
<span class="lineno">  175 </span>    -- | Accumulated assumptions
<span class="lineno">  176 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_osAssumes</span></span></span> :: [(ConditionMetadata, W4.Pred sym)]
<span class="lineno">  177 </span>
<span class="lineno">  178 </span>    -- | Symbolic simulation state
<span class="lineno">  179 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_syminterface</span></span></span> :: sym
<span class="lineno">  180 </span>
<span class="lineno">  181 </span>    -- | Global variables
<span class="lineno">  182 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_overrideGlobals</span></span></span> :: Crucible.SymGlobalState sym
<span class="lineno">  183 </span>
<span class="lineno">  184 </span>    -- | Source location to associated with this override
<span class="lineno">  185 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_osLocation</span></span></span> :: W4.ProgramLoc
<span class="lineno">  186 </span>  }
<span class="lineno">  187 </span>
<span class="lineno">  188 </span>type OverrideState = OverrideState' Sym
<span class="lineno">  189 </span>
<span class="lineno">  190 </span><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff">makeLenses ''OverrideState'</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno">  191 </span>
<span class="lineno">  192 </span>-- | The initial override matching state starts with an empty substitution
<span class="lineno">  193 </span>-- and no assertions or assumptions.
<span class="lineno">  194 </span>initialState ::
<span class="lineno">  195 </span>  sym                           {- ^ simulator                      -} -&gt;
<span class="lineno">  196 </span>  Crucible.SymGlobalState sym   {- ^ initial global variables       -} -&gt;
<span class="lineno">  197 </span>  Map AllocIndex (Pointer' ext sym) {- ^ initial allocation substituion -} -&gt;
<span class="lineno">  198 </span>  IntMap Term                   {- ^ initial term substitution      -} -&gt;
<span class="lineno">  199 </span>  Set VarIndex                  {- ^ initial free terms             -} -&gt;
<span class="lineno">  200 </span>  W4.ProgramLoc                 {- ^ location information for the override -} -&gt;
<span class="lineno">  201 </span>  OverrideState' sym ext
<span class="lineno">  202 </span><span class="decl"><span class="istickedoff">initialState sym globals allocs terms free loc = OverrideState</span>
<span class="lineno">  203 </span><span class="spaces">  </span><span class="istickedoff">{ _osAsserts       = []</span>
<span class="lineno">  204 </span><span class="spaces">  </span><span class="istickedoff">, _osAssumes       = []</span>
<span class="lineno">  205 </span><span class="spaces">  </span><span class="istickedoff">, _syminterface    = sym</span>
<span class="lineno">  206 </span><span class="spaces">  </span><span class="istickedoff">, _overrideGlobals = globals</span>
<span class="lineno">  207 </span><span class="spaces">  </span><span class="istickedoff">, _termSub         = terms</span>
<span class="lineno">  208 </span><span class="spaces">  </span><span class="istickedoff">, _termEqs         = []</span>
<span class="lineno">  209 </span><span class="spaces">  </span><span class="istickedoff">, _osFree          = free</span>
<span class="lineno">  210 </span><span class="spaces">  </span><span class="istickedoff">, _setupValueSub   = allocs</span>
<span class="lineno">  211 </span><span class="spaces">  </span><span class="istickedoff">, _osLocation      = loc</span>
<span class="lineno">  212 </span><span class="spaces">  </span><span class="istickedoff">}</span></span>
<span class="lineno">  213 </span>
<span class="lineno">  214 </span>--------------------------------------------------------------------------------
<span class="lineno">  215 </span>-- ** OverrideEnv
<span class="lineno">  216 </span>
<span class="lineno">  217 </span>-- | The environment used in the reader portion of `OverrideMatcher'`.
<span class="lineno">  218 </span>newtype OverrideEnv' sym = OverrideEnv
<span class="lineno">  219 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_oeConditionalPred</span></span></span> :: W4.Pred sym
<span class="lineno">  220 </span>    -- ^ The predicate that is used to construct an implication for any
<span class="lineno">  221 </span>    --   assumption or assertion as part of the specification.
<span class="lineno">  222 </span>    --   See @Note [oeConditionalPred]@.
<span class="lineno">  223 </span>  }
<span class="lineno">  224 </span>
<span class="lineno">  225 </span>-- | `OverrideEnv'` instantiated at type 'Sym'.
<span class="lineno">  226 </span>type OverrideEnv = OverrideEnv' Sym
<span class="lineno">  227 </span>
<span class="lineno">  228 </span><span class="istickedoff"><span class="decl"><span class="istickedoff">makeLenses ''OverrideEnv'</span></span></span>
<span class="lineno">  229 </span>
<span class="lineno">  230 </span>-- | The initial override matching environment starts with a trivial path
<span class="lineno">  231 </span>-- condition of @True@ (i.e., 'W4.truePred). See @Note [oeConditionalPred]@.
<span class="lineno">  232 </span>initialEnv ::
<span class="lineno">  233 </span>  W4.IsExprBuilder sym =&gt;
<span class="lineno">  234 </span>  sym -&gt;
<span class="lineno">  235 </span>  OverrideEnv' sym
<span class="lineno">  236 </span><span class="decl"><span class="istickedoff">initialEnv sym = OverrideEnv</span>
<span class="lineno">  237 </span><span class="spaces">  </span><span class="istickedoff">{ _oeConditionalPred = W4.truePred sym</span>
<span class="lineno">  238 </span><span class="spaces">  </span><span class="istickedoff">}</span></span>
<span class="lineno">  239 </span>
<span class="lineno">  240 </span>{-
<span class="lineno">  241 </span>Note [oeConditionalPred]
<span class="lineno">  242 </span>~~~~~~~~~~~~~~~~~~~~~~~~
<span class="lineno">  243 </span>oeConditionalPred is a predicate that is used to construct an implication for
<span class="lineno">  244 </span>any assumption or assertion used in a specification. That is, oeConditionalPred
<span class="lineno">  245 </span>can be thought of as the path condition for the part of the specification where
<span class="lineno">  246 </span>the assumption/assertion is created. By default, the oeConditionalPred is
<span class="lineno">  247 </span>simply `True` (see `initialEnv`), so when an assertion is created, e.g.,
<span class="lineno">  248 </span>
<span class="lineno">  249 </span>  llvm_assert {{ x == 2*y }};
<span class="lineno">  250 </span>
<span class="lineno">  251 </span>Then the overall assertion would be `True ==&gt; (x == 2*y)`. An implication with
<span class="lineno">  252 </span>`True` as the premise is not very interesting, of course, but other parts of
<span class="lineno">  253 </span>the program may add additional premises (see the `withConditionalPred`
<span class="lineno">  254 </span>function).
<span class="lineno">  255 </span>
<span class="lineno">  256 </span>Currently, the only place in SAW where non-trivial `oeConditionalPred`s are
<span class="lineno">  257 </span>added is when matching against an `llvm_conditional_points_to` statement. For
<span class="lineno">  258 </span>instance, consider this spec (taken from #1945):
<span class="lineno">  259 </span>
<span class="lineno">  260 </span>  let test_spec = do {
<span class="lineno">  261 </span>    p &lt;- llvm_alloc (llvm_int 8);
<span class="lineno">  262 </span>    x &lt;- llvm_fresh_var &quot;x&quot; (llvm_int 8);
<span class="lineno">  263 </span>    llvm_points_to p (llvm_term x);
<span class="lineno">  264 </span>
<span class="lineno">  265 </span>    llvm_execute_func [p];
<span class="lineno">  266 </span>
<span class="lineno">  267 </span>    llvm_conditional_points_to {{ x == 1 }} p (llvm_term {{ 1 : [8] }});
<span class="lineno">  268 </span>  };
<span class="lineno">  269 </span>
<span class="lineno">  270 </span>The `llvm_conditional_points_to` statement in the postcondition generates an
<span class="lineno">  271 </span>assertion that checks `x` (the value that `p` points to) against `1 : [8]`. But
<span class="lineno">  272 </span>we only want to check this under the assumption that `x` already equals `1` due
<span class="lineno">  273 </span>to the `x == 1` part of the `llvm_conditional_points_to` statement. To do this,
<span class="lineno">  274 </span>the implementation of `llvm_conditional_points_to` will add `x == 1` to the
<span class="lineno">  275 </span>oeConditionalPred. This way, the assertion that gets generated will be:
<span class="lineno">  276 </span>
<span class="lineno">  277 </span>  (x == 1 /\ True) ==&gt; (x == 1)
<span class="lineno">  278 </span>
<span class="lineno">  279 </span>Here, leaving out the (x == 1) premise would be catastrophic, as that would
<span class="lineno">  280 </span>result in the far more general assertion `True ==&gt; (x == 1)`. (This was
<span class="lineno">  281 </span>ultimately the cause of #1945.)
<span class="lineno">  282 </span>-}
<span class="lineno">  283 </span>
<span class="lineno">  284 </span>--------------------------------------------------------------------------------
<span class="lineno">  285 </span>-- ** OverrideFailureReason
<span class="lineno">  286 </span>
<span class="lineno">  287 </span>data OverrideFailureReason ext
<span class="lineno">  288 </span>  = AmbiguousPointsTos [MS.PointsTo ext]
<span class="lineno">  289 </span>  | AmbiguousVars [TypedVariable]
<span class="lineno">  290 </span>  | BadTermMatch Term Term -- ^ simulated and specified terms did not match
<span class="lineno">  291 </span>  | BadPointerCast -- ^ Pointer required to process points-to
<span class="lineno">  292 </span>  | BadReturnSpecification (Some Crucible.TypeRepr)
<span class="lineno">  293 </span>    -- ^ type mismatch in return specification
<span class="lineno">  294 </span>  | NonlinearPatternNotSupported
<span class="lineno">  295 </span>  | BadEqualityComparison -- ^ Comparison on an undef value
<span class="lineno">  296 </span>  | BadPointerLoad (Either (MS.PointsTo ext) (PP.Doc Void)) (PP.Doc Void)
<span class="lineno">  297 </span>    -- ^ @loadRaw@ failed due to type error
<span class="lineno">  298 </span>  | StructuralMismatch (PP.Doc Void) (PP.Doc Void) (Maybe (ExtType ext)) (ExtType ext)
<span class="lineno">  299 </span>    -- ^
<span class="lineno">  300 </span>    -- * pretty-printed simulated value
<span class="lineno">  301 </span>    -- * pretty-printed specified value
<span class="lineno">  302 </span>    -- * type of specified value
<span class="lineno">  303 </span>    -- * type of simulated value
<span class="lineno">  304 </span>
<span class="lineno">  305 </span>instance <span class="decl"><span class="nottickedoff">( PP.Pretty (ExtType ext)</span>
<span class="lineno">  306 </span><span class="spaces">         </span><span class="nottickedoff">, PP.Pretty (MS.PointsTo ext)</span>
<span class="lineno">  307 </span><span class="spaces">         </span><span class="nottickedoff">) =&gt; PP.Pretty (OverrideFailureReason ext)</span></span> where
<span class="lineno">  308 </span>  <span class="decl"><span class="nottickedoff">pretty = ppOverrideFailureReason</span></span>
<span class="lineno">  309 </span>
<span class="lineno">  310 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">( PP.Pretty (ExtType ext)</span>
<span class="lineno">  311 </span><span class="spaces">         </span><span class="nottickedoff">, PP.Pretty (MS.PointsTo ext)</span>
<span class="lineno">  312 </span><span class="spaces">         </span><span class="nottickedoff">) =&gt; Show (OverrideFailureReason ext)</span></span></span></span> where
<span class="lineno">  313 </span>  <span class="decl"><span class="nottickedoff">show = show . PP.pretty</span></span>
<span class="lineno">  314 </span>
<span class="lineno">  315 </span>ppOverrideFailureReason ::
<span class="lineno">  316 </span>  ( PP.Pretty (ExtType ext)
<span class="lineno">  317 </span>  , PP.Pretty (MS.PointsTo ext)
<span class="lineno">  318 </span>  ) =&gt; OverrideFailureReason ext -&gt; PP.Doc ann
<span class="lineno">  319 </span><span class="decl"><span class="istickedoff">ppOverrideFailureReason rsn = case rsn of</span>
<span class="lineno">  320 </span><span class="spaces">  </span><span class="istickedoff">AmbiguousPointsTos pts -&gt;</span>
<span class="lineno">  321 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">PP.vcat</span></span>
<span class="lineno">  322 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ PP.pretty &quot;LHS of points-to assertion(s) not reachable via points-tos from inputs/outputs:&quot;</span></span>
<span class="lineno">  323 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, PP.indent 2 $ PP.vcat (map PP.pretty pts)</span></span>
<span class="lineno">  324 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  325 </span><span class="spaces">  </span><span class="istickedoff">AmbiguousVars vs -&gt;</span>
<span class="lineno">  326 </span><span class="spaces">    </span><span class="istickedoff">PP.vcat</span>
<span class="lineno">  327 </span><span class="spaces">    </span><span class="istickedoff">[ PP.pretty &quot;Fresh variable(s) not reachable via points-tos from function inputs/outputs:&quot;</span>
<span class="lineno">  328 </span><span class="spaces">    </span><span class="istickedoff">, PP.indent 2 $ PP.vcat (map ppTypedVariable vs)</span>
<span class="lineno">  329 </span><span class="spaces">    </span><span class="istickedoff">]</span>
<span class="lineno">  330 </span><span class="spaces">  </span><span class="istickedoff">BadTermMatch x y -&gt;</span>
<span class="lineno">  331 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">PP.vcat</span></span>
<span class="lineno">  332 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ PP.pretty &quot;terms do not match&quot;</span></span>
<span class="lineno">  333 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, PP.indent 2 (PP.unAnnotate (ppTerm PPS.defaultOpts x))</span></span>
<span class="lineno">  334 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, PP.indent 2 (PP.unAnnotate (ppTerm PPS.defaultOpts y))</span></span>
<span class="lineno">  335 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  336 </span><span class="spaces">  </span><span class="istickedoff">BadPointerCast -&gt;</span>
<span class="lineno">  337 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">PP.pretty &quot;bad pointer cast&quot;</span></span>
<span class="lineno">  338 </span><span class="spaces">  </span><span class="istickedoff">BadReturnSpecification ty -&gt;</span>
<span class="lineno">  339 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">PP.vcat</span></span>
<span class="lineno">  340 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ PP.pretty &quot;Spec had no return value, but the function returns a value of type:&quot;</span></span>
<span class="lineno">  341 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, PP.viaShow ty</span></span>
<span class="lineno">  342 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  343 </span><span class="spaces">  </span><span class="istickedoff">NonlinearPatternNotSupported -&gt;</span>
<span class="lineno">  344 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">PP.pretty &quot;nonlinear pattern not supported&quot;</span></span>
<span class="lineno">  345 </span><span class="spaces">  </span><span class="istickedoff">BadEqualityComparison -&gt;</span>
<span class="lineno">  346 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">PP.pretty &quot;value containing `undef` compared for equality&quot;</span></span>
<span class="lineno">  347 </span><span class="spaces">  </span><span class="istickedoff">BadPointerLoad pointsTo msg -&gt;</span>
<span class="lineno">  348 </span><span class="spaces">    </span><span class="istickedoff">PP.vcat</span>
<span class="lineno">  349 </span><span class="spaces">    </span><span class="istickedoff">[ PP.pretty &quot;error when loading through pointer that&quot; PP.&lt;+&gt;</span>
<span class="lineno">  350 </span><span class="spaces">      </span><span class="istickedoff">PP.pretty &quot;appeared in the override's points-to precondition(s):&quot;</span>
<span class="lineno">  351 </span><span class="spaces">    </span><span class="istickedoff">, PP.pretty &quot;Precondition:&quot;</span>
<span class="lineno">  352 </span><span class="spaces">    </span><span class="istickedoff">, PP.indent 2 (either <span class="nottickedoff">PP.pretty</span> PP.unAnnotate pointsTo)</span>
<span class="lineno">  353 </span><span class="spaces">    </span><span class="istickedoff">, PP.pretty &quot;Failure reason: &quot;</span>
<span class="lineno">  354 </span><span class="spaces">    </span><span class="istickedoff">, PP.indent 2 (PP.unAnnotate msg) -- this can be long</span>
<span class="lineno">  355 </span><span class="spaces">    </span><span class="istickedoff">]</span>
<span class="lineno">  356 </span><span class="spaces">  </span><span class="istickedoff">StructuralMismatch simVal setupVal setupValTy ty -&gt;</span>
<span class="lineno">  357 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">PP.vcat</span></span>
<span class="lineno">  358 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ PP.pretty &quot;could not match specified value with actual value:&quot;</span></span>
<span class="lineno">  359 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, PP.vcat (map (PP.indent 2) $</span></span>
<span class="lineno">  360 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">[ PP.pretty &quot;actual (simulator) value:&quot; PP.&lt;+&gt; PP.unAnnotate simVal</span></span>
<span class="lineno">  361 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, PP.pretty &quot;specified value:         &quot; PP.&lt;+&gt; PP.unAnnotate setupVal</span></span>
<span class="lineno">  362 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, PP.pretty &quot;type of actual value:   &quot; PP.&lt;+&gt; PP.pretty ty</span></span>
<span class="lineno">  363 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">] ++ let msg ty_ =</span></span>
<span class="lineno">  364 </span><span class="spaces">                         </span><span class="istickedoff"><span class="nottickedoff">[PP.pretty &quot;type of specified value:&quot;</span></span>
<span class="lineno">  365 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">PP.&lt;+&gt; PP.pretty ty_]</span></span>
<span class="lineno">  366 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">in maybe [] msg setupValTy)</span></span>
<span class="lineno">  367 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno">  368 </span>
<span class="lineno">  369 </span>--------------------------------------------------------------------------------
<span class="lineno">  370 </span>-- ** OverrideFailure
<span class="lineno">  371 </span>
<span class="lineno">  372 </span>data OverrideFailure ext = OF W4.ProgramLoc (OverrideFailureReason ext)
<span class="lineno">  373 </span>
<span class="lineno">  374 </span>ppOverrideFailure :: ( PP.Pretty (ExtType ext)
<span class="lineno">  375 </span>                     , PP.Pretty (MS.PointsTo ext)
<span class="lineno">  376 </span>                     ) =&gt; OverrideFailure ext -&gt; PP.Doc ann
<span class="lineno">  377 </span><span class="decl"><span class="istickedoff">ppOverrideFailure (OF loc rsn) =</span>
<span class="lineno">  378 </span><span class="spaces">  </span><span class="istickedoff">PP.vcat</span>
<span class="lineno">  379 </span><span class="spaces">  </span><span class="istickedoff">[ PP.pretty &quot;at&quot; PP.&lt;+&gt; PP.viaShow (W4.plSourceLoc loc) -- TODO: fix when what4 switches to prettyprinter</span>
<span class="lineno">  380 </span><span class="spaces">  </span><span class="istickedoff">, ppOverrideFailureReason rsn</span>
<span class="lineno">  381 </span><span class="spaces">  </span><span class="istickedoff">]</span></span>
<span class="lineno">  382 </span>
<span class="lineno">  383 </span>instance <span class="decl"><span class="nottickedoff">( PP.Pretty (ExtType ext)</span>
<span class="lineno">  384 </span><span class="spaces">         </span><span class="nottickedoff">, PP.Pretty (MS.PointsTo ext)</span>
<span class="lineno">  385 </span><span class="spaces">         </span><span class="nottickedoff">) =&gt; PP.Pretty (OverrideFailure ext)</span></span> where
<span class="lineno">  386 </span>  <span class="decl"><span class="nottickedoff">pretty = ppOverrideFailure</span></span>
<span class="lineno">  387 </span>
<span class="lineno">  388 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">( PP.Pretty (ExtType ext)</span>
<span class="lineno">  389 </span><span class="spaces">         </span><span class="nottickedoff">, PP.Pretty (MS.PointsTo ext)</span>
<span class="lineno">  390 </span><span class="spaces">         </span><span class="nottickedoff">) =&gt; Show (OverrideFailure ext)</span></span></span></span> where
<span class="lineno">  391 </span>  <span class="decl"><span class="nottickedoff">show = show . PP.pretty</span></span>
<span class="lineno">  392 </span>
<span class="lineno">  393 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">( PP.Pretty (ExtType ext)</span>
<span class="lineno">  394 </span><span class="spaces">         </span><span class="nottickedoff">, PP.Pretty (MS.PointsTo ext)</span>
<span class="lineno">  395 </span><span class="spaces">         </span><span class="nottickedoff">, Typeable ext</span>
<span class="lineno">  396 </span><span class="spaces">         </span><span class="nottickedoff">) =&gt; X.Exception (OverrideFailure ext)</span></span></span></span></span></span>
<span class="lineno">  397 </span>
<span class="lineno">  398 </span>--------------------------------------------------------------------------------
<span class="lineno">  399 </span>-- ** OverrideMatcher
<span class="lineno">  400 </span>
<span class="lineno">  401 </span>data RO
<span class="lineno">  402 </span>data RW
<span class="lineno">  403 </span>
<span class="lineno">  404 </span>-- | The 'OverrideMatcher' type provides the operations that are needed
<span class="lineno">  405 </span>-- to match a specification's arguments with the arguments provided by
<span class="lineno">  406 </span>-- the Crucible simulation in order to compute the variable substitution
<span class="lineno">  407 </span>-- and side-conditions needed to proceed.
<span class="lineno">  408 </span>newtype OverrideMatcher' sym ext rorw m a =
<span class="lineno">  409 </span>  OM (ReaderT (OverrideEnv' sym) (StateT (OverrideState' sym ext) (ExceptT (OverrideFailure ext) m)) a)
<span class="lineno">  410 </span>  deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Applicative</span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Functor</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic1</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Monad</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff">MonadIO</span></span>, <span class="decl"><span class="nottickedoff">MonadThrow</span></span>)
<span class="lineno">  411 </span>
<span class="lineno">  412 </span>type OverrideMatcher ext rorw a = OverrideMatcher' Sym ext rorw IO a
<span class="lineno">  413 </span>
<span class="lineno">  414 </span>instance <span class="decl"><span class="nottickedoff">Wrapped (OverrideMatcher' sym ext rorw m a)</span></span> where
<span class="lineno">  415 </span>
<span class="lineno">  416 </span><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">deriving instance Monad m =&gt; MonadReader (OverrideEnv' sym) (OverrideMatcher' sym ext rorw m)</span></span></span></span></span></span>
<span class="lineno">  417 </span><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving instance Monad m =&gt; MonadState (OverrideState' sym ext) (OverrideMatcher' sym ext rorw m)</span></span></span></span></span></span>
<span class="lineno">  418 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving instance Monad m =&gt; MonadError (OverrideFailure ext) (OverrideMatcher' sym ext rorw m)</span></span></span></span>
<span class="lineno">  419 </span>
<span class="lineno">  420 </span>instance MonadTrans (OverrideMatcher' sym ext rorw) where
<span class="lineno">  421 </span>    <span class="decl"><span class="nottickedoff">lift f = OM $ lift $ lift $ lift f</span></span>
<span class="lineno">  422 </span>
<span class="lineno">  423 </span>throwOverrideMatcher :: Monad m =&gt; String -&gt; OverrideMatcher' sym ext rorw m a
<span class="lineno">  424 </span><span class="decl"><span class="istickedoff">throwOverrideMatcher msg = do</span>
<span class="lineno">  425 </span><span class="spaces">  </span><span class="istickedoff">loc &lt;- use osLocation</span>
<span class="lineno">  426 </span><span class="spaces">  </span><span class="istickedoff">X.throw $ OverrideMatcherException <span class="nottickedoff">loc</span> msg</span></span>
<span class="lineno">  427 </span>
<span class="lineno">  428 </span>instance Monad m =&gt; Fail.MonadFail (OverrideMatcher' sym ext rorw m) where
<span class="lineno">  429 </span>  <span class="decl"><span class="istickedoff">fail = throwOverrideMatcher</span></span>
<span class="lineno">  430 </span>
<span class="lineno">  431 </span>-- | &quot;Run&quot; function for OverrideMatcher. The final result and state
<span class="lineno">  432 </span>-- are returned. The state will contain the updated globals and substitutions
<span class="lineno">  433 </span>runOverrideMatcher ::
<span class="lineno">  434 </span>   (Monad m, W4.IsExprBuilder sym) =&gt;
<span class="lineno">  435 </span>   sym                         {- ^ simulator                       -} -&gt;
<span class="lineno">  436 </span>   Crucible.SymGlobalState sym {- ^ initial global variables        -} -&gt;
<span class="lineno">  437 </span>   Map AllocIndex (Pointer' ext sym) {- ^ initial allocation substitution -} -&gt;
<span class="lineno">  438 </span>   IntMap Term                 {- ^ initial term substitution       -} -&gt;
<span class="lineno">  439 </span>   Set VarIndex                {- ^ initial free variables          -} -&gt;
<span class="lineno">  440 </span>   W4.ProgramLoc               {- ^ override location information   -} -&gt;
<span class="lineno">  441 </span>   OverrideMatcher' sym ext md m a {- ^ matching action                 -} -&gt;
<span class="lineno">  442 </span>   m (Either (OverrideFailure ext) (a, OverrideState' sym ext))
<span class="lineno">  443 </span><span class="decl"><span class="istickedoff">runOverrideMatcher sym g a t free loc (OM m) =</span>
<span class="lineno">  444 </span><span class="spaces">  </span><span class="istickedoff">runExceptT (runStateT (runReaderT m (initialEnv sym)) (initialState sym g a t free loc))</span></span>
<span class="lineno">  445 </span>
<span class="lineno">  446 </span>addTermEq ::
<span class="lineno">  447 </span>  Term {- ^ term equality -} -&gt;
<span class="lineno">  448 </span>  ConditionMetadata -&gt;
<span class="lineno">  449 </span>  Crucible.SimError {- ^ reason   -} -&gt;
<span class="lineno">  450 </span>  OverrideMatcher ext rorw ()
<span class="lineno">  451 </span><span class="decl"><span class="istickedoff">addTermEq t md r = do</span>
<span class="lineno">  452 </span><span class="spaces">  </span><span class="istickedoff">env &lt;- ask</span>
<span class="lineno">  453 </span><span class="spaces">  </span><span class="istickedoff">let cond = env ^. oeConditionalPred</span>
<span class="lineno">  454 </span><span class="spaces">  </span><span class="istickedoff">OM (termEqs %= cons (cond, t, md, r))</span></span>
<span class="lineno">  455 </span>
<span class="lineno">  456 </span>addAssert ::
<span class="lineno">  457 </span>  (MonadIO m, W4.IsExprBuilder sym) =&gt;
<span class="lineno">  458 </span>  W4.Pred sym       {- ^ property -} -&gt;
<span class="lineno">  459 </span>  ConditionMetadata -&gt;
<span class="lineno">  460 </span>  Crucible.SimError {- ^ reason   -} -&gt;
<span class="lineno">  461 </span>  OverrideMatcher' sym ext rorw m ()
<span class="lineno">  462 </span><span class="decl"><span class="istickedoff">addAssert p md r = do</span>
<span class="lineno">  463 </span><span class="spaces">  </span><span class="istickedoff">sym &lt;- getSymInterface</span>
<span class="lineno">  464 </span><span class="spaces">  </span><span class="istickedoff">env &lt;- ask</span>
<span class="lineno">  465 </span><span class="spaces">  </span><span class="istickedoff">p' &lt;- liftIO $ W4.impliesPred sym (env ^. oeConditionalPred) p</span>
<span class="lineno">  466 </span><span class="spaces">  </span><span class="istickedoff">OM (osAsserts %= cons (md,W4.LabeledPred p' r))</span></span>
<span class="lineno">  467 </span>
<span class="lineno">  468 </span>addAssume ::
<span class="lineno">  469 </span>  (MonadIO m, W4.IsExprBuilder sym) =&gt;
<span class="lineno">  470 </span>  W4.Pred sym       {- ^ property -} -&gt;
<span class="lineno">  471 </span>  ConditionMetadata -&gt;
<span class="lineno">  472 </span>  OverrideMatcher' sym ext rorw m ()
<span class="lineno">  473 </span><span class="decl"><span class="istickedoff">addAssume p md = do</span>
<span class="lineno">  474 </span><span class="spaces">  </span><span class="istickedoff">sym &lt;- getSymInterface</span>
<span class="lineno">  475 </span><span class="spaces">  </span><span class="istickedoff">env &lt;- ask</span>
<span class="lineno">  476 </span><span class="spaces">  </span><span class="istickedoff">p' &lt;- liftIO $ W4.impliesPred sym (env ^. oeConditionalPred) p</span>
<span class="lineno">  477 </span><span class="spaces">  </span><span class="istickedoff">OM (osAssumes %= cons (<span class="nottickedoff">md</span>,p'))</span></span>
<span class="lineno">  478 </span>
<span class="lineno">  479 </span>-- | Add an additional premise to the path condition when executing an
<span class="lineno">  480 </span>-- `OverrideMatcher'` subcomputation. See @Note [oeConditionalPred]@ for an
<span class="lineno">  481 </span>-- explanation of where this is used.
<span class="lineno">  482 </span>withConditionalPred ::
<span class="lineno">  483 </span>  (MonadIO m, W4.IsExprBuilder sym) =&gt;
<span class="lineno">  484 </span>  W4.Pred sym {- ^ The additional premise -} -&gt;
<span class="lineno">  485 </span>  OverrideMatcher' sym ext rorw m a {- ^ The subcomputation -} -&gt;
<span class="lineno">  486 </span>  OverrideMatcher' sym ext rorw m a
<span class="lineno">  487 </span><span class="decl"><span class="istickedoff">withConditionalPred premise om = do</span>
<span class="lineno">  488 </span><span class="spaces">  </span><span class="istickedoff">sym &lt;- getSymInterface</span>
<span class="lineno">  489 </span><span class="spaces">  </span><span class="istickedoff">env &lt;- ask</span>
<span class="lineno">  490 </span><span class="spaces">  </span><span class="istickedoff">premise' &lt;- liftIO $ W4.andPred <span class="nottickedoff">sym</span> premise (env ^. oeConditionalPred)</span>
<span class="lineno">  491 </span><span class="spaces">  </span><span class="istickedoff">let env' = <span class="nottickedoff">env</span> &amp; oeConditionalPred .~ premise'</span>
<span class="lineno">  492 </span><span class="spaces">  </span><span class="istickedoff">local (const env') om</span></span>
<span class="lineno">  493 </span>
<span class="lineno">  494 </span>readGlobal ::
<span class="lineno">  495 </span>  Monad m =&gt;
<span class="lineno">  496 </span>  Crucible.GlobalVar tp -&gt;
<span class="lineno">  497 </span>  OverrideMatcher' sym ext rorw m (Crucible.RegValue sym tp)
<span class="lineno">  498 </span><span class="decl"><span class="istickedoff">readGlobal k =</span>
<span class="lineno">  499 </span><span class="spaces">  </span><span class="istickedoff">do mb &lt;- OM (uses overrideGlobals (Crucible.lookupGlobal k))</span>
<span class="lineno">  500 </span><span class="spaces">     </span><span class="istickedoff">case mb of</span>
<span class="lineno">  501 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">throwOverrideMatcher (&quot;No such global: &quot; ++ show k)</span></span>
<span class="lineno">  502 </span><span class="spaces">       </span><span class="istickedoff">Just v  -&gt; return v</span></span>
<span class="lineno">  503 </span>
<span class="lineno">  504 </span>writeGlobal ::
<span class="lineno">  505 </span>  Monad m =&gt;
<span class="lineno">  506 </span>  Crucible.GlobalVar    tp -&gt;
<span class="lineno">  507 </span>  Crucible.RegValue sym tp -&gt;
<span class="lineno">  508 </span>  OverrideMatcher' sym ext RW m ()
<span class="lineno">  509 </span><span class="decl"><span class="istickedoff">writeGlobal k v = OM (overrideGlobals %= Crucible.insertGlobal k v)</span></span>
<span class="lineno">  510 </span>
<span class="lineno">  511 </span>-- | Abort the current computation by raising the given 'OverrideFailure'
<span class="lineno">  512 </span>-- exception.
<span class="lineno">  513 </span>failure ::
<span class="lineno">  514 </span>  Monad m =&gt;
<span class="lineno">  515 </span>  W4.ProgramLoc -&gt;
<span class="lineno">  516 </span>  OverrideFailureReason ext -&gt;
<span class="lineno">  517 </span>  OverrideMatcher' sym ext md m a
<span class="lineno">  518 </span><span class="decl"><span class="istickedoff">failure loc e = OM (lift (lift (throwE (OF loc e))))</span></span>
<span class="lineno">  519 </span>
<span class="lineno">  520 </span>getSymInterface :: Monad m =&gt; OverrideMatcher' sym ext md m sym
<span class="lineno">  521 </span><span class="decl"><span class="istickedoff">getSymInterface = OM (use syminterface)</span></span>
<span class="lineno">  522 </span>
<span class="lineno">  523 </span>-- | Verify that all of the fresh variables for the given
<span class="lineno">  524 </span>-- state spec have been &quot;learned&quot;. If not, throws
<span class="lineno">  525 </span>-- 'AmbiguousVars' exception.
<span class="lineno">  526 </span>enforceCompleteSubstitution ::
<span class="lineno">  527 </span>  W4.ProgramLoc -&gt;
<span class="lineno">  528 </span>  MS.StateSpec ext -&gt;
<span class="lineno">  529 </span>  OverrideMatcher ext w ()
<span class="lineno">  530 </span><span class="decl"><span class="istickedoff">enforceCompleteSubstitution loc ss =</span>
<span class="lineno">  531 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  532 </span><span class="spaces">  </span><span class="istickedoff">do sub &lt;- OM (use termSub)</span>
<span class="lineno">  533 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  534 </span><span class="spaces">     </span><span class="istickedoff">let -- predicate matches terms that are not covered by the computed</span>
<span class="lineno">  535 </span><span class="spaces">         </span><span class="istickedoff">-- term substitution</span>
<span class="lineno">  536 </span><span class="spaces">         </span><span class="istickedoff">isMissing tt = vnIndex (tvName tt) `IntMap.notMember` sub</span>
<span class="lineno">  537 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  538 </span><span class="spaces">         </span><span class="istickedoff">-- list of all terms not covered by substitution</span>
<span class="lineno">  539 </span><span class="spaces">         </span><span class="istickedoff">missing = filter isMissing (view MS.csFreshVars ss)</span>
<span class="lineno">  540 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  541 </span><span class="spaces">     </span><span class="istickedoff">unless (null missing) (failure loc (AmbiguousVars missing))</span></span>
<span class="lineno">  542 </span>
<span class="lineno">  543 </span>-- | Allocate fresh variables for all of the &quot;fresh&quot; vars
<span class="lineno">  544 </span>-- used in this phase and add them to the term substitution.
<span class="lineno">  545 </span>refreshTerms ::
<span class="lineno">  546 </span>  SharedContext    {- ^ shared context -} -&gt;
<span class="lineno">  547 </span>  MS.StateSpec ext {- ^ current phase spec -} -&gt;
<span class="lineno">  548 </span>  OverrideMatcher ext w ()
<span class="lineno">  549 </span><span class="decl"><span class="istickedoff">refreshTerms sc ss =</span>
<span class="lineno">  550 </span><span class="spaces">  </span><span class="istickedoff">do extension &lt;- IntMap.fromList &lt;$&gt; traverse freshenTerm (view MS.csFreshVars ss)</span>
<span class="lineno">  551 </span><span class="spaces">     </span><span class="istickedoff">OM (termSub %= IntMap.union extension)</span>
<span class="lineno">  552 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  553 </span><span class="spaces">    </span><span class="istickedoff">freshenTerm (TypedVariable _cty vn ty) =</span>
<span class="lineno">  554 </span><span class="spaces">      </span><span class="istickedoff">do vn' &lt;- liftIO $ scFreshVarName sc (vnName vn)</span>
<span class="lineno">  555 </span><span class="spaces">         </span><span class="istickedoff">new &lt;- liftIO $ scVariable sc (EC vn' ty)</span>
<span class="lineno">  556 </span><span class="spaces">         </span><span class="istickedoff">return (vnIndex vn, new)</span></span>
<span class="lineno">  557 </span>
<span class="lineno">  558 </span>-- | An override packaged together with its preconditions, labeled with some
<span class="lineno">  559 </span>--   human-readable info about each condition.
<span class="lineno">  560 </span>data OverrideWithPreconditions ext =
<span class="lineno">  561 </span>  OverrideWithPreconditions
<span class="lineno">  562 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_owpPreconditions</span></span></span> :: [(MS.ConditionMetadata, LabeledPred Sym)]
<span class="lineno">  563 </span>         -- ^ c.f. '_osAsserts'
<span class="lineno">  564 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_owpMethodSpec</span></span></span> :: MS.CrucibleMethodSpecIR ext
<span class="lineno">  565 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">owpState</span></span></span> :: OverrideState ext
<span class="lineno">  566 </span>    }
<span class="lineno">  567 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>)
<span class="lineno">  568 </span>
<span class="lineno">  569 </span><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff">makeLenses ''OverrideWithPreconditions</span></span></span></span></span></span></span></span>
<span class="lineno">  570 </span>
<span class="lineno">  571 </span>-- | Partition into three groups:
<span class="lineno">  572 </span>--   * Preconditions concretely succeed
<span class="lineno">  573 </span>--   * Preconditions concretely fail
<span class="lineno">  574 </span>--   * Preconditions are symbolic
<span class="lineno">  575 </span>partitionOWPsConcrete :: forall ext.
<span class="lineno">  576 </span>  Sym -&gt;
<span class="lineno">  577 </span>  [OverrideWithPreconditions ext] -&gt;
<span class="lineno">  578 </span>  IO ([OverrideWithPreconditions ext], [OverrideWithPreconditions ext], [OverrideWithPreconditions ext])
<span class="lineno">  579 </span><span class="decl"><span class="istickedoff">partitionOWPsConcrete sym =</span>
<span class="lineno">  580 </span><span class="spaces">  </span><span class="istickedoff">let trav = owpPreconditions . each . _2 . W4.labeledPred</span>
<span class="lineno">  581 </span><span class="spaces">  </span><span class="istickedoff">in W4.partitionByPredsM <span class="nottickedoff">(Just sym)</span> $</span>
<span class="lineno">  582 </span><span class="spaces">       </span><span class="istickedoff">foldlMOf trav (W4.andPred sym) (W4.truePred sym)</span></span>
<span class="lineno">  583 </span>
<span class="lineno">  584 </span>-- | Like 'W4.partitionByPreds', but partitions on solver responses, not just
<span class="lineno">  585 </span>--   concretized values.
<span class="lineno">  586 </span>partitionBySymbolicPreds ::
<span class="lineno">  587 </span>  (OnlineSolver solver, Foldable t) =&gt;
<span class="lineno">  588 </span>  Backend solver {- ^ solver connection -} -&gt;
<span class="lineno">  589 </span>  (a -&gt; W4.Pred Sym) {- ^ how to extract predicates -} -&gt;
<span class="lineno">  590 </span>  t a -&gt;
<span class="lineno">  591 </span>  IO (Map Crucible.BranchResult [a])
<span class="lineno">  592 </span><span class="decl"><span class="istickedoff">partitionBySymbolicPreds sym getPred =</span>
<span class="lineno">  593 </span><span class="spaces">  </span><span class="istickedoff">let step mp a =</span>
<span class="lineno">  594 </span><span class="spaces">        </span><span class="istickedoff">Crucible.considerSatisfiability sym <span class="nottickedoff">Nothing</span> (getPred a) &lt;&amp;&gt; \k -&gt;</span>
<span class="lineno">  595 </span><span class="spaces">          </span><span class="istickedoff">Map.insertWith <span class="nottickedoff">(++)</span> k [<span class="nottickedoff">a</span>] mp</span>
<span class="lineno">  596 </span><span class="spaces">  </span><span class="istickedoff">in foldM step Map.empty</span></span>
<span class="lineno">  597 </span>
<span class="lineno">  598 </span>-- | Find individual preconditions that are symbolically false
<span class="lineno">  599 </span>--
<span class="lineno">  600 </span>-- We should probably be using unsat cores for this.
<span class="lineno">  601 </span>findFalsePreconditions ::
<span class="lineno">  602 </span>  OnlineSolver solver =&gt;
<span class="lineno">  603 </span>  Backend solver -&gt;
<span class="lineno">  604 </span>  OverrideWithPreconditions ext -&gt;
<span class="lineno">  605 </span>  IO [(MS.ConditionMetadata, LabeledPred Sym)]
<span class="lineno">  606 </span><span class="decl"><span class="istickedoff">findFalsePreconditions bak owp =</span>
<span class="lineno">  607 </span><span class="spaces">  </span><span class="istickedoff">fromMaybe [] . Map.lookup (Crucible.NoBranch False) &lt;$&gt;</span>
<span class="lineno">  608 </span><span class="spaces">    </span><span class="istickedoff">partitionBySymbolicPreds bak (view (_2 . W4.labeledPred)) (owp ^. owpPreconditions)</span></span>
<span class="lineno">  609 </span>
<span class="lineno">  610 </span>-- | Is this group of predicates collectively unsatisfiable?
<span class="lineno">  611 </span>unsatPreconditions ::
<span class="lineno">  612 </span>  OnlineSolver solver =&gt;
<span class="lineno">  613 </span>  Backend solver {- ^ solver connection -} -&gt;
<span class="lineno">  614 </span>  Fold s (W4.Pred Sym) {- ^ how to extract predicates -} -&gt;
<span class="lineno">  615 </span>  s {- ^ a container full of predicates -}-&gt;
<span class="lineno">  616 </span>  IO Bool
<span class="lineno">  617 </span><span class="decl"><span class="istickedoff">unsatPreconditions bak container getPreds = do</span>
<span class="lineno">  618 </span><span class="spaces">  </span><span class="istickedoff">let sym = Crucible.backendGetSym bak</span>
<span class="lineno">  619 </span><span class="spaces">  </span><span class="istickedoff">conj &lt;- W4.andAllOf sym container getPreds</span>
<span class="lineno">  620 </span><span class="spaces">  </span><span class="istickedoff">Crucible.considerSatisfiability bak <span class="nottickedoff">Nothing</span> conj &gt;&gt;=</span>
<span class="lineno">  621 </span><span class="spaces">    </span><span class="istickedoff">\case</span>
<span class="lineno">  622 </span><span class="spaces">      </span><span class="istickedoff">Crucible.NoBranch False -&gt; pure True</span>
<span class="lineno">  623 </span><span class="spaces">      </span><span class="istickedoff">_ -&gt; pure False</span></span>
<span class="lineno">  624 </span>
<span class="lineno">  625 </span>-- | Print a message about failure of an override's preconditions
<span class="lineno">  626 </span>ppFailure ::
<span class="lineno">  627 </span>  (PP.Pretty (ExtType ext), PP.Pretty (MethodId ext)) =&gt;
<span class="lineno">  628 </span>  OverrideWithPreconditions ext -&gt;
<span class="lineno">  629 </span>  [LabeledPred Sym] -&gt;
<span class="lineno">  630 </span>  PP.Doc ann
<span class="lineno">  631 </span><span class="decl"><span class="istickedoff">ppFailure owp false =</span>
<span class="lineno">  632 </span><span class="spaces">  </span><span class="istickedoff">PP.vcat</span>
<span class="lineno">  633 </span><span class="spaces">  </span><span class="istickedoff">[ MS.ppMethodSpec (owp ^. owpMethodSpec)</span>
<span class="lineno">  634 </span><span class="spaces">    </span><span class="istickedoff">-- TODO: remove viaShow when crucible switches to prettyprinter</span>
<span class="lineno">  635 </span><span class="spaces">  </span><span class="istickedoff">, bullets '*' (map (PP.viaShow . Crucible.ppSimError)</span>
<span class="lineno">  636 </span><span class="spaces">                  </span><span class="istickedoff">(false ^.. traverse . W4.labeledPredMsg))</span>
<span class="lineno">  637 </span><span class="spaces">  </span><span class="istickedoff">]</span></span>
<span class="lineno">  638 </span>
<span class="lineno">  639 </span>-- | Print a message about concrete failure of an override's preconditions
<span class="lineno">  640 </span>--
<span class="lineno">  641 </span>-- Assumes that the override it's being passed does have concretely failing
<span class="lineno">  642 </span>-- preconditions. Otherwise, the error won't make much sense.
<span class="lineno">  643 </span>ppConcreteFailure ::
<span class="lineno">  644 </span>  (PP.Pretty (ExtType ext), PP.Pretty (MethodId ext)) =&gt;
<span class="lineno">  645 </span>  OverrideWithPreconditions ext -&gt;
<span class="lineno">  646 </span>  PP.Doc ann
<span class="lineno">  647 </span><span class="decl"><span class="istickedoff">ppConcreteFailure owp =</span>
<span class="lineno">  648 </span><span class="spaces">  </span><span class="istickedoff">let (_, false, _) =</span>
<span class="lineno">  649 </span><span class="spaces">        </span><span class="istickedoff">W4.partitionLabeledPreds <span class="nottickedoff">(Proxy :: Proxy Sym)</span> (map snd (owp ^. owpPreconditions))</span>
<span class="lineno">  650 </span><span class="spaces">  </span><span class="istickedoff">in ppFailure owp false</span></span>
<span class="lineno">  651 </span>
<span class="lineno">  652 </span>------------------------------------------------------------------------
<span class="lineno">  653 </span>
<span class="lineno">  654 </span>-- | Forget the type indexes and length of the arguments.
<span class="lineno">  655 </span>assignmentToList ::
<span class="lineno">  656 </span>  Ctx.Assignment (Crucible.RegEntry sym) ctx -&gt;
<span class="lineno">  657 </span>  [Crucible.AnyValue sym]
<span class="lineno">  658 </span><span class="decl"><span class="istickedoff">assignmentToList = toListFC (\(Crucible.RegEntry x y) -&gt; Crucible.AnyValue x y)</span></span>
<span class="lineno">  659 </span>
<span class="lineno">  660 </span>------------------------------------------------------------------------
<span class="lineno">  661 </span>
<span class="lineno">  662 </span>learnGhost ::
<span class="lineno">  663 </span>  SharedContext                                          -&gt;
<span class="lineno">  664 </span>  MS.ConditionMetadata                                   -&gt;
<span class="lineno">  665 </span>  PrePost                                                -&gt;
<span class="lineno">  666 </span>  MS.GhostGlobal                                            -&gt;
<span class="lineno">  667 </span>  TypedTerm                                              -&gt;
<span class="lineno">  668 </span>  OverrideMatcher ext md ()
<span class="lineno">  669 </span><span class="decl"><span class="istickedoff">learnGhost sc md prepost var (TypedTerm (TypedTermSchema schEx) tmEx) =</span>
<span class="lineno">  670 </span><span class="spaces">  </span><span class="istickedoff">do (sch,tm) &lt;- readGlobal var</span>
<span class="lineno">  671 </span><span class="spaces">     </span><span class="istickedoff">when (sch /= schEx) $ <span class="nottickedoff">fail $ unlines $</span></span>
<span class="lineno">  672 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Ghost variable had the wrong type:&quot;</span></span>
<span class="lineno">  673 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">, &quot;- Expected: &quot; ++ show (Cryptol.pp schEx)</span></span>
<span class="lineno">  674 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">, &quot;- Actual:   &quot; ++ show (Cryptol.pp sch)</span></span>
<span class="lineno">  675 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  676 </span><span class="spaces">     </span><span class="istickedoff">instantiateExtMatchTerm sc md prepost tm tmEx</span>
<span class="lineno">  677 </span><span class="spaces"></span><span class="istickedoff">learnGhost _sc _md _prepost _var (TypedTerm tp _)</span>
<span class="lineno">  678 </span><span class="spaces">  </span><span class="istickedoff">= <span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno">  679 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Ghost variable expected value has improper type&quot;</span></span>
<span class="lineno">  680 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;expected Cryptol schema type, but got&quot;</span></span>
<span class="lineno">  681 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, show (ppTypedTermType tp)</span></span>
<span class="lineno">  682 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno">  683 </span>
<span class="lineno">  684 </span>executeGhost ::
<span class="lineno">  685 </span>  SharedContext -&gt;
<span class="lineno">  686 </span>  MS.ConditionMetadata -&gt;
<span class="lineno">  687 </span>  MS.GhostGlobal -&gt;
<span class="lineno">  688 </span>  TypedTerm -&gt;
<span class="lineno">  689 </span>  OverrideMatcher ext RW ()
<span class="lineno">  690 </span><span class="decl"><span class="istickedoff">executeGhost sc _md var (TypedTerm (TypedTermSchema sch) tm) =</span>
<span class="lineno">  691 </span><span class="spaces">  </span><span class="istickedoff">do s &lt;- OM (use termSub)</span>
<span class="lineno">  692 </span><span class="spaces">     </span><span class="istickedoff">tm' &lt;- liftIO (scInstantiateExt sc s tm)</span>
<span class="lineno">  693 </span><span class="spaces">     </span><span class="istickedoff">writeGlobal var (sch,tm')</span>
<span class="lineno">  694 </span><span class="spaces"></span><span class="istickedoff">executeGhost _sc _md _var (TypedTerm tp _) =</span>
<span class="lineno">  695 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno">  696 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;executeGhost: improper value type&quot;</span></span>
<span class="lineno">  697 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;expected Cryptol schema type, but got&quot;</span></span>
<span class="lineno">  698 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, show (ppTypedTermType tp)</span></span>
<span class="lineno">  699 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno">  700 </span>
<span class="lineno">  701 </span>-- | NOTE: The two 'Term' arguments must have the same type.
<span class="lineno">  702 </span>instantiateExtMatchTerm ::
<span class="lineno">  703 </span>  SharedContext   {- ^ context for constructing SAW terms    -} -&gt;
<span class="lineno">  704 </span>  MS.ConditionMetadata -&gt;
<span class="lineno">  705 </span>  PrePost                                                       -&gt;
<span class="lineno">  706 </span>  Term            {- ^ exported concrete term                -} -&gt;
<span class="lineno">  707 </span>  Term            {- ^ expected specification term           -} -&gt;
<span class="lineno">  708 </span>  OverrideMatcher ext md ()
<span class="lineno">  709 </span><span class="decl"><span class="istickedoff">instantiateExtMatchTerm sc md prepost actual expected = do</span>
<span class="lineno">  710 </span><span class="spaces">  </span><span class="istickedoff">sub &lt;- OM (use termSub)</span>
<span class="lineno">  711 </span><span class="spaces">  </span><span class="istickedoff">matchTerm sc md prepost actual =&lt;&lt; liftIO (scInstantiateExt sc sub expected)</span></span>
<span class="lineno">  712 </span>
<span class="lineno">  713 </span>matchTerm ::
<span class="lineno">  714 </span>  SharedContext   {- ^ context for constructing SAW terms    -} -&gt;
<span class="lineno">  715 </span>  MS.ConditionMetadata -&gt;
<span class="lineno">  716 </span>  PrePost                                                       -&gt;
<span class="lineno">  717 </span>  Term            {- ^ exported concrete term                -} -&gt;
<span class="lineno">  718 </span>  Term            {- ^ expected specification term           -} -&gt;
<span class="lineno">  719 </span>  OverrideMatcher ext md ()
<span class="lineno">  720 </span>
<span class="lineno">  721 </span><span class="decl"><span class="istickedoff">matchTerm _ _ _ real expect | real == expect = return <span class="nottickedoff">()</span></span>
<span class="lineno">  722 </span><span class="spaces"></span><span class="istickedoff">matchTerm sc md prepost real expect =</span>
<span class="lineno">  723 </span><span class="spaces">  </span><span class="istickedoff">do let loc = MS.conditionLoc md</span>
<span class="lineno">  724 </span><span class="spaces">     </span><span class="istickedoff">free &lt;- OM (use osFree)</span>
<span class="lineno">  725 </span><span class="spaces">     </span><span class="istickedoff">case unwrapTermF expect of</span>
<span class="lineno">  726 </span><span class="spaces">       </span><span class="istickedoff">Variable vn _tp</span>
<span class="lineno">  727 </span><span class="spaces">         </span><span class="istickedoff">| Set.member (vnIndex vn) free -&gt;</span>
<span class="lineno">  728 </span><span class="spaces">         </span><span class="istickedoff">do assignTerm <span class="nottickedoff">sc</span> <span class="nottickedoff">md</span> <span class="nottickedoff">prepost</span> (vnIndex vn) real</span>
<span class="lineno">  729 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  730 </span><span class="spaces">       </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  731 </span><span class="spaces">         </span><span class="istickedoff">do t &lt;- liftIO $ scEq sc real expect</span>
<span class="lineno">  732 </span><span class="spaces">            </span><span class="istickedoff">-- XXX get the user's ppOpts setting from somewhere</span>
<span class="lineno">  733 </span><span class="spaces">            </span><span class="istickedoff">let ppOpts = PPS.defaultOpts</span>
<span class="lineno">  734 </span><span class="spaces">            </span><span class="istickedoff">-- clamp the print depth to 20</span>
<span class="lineno">  735 </span><span class="spaces">            </span><span class="istickedoff">let ppOpts' = PPS.limitMaxDepth ppOpts 20</span>
<span class="lineno">  736 </span><span class="spaces">                </span><span class="istickedoff">expect' = scPrettyTerm ppOpts' expect</span>
<span class="lineno">  737 </span><span class="spaces">                </span><span class="istickedoff">real' = scPrettyTerm ppOpts' real</span>
<span class="lineno">  738 </span><span class="spaces">            </span><span class="istickedoff">let msg = unlines $</span>
<span class="lineno">  739 </span><span class="spaces">                  </span><span class="istickedoff">[ &quot;Literal equality &quot; ++ MS.stateCond prepost</span>
<span class="lineno">  740 </span><span class="spaces">                  </span><span class="istickedoff">, &quot;Expected term: &quot;</span>
<span class="lineno">  741 </span><span class="spaces">                  </span><span class="istickedoff">, expect'</span>
<span class="lineno">  742 </span><span class="spaces">                  </span><span class="istickedoff">, &quot;Actual term:&quot;</span>
<span class="lineno">  743 </span><span class="spaces">                  </span><span class="istickedoff">, real'</span>
<span class="lineno">  744 </span><span class="spaces">                  </span><span class="istickedoff">]</span>
<span class="lineno">  745 </span><span class="spaces">            </span><span class="istickedoff">addTermEq t md $ Crucible.SimError loc $ Crucible.AssertFailureSimError msg &quot;&quot;</span></span>
<span class="lineno">  746 </span>
<span class="lineno">  747 </span>assignTerm ::
<span class="lineno">  748 </span>  SharedContext      {- ^ context for constructing SAW terms    -} -&gt;
<span class="lineno">  749 </span>  MS.ConditionMetadata -&gt;
<span class="lineno">  750 </span>  PrePost                                                          -&gt;
<span class="lineno">  751 </span>  VarIndex {- ^ external constant index -} -&gt;
<span class="lineno">  752 </span>  Term     {- ^ value                   -} -&gt;
<span class="lineno">  753 </span>  OverrideMatcher ext md ()
<span class="lineno">  754 </span>
<span class="lineno">  755 </span><span class="decl"><span class="istickedoff">assignTerm sc md prepost var val =</span>
<span class="lineno">  756 </span><span class="spaces">  </span><span class="istickedoff">do mb &lt;- OM (use (termSub . at var))</span>
<span class="lineno">  757 </span><span class="spaces">     </span><span class="istickedoff">case mb of</span>
<span class="lineno">  758 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt; OM (termSub . at var ?= val)</span>
<span class="lineno">  759 </span><span class="spaces">       </span><span class="istickedoff">Just old -&gt;</span>
<span class="lineno">  760 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">matchTerm sc md prepost val old</span></span></span>
<span class="lineno">  761 </span>
<span class="lineno">  762 </span>--          do t &lt;- liftIO $ scEq sc old val
<span class="lineno">  763 </span>--             p &lt;- liftIO $ resolveSAWPred cc t
<span class="lineno">  764 </span>--             addAssert p (Crucible.AssertFailureSimError (&quot;literal equality &quot; ++ MS.stateCond prepost))

</pre>
</body>
</html>
