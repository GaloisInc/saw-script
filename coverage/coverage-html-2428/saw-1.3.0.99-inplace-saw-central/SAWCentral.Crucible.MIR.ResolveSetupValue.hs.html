<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE DataKinds #-}
<span class="lineno">    2 </span>{-# LANGUAGE GADTs #-}
<span class="lineno">    3 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">    4 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">    5 </span>{-# LANGUAGE PatternSynonyms #-}
<span class="lineno">    6 </span>{-# LANGUAGE PolyKinds #-}
<span class="lineno">    7 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">    8 </span>{-# LANGUAGE TypeApplications #-}
<span class="lineno">    9 </span>{-# LANGUAGE TypeOperators #-}
<span class="lineno">   10 </span>
<span class="lineno">   11 </span>-- | Turns 'SetupValue's back into 'MIRVal's.
<span class="lineno">   12 </span>module SAWCentral.Crucible.MIR.ResolveSetupValue
<span class="lineno">   13 </span>  ( MIRVal(..)
<span class="lineno">   14 </span>  , ppMIRVal
<span class="lineno">   15 </span>  , resolveSetupVal
<span class="lineno">   16 </span>  , typeOfSetupValue
<span class="lineno">   17 </span>  , lookupAllocIndex
<span class="lineno">   18 </span>  , toMIRType
<span class="lineno">   19 </span>  , resolveTypedTerm
<span class="lineno">   20 </span>  , resolveBoolTerm
<span class="lineno">   21 </span>  , resolveSAWPred
<span class="lineno">   22 </span>  , equalRefsPred
<span class="lineno">   23 </span>  , equalValsPred
<span class="lineno">   24 </span>  , checkCompatibleTys
<span class="lineno">   25 </span>  , readMaybeType
<span class="lineno">   26 </span>  , doAlloc
<span class="lineno">   27 </span>  , doPointsTo
<span class="lineno">   28 </span>  , firstPointsToReferent
<span class="lineno">   29 </span>  , mirAdtToTy
<span class="lineno">   30 </span>  , findDefId
<span class="lineno">   31 </span>  , findDefIdEither
<span class="lineno">   32 </span>    -- * Slices
<span class="lineno">   33 </span>  , sliceElemTy
<span class="lineno">   34 </span>  , sliceRefTyToSliceInfo
<span class="lineno">   35 </span>    -- * Static items
<span class="lineno">   36 </span>  , findStatic
<span class="lineno">   37 </span>  , findStaticInitializer
<span class="lineno">   38 </span>  , findStaticVar
<span class="lineno">   39 </span>  , staticRefMux
<span class="lineno">   40 </span>    -- * Enum discriminants
<span class="lineno">   41 </span>  , getEnumVariantDiscr
<span class="lineno">   42 </span>  , testDiscriminantIsBV
<span class="lineno">   43 </span>  , variantIntIndex
<span class="lineno">   44 </span>    -- * Types of errors
<span class="lineno">   45 </span>  , MIRTypeOfError(..)
<span class="lineno">   46 </span>  ) where
<span class="lineno">   47 </span>
<span class="lineno">   48 </span>import           Control.Lens
<span class="lineno">   49 </span>import           Control.Monad (guard, unless, zipWithM, zipWithM_)
<span class="lineno">   50 </span>import qualified Control.Monad.Catch as X
<span class="lineno">   51 </span>import           Control.Monad.IO.Class (MonadIO(..))
<span class="lineno">   52 </span>import           Control.Monad.Trans.Maybe (MaybeT(..))
<span class="lineno">   53 </span>import qualified Data.BitVector.Sized as BV
<span class="lineno">   54 </span>import qualified Data.Foldable as F
<span class="lineno">   55 </span>import qualified Data.Functor.Product as Functor
<span class="lineno">   56 </span>import           Data.Kind (Type)
<span class="lineno">   57 </span>import qualified Data.List.Extra as List (firstJust)
<span class="lineno">   58 </span>import           Data.List.NonEmpty (NonEmpty(..))
<span class="lineno">   59 </span>import           Data.Map (Map)
<span class="lineno">   60 </span>import qualified Data.Map as Map
<span class="lineno">   61 </span>import           Data.Maybe (fromMaybe)
<span class="lineno">   62 </span>import qualified Data.Parameterized.Context as Ctx
<span class="lineno">   63 </span>import qualified Data.Parameterized.Map as MapF
<span class="lineno">   64 </span>import           Data.Parameterized.Some (Some(..))
<span class="lineno">   65 </span>import qualified Data.Parameterized.TraversableFC as FC
<span class="lineno">   66 </span>import qualified Data.Parameterized.TraversableFC.WithIndex as FCI
<span class="lineno">   67 </span>import qualified Data.Text as Text
<span class="lineno">   68 </span>import           Data.Text (Text)
<span class="lineno">   69 </span>import qualified Data.Vector as V
<span class="lineno">   70 </span>import           Data.Vector (Vector)
<span class="lineno">   71 </span>import           Data.Void (absurd)
<span class="lineno">   72 </span>import           Numeric.Natural (Natural)
<span class="lineno">   73 </span>import qualified Prettyprinter as PP
<span class="lineno">   74 </span>
<span class="lineno">   75 </span>import qualified Cryptol.Eval.Type as Cryptol (TValue(..), tValTy, evalValType)
<span class="lineno">   76 </span>import qualified Cryptol.TypeCheck.AST as Cryptol (Type, Schema(..))
<span class="lineno">   77 </span>import qualified Cryptol.Utils.PP as Cryptol (pp)
<span class="lineno">   78 </span>import Lang.Crucible.Backend (IsSymInterface)
<span class="lineno">   79 </span>import Lang.Crucible.Simulator
<span class="lineno">   80 </span>  ( GlobalVar(..), RegValue, RegValue'(..), SymGlobalState
<span class="lineno">   81 </span>  , VariantBranch(..), injectVariant
<span class="lineno">   82 </span>  )
<span class="lineno">   83 </span>import Lang.Crucible.Simulator.RegMap (muxRegForType)
<span class="lineno">   84 </span>import Lang.Crucible.Types (MaybeType, TypeRepr(..))
<span class="lineno">   85 </span>import qualified Mir.DefId as Mir
<span class="lineno">   86 </span>import qualified Mir.FancyMuxTree as Mir
<span class="lineno">   87 </span>import qualified Mir.Generator as Mir
<span class="lineno">   88 </span>import qualified Mir.Intrinsics as Mir
<span class="lineno">   89 </span>import Mir.Intrinsics (MIR)
<span class="lineno">   90 </span>import qualified Mir.Mir as Mir
<span class="lineno">   91 </span>import qualified Mir.TransTy as Mir
<span class="lineno">   92 </span>
<span class="lineno">   93 </span>import qualified What4.BaseTypes as W4
<span class="lineno">   94 </span>import qualified What4.Interface as W4
<span class="lineno">   95 </span>import qualified What4.Partial as W4
<span class="lineno">   96 </span>
<span class="lineno">   97 </span>import CryptolSAWCore.Cryptol (importType, emptyEnv)
<span class="lineno">   98 </span>import SAWCore.SharedTerm
<span class="lineno">   99 </span>import qualified SAWCore.Prim as Prim
<span class="lineno">  100 </span>import qualified SAWCore.Simulator.Concrete as Concrete
<span class="lineno">  101 </span>import SAWCoreWhat4.ReturnTrip
<span class="lineno">  102 </span>import CryptolSAWCore.TypedTerm
<span class="lineno">  103 </span>
<span class="lineno">  104 </span>import SAWCentral.Crucible.Common
<span class="lineno">  105 </span>import qualified SAWCentral.Crucible.Common.MethodSpec as MS
<span class="lineno">  106 </span>import SAWCentral.Crucible.Common.MethodSpec (AllocIndex(..))
<span class="lineno">  107 </span>import SAWCentral.Crucible.Common.ResolveSetupValue (resolveBoolTerm, checkBooleanType)
<span class="lineno">  108 </span>import SAWCentral.Crucible.MIR.MethodSpecIR
<span class="lineno">  109 </span>import SAWCentral.Crucible.MIR.TypeShape
<span class="lineno">  110 </span>import SAWCentral.Panic
<span class="lineno">  111 </span>
<span class="lineno">  112 </span>-- | A pair of a simulation-time MIR value ('RegValue') and its corresponding
<span class="lineno">  113 </span>-- type ('TypeShape'), where the @tp@ type parameter is closed over
<span class="lineno">  114 </span>-- existentially. SAW's MIR backend passes around 'MIRVal's at simulation time.
<span class="lineno">  115 </span>data MIRVal where
<span class="lineno">  116 </span>  MIRVal :: TypeShape tp -&gt; RegValue Sym tp -&gt; MIRVal
<span class="lineno">  117 </span>
<span class="lineno">  118 </span>-- | Pretty-print a 'MIRVal'.
<span class="lineno">  119 </span>ppMIRVal ::
<span class="lineno">  120 </span>  forall ann.
<span class="lineno">  121 </span>  Sym -&gt;
<span class="lineno">  122 </span>  MIRVal -&gt;
<span class="lineno">  123 </span>  PP.Doc ann
<span class="lineno">  124 </span><span class="decl"><span class="istickedoff">ppMIRVal sym (MIRVal shp val) =</span>
<span class="lineno">  125 </span><span class="spaces">  </span><span class="istickedoff">case shp of</span>
<span class="lineno">  126 </span><span class="spaces">    </span><span class="istickedoff">UnitShape _ -&gt;</span>
<span class="lineno">  127 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">PP.pretty val</span></span>
<span class="lineno">  128 </span><span class="spaces">    </span><span class="istickedoff">PrimShape _ _ -&gt;</span>
<span class="lineno">  129 </span><span class="spaces">      </span><span class="istickedoff">W4.printSymExpr val</span>
<span class="lineno">  130 </span><span class="spaces">    </span><span class="istickedoff">TupleShape _ _ fldShp -&gt;</span>
<span class="lineno">  131 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">PP.parens $ prettyAdtOrTuple fldShp val</span></span>
<span class="lineno">  132 </span><span class="spaces">    </span><span class="istickedoff">ArrayShape _ _ shp' -&gt;</span>
<span class="lineno">  133 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">case val of</span></span>
<span class="lineno">  134 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">Mir.MirVector_Vector vec -&gt;</span></span>
<span class="lineno">  135 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">PP.brackets $ commaList $ V.toList $</span></span>
<span class="lineno">  136 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">fmap (\v -&gt; ppMIRVal sym (MIRVal shp' v)) vec</span></span>
<span class="lineno">  137 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">Mir.MirVector_PartialVector vec -&gt;</span></span>
<span class="lineno">  138 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">PP.braces $ commaList $ V.toList $</span></span>
<span class="lineno">  139 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">fmap (\v -&gt; let v' = readMaybeType sym &quot;vector element&quot; (shapeType shp') v in</span></span>
<span class="lineno">  140 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">ppMIRVal sym (MIRVal shp' v')) vec</span></span>
<span class="lineno">  141 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">Mir.MirVector_Array arr -&gt;</span></span>
<span class="lineno">  142 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">W4.printSymExpr arr</span></span>
<span class="lineno">  143 </span><span class="spaces">    </span><span class="istickedoff">StructShape _ _ fldShp -&gt;</span>
<span class="lineno">  144 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">PP.braces $ prettyAdtOrTuple fldShp val</span></span>
<span class="lineno">  145 </span><span class="spaces">    </span><span class="istickedoff">EnumShape _ _ variantShps _ _</span>
<span class="lineno">  146 </span><span class="spaces">      </span><span class="istickedoff">|  Ctx.Empty Ctx.:&gt; RV _ Ctx.:&gt; RV variants &lt;- <span class="nottickedoff">val</span></span>
<span class="lineno">  147 </span><span class="spaces">      </span><span class="istickedoff">-&gt; <span class="nottickedoff">case firstConcreteVariant variantShps variants of</span></span>
<span class="lineno">  148 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">Just (Some (Functor.Pair fldShps fldVals)) -&gt;</span></span>
<span class="lineno">  149 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">PP.braces $ prettyAdtOrTuple fldShps fldVals</span></span>
<span class="lineno">  150 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt;</span></span>
<span class="lineno">  151 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">&quot;&lt;symbolic enum&gt;&quot;</span></span>
<span class="lineno">  152 </span><span class="spaces">    </span><span class="istickedoff">TransparentShape _ shp' -&gt;</span>
<span class="lineno">  153 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">ppMIRVal sym $ MIRVal shp' val</span></span>
<span class="lineno">  154 </span><span class="spaces">    </span><span class="istickedoff">RefShape _ _ _ _  -&gt;</span>
<span class="lineno">  155 </span><span class="spaces">      </span><span class="istickedoff">&quot;&lt;reference&gt;&quot;</span>
<span class="lineno">  156 </span><span class="spaces">    </span><span class="istickedoff">SliceShape _ _ _ _ -&gt;</span>
<span class="lineno">  157 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">&quot;&lt;slice&gt;&quot;</span></span>
<span class="lineno">  158 </span><span class="spaces">    </span><span class="istickedoff">FnPtrShape _ _ _ -&gt;</span>
<span class="lineno">  159 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">PP.viaShow val</span></span>
<span class="lineno">  160 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  161 </span><span class="spaces">    </span><span class="istickedoff">commaList :: [PP.Doc ann] -&gt; PP.Doc ann</span>
<span class="lineno">  162 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">commaList []     = PP.emptyDoc</span></span>
<span class="lineno">  163 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">commaList (x:xs) = x PP.&lt;&gt; PP.hcat (map (\y -&gt; PP.comma PP.&lt;+&gt; y) xs)</span></span>
<span class="lineno">  164 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  165 </span><span class="spaces">    </span><span class="istickedoff">-- Return Just the first VariantBranch whose predicate is concretely equal</span>
<span class="lineno">  166 </span><span class="spaces">    </span><span class="istickedoff">-- to True. If none of the VariantBranches satisfy this property, then</span>
<span class="lineno">  167 </span><span class="spaces">    </span><span class="istickedoff">-- return Nothing.</span>
<span class="lineno">  168 </span><span class="spaces">    </span><span class="istickedoff">firstConcreteVariant ::</span>
<span class="lineno">  169 </span><span class="spaces">      </span><span class="istickedoff">Ctx.Assignment VariantShape ctx -&gt;</span>
<span class="lineno">  170 </span><span class="spaces">      </span><span class="istickedoff">Ctx.Assignment (VariantBranch Sym) ctx -&gt;</span>
<span class="lineno">  171 </span><span class="spaces">      </span><span class="istickedoff">Maybe (Some (Functor.Product</span>
<span class="lineno">  172 </span><span class="spaces">        </span><span class="istickedoff">(Ctx.Assignment FieldShape)</span>
<span class="lineno">  173 </span><span class="spaces">        </span><span class="istickedoff">(Ctx.Assignment (RegValue' Sym))))</span>
<span class="lineno">  174 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">firstConcreteVariant variantShapes variantBranches =</span></span>
<span class="lineno">  175 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">List.firstJust</span></span>
<span class="lineno">  176 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">(\(Some (Functor.Pair (VariantShape fldShps) (VB branch))) -&gt;</span></span>
<span class="lineno">  177 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">case branch of</span></span>
<span class="lineno">  178 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">W4.PE fldPred fldVals</span></span>
<span class="lineno">  179 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">|  W4.asConstantPred fldPred == Just True</span></span>
<span class="lineno">  180 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">-&gt; Just $ Some $ Functor.Pair fldShps fldVals</span></span>
<span class="lineno">  181 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">|  otherwise</span></span>
<span class="lineno">  182 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">-&gt; Nothing</span></span>
<span class="lineno">  183 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">W4.Unassigned -&gt;</span></span>
<span class="lineno">  184 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">Nothing) $</span></span>
<span class="lineno">  185 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">FC.toListFC Some $</span></span>
<span class="lineno">  186 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">Ctx.zipWith Functor.Pair variantShapes variantBranches</span></span>
<span class="lineno">  187 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  188 </span><span class="spaces">    </span><span class="istickedoff">prettyAdtOrTuple ::</span>
<span class="lineno">  189 </span><span class="spaces">      </span><span class="istickedoff">forall ctx.</span>
<span class="lineno">  190 </span><span class="spaces">      </span><span class="istickedoff">Ctx.Assignment FieldShape ctx -&gt;</span>
<span class="lineno">  191 </span><span class="spaces">      </span><span class="istickedoff">Ctx.Assignment (RegValue' Sym) ctx -&gt;</span>
<span class="lineno">  192 </span><span class="spaces">      </span><span class="istickedoff">PP.Doc ann</span>
<span class="lineno">  193 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">prettyAdtOrTuple fldShp fldVals =</span></span>
<span class="lineno">  194 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">commaList $</span></span>
<span class="lineno">  195 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">map (\(Some (Functor.Pair shp' (RV v))) -&gt; prettyField shp' v) $</span></span>
<span class="lineno">  196 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">FC.toListFC Some $</span></span>
<span class="lineno">  197 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">Ctx.zipWith Functor.Pair fldShp fldVals</span></span>
<span class="lineno">  198 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  199 </span><span class="spaces">    </span><span class="istickedoff">prettyField ::</span>
<span class="lineno">  200 </span><span class="spaces">      </span><span class="istickedoff">forall tp.</span>
<span class="lineno">  201 </span><span class="spaces">      </span><span class="istickedoff">FieldShape tp -&gt;</span>
<span class="lineno">  202 </span><span class="spaces">      </span><span class="istickedoff">RegValue Sym tp -&gt;</span>
<span class="lineno">  203 </span><span class="spaces">      </span><span class="istickedoff">PP.Doc ann</span>
<span class="lineno">  204 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">prettyField fldShp val' =</span></span>
<span class="lineno">  205 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">case fldShp of</span></span>
<span class="lineno">  206 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">OptField shp' -&gt;</span></span>
<span class="lineno">  207 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">ppMIRVal sym $ MIRVal shp' $</span></span>
<span class="lineno">  208 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">readMaybeType sym &quot;field&quot; (shapeType shp') val'</span></span>
<span class="lineno">  209 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">ReqField shp' -&gt;</span></span>
<span class="lineno">  210 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">ppMIRVal sym $ MIRVal shp' val'</span></span></span>
<span class="lineno">  211 </span>
<span class="lineno">  212 </span>type SetupValue = MS.SetupValue MIR
<span class="lineno">  213 </span>
<span class="lineno">  214 </span>data MIRTypeOfError
<span class="lineno">  215 </span>  = MIRPolymorphicType Cryptol.Schema
<span class="lineno">  216 </span>  | MIRNonRepresentableType Cryptol.Type ToMIRTypeErr
<span class="lineno">  217 </span>  | MIRInvalidTypedTerm TypedTermType
<span class="lineno">  218 </span>  | MIRInvalidIdentifier String
<span class="lineno">  219 </span>  | MIRStaticNotFound Mir.DefId
<span class="lineno">  220 </span>  | MIRSliceNonReference Mir.Ty
<span class="lineno">  221 </span>  | MIRSliceNonArrayReference Mir.Ty
<span class="lineno">  222 </span>  | MIRSliceWrongTy Mir.Ty
<span class="lineno">  223 </span>  | MIRStrSliceNonU8Array Mir.Ty
<span class="lineno">  224 </span>  | MIRMuxNonBoolCondition Mir.Ty
<span class="lineno">  225 </span>  | MIRMuxDifferentBranchTypes Mir.Ty Mir.Ty
<span class="lineno">  226 </span>
<span class="lineno">  227 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Show MIRTypeOfError</span></span></span></span> where
<span class="lineno">  228 </span>  <span class="decl"><span class="istickedoff">show (MIRPolymorphicType s) =</span>
<span class="lineno">  229 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">unlines</span></span>
<span class="lineno">  230 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Expected monomorphic term&quot;</span></span>
<span class="lineno">  231 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;instead got:&quot;</span></span>
<span class="lineno">  232 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, show (Cryptol.pp s)</span></span>
<span class="lineno">  233 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  234 </span><span class="spaces">  </span><span class="istickedoff">show (MIRNonRepresentableType ty err) =</span>
<span class="lineno">  235 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">unlines</span></span>
<span class="lineno">  236 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Type not representable in MIR:&quot;</span></span>
<span class="lineno">  237 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, show (Cryptol.pp ty)</span></span>
<span class="lineno">  238 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, toMIRTypeErrToString err</span></span>
<span class="lineno">  239 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  240 </span><span class="spaces">  </span><span class="istickedoff">show (MIRInvalidTypedTerm tp) =</span>
<span class="lineno">  241 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">unlines</span></span>
<span class="lineno">  242 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Expected typed term with Cryptol-representable type, but got&quot;</span></span>
<span class="lineno">  243 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, show (ppTypedTermType tp)</span></span>
<span class="lineno">  244 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  245 </span><span class="spaces">  </span><span class="istickedoff">show (MIRInvalidIdentifier errMsg) =</span>
<span class="lineno">  246 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">errMsg</span></span>
<span class="lineno">  247 </span><span class="spaces">  </span><span class="istickedoff">show (MIRStaticNotFound did) =</span>
<span class="lineno">  248 </span><span class="spaces">    </span><span class="istickedoff">staticNotFoundErr did</span>
<span class="lineno">  249 </span><span class="spaces">  </span><span class="istickedoff">show (MIRSliceNonReference ty) =</span>
<span class="lineno">  250 </span><span class="spaces">    </span><span class="istickedoff">unlines</span>
<span class="lineno">  251 </span><span class="spaces">    </span><span class="istickedoff">[ &quot;Expected a reference, but got&quot;</span>
<span class="lineno">  252 </span><span class="spaces">    </span><span class="istickedoff">, show (PP.pretty ty)</span>
<span class="lineno">  253 </span><span class="spaces">    </span><span class="istickedoff">]</span>
<span class="lineno">  254 </span><span class="spaces">  </span><span class="istickedoff">show (MIRSliceNonArrayReference ty) =</span>
<span class="lineno">  255 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">unlines</span></span>
<span class="lineno">  256 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Expected a reference to an array, but got&quot;</span></span>
<span class="lineno">  257 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, show (PP.pretty ty)</span></span>
<span class="lineno">  258 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  259 </span><span class="spaces">  </span><span class="istickedoff">show (MIRSliceWrongTy ty) =</span>
<span class="lineno">  260 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">unlines</span></span>
<span class="lineno">  261 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Expected a slice type, but got&quot;</span></span>
<span class="lineno">  262 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, show (PP.pretty ty)</span></span>
<span class="lineno">  263 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  264 </span><span class="spaces">  </span><span class="istickedoff">show (MIRStrSliceNonU8Array ty) =</span>
<span class="lineno">  265 </span><span class="spaces">    </span><span class="istickedoff">unlines</span>
<span class="lineno">  266 </span><span class="spaces">    </span><span class="istickedoff">[ &quot;Expected a value of type &amp;[u8; &lt;length&gt;], but got&quot;</span>
<span class="lineno">  267 </span><span class="spaces">    </span><span class="istickedoff">, show (PP.pretty ty)</span>
<span class="lineno">  268 </span><span class="spaces">    </span><span class="istickedoff">]</span>
<span class="lineno">  269 </span><span class="spaces">  </span><span class="istickedoff">show (MIRMuxNonBoolCondition ty) =</span>
<span class="lineno">  270 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">unlines</span></span>
<span class="lineno">  271 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Expected a bool-typed condition in a mux, but got&quot;</span></span>
<span class="lineno">  272 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, show (PP.pretty ty)</span></span>
<span class="lineno">  273 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  274 </span><span class="spaces">  </span><span class="istickedoff">show (MIRMuxDifferentBranchTypes tTy fTy) =</span>
<span class="lineno">  275 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">unlines</span></span>
<span class="lineno">  276 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Mismatch in mux branch types:&quot;</span></span>
<span class="lineno">  277 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;True  branch type: &quot; ++ show (PP.pretty tTy)</span></span>
<span class="lineno">  278 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;False branch type: &quot; ++ show (PP.pretty fTy)</span></span>
<span class="lineno">  279 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno">  280 </span>
<span class="lineno">  281 </span>staticNotFoundErr :: Mir.DefId -&gt; String
<span class="lineno">  282 </span><span class="decl"><span class="istickedoff">staticNotFoundErr did =</span>
<span class="lineno">  283 </span><span class="spaces">  </span><span class="istickedoff">unlines</span>
<span class="lineno">  284 </span><span class="spaces">  </span><span class="istickedoff">[ &quot;Could not find static named:&quot;</span>
<span class="lineno">  285 </span><span class="spaces">  </span><span class="istickedoff">, show did</span>
<span class="lineno">  286 </span><span class="spaces">  </span><span class="istickedoff">]</span></span>
<span class="lineno">  287 </span>
<span class="lineno">  288 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">X.Exception MIRTypeOfError</span></span></span></span></span></span>
<span class="lineno">  289 </span>
<span class="lineno">  290 </span>typeOfSetupValue ::
<span class="lineno">  291 </span>  forall m.
<span class="lineno">  292 </span>  X.MonadThrow m =&gt;
<span class="lineno">  293 </span>  MIRCrucibleContext -&gt;
<span class="lineno">  294 </span>  Map AllocIndex (Some MirAllocSpec) -&gt;
<span class="lineno">  295 </span>  Map AllocIndex Text -&gt;
<span class="lineno">  296 </span>  SetupValue -&gt;
<span class="lineno">  297 </span>  m Mir.Ty
<span class="lineno">  298 </span><span class="decl"><span class="istickedoff">typeOfSetupValue mcc env nameEnv val =</span>
<span class="lineno">  299 </span><span class="spaces">  </span><span class="istickedoff">case val of</span>
<span class="lineno">  300 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupVar i -&gt;</span>
<span class="lineno">  301 </span><span class="spaces">      </span><span class="istickedoff">case Map.lookup i env of</span>
<span class="lineno">  302 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  303 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">panic &quot;MIRSetup (in typeOfSetupValue)&quot; [</span></span>
<span class="lineno">  304 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">&quot;Unresolved prestate variable: &quot; &lt;&gt; Text.pack (show i)</span></span>
<span class="lineno">  305 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  306 </span><span class="spaces">        </span><span class="istickedoff">Just (Some alloc) -&gt;</span>
<span class="lineno">  307 </span><span class="spaces">          </span><span class="istickedoff">pure $ ptrKindToTy (alloc^.maPtrKind) (alloc^.maMirType) (alloc^.maMutbl)</span>
<span class="lineno">  308 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupTerm tt -&gt;</span>
<span class="lineno">  309 </span><span class="spaces">      </span><span class="istickedoff">typeOfTypedTerm tt</span>
<span class="lineno">  310 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupArray elemTy vs -&gt;</span>
<span class="lineno">  311 </span><span class="spaces">      </span><span class="istickedoff">pure $ Mir.TyArray elemTy (length vs)</span>
<span class="lineno">  312 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupStruct adt _ -&gt;</span>
<span class="lineno">  313 </span><span class="spaces">      </span><span class="istickedoff">pure $ mirAdtToTy adt</span>
<span class="lineno">  314 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupEnum enum_ -&gt;</span>
<span class="lineno">  315 </span><span class="spaces">      </span><span class="istickedoff">case enum_ of</span>
<span class="lineno">  316 </span><span class="spaces">        </span><span class="istickedoff">MirSetupEnumVariant adt _ _ _ -&gt;</span>
<span class="lineno">  317 </span><span class="spaces">          </span><span class="istickedoff">pure $ mirAdtToTy adt</span>
<span class="lineno">  318 </span><span class="spaces">        </span><span class="istickedoff">MirSetupEnumSymbolic adt _ _ -&gt;</span>
<span class="lineno">  319 </span><span class="spaces">          </span><span class="istickedoff">pure $ mirAdtToTy adt</span>
<span class="lineno">  320 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupTuple () vals -&gt; do</span>
<span class="lineno">  321 </span><span class="spaces">      </span><span class="istickedoff">tys &lt;- traverse (typeOfSetupValue <span class="nottickedoff">mcc</span> <span class="nottickedoff">env</span> <span class="nottickedoff">nameEnv</span>) vals</span>
<span class="lineno">  322 </span><span class="spaces">      </span><span class="istickedoff">pure $ Mir.TyTuple tys</span>
<span class="lineno">  323 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupGlobal () name -&gt;</span>
<span class="lineno">  324 </span><span class="spaces">      </span><span class="istickedoff">staticTyRef &lt;$&gt; findStatic cs name</span>
<span class="lineno">  325 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupGlobalInitializer () name -&gt; do</span>
<span class="lineno">  326 </span><span class="spaces">      </span><span class="istickedoff">static &lt;- findStatic cs name</span>
<span class="lineno">  327 </span><span class="spaces">      </span><span class="istickedoff">pure $ static ^. Mir.sTy</span>
<span class="lineno">  328 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupSlice slice -&gt;</span>
<span class="lineno">  329 </span><span class="spaces">      </span><span class="istickedoff">case slice of</span>
<span class="lineno">  330 </span><span class="spaces">        </span><span class="istickedoff">MirSetupSliceRaw{} -&gt;</span>
<span class="lineno">  331 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">panic &quot;MIRSetup (in typeOfSetupValue)&quot; [</span></span>
<span class="lineno">  332 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">&quot;MirSetupSliceRaw not yet implemented&quot;</span></span>
<span class="lineno">  333 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  334 </span><span class="spaces">        </span><span class="istickedoff">MirSetupSlice sliceInfo arrRef -&gt;</span>
<span class="lineno">  335 </span><span class="spaces">          </span><span class="istickedoff">typeOfSliceFromArrayRef sliceInfo arrRef</span>
<span class="lineno">  336 </span><span class="spaces">        </span><span class="istickedoff">MirSetupSliceRange sliceInfo arrRef _ _ -&gt;</span>
<span class="lineno">  337 </span><span class="spaces">          </span><span class="istickedoff">typeOfSliceFromArrayRef sliceInfo arrRef</span>
<span class="lineno">  338 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupMux () c t f -&gt; do</span>
<span class="lineno">  339 </span><span class="spaces">      </span><span class="istickedoff">cTy &lt;- typeOfTypedTerm c</span>
<span class="lineno">  340 </span><span class="spaces">      </span><span class="istickedoff">unless (cTy == Mir.TyBool) $</span>
<span class="lineno">  341 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">X.throwM $ MIRMuxNonBoolCondition cTy</span></span>
<span class="lineno">  342 </span><span class="spaces">      </span><span class="istickedoff">tTy &lt;- typeOfSetupValue <span class="nottickedoff">mcc</span> <span class="nottickedoff">env</span> <span class="nottickedoff">nameEnv</span> t</span>
<span class="lineno">  343 </span><span class="spaces">      </span><span class="istickedoff">fTy &lt;- typeOfSetupValue <span class="nottickedoff">mcc</span> <span class="nottickedoff">env</span> <span class="nottickedoff">nameEnv</span> f</span>
<span class="lineno">  344 </span><span class="spaces">      </span><span class="istickedoff">unless (checkCompatibleTys tTy fTy) $</span>
<span class="lineno">  345 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">X.throwM $ MIRMuxDifferentBranchTypes tTy fTy</span></span>
<span class="lineno">  346 </span><span class="spaces">      </span><span class="istickedoff">pure tTy</span>
<span class="lineno">  347 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  348 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupElem _ _ _ -&gt;</span>
<span class="lineno">  349 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">panic &quot;MIRSetup (in typeOfSetupValue)&quot; [&quot;elems not yet implemented&quot;]</span></span>
<span class="lineno">  350 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupField _ _ _ -&gt;</span>
<span class="lineno">  351 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">panic &quot;MIRSetup (in typeOfSetupValue)&quot; [&quot;fields not yet implemented&quot;]</span></span>
<span class="lineno">  352 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  353 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupNull empty                -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno">  354 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupCast empty _              -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno">  355 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupUnion empty _ _           -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno">  356 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  357 </span><span class="spaces">    </span><span class="istickedoff">cs = mcc ^. mccRustModule . Mir.rmCS</span>
<span class="lineno">  358 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  359 </span><span class="spaces">    </span><span class="istickedoff">typeOfSliceFromArrayRef :: MirSliceInfo -&gt; SetupValue -&gt; m Mir.Ty</span>
<span class="lineno">  360 </span><span class="spaces">    </span><span class="istickedoff">typeOfSliceFromArrayRef sliceInfo arrRef = do</span>
<span class="lineno">  361 </span><span class="spaces">      </span><span class="istickedoff">arrRefTy &lt;- typeOfSetupValue <span class="nottickedoff">mcc</span> env <span class="nottickedoff">nameEnv</span> arrRef</span>
<span class="lineno">  362 </span><span class="spaces">      </span><span class="istickedoff">case arrRefTy of</span>
<span class="lineno">  363 </span><span class="spaces">        </span><span class="istickedoff">Mir.TyRef arrTy mut -&gt; do</span>
<span class="lineno">  364 </span><span class="spaces">          </span><span class="istickedoff">(sliceTy, _elemTy, _len) &lt;- arrayToSliceTys sliceInfo mut arrTy</span>
<span class="lineno">  365 </span><span class="spaces">          </span><span class="istickedoff">pure $ Mir.TyRef sliceTy mut</span>
<span class="lineno">  366 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  367 </span><span class="spaces">          </span><span class="istickedoff">X.throwM $ MIRSliceNonReference arrRefTy</span>
<span class="lineno">  368 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  369 </span><span class="spaces">    </span><span class="istickedoff">typeOfTypedTerm :: TypedTerm -&gt; m Mir.Ty</span>
<span class="lineno">  370 </span><span class="spaces">    </span><span class="istickedoff">typeOfTypedTerm tt =</span>
<span class="lineno">  371 </span><span class="spaces">      </span><span class="istickedoff">case ttType tt of</span>
<span class="lineno">  372 </span><span class="spaces">        </span><span class="istickedoff">TypedTermSchema (Cryptol.Forall [] [] ty) -&gt;</span>
<span class="lineno">  373 </span><span class="spaces">          </span><span class="istickedoff">case toMIRType (Cryptol.evalValType <span class="nottickedoff">mempty</span> ty) of</span>
<span class="lineno">  374 </span><span class="spaces">            </span><span class="istickedoff">Left err -&gt; <span class="nottickedoff">X.throwM (MIRNonRepresentableType ty err)</span></span>
<span class="lineno">  375 </span><span class="spaces">            </span><span class="istickedoff">Right mirTy -&gt; return mirTy</span>
<span class="lineno">  376 </span><span class="spaces">        </span><span class="istickedoff">TypedTermSchema s -&gt; <span class="nottickedoff">X.throwM (MIRPolymorphicType s)</span></span>
<span class="lineno">  377 </span><span class="spaces">        </span><span class="istickedoff">tp -&gt; <span class="nottickedoff">X.throwM (MIRInvalidTypedTerm tp)</span></span></span>
<span class="lineno">  378 </span>
<span class="lineno">  379 </span>lookupAllocIndex :: Map AllocIndex a -&gt; AllocIndex -&gt; a
<span class="lineno">  380 </span><span class="decl"><span class="istickedoff">lookupAllocIndex env i =</span>
<span class="lineno">  381 </span><span class="spaces">  </span><span class="istickedoff">case Map.lookup i env of</span>
<span class="lineno">  382 </span><span class="spaces">    </span><span class="istickedoff">Just x -&gt; x</span>
<span class="lineno">  383 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  384 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">panic &quot;MIRSetup (in lookupAllocIndex)&quot; [</span></span>
<span class="lineno">  385 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot;Unresolved prestate variable: &quot; &lt;&gt; Text.pack (show i)</span></span>
<span class="lineno">  386 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno">  387 </span>
<span class="lineno">  388 </span>-- | Translate a SetupValue into a Crucible MIR value, resolving
<span class="lineno">  389 </span>-- references
<span class="lineno">  390 </span>resolveSetupVal ::
<span class="lineno">  391 </span>  MIRCrucibleContext -&gt;
<span class="lineno">  392 </span>  Map AllocIndex (Some (MirPointer Sym)) -&gt;
<span class="lineno">  393 </span>  Map AllocIndex (Some MirAllocSpec) -&gt;
<span class="lineno">  394 </span>  Map AllocIndex Text -&gt;
<span class="lineno">  395 </span>  SetupValue -&gt;
<span class="lineno">  396 </span>  IO MIRVal
<span class="lineno">  397 </span><span class="decl"><span class="istickedoff">resolveSetupVal mcc env tyenv nameEnv val =</span>
<span class="lineno">  398 </span><span class="spaces">  </span><span class="istickedoff">mccWithBackend mcc $ \bak -&gt;</span>
<span class="lineno">  399 </span><span class="spaces">  </span><span class="istickedoff">let sym = backendGetSym bak in</span>
<span class="lineno">  400 </span><span class="spaces">  </span><span class="istickedoff">case val of</span>
<span class="lineno">  401 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupVar i -&gt; do</span>
<span class="lineno">  402 </span><span class="spaces">      </span><span class="istickedoff">Some ptr &lt;- pure $ lookupAllocIndex env i</span>
<span class="lineno">  403 </span><span class="spaces">      </span><span class="istickedoff">let pointeeType = ptr ^. mpMirType</span>
<span class="lineno">  404 </span><span class="spaces">      </span><span class="istickedoff">pure $ MIRVal (RefShape</span>
<span class="lineno">  405 </span><span class="spaces">                        </span><span class="istickedoff">(ptrKindToTy (ptr ^. mpKind) pointeeType (ptr ^. mpMutbl))</span>
<span class="lineno">  406 </span><span class="spaces">                        </span><span class="istickedoff">pointeeType</span>
<span class="lineno">  407 </span><span class="spaces">                        </span><span class="istickedoff">(ptr ^. mpMutbl)</span>
<span class="lineno">  408 </span><span class="spaces">                        </span><span class="istickedoff">(ptr ^. mpType))</span>
<span class="lineno">  409 </span><span class="spaces">                    </span><span class="istickedoff">(ptr ^. mpRef)</span>
<span class="lineno">  410 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupTerm tm -&gt; resolveTypedTerm mcc tm</span>
<span class="lineno">  411 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupNull empty                -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno">  412 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupStruct adt flds -&gt;</span>
<span class="lineno">  413 </span><span class="spaces">      </span><span class="istickedoff">case adt of</span>
<span class="lineno">  414 </span><span class="spaces">        </span><span class="istickedoff">_ | adt ^. Mir.adtReprTransparent,</span>
<span class="lineno">  415 </span><span class="spaces">            </span><span class="istickedoff">Just i &lt;- Mir.findReprTransparentField <span class="nottickedoff">col</span> adt,</span>
<span class="lineno">  416 </span><span class="spaces">            </span><span class="istickedoff">Just fld &lt;- flds ^? ix i -&gt;</span>
<span class="lineno">  417 </span><span class="spaces">          </span><span class="istickedoff">resolveTransparentSetupVal <span class="nottickedoff">adt</span> fld</span>
<span class="lineno">  418 </span><span class="spaces">        </span><span class="istickedoff">Mir.Adt nm Mir.Struct variants _ _ _ _ -&gt; do</span>
<span class="lineno">  419 </span><span class="spaces">          </span><span class="istickedoff">-- First, retrieve the struct variant.</span>
<span class="lineno">  420 </span><span class="spaces">          </span><span class="istickedoff">variant &lt;-</span>
<span class="lineno">  421 </span><span class="spaces">            </span><span class="istickedoff">case variants of</span>
<span class="lineno">  422 </span><span class="spaces">              </span><span class="istickedoff">[variant] -&gt;</span>
<span class="lineno">  423 </span><span class="spaces">                </span><span class="istickedoff">pure variant</span>
<span class="lineno">  424 </span><span class="spaces">              </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  425 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">panic &quot;resolveSetupVal&quot; [</span></span>
<span class="lineno">  426 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">&quot;Encountered struct Adt with &quot; &lt;&gt;</span></span>
<span class="lineno">  427 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">Text.pack (show (length variants)) &lt;&gt;</span></span>
<span class="lineno">  428 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">&quot; variants: &quot;,</span></span>
<span class="lineno">  429 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">&quot;   &quot; &lt;&gt; Text.pack (show nm)</span></span>
<span class="lineno">  430 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  431 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  432 </span><span class="spaces">          </span><span class="istickedoff">-- Next, resolve the field values and check that they have the</span>
<span class="lineno">  433 </span><span class="spaces">          </span><span class="istickedoff">-- expected types.</span>
<span class="lineno">  434 </span><span class="spaces">          </span><span class="istickedoff">flds' &lt;- traverse (resolveSetupVal mcc <span class="nottickedoff">env</span> <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span>) flds</span>
<span class="lineno">  435 </span><span class="spaces">          </span><span class="istickedoff">let expectedFlds = variant ^. Mir.vfields</span>
<span class="lineno">  436 </span><span class="spaces">          </span><span class="istickedoff">let actualFldTys = map (\(MIRVal shp _) -&gt; shapeMirTy shp) flds'</span>
<span class="lineno">  437 </span><span class="spaces">          </span><span class="istickedoff">checkFields <span class="nottickedoff">nm</span> <span class="nottickedoff">&quot;Struct&quot;</span> <span class="nottickedoff">&quot;struct fields&quot;</span> expectedFlds actualFldTys</span>
<span class="lineno">  438 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  439 </span><span class="spaces">          </span><span class="istickedoff">-- Finally, construct a MIRVal of the appropriate shape.</span>
<span class="lineno">  440 </span><span class="spaces">          </span><span class="istickedoff">Some (Functor.Pair fldShpAssn valAssn) &lt;-</span>
<span class="lineno">  441 </span><span class="spaces">            </span><span class="istickedoff">pure $ variantFieldsToAssns <span class="nottickedoff">sym</span> flds'</span>
<span class="lineno">  442 </span><span class="spaces">          </span><span class="istickedoff">let structShp = StructShape (mirAdtToTy adt) <span class="nottickedoff">actualFldTys</span> fldShpAssn</span>
<span class="lineno">  443 </span><span class="spaces">          </span><span class="istickedoff">pure $ MIRVal structShp valAssn</span>
<span class="lineno">  444 </span><span class="spaces">        </span><span class="istickedoff">Mir.Adt nm (Mir.Enum _) _ _ _ _ _ -&gt;</span>
<span class="lineno">  445 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">panic &quot;resolveSetupVal&quot; [</span></span>
<span class="lineno">  446 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">&quot;Expected struct type, received enum: &quot; &lt;&gt; Text.pack (show nm)</span></span>
<span class="lineno">  447 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  448 </span><span class="spaces">        </span><span class="istickedoff">Mir.Adt nm Mir.Union _ _ _ _ _ -&gt;</span>
<span class="lineno">  449 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">panic &quot;resolveSetupVal&quot; [</span></span>
<span class="lineno">  450 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">&quot;Expected struct type, received union: &quot; &lt;&gt; Text.pack (show nm)</span></span>
<span class="lineno">  451 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  452 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupEnum enum_ -&gt;</span>
<span class="lineno">  453 </span><span class="spaces">      </span><span class="istickedoff">case enum_ of</span>
<span class="lineno">  454 </span><span class="spaces">        </span><span class="istickedoff">MirSetupEnumVariant adt variant variantIdxInt flds -&gt;</span>
<span class="lineno">  455 </span><span class="spaces">          </span><span class="istickedoff">case adt of</span>
<span class="lineno">  456 </span><span class="spaces">            </span><span class="istickedoff">_ | <span class="tickonlyfalse">adt ^. Mir.adtReprTransparent</span>,</span>
<span class="lineno">  457 </span><span class="spaces">                </span><span class="istickedoff">Just i &lt;- <span class="nottickedoff">Mir.findReprTransparentField col adt</span>,</span>
<span class="lineno">  458 </span><span class="spaces">                </span><span class="istickedoff">Just fld &lt;- <span class="nottickedoff">flds ^? ix i</span> -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  459 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">resolveTransparentSetupVal adt fld</span></span>
<span class="lineno">  460 </span><span class="spaces">            </span><span class="istickedoff">Mir.Adt nm (Mir.Enum discrTp) variants _ _ _ _ -&gt; do</span>
<span class="lineno">  461 </span><span class="spaces">              </span><span class="istickedoff">-- Resolve the field values and check that they have the expected</span>
<span class="lineno">  462 </span><span class="spaces">              </span><span class="istickedoff">-- types.</span>
<span class="lineno">  463 </span><span class="spaces">              </span><span class="istickedoff">flds' &lt;- traverse (resolveSetupVal mcc <span class="nottickedoff">env</span> <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span>) flds</span>
<span class="lineno">  464 </span><span class="spaces">              </span><span class="istickedoff">let expectedFlds = variant ^. Mir.vfields</span>
<span class="lineno">  465 </span><span class="spaces">              </span><span class="istickedoff">let actualFldTys = map (\(MIRVal shp _) -&gt; shapeMirTy shp) flds'</span>
<span class="lineno">  466 </span><span class="spaces">              </span><span class="istickedoff">checkFields</span>
<span class="lineno">  467 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">nm</span></span>
<span class="lineno">  468 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">&quot;Enum&quot;</span></span>
<span class="lineno">  469 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">(&quot;fields in enum variant &quot; ++ show (variant ^. Mir.vname))</span></span>
<span class="lineno">  470 </span><span class="spaces">                </span><span class="istickedoff">expectedFlds</span>
<span class="lineno">  471 </span><span class="spaces">                </span><span class="istickedoff">actualFldTys</span>
<span class="lineno">  472 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  473 </span><span class="spaces">              </span><span class="istickedoff">-- Ensure that the discriminant has an integral type and build</span>
<span class="lineno">  474 </span><span class="spaces">              </span><span class="istickedoff">-- a symbolic bitvector from it.</span>
<span class="lineno">  475 </span><span class="spaces">              </span><span class="istickedoff">Some discrTpr &lt;- pure $ Mir.tyToRepr <span class="nottickedoff">col</span> discrTp</span>
<span class="lineno">  476 </span><span class="spaces">              </span><span class="istickedoff">let discrShp = tyToShapeEq <span class="nottickedoff">col</span> discrTp discrTpr</span>
<span class="lineno">  477 </span><span class="spaces">              </span><span class="istickedoff">IsBVShape _ discrW &lt;- pure $ testDiscriminantIsBV discrShp</span>
<span class="lineno">  478 </span><span class="spaces">              </span><span class="istickedoff">let discr = getEnumVariantDiscr variant</span>
<span class="lineno">  479 </span><span class="spaces">              </span><span class="istickedoff">discrVal &lt;- W4.bvLit sym discrW $ BV.mkBV discrW discr</span>
<span class="lineno">  480 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  481 </span><span class="spaces">              </span><span class="istickedoff">-- Construct an EnumShape and RustEnumRepr. This requires</span>
<span class="lineno">  482 </span><span class="spaces">              </span><span class="istickedoff">-- processing /all/ variants, not just the particular variant that</span>
<span class="lineno">  483 </span><span class="spaces">              </span><span class="istickedoff">-- we are building.</span>
<span class="lineno">  484 </span><span class="spaces">              </span><span class="istickedoff">SomeEnumShape expectedVariantShps enumShp &lt;- pure $</span>
<span class="lineno">  485 </span><span class="spaces">                </span><span class="istickedoff">someEnumShape adt discrTp discrShp variants</span>
<span class="lineno">  486 </span><span class="spaces">              </span><span class="istickedoff">let variantTprs =</span>
<span class="lineno">  487 </span><span class="spaces">                    </span><span class="istickedoff">FC.fmapFC variantShapeType expectedVariantShps</span>
<span class="lineno">  488 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  489 </span><span class="spaces">              </span><span class="istickedoff">-- Construct the VariantShape of the particular variant that we</span>
<span class="lineno">  490 </span><span class="spaces">              </span><span class="istickedoff">-- are building.</span>
<span class="lineno">  491 </span><span class="spaces">              </span><span class="istickedoff">Some variantIdx &lt;- pure $</span>
<span class="lineno">  492 </span><span class="spaces">                </span><span class="istickedoff">variantIntIndex <span class="nottickedoff">nm</span> variantIdxInt $</span>
<span class="lineno">  493 </span><span class="spaces">                </span><span class="istickedoff">Ctx.size expectedVariantShps</span>
<span class="lineno">  494 </span><span class="spaces">              </span><span class="istickedoff">VariantShape expectedFldAssn &lt;-</span>
<span class="lineno">  495 </span><span class="spaces">                </span><span class="istickedoff">pure $ expectedVariantShps Ctx.! variantIdx</span>
<span class="lineno">  496 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  497 </span><span class="spaces">              </span><span class="istickedoff">-- Check that the actual field values match the expected types.</span>
<span class="lineno">  498 </span><span class="spaces">              </span><span class="istickedoff">Some (Functor.Pair actualFldAssn actualValAssn) &lt;-</span>
<span class="lineno">  499 </span><span class="spaces">                </span><span class="istickedoff">pure $ variantFieldsToAssns <span class="nottickedoff">sym</span> flds'</span>
<span class="lineno">  500 </span><span class="spaces">              </span><span class="istickedoff">Refl &lt;-</span>
<span class="lineno">  501 </span><span class="spaces">                </span><span class="istickedoff">case W4.testEquality expectedFldAssn actualFldAssn of</span>
<span class="lineno">  502 </span><span class="spaces">                  </span><span class="istickedoff">Just r -&gt; pure r</span>
<span class="lineno">  503 </span><span class="spaces">                  </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  504 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">panic &quot;resolveSetupVal&quot; [</span></span>
<span class="lineno">  505 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">&quot;Enum field shape mismatch&quot;,</span></span>
<span class="lineno">  506 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">&quot;Expected: &quot; &lt;&gt; Text.pack (show expectedFldAssn),</span></span>
<span class="lineno">  507 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">&quot;Actual: &quot; &lt;&gt; Text.pack (show actualFldAssn)</span></span>
<span class="lineno">  508 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  509 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  510 </span><span class="spaces">              </span><span class="istickedoff">-- Finally, construct a MIRVal.</span>
<span class="lineno">  511 </span><span class="spaces">              </span><span class="istickedoff">let enumVal =</span>
<span class="lineno">  512 </span><span class="spaces">                    </span><span class="istickedoff">Ctx.empty</span>
<span class="lineno">  513 </span><span class="spaces">                      </span><span class="istickedoff">Ctx.:&gt; RV discrVal</span>
<span class="lineno">  514 </span><span class="spaces">                      </span><span class="istickedoff">Ctx.:&gt; RV (injectVariant sym variantTprs variantIdx actualValAssn)</span>
<span class="lineno">  515 </span><span class="spaces">              </span><span class="istickedoff">pure $ MIRVal enumShp enumVal</span>
<span class="lineno">  516 </span><span class="spaces">            </span><span class="istickedoff">Mir.Adt nm Mir.Struct _ _ _ _ _ -&gt;</span>
<span class="lineno">  517 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">panic &quot;resolveSetupVal&quot; [</span></span>
<span class="lineno">  518 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">&quot;Expected enum type, received struct: &quot; &lt;&gt; Text.pack (show nm)</span></span>
<span class="lineno">  519 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  520 </span><span class="spaces">            </span><span class="istickedoff">Mir.Adt nm Mir.Union _ _ _ _ _ -&gt;</span>
<span class="lineno">  521 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">panic &quot;resolveSetupVal&quot; [</span></span>
<span class="lineno">  522 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">&quot;Expected enum type, received union: &quot; &lt;&gt; Text.pack (show nm)</span></span>
<span class="lineno">  523 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  524 </span><span class="spaces">        </span><span class="istickedoff">-- See Note [Symbolic enums] in SAWCentral.Crucible.MIR.Setup.Value for</span>
<span class="lineno">  525 </span><span class="spaces">        </span><span class="istickedoff">-- more information on the approach used to resolve symbolic enum</span>
<span class="lineno">  526 </span><span class="spaces">        </span><span class="istickedoff">-- values.</span>
<span class="lineno">  527 </span><span class="spaces">        </span><span class="istickedoff">MirSetupEnumSymbolic adt discr variantFlds -&gt;</span>
<span class="lineno">  528 </span><span class="spaces">          </span><span class="istickedoff">case adt of</span>
<span class="lineno">  529 </span><span class="spaces">            </span><span class="istickedoff">_ | <span class="tickonlyfalse">adt ^. Mir.adtReprTransparent</span> -&gt;</span>
<span class="lineno">  530 </span><span class="spaces">              </span><span class="istickedoff">-- `repr(transparent)` enum values use MirSetupEnumVariant rather</span>
<span class="lineno">  531 </span><span class="spaces">              </span><span class="istickedoff">-- than MirSetupEnumSymbolic. See the Haddocks for</span>
<span class="lineno">  532 </span><span class="spaces">              </span><span class="istickedoff">-- MirSetupEnumSymbolic for an explanation.</span>
<span class="lineno">  533 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">panic &quot;resolveSetupVal&quot; [</span></span>
<span class="lineno">  534 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">&quot;Symbolic enum of type &quot; &lt;&gt; Text.pack (show (adt ^. Mir.adtname)),</span></span>
<span class="lineno">  535 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">&quot;that uses MirSetupEnumSymbolic rather than MirSetupEnumVariant&quot;</span></span>
<span class="lineno">  536 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  537 </span><span class="spaces">            </span><span class="istickedoff">Mir.Adt nm (Mir.Enum discrTp) variants _ _ _ _ -&gt; do</span>
<span class="lineno">  538 </span><span class="spaces">              </span><span class="istickedoff">-- Resolve the discriminant value and ensure that it has an</span>
<span class="lineno">  539 </span><span class="spaces">              </span><span class="istickedoff">-- integral type.</span>
<span class="lineno">  540 </span><span class="spaces">              </span><span class="istickedoff">MIRVal discrShp discrVal &lt;- resolveSetupVal mcc <span class="nottickedoff">env</span> <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span> discr</span>
<span class="lineno">  541 </span><span class="spaces">              </span><span class="istickedoff">IsBVShape _ discrW &lt;- pure $ testDiscriminantIsBV discrShp</span>
<span class="lineno">  542 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  543 </span><span class="spaces">              </span><span class="istickedoff">-- Resolve the field values in each possible variant and check</span>
<span class="lineno">  544 </span><span class="spaces">              </span><span class="istickedoff">-- that they have the expected types.</span>
<span class="lineno">  545 </span><span class="spaces">              </span><span class="istickedoff">variantFlds' &lt;-</span>
<span class="lineno">  546 </span><span class="spaces">                </span><span class="istickedoff">zipWithM</span>
<span class="lineno">  547 </span><span class="spaces">                  </span><span class="istickedoff">(\variant flds -&gt; do</span>
<span class="lineno">  548 </span><span class="spaces">                    </span><span class="istickedoff">let variantDiscr = getEnumVariantDiscr variant</span>
<span class="lineno">  549 </span><span class="spaces">                    </span><span class="istickedoff">variantDiscrBV &lt;- W4.bvLit sym discrW $ BV.mkBV discrW variantDiscr</span>
<span class="lineno">  550 </span><span class="spaces">                    </span><span class="istickedoff">branch &lt;- W4.bvEq sym variantDiscrBV discrVal</span>
<span class="lineno">  551 </span><span class="spaces">                    </span><span class="istickedoff">flds' &lt;- traverse (resolveSetupVal mcc <span class="nottickedoff">env</span> <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span>) flds</span>
<span class="lineno">  552 </span><span class="spaces">                    </span><span class="istickedoff">let expectedFlds = variant ^. Mir.vfields</span>
<span class="lineno">  553 </span><span class="spaces">                    </span><span class="istickedoff">let actualFldTys = map (\(MIRVal shp _) -&gt; shapeMirTy shp) flds'</span>
<span class="lineno">  554 </span><span class="spaces">                    </span><span class="istickedoff">checkFields</span>
<span class="lineno">  555 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">nm</span></span>
<span class="lineno">  556 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">&quot;Enum&quot;</span></span>
<span class="lineno">  557 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">(&quot;fields in enum variant &quot; ++ show (variant ^. Mir.vname))</span></span>
<span class="lineno">  558 </span><span class="spaces">                      </span><span class="istickedoff">expectedFlds</span>
<span class="lineno">  559 </span><span class="spaces">                      </span><span class="istickedoff">actualFldTys</span>
<span class="lineno">  560 </span><span class="spaces">                    </span><span class="istickedoff">Some (Functor.Pair fldShpAssn valAssn) &lt;-</span>
<span class="lineno">  561 </span><span class="spaces">                      </span><span class="istickedoff">pure $ variantFieldsToAssns <span class="nottickedoff">sym</span> flds'</span>
<span class="lineno">  562 </span><span class="spaces">                    </span><span class="istickedoff">pure $ Some</span>
<span class="lineno">  563 </span><span class="spaces">                         </span><span class="istickedoff">$ Functor.Pair</span>
<span class="lineno">  564 </span><span class="spaces">                             </span><span class="istickedoff">(VariantShape fldShpAssn)</span>
<span class="lineno">  565 </span><span class="spaces">                             </span><span class="istickedoff">(VB (W4.PE branch valAssn)))</span>
<span class="lineno">  566 </span><span class="spaces">                  </span><span class="istickedoff">variants</span>
<span class="lineno">  567 </span><span class="spaces">                  </span><span class="istickedoff">variantFlds</span>
<span class="lineno">  568 </span><span class="spaces">              </span><span class="istickedoff">Some variantBranchAssn &lt;- pure $ Ctx.fromList variantFlds'</span>
<span class="lineno">  569 </span><span class="spaces">              </span><span class="istickedoff">let (actualVariantShps, branchAssn) =</span>
<span class="lineno">  570 </span><span class="spaces">                    </span><span class="istickedoff">Ctx.unzip variantBranchAssn</span>
<span class="lineno">  571 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  572 </span><span class="spaces">              </span><span class="istickedoff">-- Construct an EnumShape.</span>
<span class="lineno">  573 </span><span class="spaces">              </span><span class="istickedoff">SomeEnumShape expectedVariantShps enumShp &lt;- pure $</span>
<span class="lineno">  574 </span><span class="spaces">                </span><span class="istickedoff">someEnumShape <span class="nottickedoff">adt</span> <span class="nottickedoff">discrTp</span> discrShp variants</span>
<span class="lineno">  575 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  576 </span><span class="spaces">              </span><span class="istickedoff">-- Check that the actual variant types match the expected types.</span>
<span class="lineno">  577 </span><span class="spaces">              </span><span class="istickedoff">Refl &lt;-</span>
<span class="lineno">  578 </span><span class="spaces">                </span><span class="istickedoff">case W4.testEquality expectedVariantShps actualVariantShps of</span>
<span class="lineno">  579 </span><span class="spaces">                  </span><span class="istickedoff">Just r -&gt; pure r</span>
<span class="lineno">  580 </span><span class="spaces">                  </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  581 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">panic &quot;resolveSetupVal&quot; [</span></span>
<span class="lineno">  582 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">&quot;Enum variant shape mismatch&quot;,</span></span>
<span class="lineno">  583 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">&quot;Expected: &quot; &lt;&gt; Text.pack (show expectedVariantShps),</span></span>
<span class="lineno">  584 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">&quot;Actual: &quot; &lt;&gt; Text.pack (show actualVariantShps)</span></span>
<span class="lineno">  585 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  586 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  587 </span><span class="spaces">              </span><span class="istickedoff">-- Finally, construct a MIRVal.</span>
<span class="lineno">  588 </span><span class="spaces">              </span><span class="istickedoff">let enumVal =</span>
<span class="lineno">  589 </span><span class="spaces">                    </span><span class="istickedoff">Ctx.empty</span>
<span class="lineno">  590 </span><span class="spaces">                      </span><span class="istickedoff">Ctx.:&gt; RV discrVal</span>
<span class="lineno">  591 </span><span class="spaces">                      </span><span class="istickedoff">Ctx.:&gt; RV branchAssn</span>
<span class="lineno">  592 </span><span class="spaces">              </span><span class="istickedoff">pure $ MIRVal enumShp enumVal</span>
<span class="lineno">  593 </span><span class="spaces">            </span><span class="istickedoff">Mir.Adt nm Mir.Struct _ _ _ _ _ -&gt;</span>
<span class="lineno">  594 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">panic &quot;resolveSetupVal&quot; [</span></span>
<span class="lineno">  595 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">&quot;Expected enum type, received struct: &quot; &lt;&gt; Text.pack (show nm)</span></span>
<span class="lineno">  596 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  597 </span><span class="spaces">            </span><span class="istickedoff">Mir.Adt nm Mir.Union _ _ _ _ _ -&gt;</span>
<span class="lineno">  598 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">panic &quot;resolveSetupVal&quot; [</span></span>
<span class="lineno">  599 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">&quot;Expected enum type, received union: &quot; &lt;&gt; Text.pack (show nm)</span></span>
<span class="lineno">  600 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  601 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupTuple () flds -&gt; do</span>
<span class="lineno">  602 </span><span class="spaces">      </span><span class="istickedoff">flds' &lt;- traverse (resolveSetupVal mcc <span class="nottickedoff">env</span> <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span>) flds</span>
<span class="lineno">  603 </span><span class="spaces">      </span><span class="istickedoff">let <span class="nottickedoff">fldMirTys = map (\(MIRVal shp _) -&gt; shapeMirTy shp) flds'</span></span>
<span class="lineno">  604 </span><span class="spaces">      </span><span class="istickedoff">Some fldAssn &lt;-</span>
<span class="lineno">  605 </span><span class="spaces">        </span><span class="istickedoff">pure $ Ctx.fromList $</span>
<span class="lineno">  606 </span><span class="spaces">        </span><span class="istickedoff">map (\(MIRVal shp v) -&gt;</span>
<span class="lineno">  607 </span><span class="spaces">              </span><span class="istickedoff">Some $ Functor.Pair (OptField shp) (RV (W4.justPartExpr sym v)))</span>
<span class="lineno">  608 </span><span class="spaces">            </span><span class="istickedoff">flds'</span>
<span class="lineno">  609 </span><span class="spaces">      </span><span class="istickedoff">let (fldShpAssn, valAssn) = Ctx.unzip fldAssn</span>
<span class="lineno">  610 </span><span class="spaces">      </span><span class="istickedoff">let tupleShp = TupleShape <span class="nottickedoff">(Mir.TyTuple fldMirTys)</span> <span class="nottickedoff">fldMirTys</span> fldShpAssn</span>
<span class="lineno">  611 </span><span class="spaces">      </span><span class="istickedoff">pure $ MIRVal tupleShp valAssn</span>
<span class="lineno">  612 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupSlice slice -&gt;</span>
<span class="lineno">  613 </span><span class="spaces">      </span><span class="istickedoff">case slice of</span>
<span class="lineno">  614 </span><span class="spaces">        </span><span class="istickedoff">MirSetupSliceRaw{} -&gt;</span>
<span class="lineno">  615 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">panic &quot;resolveSetupVal&quot; [&quot;MirSetupSliceRaw not yet implemented&quot;]</span></span>
<span class="lineno">  616 </span><span class="spaces">        </span><span class="istickedoff">MirSetupSlice sliceInfo arrRef -&gt; do</span>
<span class="lineno">  617 </span><span class="spaces">          </span><span class="istickedoff">SetupSliceFromArrayRef sliceShp refVal len &lt;-</span>
<span class="lineno">  618 </span><span class="spaces">            </span><span class="istickedoff">resolveSetupSliceFromArrayRef bak sliceInfo arrRef</span>
<span class="lineno">  619 </span><span class="spaces">          </span><span class="istickedoff">lenVal &lt;- usizeBvLit sym len</span>
<span class="lineno">  620 </span><span class="spaces">          </span><span class="istickedoff">pure $ MIRVal sliceShp (Ctx.Empty Ctx.:&gt; RV refVal Ctx.:&gt; RV lenVal)</span>
<span class="lineno">  621 </span><span class="spaces">        </span><span class="istickedoff">MirSetupSliceRange sliceInfo arrRef start end -&gt; do</span>
<span class="lineno">  622 </span><span class="spaces">          </span><span class="istickedoff">unless (start &lt;= end) $</span>
<span class="lineno">  623 </span><span class="spaces">            </span><span class="istickedoff">fail $ &quot;slice index starts at &quot; ++ show start</span>
<span class="lineno">  624 </span><span class="spaces">                </span><span class="istickedoff">++ &quot; but ends at &quot; ++ show end</span>
<span class="lineno">  625 </span><span class="spaces">          </span><span class="istickedoff">SetupSliceFromArrayRef sliceShp refVal0 len &lt;-</span>
<span class="lineno">  626 </span><span class="spaces">            </span><span class="istickedoff">resolveSetupSliceFromArrayRef bak sliceInfo arrRef</span>
<span class="lineno">  627 </span><span class="spaces">          </span><span class="istickedoff">unless (end &lt;= len) $</span>
<span class="lineno">  628 </span><span class="spaces">            </span><span class="istickedoff">fail $ &quot;range end index &quot; ++ show end</span>
<span class="lineno">  629 </span><span class="spaces">                </span><span class="istickedoff">++ &quot; out of range for slice of length &quot; ++ show len</span>
<span class="lineno">  630 </span><span class="spaces">          </span><span class="istickedoff">startBV &lt;- usizeBvLit sym start</span>
<span class="lineno">  631 </span><span class="spaces">          </span><span class="istickedoff">refVal1 &lt;- Mir.mirRef_offsetIO bak <span class="nottickedoff">iTypes</span> refVal0 startBV</span>
<span class="lineno">  632 </span><span class="spaces">          </span><span class="istickedoff">lenVal &lt;- usizeBvLit sym $ end - start</span>
<span class="lineno">  633 </span><span class="spaces">          </span><span class="istickedoff">pure $ MIRVal sliceShp (Ctx.Empty Ctx.:&gt; RV refVal1 Ctx.:&gt; RV lenVal)</span>
<span class="lineno">  634 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupArray elemTy vs -&gt; do</span>
<span class="lineno">  635 </span><span class="spaces">      </span><span class="istickedoff">vals &lt;- V.mapM (resolveSetupVal mcc env <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span>) (V.fromList vs)</span>
<span class="lineno">  636 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  637 </span><span class="spaces">      </span><span class="istickedoff">Some (shp :: TypeShape tp) &lt;-</span>
<span class="lineno">  638 </span><span class="spaces">        </span><span class="istickedoff">pure $ tyToShape <span class="nottickedoff">col</span> elemTy</span>
<span class="lineno">  639 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  640 </span><span class="spaces">      </span><span class="istickedoff">let vals' :: Vector (RegValue Sym tp)</span>
<span class="lineno">  641 </span><span class="spaces">          </span><span class="istickedoff">vals' = V.map (\(MIRVal shp' val') -&gt;</span>
<span class="lineno">  642 </span><span class="spaces">                          </span><span class="istickedoff">case W4.testEquality shp shp' of</span>
<span class="lineno">  643 </span><span class="spaces">                            </span><span class="istickedoff">Just Refl -&gt; val'</span>
<span class="lineno">  644 </span><span class="spaces">                            </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">error $ unlines</span></span>
<span class="lineno">  645 </span><span class="spaces">                              </span><span class="istickedoff"><span class="nottickedoff">[ &quot;resolveSetupVal: internal error&quot;</span></span>
<span class="lineno">  646 </span><span class="spaces">                              </span><span class="istickedoff"><span class="nottickedoff">, show shp</span></span>
<span class="lineno">  647 </span><span class="spaces">                              </span><span class="istickedoff"><span class="nottickedoff">, show shp'</span></span>
<span class="lineno">  648 </span><span class="spaces">                              </span><span class="istickedoff"><span class="nottickedoff">]</span>)</span>
<span class="lineno">  649 </span><span class="spaces">                        </span><span class="istickedoff">vals</span>
<span class="lineno">  650 </span><span class="spaces">      </span><span class="istickedoff">return $ MIRVal (ArrayShape (Mir.TyArray elemTy (V.length vals)) elemTy shp)</span>
<span class="lineno">  651 </span><span class="spaces">                      </span><span class="istickedoff">(Mir.MirVector_Vector vals')</span>
<span class="lineno">  652 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupElem _ _ _                -&gt; <span class="nottickedoff">panic &quot;resolveSetupValue&quot; [&quot;elems not yet implemented&quot;]</span></span>
<span class="lineno">  653 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupField _ _ _               -&gt; <span class="nottickedoff">panic &quot;resolveSetupValue&quot; [&quot;fields not yet implemented&quot;]</span></span>
<span class="lineno">  654 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupCast empty _              -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno">  655 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupUnion empty _ _           -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno">  656 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupGlobal () name -&gt; do</span>
<span class="lineno">  657 </span><span class="spaces">      </span><span class="istickedoff">static &lt;- findStatic cs name</span>
<span class="lineno">  658 </span><span class="spaces">      </span><span class="istickedoff">Mir.StaticVar gv &lt;- findStaticVar cs (static ^. Mir.sName)</span>
<span class="lineno">  659 </span><span class="spaces">      </span><span class="istickedoff">let <span class="nottickedoff">sMut = staticMutability static</span></span>
<span class="lineno">  660 </span><span class="spaces">          </span><span class="istickedoff">sTy  = static ^. Mir.sTy</span>
<span class="lineno">  661 </span><span class="spaces">      </span><span class="istickedoff">pure $ MIRVal (RefShape <span class="nottickedoff">(staticTyRef static)</span> sTy <span class="nottickedoff">sMut</span> (globalType gv))</span>
<span class="lineno">  662 </span><span class="spaces">           </span><span class="istickedoff">$ staticRefMux sym gv</span>
<span class="lineno">  663 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupGlobalInitializer () name -&gt; do</span>
<span class="lineno">  664 </span><span class="spaces">      </span><span class="istickedoff">static &lt;- findStatic cs name</span>
<span class="lineno">  665 </span><span class="spaces">      </span><span class="istickedoff">findStaticInitializer mcc static</span>
<span class="lineno">  666 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupMux () c t f -&gt; do</span>
<span class="lineno">  667 </span><span class="spaces">      </span><span class="istickedoff">MIRVal cShp cVal &lt;- resolveTypedTerm mcc c</span>
<span class="lineno">  668 </span><span class="spaces">      </span><span class="istickedoff">let <span class="nottickedoff">cTy = shapeMirTy cShp</span></span>
<span class="lineno">  669 </span><span class="spaces">      </span><span class="istickedoff">let cTpr = shapeType cShp</span>
<span class="lineno">  670 </span><span class="spaces">      </span><span class="istickedoff">Refl &lt;-</span>
<span class="lineno">  671 </span><span class="spaces">        </span><span class="istickedoff">case W4.testEquality cTpr BoolRepr of</span>
<span class="lineno">  672 </span><span class="spaces">          </span><span class="istickedoff">Just r -&gt; pure r</span>
<span class="lineno">  673 </span><span class="spaces">          </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">X.throwM $ MIRMuxNonBoolCondition cTy</span></span>
<span class="lineno">  674 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  675 </span><span class="spaces">      </span><span class="istickedoff">MIRVal tShp tVal &lt;- resolveSetupVal mcc <span class="nottickedoff">env</span> <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span> t</span>
<span class="lineno">  676 </span><span class="spaces">      </span><span class="istickedoff">let <span class="nottickedoff">tTy = shapeMirTy tShp</span></span>
<span class="lineno">  677 </span><span class="spaces">      </span><span class="istickedoff">let tTpr = shapeType tShp</span>
<span class="lineno">  678 </span><span class="spaces">      </span><span class="istickedoff">MIRVal fShp fVal &lt;- resolveSetupVal mcc <span class="nottickedoff">env</span> <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span> f</span>
<span class="lineno">  679 </span><span class="spaces">      </span><span class="istickedoff">let <span class="nottickedoff">fTy = shapeMirTy fShp</span></span>
<span class="lineno">  680 </span><span class="spaces">      </span><span class="istickedoff">let fTpr = shapeType fShp</span>
<span class="lineno">  681 </span><span class="spaces">      </span><span class="istickedoff">Refl &lt;-</span>
<span class="lineno">  682 </span><span class="spaces">        </span><span class="istickedoff">case W4.testEquality tTpr fTpr of</span>
<span class="lineno">  683 </span><span class="spaces">          </span><span class="istickedoff">Just r -&gt; pure r</span>
<span class="lineno">  684 </span><span class="spaces">          </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">X.throwM $ MIRMuxDifferentBranchTypes tTy fTy</span></span>
<span class="lineno">  685 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  686 </span><span class="spaces">      </span><span class="istickedoff">let muxShp = tShp</span>
<span class="lineno">  687 </span><span class="spaces">      </span><span class="istickedoff">let muxTpr = tTpr</span>
<span class="lineno">  688 </span><span class="spaces">      </span><span class="istickedoff">muxVal &lt;- muxRegForType sym <span class="nottickedoff">iTypes</span> muxTpr cVal tVal fVal</span>
<span class="lineno">  689 </span><span class="spaces">      </span><span class="istickedoff">pure $ MIRVal muxShp muxVal</span>
<span class="lineno">  690 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  691 </span><span class="spaces">    </span><span class="istickedoff">cs  = mcc ^. mccRustModule . Mir.rmCS</span>
<span class="lineno">  692 </span><span class="spaces">    </span><span class="istickedoff">col = cs ^. Mir.collection</span>
<span class="lineno">  693 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">iTypes = mcc ^. mccIntrinsicTypes</span></span>
<span class="lineno">  694 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  695 </span><span class="spaces">    </span><span class="istickedoff">usizeBvLit :: Sym -&gt; Int -&gt; IO (W4.SymBV Sym Mir.SizeBits)</span>
<span class="lineno">  696 </span><span class="spaces">    </span><span class="istickedoff">usizeBvLit sym = W4.bvLit sym W4.knownNat . BV.mkBV W4.knownNat . toInteger</span>
<span class="lineno">  697 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  698 </span><span class="spaces">    </span><span class="istickedoff">-- Perform a light amount of typechecking on the fields in a struct or enum</span>
<span class="lineno">  699 </span><span class="spaces">    </span><span class="istickedoff">-- variant. This ensures that the variant receives the expected number of</span>
<span class="lineno">  700 </span><span class="spaces">    </span><span class="istickedoff">-- types and that the types of each field match.</span>
<span class="lineno">  701 </span><span class="spaces">    </span><span class="istickedoff">checkFields ::</span>
<span class="lineno">  702 </span><span class="spaces">      </span><span class="istickedoff">Mir.DefId {- The struct or enum name. (Only used for error messages.) -} -&gt;</span>
<span class="lineno">  703 </span><span class="spaces">      </span><span class="istickedoff">String {- &quot;Struct&quot; or &quot;Enum&quot;. (Only used for error messages.) -} -&gt;</span>
<span class="lineno">  704 </span><span class="spaces">      </span><span class="istickedoff">String {- What type of fields are we checking?</span>
<span class="lineno">  705 </span><span class="spaces">                </span><span class="istickedoff">(Only used for error messages.) -} -&gt;</span>
<span class="lineno">  706 </span><span class="spaces">      </span><span class="istickedoff">[Mir.Field] {- The expected fields. -} -&gt;</span>
<span class="lineno">  707 </span><span class="spaces">      </span><span class="istickedoff">[Mir.Ty] {- The actual field types. -} -&gt;</span>
<span class="lineno">  708 </span><span class="spaces">      </span><span class="istickedoff">IO ()</span>
<span class="lineno">  709 </span><span class="spaces">    </span><span class="istickedoff">checkFields adtNm what fieldDiscr expectedFlds actualFldTys = do</span>
<span class="lineno">  710 </span><span class="spaces">      </span><span class="istickedoff">let expectedFldsNum = length expectedFlds</span>
<span class="lineno">  711 </span><span class="spaces">      </span><span class="istickedoff">let actualFldsNum = length actualFldTys</span>
<span class="lineno">  712 </span><span class="spaces">      </span><span class="istickedoff">unless (expectedFldsNum == actualFldsNum) $</span>
<span class="lineno">  713 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno">  714 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Mismatch in number of &quot; ++ fieldDiscr</span></span>
<span class="lineno">  715 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">, what ++ &quot; name: &quot; ++ show adtNm</span></span>
<span class="lineno">  716 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">, &quot;Expected number of fields: &quot; ++ show expectedFldsNum</span></span>
<span class="lineno">  717 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">, &quot;Actual number of fields:   &quot; ++ show actualFldsNum</span></span>
<span class="lineno">  718 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  719 </span><span class="spaces">      </span><span class="istickedoff">zipWithM_</span>
<span class="lineno">  720 </span><span class="spaces">        </span><span class="istickedoff">(\expectedFld actualFldTy -&gt;</span>
<span class="lineno">  721 </span><span class="spaces">          </span><span class="istickedoff">let expectedFldTy = expectedFld ^. Mir.fty in</span>
<span class="lineno">  722 </span><span class="spaces">          </span><span class="istickedoff">let <span class="nottickedoff">expectedFldName = expectedFld ^. Mir.fName</span> in</span>
<span class="lineno">  723 </span><span class="spaces">          </span><span class="istickedoff">unless (checkCompatibleTys expectedFldTy actualFldTy) $</span>
<span class="lineno">  724 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno">  725 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">[ what ++ &quot; field type mismatch&quot;</span></span>
<span class="lineno">  726 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, &quot;Field name: &quot; ++ show expectedFldName</span></span>
<span class="lineno">  727 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, &quot;Expected type: &quot; ++ show (PP.pretty expectedFldTy)</span></span>
<span class="lineno">  728 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, &quot;Given type:    &quot; ++ show (PP.pretty actualFldTy)</span></span>
<span class="lineno">  729 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">]</span>)</span>
<span class="lineno">  730 </span><span class="spaces">        </span><span class="istickedoff">expectedFlds</span>
<span class="lineno">  731 </span><span class="spaces">        </span><span class="istickedoff">actualFldTys</span>
<span class="lineno">  732 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  733 </span><span class="spaces">    </span><span class="istickedoff">-- Construct the shape for an enum, returning it as a 'SomeEnumShape' value.</span>
<span class="lineno">  734 </span><span class="spaces">    </span><span class="istickedoff">someEnumShape ::</span>
<span class="lineno">  735 </span><span class="spaces">      </span><span class="istickedoff">Mir.Adt {- The enum type -} -&gt;</span>
<span class="lineno">  736 </span><span class="spaces">      </span><span class="istickedoff">Mir.Ty {- The discriminant's MIR type -} -&gt;</span>
<span class="lineno">  737 </span><span class="spaces">      </span><span class="istickedoff">TypeShape discrTp {- The discriminant's TypeShape -} -&gt;</span>
<span class="lineno">  738 </span><span class="spaces">      </span><span class="istickedoff">[Mir.Variant] {- The enum's variants -} -&gt;</span>
<span class="lineno">  739 </span><span class="spaces">      </span><span class="istickedoff">SomeEnumShape discrTp</span>
<span class="lineno">  740 </span><span class="spaces">    </span><span class="istickedoff">someEnumShape adt discrTp discrShp variants</span>
<span class="lineno">  741 </span><span class="spaces">      </span><span class="istickedoff">| let variantTys =</span>
<span class="lineno">  742 </span><span class="spaces">              </span><span class="istickedoff">map (\v -&gt; v ^.. Mir.vfields . each . Mir.fty) variants</span>
<span class="lineno">  743 </span><span class="spaces">      </span><span class="istickedoff">, Some variantShps &lt;-</span>
<span class="lineno">  744 </span><span class="spaces">          </span><span class="istickedoff">Ctx.fromList $</span>
<span class="lineno">  745 </span><span class="spaces">          </span><span class="istickedoff">map (\fldTys -&gt;</span>
<span class="lineno">  746 </span><span class="spaces">                </span><span class="istickedoff">case Ctx.fromList $</span>
<span class="lineno">  747 </span><span class="spaces">                     </span><span class="istickedoff">map</span>
<span class="lineno">  748 </span><span class="spaces">                       </span><span class="istickedoff">(\ty -&gt;</span>
<span class="lineno">  749 </span><span class="spaces">                         </span><span class="istickedoff">case tyToShape col ty of</span>
<span class="lineno">  750 </span><span class="spaces">                           </span><span class="istickedoff">Some shp -&gt;</span>
<span class="lineno">  751 </span><span class="spaces">                             </span><span class="istickedoff">if <span class="tickonlytrue">Mir.canInitialize col ty</span></span>
<span class="lineno">  752 </span><span class="spaces">                             </span><span class="istickedoff">then Some $ ReqField shp</span>
<span class="lineno">  753 </span><span class="spaces">                             </span><span class="istickedoff">else <span class="nottickedoff">Some $ OptField shp</span>)</span>
<span class="lineno">  754 </span><span class="spaces">                       </span><span class="istickedoff">fldTys of</span>
<span class="lineno">  755 </span><span class="spaces">                  </span><span class="istickedoff">Some fldAssn -&gt; Some $ VariantShape fldAssn)</span>
<span class="lineno">  756 </span><span class="spaces">              </span><span class="istickedoff">variantTys</span>
<span class="lineno">  757 </span><span class="spaces">      </span><span class="istickedoff">, let enumShp =</span>
<span class="lineno">  758 </span><span class="spaces">              </span><span class="istickedoff">EnumShape</span>
<span class="lineno">  759 </span><span class="spaces">                </span><span class="istickedoff">(mirAdtToTy adt) variantTys</span>
<span class="lineno">  760 </span><span class="spaces">                </span><span class="istickedoff">variantShps discrTp discrShp</span>
<span class="lineno">  761 </span><span class="spaces">      </span><span class="istickedoff">= SomeEnumShape variantShps enumShp</span>
<span class="lineno">  762 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  763 </span><span class="spaces">    </span><span class="istickedoff">-- Resolve parts of a slice that are shared in common between</span>
<span class="lineno">  764 </span><span class="spaces">    </span><span class="istickedoff">-- 'MirSetupSlice' and 'MirSetupSliceRange'.</span>
<span class="lineno">  765 </span><span class="spaces">    </span><span class="istickedoff">resolveSetupSliceFromArrayRef ::</span>
<span class="lineno">  766 </span><span class="spaces">      </span><span class="istickedoff">OnlineSolver solver =&gt;</span>
<span class="lineno">  767 </span><span class="spaces">      </span><span class="istickedoff">Backend solver -&gt;</span>
<span class="lineno">  768 </span><span class="spaces">      </span><span class="istickedoff">MirSliceInfo -&gt;</span>
<span class="lineno">  769 </span><span class="spaces">      </span><span class="istickedoff">SetupValue -&gt;</span>
<span class="lineno">  770 </span><span class="spaces">      </span><span class="istickedoff">IO SetupSliceFromArrayRef</span>
<span class="lineno">  771 </span><span class="spaces">    </span><span class="istickedoff">resolveSetupSliceFromArrayRef bak sliceInfo arrRef = do</span>
<span class="lineno">  772 </span><span class="spaces">      </span><span class="istickedoff">let sym = backendGetSym bak</span>
<span class="lineno">  773 </span><span class="spaces">      </span><span class="istickedoff">MIRVal arrRefShp arrRefVal &lt;- resolveSetupVal mcc env <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span> arrRef</span>
<span class="lineno">  774 </span><span class="spaces">      </span><span class="istickedoff">case arrRefShp of</span>
<span class="lineno">  775 </span><span class="spaces">        </span><span class="istickedoff">RefShape _ arrTy mut (Mir.MirVectorRepr elemTpr) -&gt; do</span>
<span class="lineno">  776 </span><span class="spaces">          </span><span class="istickedoff">(sliceTy, elemTy, len) &lt;- arrayToSliceTys sliceInfo <span class="nottickedoff">mut</span> arrTy</span>
<span class="lineno">  777 </span><span class="spaces">          </span><span class="istickedoff">zeroBV &lt;- usizeBvLit sym 0</span>
<span class="lineno">  778 </span><span class="spaces">          </span><span class="istickedoff">refVal &lt;- Mir.subindexMirRefIO bak <span class="nottickedoff">iTypes</span> elemTpr arrRefVal zeroBV</span>
<span class="lineno">  779 </span><span class="spaces">          </span><span class="istickedoff">let sliceShp = SliceShape <span class="nottickedoff">(Mir.TyRef sliceTy mut)</span> <span class="nottickedoff">elemTy</span> <span class="nottickedoff">mut</span> <span class="nottickedoff">elemTpr</span></span>
<span class="lineno">  780 </span><span class="spaces">          </span><span class="istickedoff">pure $ SetupSliceFromArrayRef sliceShp refVal len</span>
<span class="lineno">  781 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">X.throwM $ MIRSliceNonReference $ shapeMirTy arrRefShp</span></span>
<span class="lineno">  782 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  783 </span><span class="spaces">    </span><span class="istickedoff">-- Resolve a transparent struct or enum value.</span>
<span class="lineno">  784 </span><span class="spaces">    </span><span class="istickedoff">resolveTransparentSetupVal :: Mir.Adt -&gt; SetupValue -&gt; IO MIRVal</span>
<span class="lineno">  785 </span><span class="spaces">    </span><span class="istickedoff">resolveTransparentSetupVal adt fld = do</span>
<span class="lineno">  786 </span><span class="spaces">      </span><span class="istickedoff">MIRVal shp fld' &lt;- resolveSetupVal mcc <span class="nottickedoff">env</span> <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span> fld</span>
<span class="lineno">  787 </span><span class="spaces">      </span><span class="istickedoff">pure $ MIRVal (TransparentShape <span class="nottickedoff">(mirAdtToTy adt)</span> shp) fld'</span>
<span class="lineno">  788 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  789 </span><span class="spaces">    </span><span class="istickedoff">-- Given the list of fields in a struct or enum variant, construct two</span>
<span class="lineno">  790 </span><span class="spaces">    </span><span class="istickedoff">-- Assignments, where the first Assignment consists of each field's type,</span>
<span class="lineno">  791 </span><span class="spaces">    </span><span class="istickedoff">-- and the second assignment consists of each field's value.</span>
<span class="lineno">  792 </span><span class="spaces">    </span><span class="istickedoff">variantFieldsToAssns ::</span>
<span class="lineno">  793 </span><span class="spaces">      </span><span class="istickedoff">Sym -&gt;</span>
<span class="lineno">  794 </span><span class="spaces">      </span><span class="istickedoff">[MIRVal] -&gt;</span>
<span class="lineno">  795 </span><span class="spaces">      </span><span class="istickedoff">Some (Functor.Product</span>
<span class="lineno">  796 </span><span class="spaces">             </span><span class="istickedoff">(Ctx.Assignment FieldShape)</span>
<span class="lineno">  797 </span><span class="spaces">             </span><span class="istickedoff">(Ctx.Assignment (RegValue' Sym)))</span>
<span class="lineno">  798 </span><span class="spaces">    </span><span class="istickedoff">variantFieldsToAssns sym flds</span>
<span class="lineno">  799 </span><span class="spaces">      </span><span class="istickedoff">| Some fldValAssn &lt;- someFldValAssn</span>
<span class="lineno">  800 </span><span class="spaces">      </span><span class="istickedoff">, (fldAssn, valAssn) &lt;- Ctx.unzip fldValAssn</span>
<span class="lineno">  801 </span><span class="spaces">      </span><span class="istickedoff">= Some $ Functor.Pair fldAssn valAssn</span>
<span class="lineno">  802 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  803 </span><span class="spaces">        </span><span class="istickedoff">someFldValAssn ::</span>
<span class="lineno">  804 </span><span class="spaces">          </span><span class="istickedoff">Some (Ctx.Assignment (Functor.Product FieldShape (RegValue' Sym)))</span>
<span class="lineno">  805 </span><span class="spaces">        </span><span class="istickedoff">someFldValAssn =</span>
<span class="lineno">  806 </span><span class="spaces">          </span><span class="istickedoff">Ctx.fromList $</span>
<span class="lineno">  807 </span><span class="spaces">          </span><span class="istickedoff">map (\(MIRVal shp v) -&gt;</span>
<span class="lineno">  808 </span><span class="spaces">                </span><span class="istickedoff">if <span class="tickonlytrue">Mir.canInitialize col (shapeMirTy shp)</span></span>
<span class="lineno">  809 </span><span class="spaces">                </span><span class="istickedoff">then Some $ Functor.Pair (ReqField shp) (RV v)</span>
<span class="lineno">  810 </span><span class="spaces">                </span><span class="istickedoff">else <span class="nottickedoff">Some $ Functor.Pair (OptField shp) (RV (W4.justPartExpr sym v))</span>)</span>
<span class="lineno">  811 </span><span class="spaces">              </span><span class="istickedoff">flds</span></span>
<span class="lineno">  812 </span>
<span class="lineno">  813 </span>-- | An intermediate data structure that is only used by
<span class="lineno">  814 </span>-- 'someEnumShape'. This existentially closes over the @variantsCtx@ type
<span class="lineno">  815 </span>-- parameter.
<span class="lineno">  816 </span>data SomeEnumShape discrTp where
<span class="lineno">  817 </span>  SomeEnumShape ::
<span class="lineno">  818 </span>    Ctx.Assignment VariantShape variantsCtx -&gt;
<span class="lineno">  819 </span>    TypeShape (Mir.RustEnumType discrTp variantsCtx) -&gt;
<span class="lineno">  820 </span>    SomeEnumShape discrTp
<span class="lineno">  821 </span>
<span class="lineno">  822 </span>-- | An intermediate data structure that is only used by
<span class="lineno">  823 </span>-- 'resolveSetupSliceFromArrayRef'.
<span class="lineno">  824 </span>data SetupSliceFromArrayRef where
<span class="lineno">  825 </span>  SetupSliceFromArrayRef ::
<span class="lineno">  826 </span>    TypeShape Mir.MirSlice {- ^ The overall shape of the slice -} -&gt;
<span class="lineno">  827 </span>    Mir.MirReferenceMux Sym {- ^ The reference to the array -} -&gt;
<span class="lineno">  828 </span>    Int {- ^ The array length -} -&gt;
<span class="lineno">  829 </span>    SetupSliceFromArrayRef
<span class="lineno">  830 </span>
<span class="lineno">  831 </span>resolveTypedTerm ::
<span class="lineno">  832 </span>  MIRCrucibleContext -&gt;
<span class="lineno">  833 </span>  TypedTerm       -&gt;
<span class="lineno">  834 </span>  IO MIRVal
<span class="lineno">  835 </span><span class="decl"><span class="istickedoff">resolveTypedTerm mcc tm =</span>
<span class="lineno">  836 </span><span class="spaces">  </span><span class="istickedoff">case ttType tm of</span>
<span class="lineno">  837 </span><span class="spaces">    </span><span class="istickedoff">TypedTermSchema (Cryptol.Forall [] [] ty) -&gt;</span>
<span class="lineno">  838 </span><span class="spaces">      </span><span class="istickedoff">resolveSAWTerm mcc (Cryptol.evalValType <span class="nottickedoff">mempty</span> ty) (ttTerm tm)</span>
<span class="lineno">  839 </span><span class="spaces">    </span><span class="istickedoff">tp -&gt; <span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno">  840 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">[ &quot;resolveTypedTerm: expected monomorphic term&quot;</span></span>
<span class="lineno">  841 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">, &quot;but got a term of type&quot;</span></span>
<span class="lineno">  842 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">, show (ppTypedTermType tp)</span></span>
<span class="lineno">  843 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno">  844 </span>
<span class="lineno">  845 </span>resolveSAWPred ::
<span class="lineno">  846 </span>  MIRCrucibleContext -&gt;
<span class="lineno">  847 </span>  Term -&gt;
<span class="lineno">  848 </span>  IO (W4.Pred Sym)
<span class="lineno">  849 </span><span class="decl"><span class="istickedoff">resolveSAWPred cc tm =</span>
<span class="lineno">  850 </span><span class="spaces">  </span><span class="istickedoff">do let sym = cc^.mccSym</span>
<span class="lineno">  851 </span><span class="spaces">     </span><span class="istickedoff">st &lt;- sawCoreState sym</span>
<span class="lineno">  852 </span><span class="spaces">     </span><span class="istickedoff">let sc = saw_ctx st</span>
<span class="lineno">  853 </span><span class="spaces">     </span><span class="istickedoff">checkBooleanType sc tm</span>
<span class="lineno">  854 </span><span class="spaces">     </span><span class="istickedoff">bindSAWTerm sym st W4.BaseBoolRepr tm</span></span>
<span class="lineno">  855 </span>
<span class="lineno">  856 </span>resolveSAWTerm ::
<span class="lineno">  857 </span>  MIRCrucibleContext -&gt;
<span class="lineno">  858 </span>  Cryptol.TValue -&gt;
<span class="lineno">  859 </span>  Term -&gt;
<span class="lineno">  860 </span>  IO MIRVal
<span class="lineno">  861 </span><span class="decl"><span class="istickedoff">resolveSAWTerm mcc tp tm =</span>
<span class="lineno">  862 </span><span class="spaces">  </span><span class="istickedoff">case tp of</span>
<span class="lineno">  863 </span><span class="spaces">    </span><span class="istickedoff">Cryptol.TVBit -&gt;</span>
<span class="lineno">  864 </span><span class="spaces">      </span><span class="istickedoff">do b &lt;- resolveBoolTerm sym tm</span>
<span class="lineno">  865 </span><span class="spaces">         </span><span class="istickedoff">pure $ MIRVal (PrimShape <span class="nottickedoff">Mir.TyBool</span> W4.BaseBoolRepr) b</span>
<span class="lineno">  866 </span><span class="spaces">    </span><span class="istickedoff">Cryptol.TVInteger -&gt;</span>
<span class="lineno">  867 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">fail &quot;resolveSAWTerm: unimplemented type Integer (FIXME)&quot;</span></span>
<span class="lineno">  868 </span><span class="spaces">    </span><span class="istickedoff">Cryptol.TVIntMod _ -&gt;</span>
<span class="lineno">  869 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">fail &quot;resolveSAWTerm: unimplemented type Z n (FIXME)&quot;</span></span>
<span class="lineno">  870 </span><span class="spaces">    </span><span class="istickedoff">Cryptol.TVFloat{} -&gt;</span>
<span class="lineno">  871 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">fail &quot;resolveSAWTerm: unimplemented type Float e p (FIXME)&quot;</span></span>
<span class="lineno">  872 </span><span class="spaces">    </span><span class="istickedoff">Cryptol.TVArray{} -&gt;</span>
<span class="lineno">  873 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">fail &quot;resolveSAWTerm: unimplemented type Array a b (FIXME)&quot;</span></span>
<span class="lineno">  874 </span><span class="spaces">    </span><span class="istickedoff">Cryptol.TVRational -&gt;</span>
<span class="lineno">  875 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">fail &quot;resolveSAWTerm: unimplemented type Rational (FIXME)&quot;</span></span>
<span class="lineno">  876 </span><span class="spaces">    </span><span class="istickedoff">Cryptol.TVSeq sz Cryptol.TVBit -&gt;</span>
<span class="lineno">  877 </span><span class="spaces">      </span><span class="istickedoff">case sz of</span>
<span class="lineno">  878 </span><span class="spaces">        </span><span class="istickedoff">8   -&gt; bv_term Mir.B8   $ W4.knownNat @8</span>
<span class="lineno">  879 </span><span class="spaces">        </span><span class="istickedoff">16  -&gt; bv_term Mir.B16  $ W4.knownNat @16</span>
<span class="lineno">  880 </span><span class="spaces">        </span><span class="istickedoff">32  -&gt; bv_term Mir.B32  $ W4.knownNat @32</span>
<span class="lineno">  881 </span><span class="spaces">        </span><span class="istickedoff">64  -&gt; bv_term <span class="nottickedoff">Mir.B64</span>  $ W4.knownNat @64</span>
<span class="lineno">  882 </span><span class="spaces">        </span><span class="istickedoff">128 -&gt; <span class="nottickedoff">bv_term Mir.B128 $ W4.knownNat @128</span></span>
<span class="lineno">  883 </span><span class="spaces">        </span><span class="istickedoff">_   -&gt; <span class="nottickedoff">fail (&quot;Invalid bitvector width: &quot; ++ show sz)</span></span>
<span class="lineno">  884 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  885 </span><span class="spaces">        </span><span class="istickedoff">bv_term :: forall w. 1 W4.&lt;= w</span>
<span class="lineno">  886 </span><span class="spaces">                </span><span class="istickedoff">=&gt; Mir.BaseSize -&gt; W4.NatRepr w -&gt; IO MIRVal</span>
<span class="lineno">  887 </span><span class="spaces">        </span><span class="istickedoff">bv_term b n =</span>
<span class="lineno">  888 </span><span class="spaces">         </span><span class="istickedoff">MIRVal (PrimShape (Mir.TyUint b) (W4.BaseBVRepr n)) &lt;$&gt;</span>
<span class="lineno">  889 </span><span class="spaces">         </span><span class="istickedoff">resolveBitvectorTerm sym n tm</span>
<span class="lineno">  890 </span><span class="spaces">    </span><span class="istickedoff">Cryptol.TVSeq sz tp' -&gt; do</span>
<span class="lineno">  891 </span><span class="spaces">      </span><span class="istickedoff">st &lt;- sawCoreState sym</span>
<span class="lineno">  892 </span><span class="spaces">      </span><span class="istickedoff">let sc = saw_ctx st</span>
<span class="lineno">  893 </span><span class="spaces">      </span><span class="istickedoff">sz_tm &lt;- scNat sc (fromIntegral sz)</span>
<span class="lineno">  894 </span><span class="spaces">      </span><span class="istickedoff">tp_tm &lt;- importType sc <span class="nottickedoff">emptyEnv</span> (Cryptol.tValTy tp')</span>
<span class="lineno">  895 </span><span class="spaces">      </span><span class="istickedoff">case toMIRType tp' of</span>
<span class="lineno">  896 </span><span class="spaces">        </span><span class="istickedoff">Left e -&gt; <span class="nottickedoff">fail (&quot;In resolveSAWTerm: &quot; ++ toMIRTypeErrToString e)</span></span>
<span class="lineno">  897 </span><span class="spaces">        </span><span class="istickedoff">Right mirTy -&gt; do</span>
<span class="lineno">  898 </span><span class="spaces">          </span><span class="istickedoff">Some (shp :: TypeShape tp) &lt;- pure $ tyToShape <span class="nottickedoff">col</span> mirTy</span>
<span class="lineno">  899 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  900 </span><span class="spaces">          </span><span class="istickedoff">let sz' = fromInteger sz</span>
<span class="lineno">  901 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  902 </span><span class="spaces">              </span><span class="istickedoff">f :: Int -&gt; IO (RegValue Sym tp)</span>
<span class="lineno">  903 </span><span class="spaces">              </span><span class="istickedoff">f i = do</span>
<span class="lineno">  904 </span><span class="spaces">                </span><span class="istickedoff">i_tm &lt;- scNat sc (fromIntegral i)</span>
<span class="lineno">  905 </span><span class="spaces">                </span><span class="istickedoff">tm' &lt;- scAt sc sz_tm tp_tm tm i_tm</span>
<span class="lineno">  906 </span><span class="spaces">                </span><span class="istickedoff">MIRVal shp' val &lt;- resolveSAWTerm mcc tp' tm'</span>
<span class="lineno">  907 </span><span class="spaces">                </span><span class="istickedoff">Refl &lt;- case W4.testEquality shp shp' of</span>
<span class="lineno">  908 </span><span class="spaces">                          </span><span class="istickedoff">Just r -&gt; pure r</span>
<span class="lineno">  909 </span><span class="spaces">                          </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno">  910 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">[ &quot;resolveSAWTerm: internal error&quot;</span></span>
<span class="lineno">  911 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">, show shp</span></span>
<span class="lineno">  912 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">, show shp'</span></span>
<span class="lineno">  913 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  914 </span><span class="spaces">                </span><span class="istickedoff">pure val</span>
<span class="lineno">  915 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  916 </span><span class="spaces">          </span><span class="istickedoff">vals &lt;- V.generateM sz' f</span>
<span class="lineno">  917 </span><span class="spaces">          </span><span class="istickedoff">pure $ MIRVal (ArrayShape <span class="nottickedoff">(Mir.TyArray mirTy sz')</span> <span class="nottickedoff">mirTy</span> shp)</span>
<span class="lineno">  918 </span><span class="spaces">               </span><span class="istickedoff">$ Mir.MirVector_Vector vals</span>
<span class="lineno">  919 </span><span class="spaces">    </span><span class="istickedoff">Cryptol.TVStream _tp' -&gt;</span>
<span class="lineno">  920 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">fail &quot;resolveSAWTerm: unsupported infinite stream type&quot;</span></span>
<span class="lineno">  921 </span><span class="spaces">    </span><span class="istickedoff">Cryptol.TVTuple tps -&gt; do</span>
<span class="lineno">  922 </span><span class="spaces">      </span><span class="istickedoff">st &lt;- sawCoreState sym</span>
<span class="lineno">  923 </span><span class="spaces">      </span><span class="istickedoff">let sc = saw_ctx st</span>
<span class="lineno">  924 </span><span class="spaces">      </span><span class="istickedoff">tms &lt;- traverse (\i -&gt; scTupleSelector sc tm i (length tps)) [1 .. length tps]</span>
<span class="lineno">  925 </span><span class="spaces">      </span><span class="istickedoff">vals &lt;- zipWithM (resolveSAWTerm mcc) tps tms</span>
<span class="lineno">  926 </span><span class="spaces">      </span><span class="istickedoff">if null vals</span>
<span class="lineno">  927 </span><span class="spaces">        </span><span class="istickedoff">then pure $ MIRVal (UnitShape <span class="nottickedoff">(Mir.TyTuple [])</span>) ()</span>
<span class="lineno">  928 </span><span class="spaces">        </span><span class="istickedoff">else do</span>
<span class="lineno">  929 </span><span class="spaces">          </span><span class="istickedoff">let <span class="nottickedoff">mirTys = map (\(MIRVal shp _) -&gt; shapeMirTy shp) vals</span></span>
<span class="lineno">  930 </span><span class="spaces">          </span><span class="istickedoff">let <span class="nottickedoff">mirTupleTy = Mir.TyTuple mirTys</span></span>
<span class="lineno">  931 </span><span class="spaces">          </span><span class="istickedoff">Some fldAssn &lt;-</span>
<span class="lineno">  932 </span><span class="spaces">            </span><span class="istickedoff">pure $ Ctx.fromList $</span>
<span class="lineno">  933 </span><span class="spaces">            </span><span class="istickedoff">map (\(MIRVal shp val) -&gt;</span>
<span class="lineno">  934 </span><span class="spaces">                  </span><span class="istickedoff">Some $ Functor.Pair (OptField shp) (RV (W4.justPartExpr sym val)))</span>
<span class="lineno">  935 </span><span class="spaces">                </span><span class="istickedoff">vals</span>
<span class="lineno">  936 </span><span class="spaces">          </span><span class="istickedoff">let (fldShpAssn, valAssn) = Ctx.unzip fldAssn</span>
<span class="lineno">  937 </span><span class="spaces">          </span><span class="istickedoff">pure $ MIRVal (TupleShape <span class="nottickedoff">mirTupleTy</span> <span class="nottickedoff">mirTys</span> fldShpAssn) valAssn</span>
<span class="lineno">  938 </span><span class="spaces">    </span><span class="istickedoff">Cryptol.TVRec _flds -&gt;</span>
<span class="lineno">  939 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">fail &quot;resolveSAWTerm: unsupported record type&quot;</span></span>
<span class="lineno">  940 </span><span class="spaces">    </span><span class="istickedoff">Cryptol.TVFun _ _ -&gt;</span>
<span class="lineno">  941 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">fail &quot;resolveSAWTerm: unsupported function type&quot;</span></span>
<span class="lineno">  942 </span><span class="spaces">    </span><span class="istickedoff">Cryptol.TVNominal {} -&gt;</span>
<span class="lineno">  943 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">fail &quot;resolveSAWTerm: unsupported nominal type&quot;</span></span>
<span class="lineno">  944 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  945 </span><span class="spaces">    </span><span class="istickedoff">sym = mcc ^. mccSym</span>
<span class="lineno">  946 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">col = mcc ^. mccRustModule ^. Mir.rmCS ^. Mir.collection</span></span></span>
<span class="lineno">  947 </span>
<span class="lineno">  948 </span>resolveBitvectorTerm ::
<span class="lineno">  949 </span>  forall w.
<span class="lineno">  950 </span>  (1 W4.&lt;= w) =&gt;
<span class="lineno">  951 </span>  Sym -&gt;
<span class="lineno">  952 </span>  W4.NatRepr w -&gt;
<span class="lineno">  953 </span>  Term -&gt;
<span class="lineno">  954 </span>  IO (W4.SymBV Sym w)
<span class="lineno">  955 </span><span class="decl"><span class="istickedoff">resolveBitvectorTerm sym w tm =</span>
<span class="lineno">  956 </span><span class="spaces">  </span><span class="istickedoff">do st &lt;- sawCoreState sym</span>
<span class="lineno">  957 </span><span class="spaces">     </span><span class="istickedoff">let sc = saw_ctx st</span>
<span class="lineno">  958 </span><span class="spaces">     </span><span class="istickedoff">mx &lt;- case getAllExts tm of</span>
<span class="lineno">  959 </span><span class="spaces">             </span><span class="istickedoff">-- concretely evaluate if it is a closed term</span>
<span class="lineno">  960 </span><span class="spaces">             </span><span class="istickedoff">[] -&gt;</span>
<span class="lineno">  961 </span><span class="spaces">               </span><span class="istickedoff">do modmap &lt;- scGetModuleMap sc</span>
<span class="lineno">  962 </span><span class="spaces">                  </span><span class="istickedoff">let v = Concrete.evalSharedTerm modmap mempty <span class="nottickedoff">mempty</span> tm</span>
<span class="lineno">  963 </span><span class="spaces">                  </span><span class="istickedoff">pure (Just (Prim.unsigned (Concrete.toWord v)))</span>
<span class="lineno">  964 </span><span class="spaces">             </span><span class="istickedoff">_ -&gt; return Nothing</span>
<span class="lineno">  965 </span><span class="spaces">     </span><span class="istickedoff">case mx of</span>
<span class="lineno">  966 </span><span class="spaces">       </span><span class="istickedoff">Just x  -&gt; W4.bvLit sym w (BV.mkBV w x)</span>
<span class="lineno">  967 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt; bindSAWTerm sym st (W4.BaseBVRepr w) tm</span></span>
<span class="lineno">  968 </span>
<span class="lineno">  969 </span>data ToMIRTypeErr = NotYetSupported String | Impossible String
<span class="lineno">  970 </span>
<span class="lineno">  971 </span>toMIRTypeErrToString :: ToMIRTypeErr -&gt; String
<span class="lineno">  972 </span><span class="decl"><span class="nottickedoff">toMIRTypeErrToString =</span>
<span class="lineno">  973 </span><span class="spaces">  </span><span class="nottickedoff">\case</span>
<span class="lineno">  974 </span><span class="spaces">    </span><span class="nottickedoff">NotYetSupported ty -&gt;</span>
<span class="lineno">  975 </span><span class="spaces">      </span><span class="nottickedoff">unwords [ &quot;SAW doesn't yet support translating Cryptol's&quot;</span>
<span class="lineno">  976 </span><span class="spaces">              </span><span class="nottickedoff">, ty</span>
<span class="lineno">  977 </span><span class="spaces">              </span><span class="nottickedoff">, &quot;type(s) into crucible-mir's type system.&quot;</span>
<span class="lineno">  978 </span><span class="spaces">              </span><span class="nottickedoff">]</span>
<span class="lineno">  979 </span><span class="spaces">    </span><span class="nottickedoff">Impossible ty -&gt;</span>
<span class="lineno">  980 </span><span class="spaces">      </span><span class="nottickedoff">unwords [ &quot;User error: It's impossible to store Cryptol&quot;</span>
<span class="lineno">  981 </span><span class="spaces">              </span><span class="nottickedoff">, ty</span>
<span class="lineno">  982 </span><span class="spaces">              </span><span class="nottickedoff">, &quot;values in crucible-mir's memory model.&quot;</span>
<span class="lineno">  983 </span><span class="spaces">              </span><span class="nottickedoff">]</span></span>
<span class="lineno">  984 </span>
<span class="lineno">  985 </span>toMIRType ::
<span class="lineno">  986 </span>  Cryptol.TValue -&gt;
<span class="lineno">  987 </span>  Either ToMIRTypeErr Mir.Ty
<span class="lineno">  988 </span><span class="decl"><span class="istickedoff">toMIRType tp =</span>
<span class="lineno">  989 </span><span class="spaces">  </span><span class="istickedoff">case tp of</span>
<span class="lineno">  990 </span><span class="spaces">    </span><span class="istickedoff">Cryptol.TVBit -&gt; Right Mir.TyBool</span>
<span class="lineno">  991 </span><span class="spaces">    </span><span class="istickedoff">Cryptol.TVInteger -&gt; <span class="nottickedoff">Left (NotYetSupported &quot;integer&quot;)</span></span>
<span class="lineno">  992 </span><span class="spaces">    </span><span class="istickedoff">Cryptol.TVIntMod _ -&gt; <span class="nottickedoff">Left (Impossible &quot;integer (mod n)&quot;)</span></span>
<span class="lineno">  993 </span><span class="spaces">    </span><span class="istickedoff">Cryptol.TVFloat{} -&gt; <span class="nottickedoff">Left (NotYetSupported &quot;float e p&quot;)</span></span>
<span class="lineno">  994 </span><span class="spaces">    </span><span class="istickedoff">Cryptol.TVArray{} -&gt; <span class="nottickedoff">Left (NotYetSupported &quot;array a b&quot;)</span></span>
<span class="lineno">  995 </span><span class="spaces">    </span><span class="istickedoff">Cryptol.TVRational -&gt; <span class="nottickedoff">Left (NotYetSupported &quot;rational&quot;)</span></span>
<span class="lineno">  996 </span><span class="spaces">    </span><span class="istickedoff">Cryptol.TVSeq n Cryptol.TVBit -&gt;</span>
<span class="lineno">  997 </span><span class="spaces">      </span><span class="istickedoff">case n of</span>
<span class="lineno">  998 </span><span class="spaces">        </span><span class="istickedoff">8   -&gt; Right $ Mir.TyUint Mir.B8</span>
<span class="lineno">  999 </span><span class="spaces">        </span><span class="istickedoff">16  -&gt; Right $ Mir.TyUint Mir.B16</span>
<span class="lineno"> 1000 </span><span class="spaces">        </span><span class="istickedoff">32  -&gt; Right $ Mir.TyUint Mir.B32</span>
<span class="lineno"> 1001 </span><span class="spaces">        </span><span class="istickedoff">64  -&gt; Right $ Mir.TyUint Mir.B64</span>
<span class="lineno"> 1002 </span><span class="spaces">        </span><span class="istickedoff">128 -&gt; <span class="nottickedoff">Right $ Mir.TyUint Mir.B128</span></span>
<span class="lineno"> 1003 </span><span class="spaces">        </span><span class="istickedoff">_   -&gt; <span class="nottickedoff">Left (Impossible (&quot;unsupported bitvector size: &quot; ++ show n))</span></span>
<span class="lineno"> 1004 </span><span class="spaces">    </span><span class="istickedoff">Cryptol.TVSeq n t -&gt; do</span>
<span class="lineno"> 1005 </span><span class="spaces">      </span><span class="istickedoff">t' &lt;- toMIRType t</span>
<span class="lineno"> 1006 </span><span class="spaces">      </span><span class="istickedoff">let n' = fromIntegral n</span>
<span class="lineno"> 1007 </span><span class="spaces">      </span><span class="istickedoff">Right $ Mir.TyArray t' n'</span>
<span class="lineno"> 1008 </span><span class="spaces">    </span><span class="istickedoff">Cryptol.TVStream _tp' -&gt; <span class="nottickedoff">Left (Impossible &quot;stream&quot;)</span></span>
<span class="lineno"> 1009 </span><span class="spaces">    </span><span class="istickedoff">Cryptol.TVTuple tps -&gt; do</span>
<span class="lineno"> 1010 </span><span class="spaces">      </span><span class="istickedoff">tps' &lt;- traverse toMIRType tps</span>
<span class="lineno"> 1011 </span><span class="spaces">      </span><span class="istickedoff">Right $ Mir.TyTuple tps'</span>
<span class="lineno"> 1012 </span><span class="spaces">    </span><span class="istickedoff">Cryptol.TVRec _flds -&gt; <span class="nottickedoff">Left (NotYetSupported &quot;record&quot;)</span></span>
<span class="lineno"> 1013 </span><span class="spaces">    </span><span class="istickedoff">Cryptol.TVFun _ _ -&gt; <span class="nottickedoff">Left (Impossible &quot;function&quot;)</span></span>
<span class="lineno"> 1014 </span><span class="spaces">    </span><span class="istickedoff">Cryptol.TVNominal {} -&gt; <span class="nottickedoff">Left (Impossible &quot;nominal&quot;)</span></span></span>
<span class="lineno"> 1015 </span>
<span class="lineno"> 1016 </span>-- | Check if two MIR references are equal.
<span class="lineno"> 1017 </span>equalRefsPred ::
<span class="lineno"> 1018 </span>  MIRCrucibleContext -&gt;
<span class="lineno"> 1019 </span>  MirPointer Sym tp1 -&gt;
<span class="lineno"> 1020 </span>  MirPointer Sym tp2 -&gt;
<span class="lineno"> 1021 </span>  IO (W4.Pred Sym)
<span class="lineno"> 1022 </span><span class="decl"><span class="istickedoff">equalRefsPred cc mp1 mp2 =</span>
<span class="lineno"> 1023 </span><span class="spaces">  </span><span class="istickedoff">mccWithBackend cc $ \bak -&gt;</span>
<span class="lineno"> 1024 </span><span class="spaces">  </span><span class="istickedoff">let <span class="nottickedoff">sym = backendGetSym bak</span> in</span>
<span class="lineno"> 1025 </span><span class="spaces">  </span><span class="istickedoff">case W4.testEquality (mp1^.mpType) (mp2^.mpType) of</span>
<span class="lineno"> 1026 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">pure $ W4.falsePred sym</span></span>
<span class="lineno"> 1027 </span><span class="spaces">    </span><span class="istickedoff">Just Refl -&gt; Mir.mirRef_eqIO bak (mp1^.mpRef) (mp2^.mpRef)</span></span>
<span class="lineno"> 1028 </span>
<span class="lineno"> 1029 </span>-- | Check if two 'MIRVal's are equal.
<span class="lineno"> 1030 </span>equalValsPred ::
<span class="lineno"> 1031 </span>  MIRCrucibleContext -&gt;
<span class="lineno"> 1032 </span>  MIRVal -&gt;
<span class="lineno"> 1033 </span>  MIRVal -&gt;
<span class="lineno"> 1034 </span>  IO (W4.Pred Sym)
<span class="lineno"> 1035 </span><span class="decl"><span class="istickedoff">equalValsPred cc mv1 mv2 =</span>
<span class="lineno"> 1036 </span><span class="spaces">  </span><span class="istickedoff">case (mv1, mv2) of</span>
<span class="lineno"> 1037 </span><span class="spaces">    </span><span class="istickedoff">(MIRVal shp1 v1, MIRVal shp2 v2) -&gt; do</span>
<span class="lineno"> 1038 </span><span class="spaces">      </span><span class="istickedoff">mbEq &lt;- runMaybeT $ do</span>
<span class="lineno"> 1039 </span><span class="spaces">        </span><span class="istickedoff">guard $ checkCompatibleTys (shapeMirTy shp1) (shapeMirTy shp2)</span>
<span class="lineno"> 1040 </span><span class="spaces">        </span><span class="istickedoff">Refl &lt;- testEquality shp1 shp2</span>
<span class="lineno"> 1041 </span><span class="spaces">        </span><span class="istickedoff">goTy shp1 v1 v2</span>
<span class="lineno"> 1042 </span><span class="spaces">      </span><span class="istickedoff">pure $ fromMaybe <span class="nottickedoff">(W4.falsePred sym)</span> mbEq</span>
<span class="lineno"> 1043 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1044 </span><span class="spaces">    </span><span class="istickedoff">sym = cc^.mccSym</span>
<span class="lineno"> 1045 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1046 </span><span class="spaces">    </span><span class="istickedoff">testEquality :: forall k (f :: k -&gt; Type) (a :: k) (b :: k)</span>
<span class="lineno"> 1047 </span><span class="spaces">                  </span><span class="istickedoff">. W4.TestEquality f</span>
<span class="lineno"> 1048 </span><span class="spaces">                 </span><span class="istickedoff">=&gt; f a -&gt; f b -&gt; MaybeT IO (a :~: b)</span>
<span class="lineno"> 1049 </span><span class="spaces">    </span><span class="istickedoff">testEquality v1 v2 = MaybeT $ pure $ W4.testEquality v1 v2</span>
<span class="lineno"> 1050 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1051 </span><span class="spaces">    </span><span class="istickedoff">goTy :: TypeShape tp</span>
<span class="lineno"> 1052 </span><span class="spaces">         </span><span class="istickedoff">-&gt; RegValue Sym tp</span>
<span class="lineno"> 1053 </span><span class="spaces">         </span><span class="istickedoff">-&gt; RegValue Sym tp</span>
<span class="lineno"> 1054 </span><span class="spaces">         </span><span class="istickedoff">-&gt; MaybeT IO (W4.Pred Sym)</span>
<span class="lineno"> 1055 </span><span class="spaces">    </span><span class="istickedoff">goTy (UnitShape _) () () =</span>
<span class="lineno"> 1056 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">pure $ W4.truePred sym</span></span>
<span class="lineno"> 1057 </span><span class="spaces">    </span><span class="istickedoff">goTy (PrimShape _ _) v1 v2 =</span>
<span class="lineno"> 1058 </span><span class="spaces">      </span><span class="istickedoff">liftIO $ W4.isEq sym v1 v2</span>
<span class="lineno"> 1059 </span><span class="spaces">    </span><span class="istickedoff">goTy (TupleShape _ _ fldShp) fldAssn1 fldAssn2 =</span>
<span class="lineno"> 1060 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">goFldAssn fldShp fldAssn1 fldAssn2</span></span>
<span class="lineno"> 1061 </span><span class="spaces">    </span><span class="istickedoff">goTy (ArrayShape _ _ shp) vec1 vec2 =</span>
<span class="lineno"> 1062 </span><span class="spaces">      </span><span class="istickedoff">goVec shp vec1 vec2</span>
<span class="lineno"> 1063 </span><span class="spaces">    </span><span class="istickedoff">goTy (StructShape _ _ fldShp) fldAssn1 fldAssn2 =</span>
<span class="lineno"> 1064 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">goFldAssn fldShp fldAssn1 fldAssn2</span></span>
<span class="lineno"> 1065 </span><span class="spaces">    </span><span class="istickedoff">goTy (EnumShape _ _ variantShp _ discrShp)</span>
<span class="lineno"> 1066 </span><span class="spaces">         </span><span class="istickedoff">(Ctx.Empty Ctx.:&gt; RV discr1 Ctx.:&gt; RV variant1)</span>
<span class="lineno"> 1067 </span><span class="spaces">         </span><span class="istickedoff">(Ctx.Empty Ctx.:&gt; RV discr2 Ctx.:&gt; RV variant2) = <span class="nottickedoff">do</span></span>
<span class="lineno"> 1068 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">discrPred &lt;- goTy discrShp discr1 discr2</span></span>
<span class="lineno"> 1069 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">variantPred &lt;- goVariantAssn variantShp variant1 variant2</span></span>
<span class="lineno"> 1070 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">liftIO $ W4.andPred sym discrPred variantPred</span></span>
<span class="lineno"> 1071 </span><span class="spaces">    </span><span class="istickedoff">goTy (TransparentShape _ shp) v1 v2 =</span>
<span class="lineno"> 1072 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">goTy shp v1 v2</span></span>
<span class="lineno"> 1073 </span><span class="spaces">    </span><span class="istickedoff">goTy (RefShape _ _ _ _) ref1 ref2 =</span>
<span class="lineno"> 1074 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">mccWithBackend cc $ \bak -&gt;</span></span>
<span class="lineno"> 1075 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">liftIO $ Mir.mirRef_eqIO bak ref1 ref2</span></span>
<span class="lineno"> 1076 </span><span class="spaces">    </span><span class="istickedoff">goTy (SliceShape _ ty mut tpr)</span>
<span class="lineno"> 1077 </span><span class="spaces">         </span><span class="istickedoff">(Ctx.Empty Ctx.:&gt; RV ref1 Ctx.:&gt; RV len1)</span>
<span class="lineno"> 1078 </span><span class="spaces">         </span><span class="istickedoff">(Ctx.Empty Ctx.:&gt; RV ref2 Ctx.:&gt; RV len2) = <span class="nottickedoff">do</span></span>
<span class="lineno"> 1079 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">let (refShp, lenShp) = sliceShapeParts ty mut tpr</span></span>
<span class="lineno"> 1080 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">refPred &lt;- goTy refShp ref1 ref2</span></span>
<span class="lineno"> 1081 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">lenPred &lt;- goTy lenShp len1 len2</span></span>
<span class="lineno"> 1082 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">liftIO $ W4.andPred sym refPred lenPred</span></span>
<span class="lineno"> 1083 </span><span class="spaces">    </span><span class="istickedoff">goTy (FnPtrShape _ _ _) _fh1 _fh2 =</span>
<span class="lineno"> 1084 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">error &quot;Function pointers not currently supported in overrides&quot;</span></span>
<span class="lineno"> 1085 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1086 </span><span class="spaces">    </span><span class="istickedoff">goVec :: TypeShape tp</span>
<span class="lineno"> 1087 </span><span class="spaces">          </span><span class="istickedoff">-&gt; Mir.MirVector Sym tp</span>
<span class="lineno"> 1088 </span><span class="spaces">          </span><span class="istickedoff">-&gt; Mir.MirVector Sym tp</span>
<span class="lineno"> 1089 </span><span class="spaces">          </span><span class="istickedoff">-&gt; MaybeT IO (W4.Pred Sym)</span>
<span class="lineno"> 1090 </span><span class="spaces">    </span><span class="istickedoff">goVec shp (Mir.MirVector_Vector vec1)</span>
<span class="lineno"> 1091 </span><span class="spaces">              </span><span class="istickedoff">(Mir.MirVector_Vector vec2) = do</span>
<span class="lineno"> 1092 </span><span class="spaces">      </span><span class="istickedoff">eqs &lt;- V.zipWithM (goTy shp) vec1 vec2</span>
<span class="lineno"> 1093 </span><span class="spaces">      </span><span class="istickedoff">liftIO $ F.foldrM (W4.andPred sym) (W4.truePred sym) eqs</span>
<span class="lineno"> 1094 </span><span class="spaces">    </span><span class="istickedoff">goVec shp (Mir.MirVector_PartialVector vec1)</span>
<span class="lineno"> 1095 </span><span class="spaces">              </span><span class="istickedoff">(Mir.MirVector_PartialVector vec2) = <span class="nottickedoff">do</span></span>
<span class="lineno"> 1096 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">eqs &lt;- V.zipWithM</span></span>
<span class="lineno"> 1097 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">(\v1 v2 -&gt; do</span></span>
<span class="lineno"> 1098 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">let readElem v = readMaybeType sym &quot;vector element&quot; (shapeType shp) v</span></span>
<span class="lineno"> 1099 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">let v1' = readElem v1</span></span>
<span class="lineno"> 1100 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">let v2' = readElem v2</span></span>
<span class="lineno"> 1101 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">goTy shp v1' v2')</span></span>
<span class="lineno"> 1102 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">vec1</span></span>
<span class="lineno"> 1103 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">vec2</span></span>
<span class="lineno"> 1104 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">liftIO $ F.foldrM (W4.andPred sym) (W4.truePred sym) eqs</span></span>
<span class="lineno"> 1105 </span><span class="spaces">    </span><span class="istickedoff">goVec _shp (Mir.MirVector_Array vec1) (Mir.MirVector_Array vec2) =</span>
<span class="lineno"> 1106 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">liftIO $ W4.arrayEq sym vec1 vec2</span></span>
<span class="lineno"> 1107 </span><span class="spaces">    </span><span class="istickedoff">goVec _shp _vec1 _vec2 =</span>
<span class="lineno"> 1108 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">pure $ W4.falsePred sym</span></span>
<span class="lineno"> 1109 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1110 </span><span class="spaces">    </span><span class="istickedoff">goFldAssn :: Ctx.Assignment FieldShape ctx</span>
<span class="lineno"> 1111 </span><span class="spaces">              </span><span class="istickedoff">-&gt; Ctx.Assignment (RegValue' Sym) ctx</span>
<span class="lineno"> 1112 </span><span class="spaces">              </span><span class="istickedoff">-&gt; Ctx.Assignment (RegValue' Sym) ctx</span>
<span class="lineno"> 1113 </span><span class="spaces">              </span><span class="istickedoff">-&gt; MaybeT IO (W4.Pred Sym)</span>
<span class="lineno"> 1114 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">goFldAssn fldShp fldAssn1 fldAssn2 =</span></span>
<span class="lineno"> 1115 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">FCI.ifoldrMFC</span></span>
<span class="lineno"> 1116 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">(\idx (Functor.Pair (RV fld1) (RV fld2)) z -&gt; do</span></span>
<span class="lineno"> 1117 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">let shp = fldShp Ctx.! idx</span></span>
<span class="lineno"> 1118 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">eq &lt;- goFld shp fld1 fld2</span></span>
<span class="lineno"> 1119 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">liftIO $ W4.andPred sym eq z)</span></span>
<span class="lineno"> 1120 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">(W4.truePred sym)</span></span>
<span class="lineno"> 1121 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">(Ctx.zipWith Functor.Pair fldAssn1 fldAssn2)</span></span>
<span class="lineno"> 1122 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1123 </span><span class="spaces">    </span><span class="istickedoff">goVariantAssn :: Ctx.Assignment VariantShape ctx</span>
<span class="lineno"> 1124 </span><span class="spaces">                  </span><span class="istickedoff">-&gt; Ctx.Assignment (VariantBranch Sym) ctx</span>
<span class="lineno"> 1125 </span><span class="spaces">                  </span><span class="istickedoff">-&gt; Ctx.Assignment (VariantBranch Sym) ctx</span>
<span class="lineno"> 1126 </span><span class="spaces">                  </span><span class="istickedoff">-&gt; MaybeT IO (W4.Pred Sym)</span>
<span class="lineno"> 1127 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">goVariantAssn variantShp vbAssn1 vbAssn2 =</span></span>
<span class="lineno"> 1128 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">FCI.ifoldrMFC</span></span>
<span class="lineno"> 1129 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">(\idx (Functor.Pair (VB var1) (VB var2)) z -&gt; do</span></span>
<span class="lineno"> 1130 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">VariantShape fldShp &lt;- pure $ variantShp Ctx.! idx</span></span>
<span class="lineno"> 1131 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">varPred &lt;- goVariantFlds fldShp var1 var2</span></span>
<span class="lineno"> 1132 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">liftIO $ W4.andPred sym varPred z)</span></span>
<span class="lineno"> 1133 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">(W4.truePred sym)</span></span>
<span class="lineno"> 1134 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">(Ctx.zipWith Functor.Pair vbAssn1 vbAssn2)</span></span>
<span class="lineno"> 1135 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1136 </span><span class="spaces">    </span><span class="istickedoff">goVariantFlds :: Ctx.Assignment FieldShape ctx</span>
<span class="lineno"> 1137 </span><span class="spaces">                  </span><span class="istickedoff">-&gt; W4.PartExpr (W4.Pred Sym) (Ctx.Assignment (RegValue' Sym) ctx)</span>
<span class="lineno"> 1138 </span><span class="spaces">                  </span><span class="istickedoff">-&gt; W4.PartExpr (W4.Pred Sym) (Ctx.Assignment (RegValue' Sym) ctx)</span>
<span class="lineno"> 1139 </span><span class="spaces">                  </span><span class="istickedoff">-&gt; MaybeT IO (W4.Pred Sym)</span>
<span class="lineno"> 1140 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">goVariantFlds fldShp (W4.PE p1 fldAssn1) (W4.PE p2 fldAssn2) = do</span></span>
<span class="lineno"> 1141 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">pPred &lt;- liftIO $ W4.eqPred sym p1 p2</span></span>
<span class="lineno"> 1142 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">fldPred &lt;- goFldAssn fldShp fldAssn1 fldAssn2</span></span>
<span class="lineno"> 1143 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">liftIO $ W4.andPred sym pPred fldPred</span></span>
<span class="lineno"> 1144 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">goVariantFlds _ W4.Unassigned W4.Unassigned =</span></span>
<span class="lineno"> 1145 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">pure $ W4.truePred sym</span></span>
<span class="lineno"> 1146 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">goVariantFlds _ (W4.PE{}) W4.Unassigned =</span></span>
<span class="lineno"> 1147 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">pure $ W4.falsePred sym</span></span>
<span class="lineno"> 1148 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">goVariantFlds _ W4.Unassigned (W4.PE{}) =</span></span>
<span class="lineno"> 1149 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">pure $ W4.falsePred sym</span></span>
<span class="lineno"> 1150 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1151 </span><span class="spaces">    </span><span class="istickedoff">goFld :: FieldShape tp</span>
<span class="lineno"> 1152 </span><span class="spaces">          </span><span class="istickedoff">-&gt; RegValue Sym tp</span>
<span class="lineno"> 1153 </span><span class="spaces">          </span><span class="istickedoff">-&gt; RegValue Sym tp</span>
<span class="lineno"> 1154 </span><span class="spaces">          </span><span class="istickedoff">-&gt; MaybeT IO (W4.Pred Sym)</span>
<span class="lineno"> 1155 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">goFld shp v1 v2 =</span></span>
<span class="lineno"> 1156 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">case shp of</span></span>
<span class="lineno"> 1157 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">ReqField shp' -&gt;</span></span>
<span class="lineno"> 1158 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">goTy shp' v1 v2</span></span>
<span class="lineno"> 1159 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">OptField shp' -&gt; do</span></span>
<span class="lineno"> 1160 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">let readField v = readMaybeType sym &quot;field&quot; (shapeType shp') v</span></span>
<span class="lineno"> 1161 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">let v1' = readField v1</span></span>
<span class="lineno"> 1162 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">let v2' = readField v2</span></span>
<span class="lineno"> 1163 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">goTy shp' v1' v2'</span></span></span>
<span class="lineno"> 1164 </span>
<span class="lineno"> 1165 </span>-- | Take an array 'Mir.Ty' (arising from a reference type) and return three
<span class="lineno"> 1166 </span>-- things:
<span class="lineno"> 1167 </span>--
<span class="lineno"> 1168 </span>-- 1. The 'Mir.Ty' of the corresponding slice. When the 'MirSliceInfo' argument
<span class="lineno"> 1169 </span>--    is 'MirArraySlice', then 'Mir.TySlice' will be returned. When the
<span class="lineno"> 1170 </span>--    'MirSliceInfo' argument is a 'MirStrSlice', then 'Mir.TyStr' will be
<span class="lineno"> 1171 </span>--    returned.
<span class="lineno"> 1172 </span>--
<span class="lineno"> 1173 </span>-- 2. The 'Mir.Ty' of the \&quot;element type\&quot; of the slice. When the 'MirSliceInfo'
<span class="lineno"> 1174 </span>--    argument is 'MirArraySlice', then the element type of the array will be
<span class="lineno"> 1175 </span>--    returned. When the 'MirSliceInfo' argument is a 'MirStrSlice', then @u8@
<span class="lineno"> 1176 </span>--    will be returned.
<span class="lineno"> 1177 </span>--
<span class="lineno"> 1178 </span>-- 3. The length of the array.
<span class="lineno"> 1179 </span>--
<span class="lineno"> 1180 </span>-- This function will throw an exception if the supplied 'Mir.Ty' is not an
<span class="lineno"> 1181 </span>-- array type.
<span class="lineno"> 1182 </span>arrayToSliceTys ::
<span class="lineno"> 1183 </span>  X.MonadThrow m =&gt;
<span class="lineno"> 1184 </span>  MirSliceInfo -&gt;
<span class="lineno"> 1185 </span>  Mir.Mutability -&gt;
<span class="lineno"> 1186 </span>  Mir.Ty -&gt;
<span class="lineno"> 1187 </span>  m (Mir.Ty, Mir.Ty, Int)
<span class="lineno"> 1188 </span><span class="decl"><span class="istickedoff">arrayToSliceTys sliceInfo mut arrTy@(Mir.TyArray ty len) =</span>
<span class="lineno"> 1189 </span><span class="spaces">  </span><span class="istickedoff">case sliceInfo of</span>
<span class="lineno"> 1190 </span><span class="spaces">    </span><span class="istickedoff">MirArraySlice -&gt;</span>
<span class="lineno"> 1191 </span><span class="spaces">      </span><span class="istickedoff">pure (Mir.TySlice ty, <span class="nottickedoff">ty</span>, len)</span>
<span class="lineno"> 1192 </span><span class="spaces">    </span><span class="istickedoff">MirStrSlice</span>
<span class="lineno"> 1193 </span><span class="spaces">      </span><span class="istickedoff">|  checkCompatibleTys ty u8</span>
<span class="lineno"> 1194 </span><span class="spaces">      </span><span class="istickedoff">-&gt; pure (Mir.TyStr, <span class="nottickedoff">u8</span>, len)</span>
<span class="lineno"> 1195 </span><span class="spaces">      </span><span class="istickedoff">|  <span class="tickonlytrue">otherwise</span></span>
<span class="lineno"> 1196 </span><span class="spaces">      </span><span class="istickedoff">-&gt; X.throwM $ MIRStrSliceNonU8Array $ Mir.TyRef arrTy mut</span>
<span class="lineno"> 1197 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1198 </span><span class="spaces">    </span><span class="istickedoff">u8 = Mir.TyUint Mir.B8</span>
<span class="lineno"> 1199 </span><span class="spaces"></span><span class="istickedoff">arrayToSliceTys _sliceInfo mut arrTy =</span>
<span class="lineno"> 1200 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">X.throwM $ MIRSliceNonArrayReference $ Mir.TyRef arrTy mut</span></span></span>
<span class="lineno"> 1201 </span>
<span class="lineno"> 1202 </span>-- | Retrieve the \&quot;element type\&quot; of a slice type. If the supplied type is an
<span class="lineno"> 1203 </span>-- array slice type (e.g., @[u32]@), return the underlying type (e.g., @u32@).
<span class="lineno"> 1204 </span>-- If the supplied type is a @str@ slice, return @u8@. For all other types,
<span class="lineno"> 1205 </span>-- throw an exception.
<span class="lineno"> 1206 </span>sliceElemTy ::
<span class="lineno"> 1207 </span>  X.MonadThrow m =&gt;
<span class="lineno"> 1208 </span>  Mir.Ty -&gt;
<span class="lineno"> 1209 </span>  m Mir.Ty
<span class="lineno"> 1210 </span><span class="decl"><span class="nottickedoff">sliceElemTy (Mir.TySlice ty) =</span>
<span class="lineno"> 1211 </span><span class="spaces">  </span><span class="nottickedoff">pure ty</span>
<span class="lineno"> 1212 </span><span class="spaces"></span><span class="nottickedoff">sliceElemTy Mir.TyStr =</span>
<span class="lineno"> 1213 </span><span class="spaces">  </span><span class="nottickedoff">pure $ Mir.TyUint Mir.B8</span>
<span class="lineno"> 1214 </span><span class="spaces"></span><span class="nottickedoff">sliceElemTy ty =</span>
<span class="lineno"> 1215 </span><span class="spaces">  </span><span class="nottickedoff">X.throwM $ MIRSliceWrongTy ty</span></span>
<span class="lineno"> 1216 </span>
<span class="lineno"> 1217 </span>-- | Take a slice reference type and return the corresponding 'MirSliceInfo'.
<span class="lineno"> 1218 </span>-- Throw an exception if the supplied type is not a slice reference type.
<span class="lineno"> 1219 </span>sliceRefTyToSliceInfo ::
<span class="lineno"> 1220 </span>  X.MonadThrow m =&gt;
<span class="lineno"> 1221 </span>  Mir.Ty -&gt;
<span class="lineno"> 1222 </span>  m MirSliceInfo
<span class="lineno"> 1223 </span><span class="decl"><span class="istickedoff">sliceRefTyToSliceInfo (Mir.TyRef sliceTy _) =</span>
<span class="lineno"> 1224 </span><span class="spaces">  </span><span class="istickedoff">case sliceTy of</span>
<span class="lineno"> 1225 </span><span class="spaces">    </span><span class="istickedoff">Mir.TySlice _ -&gt;</span>
<span class="lineno"> 1226 </span><span class="spaces">      </span><span class="istickedoff">pure MirArraySlice</span>
<span class="lineno"> 1227 </span><span class="spaces">    </span><span class="istickedoff">Mir.TyStr -&gt;</span>
<span class="lineno"> 1228 </span><span class="spaces">      </span><span class="istickedoff">pure MirStrSlice</span>
<span class="lineno"> 1229 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 1230 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">X.throwM $ MIRSliceWrongTy sliceTy</span></span>
<span class="lineno"> 1231 </span><span class="spaces"></span><span class="istickedoff">sliceRefTyToSliceInfo ty =</span>
<span class="lineno"> 1232 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">X.throwM $ MIRSliceNonReference ty</span></span></span>
<span class="lineno"> 1233 </span>
<span class="lineno"> 1234 </span>-- | Check if two 'Mir.Ty's are compatible in SAW. This is a slightly coarser
<span class="lineno"> 1235 </span>-- notion of equality to reflect the fact that MIR's type system is richer than
<span class="lineno"> 1236 </span>-- Cryptol's type system, and some types which would be distinct in MIR are in
<span class="lineno"> 1237 </span>-- fact equal when converted to the equivalent Cryptol types. In particular:
<span class="lineno"> 1238 </span>--
<span class="lineno"> 1239 </span>-- 1. A @u&lt;N&gt;@ type is always compatible with an @i&lt;N&gt;@ type. For instance, @u8@
<span class="lineno"> 1240 </span>--    is compatible with @i8@, and @u16@ is compatible with @i16@. Note that the
<span class="lineno"> 1241 </span>--    bit sizes of both types must be the same. For instance, @u8@ is /not/
<span class="lineno"> 1242 </span>--    compatible with @i16@.
<span class="lineno"> 1243 </span>--
<span class="lineno"> 1244 </span>-- 2. The @usize@/@isize@ types are always compatible with @u&lt;N&gt;@/@i&lt;N&gt;@, where
<span class="lineno"> 1245 </span>--    @N@ is the number of bits corresponding to the 'Mir.SizeBits' type in
<span class="lineno"> 1246 </span>--    &quot;Mir.Intrinsics&quot;. (This is a bit unsavory, as the actual size of
<span class="lineno"> 1247 </span>--    @usize@/@isize@ is platform-dependent, but this is the current approach.)
<span class="lineno"> 1248 </span>--
<span class="lineno"> 1249 </span>-- 3. Compatibility applies recursively. For instance, @[ty_1; N]@ is compatible
<span class="lineno"> 1250 </span>--    with @[ty_2; N]@ iff @ty_1@ and @ty_2@ are compatibile. Similarly, a tuple
<span class="lineno"> 1251 </span>--    typle @(ty_1_a, ..., ty_n_a)@ is compatible with @(ty_1_b, ..., ty_n_b)@
<span class="lineno"> 1252 </span>--    iff @ty_1_a@ is compatible with @ty_1_b@, ..., and @ty_n_a@ is compatible
<span class="lineno"> 1253 </span>--    with @ty_n_b@.
<span class="lineno"> 1254 </span>--
<span class="lineno"> 1255 </span>-- See also @checkRegisterCompatibility@ in &quot;SAWCentral.Crucible.LLVM.Builtins&quot;
<span class="lineno"> 1256 </span>-- and @registerCompatible@ in &quot;SAWCentral.Crucible.JVM.Builtins&quot;, which fill a
<span class="lineno"> 1257 </span>-- similar niche in the LLVM and JVM backends, respectively.
<span class="lineno"> 1258 </span>checkCompatibleTys :: Mir.Ty -&gt; Mir.Ty -&gt; Bool
<span class="lineno"> 1259 </span><span class="decl"><span class="istickedoff">checkCompatibleTys ty1 ty2 = tyView ty1 == tyView ty2</span></span>
<span class="lineno"> 1260 </span>
<span class="lineno"> 1261 </span>-- | Like 'Mir.Ty', but where:
<span class="lineno"> 1262 </span>--
<span class="lineno"> 1263 </span>-- * The 'TyInt' and 'TyUint' constructors have been collapsed into a single
<span class="lineno"> 1264 </span>--   'TyViewInt' constructor.
<span class="lineno"> 1265 </span>--
<span class="lineno"> 1266 </span>-- * 'TyViewInt' uses 'BaseSizeView' instead of 'Mir.BaseSize'.
<span class="lineno"> 1267 </span>--
<span class="lineno"> 1268 </span>-- * Recursive occurrences of 'Mir.Ty' use 'TyView' instead. This also applies
<span class="lineno"> 1269 </span>--   to fields of type 'SubstsView' and 'FnSigView', which also replace 'Mir.Ty'
<span class="lineno"> 1270 </span>--   with 'TyView' in their definitions.
<span class="lineno"> 1271 </span>--
<span class="lineno"> 1272 </span>-- This provides a coarser notion of equality than what the 'Eq' instance for
<span class="lineno"> 1273 </span>-- 'Mir.Ty' provides, which distinguishes the two sorts of integer types.
<span class="lineno"> 1274 </span>--
<span class="lineno"> 1275 </span>-- This is an internal data type that is used to power the 'checkCompatibleTys'
<span class="lineno"> 1276 </span>-- function. Refer to the Haddocks for that function for more information on why
<span class="lineno"> 1277 </span>-- this is needed.
<span class="lineno"> 1278 </span>data TyView
<span class="lineno"> 1279 </span>  = TyViewBool
<span class="lineno"> 1280 </span>  | TyViewChar
<span class="lineno"> 1281 </span>    -- | The sole integer type. Both 'TyInt' and 'TyUint' are mapped to
<span class="lineno"> 1282 </span>    -- 'TyViewInt', and 'BaseSizeView' is used instead of 'Mir.BaseSize'.
<span class="lineno"> 1283 </span>  | TyViewInt !BaseSizeView
<span class="lineno"> 1284 </span>  | TyViewTuple ![TyView]
<span class="lineno"> 1285 </span>  | TyViewSlice !TyView
<span class="lineno"> 1286 </span>  | TyViewArray !TyView !Int
<span class="lineno"> 1287 </span>  | TyViewRef !TyView !Mir.Mutability
<span class="lineno"> 1288 </span>  | TyViewAdt !Mir.DefId !Mir.DefId !SubstsView
<span class="lineno"> 1289 </span>  | TyViewFnDef !Mir.DefId
<span class="lineno"> 1290 </span>  | TyViewClosure [TyView]
<span class="lineno"> 1291 </span>  | TyViewStr
<span class="lineno"> 1292 </span>  | TyViewFnPtr !FnSigView
<span class="lineno"> 1293 </span>  | TyViewDynamic !Mir.TraitName
<span class="lineno"> 1294 </span>  | TyViewRawPtr !TyView !Mir.Mutability
<span class="lineno"> 1295 </span>  | TyViewFloat !Mir.FloatKind
<span class="lineno"> 1296 </span>  | TyViewDowncast !TyView !Integer
<span class="lineno"> 1297 </span>  | TyViewNever
<span class="lineno"> 1298 </span>  | TyViewForeign
<span class="lineno"> 1299 </span>  | TyViewLifetime
<span class="lineno"> 1300 </span>  | TyViewConst
<span class="lineno"> 1301 </span>  | TyViewErased
<span class="lineno"> 1302 </span>  | TyViewInterned Mir.TyName
<span class="lineno"> 1303 </span>  deriving <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>
<span class="lineno"> 1304 </span>
<span class="lineno"> 1305 </span>-- | Like 'Mir.BaseSize', but without a special case for @usize@/@isize@.
<span class="lineno"> 1306 </span>-- Instead, these are mapped to their actual size, which is determined by the
<span class="lineno"> 1307 </span>-- number of bits in the 'Mir.SizeBits' type in &quot;Mir.Intrinsics&quot;. (This is a bit
<span class="lineno"> 1308 </span>-- unsavory, as the actual size of @usize@/@isize@ is platform-dependent, but
<span class="lineno"> 1309 </span>-- this is the current approach.)
<span class="lineno"> 1310 </span>data BaseSizeView
<span class="lineno"> 1311 </span>  = B8View
<span class="lineno"> 1312 </span>  | B16View
<span class="lineno"> 1313 </span>  | B32View
<span class="lineno"> 1314 </span>  | B64View
<span class="lineno"> 1315 </span>  | B128View
<span class="lineno"> 1316 </span>  deriving <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>
<span class="lineno"> 1317 </span>
<span class="lineno"> 1318 </span>-- | Like 'Mir.Substs', but using 'TyView's instead of 'Mir.Ty'.
<span class="lineno"> 1319 </span>--
<span class="lineno"> 1320 </span>-- This is an internal data type that is used to power the 'checkCompatibleTys'
<span class="lineno"> 1321 </span>-- function. Refer to the Haddocks for that function for more information on why
<span class="lineno"> 1322 </span>-- this is needed.
<span class="lineno"> 1323 </span>newtype SubstsView = SubstsView [TyView]
<span class="lineno"> 1324 </span>  deriving <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>
<span class="lineno"> 1325 </span>
<span class="lineno"> 1326 </span>-- | Like 'Mir.FnSig', but using 'TyView's instead of 'Mir.Ty'.
<span class="lineno"> 1327 </span>--
<span class="lineno"> 1328 </span>-- This is an internal data type that is used to power the 'checkCompatibleTys'
<span class="lineno"> 1329 </span>-- function. Refer to the Haddocks for that function for more information on why
<span class="lineno"> 1330 </span>-- this is needed.
<span class="lineno"> 1331 </span>data FnSigView = FnSigView {
<span class="lineno"> 1332 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_fsvarg_tys</span></span></span>    :: ![TyView]
<span class="lineno"> 1333 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_fsvreturn_ty</span></span></span>  :: !TyView
<span class="lineno"> 1334 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_fsvabi</span></span></span>        :: Mir.Abi
<span class="lineno"> 1335 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_fsvspreadarg</span></span></span>  :: Maybe Int
<span class="lineno"> 1336 </span>  }
<span class="lineno"> 1337 </span>  deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>
<span class="lineno"> 1338 </span>
<span class="lineno"> 1339 </span>-- | Convert a 'Mir.Ty' value to a 'TyView' value.
<span class="lineno"> 1340 </span>tyView :: Mir.Ty -&gt; TyView
<span class="lineno"> 1341 </span>-- The two most important cases. Both sorts of integers are mapped to TyViewInt.
<span class="lineno"> 1342 </span><span class="decl"><span class="istickedoff">tyView (Mir.TyInt  bs) = TyViewInt (baseSizeView bs)</span>
<span class="lineno"> 1343 </span><span class="spaces"></span><span class="istickedoff">tyView (Mir.TyUint bs) = TyViewInt (baseSizeView bs)</span>
<span class="lineno"> 1344 </span><span class="spaces"></span><span class="istickedoff">-- All other cases are straightforward.</span>
<span class="lineno"> 1345 </span><span class="spaces"></span><span class="istickedoff">tyView Mir.TyBool = TyViewBool</span>
<span class="lineno"> 1346 </span><span class="spaces"></span><span class="istickedoff">tyView Mir.TyChar = <span class="nottickedoff">TyViewChar</span></span>
<span class="lineno"> 1347 </span><span class="spaces"></span><span class="istickedoff">tyView (Mir.TyTuple tys) = TyViewTuple (map tyView tys)</span>
<span class="lineno"> 1348 </span><span class="spaces"></span><span class="istickedoff">tyView (Mir.TySlice ty) = TyViewSlice (tyView ty)</span>
<span class="lineno"> 1349 </span><span class="spaces"></span><span class="istickedoff">tyView (Mir.TyArray ty n) = TyViewArray (tyView ty) n</span>
<span class="lineno"> 1350 </span><span class="spaces"></span><span class="istickedoff">tyView (Mir.TyRef ty mut) = TyViewRef (tyView ty) mut</span>
<span class="lineno"> 1351 </span><span class="spaces"></span><span class="istickedoff">tyView (Mir.TyAdt monoDid origDid substs) =</span>
<span class="lineno"> 1352 </span><span class="spaces">  </span><span class="istickedoff">TyViewAdt monoDid origDid (substsView substs)</span>
<span class="lineno"> 1353 </span><span class="spaces"></span><span class="istickedoff">tyView (Mir.TyFnDef did) = <span class="nottickedoff">TyViewFnDef did</span></span>
<span class="lineno"> 1354 </span><span class="spaces"></span><span class="istickedoff">tyView (Mir.TyClosure tys) = <span class="nottickedoff">TyViewClosure (map tyView tys)</span></span>
<span class="lineno"> 1355 </span><span class="spaces"></span><span class="istickedoff">tyView Mir.TyStr = TyViewStr</span>
<span class="lineno"> 1356 </span><span class="spaces"></span><span class="istickedoff">tyView (Mir.TyFnPtr sig) = <span class="nottickedoff">TyViewFnPtr (fnSigView sig)</span></span>
<span class="lineno"> 1357 </span><span class="spaces"></span><span class="istickedoff">tyView (Mir.TyDynamic trait) = <span class="nottickedoff">TyViewDynamic trait</span></span>
<span class="lineno"> 1358 </span><span class="spaces"></span><span class="istickedoff">tyView (Mir.TyRawPtr ty mut) = TyViewRawPtr (tyView ty) mut</span>
<span class="lineno"> 1359 </span><span class="spaces"></span><span class="istickedoff">tyView (Mir.TyFloat fk) = <span class="nottickedoff">TyViewFloat fk</span></span>
<span class="lineno"> 1360 </span><span class="spaces"></span><span class="istickedoff">tyView (Mir.TyDowncast ty n) = <span class="nottickedoff">TyViewDowncast (tyView ty) n</span></span>
<span class="lineno"> 1361 </span><span class="spaces"></span><span class="istickedoff">tyView Mir.TyNever = <span class="nottickedoff">TyViewNever</span></span>
<span class="lineno"> 1362 </span><span class="spaces"></span><span class="istickedoff">tyView Mir.TyForeign = <span class="nottickedoff">TyViewForeign</span></span>
<span class="lineno"> 1363 </span><span class="spaces"></span><span class="istickedoff">tyView Mir.TyLifetime = TyViewLifetime</span>
<span class="lineno"> 1364 </span><span class="spaces"></span><span class="istickedoff">tyView Mir.TyConst = <span class="nottickedoff">TyViewConst</span></span>
<span class="lineno"> 1365 </span><span class="spaces"></span><span class="istickedoff">tyView Mir.TyErased = <span class="nottickedoff">TyViewErased</span></span>
<span class="lineno"> 1366 </span><span class="spaces"></span><span class="istickedoff">tyView (Mir.TyInterned nm) = <span class="nottickedoff">TyViewInterned nm</span></span></span>
<span class="lineno"> 1367 </span>
<span class="lineno"> 1368 </span>-- | Convert a 'Mir.BaseSize' value to a 'BaseSizeView' value.
<span class="lineno"> 1369 </span>baseSizeView :: Mir.BaseSize -&gt; BaseSizeView
<span class="lineno"> 1370 </span><span class="decl"><span class="istickedoff">baseSizeView Mir.B8    = B8View</span>
<span class="lineno"> 1371 </span><span class="spaces"></span><span class="istickedoff">baseSizeView Mir.B16   = B16View</span>
<span class="lineno"> 1372 </span><span class="spaces"></span><span class="istickedoff">baseSizeView Mir.B32   = B32View</span>
<span class="lineno"> 1373 </span><span class="spaces"></span><span class="istickedoff">baseSizeView Mir.B64   = B64View</span>
<span class="lineno"> 1374 </span><span class="spaces"></span><span class="istickedoff">baseSizeView Mir.B128  = <span class="nottickedoff">B128View</span></span>
<span class="lineno"> 1375 </span><span class="spaces"></span><span class="istickedoff">baseSizeView Mir.USize =</span>
<span class="lineno"> 1376 </span><span class="spaces">  </span><span class="istickedoff">case Map.lookup (W4.natValue sizeBitsRepr) bitSizesMap of</span>
<span class="lineno"> 1377 </span><span class="spaces">    </span><span class="istickedoff">Just bsv -&gt; bsv</span>
<span class="lineno"> 1378 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1379 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">error $ &quot;Mir.Intrinsics.BaseSize bit size not supported: &quot; ++ show sizeBitsRepr</span></span>
<span class="lineno"> 1380 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1381 </span><span class="spaces">    </span><span class="istickedoff">sizeBitsRepr = W4.knownNat @Mir.SizeBits</span>
<span class="lineno"> 1382 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1383 </span><span class="spaces">    </span><span class="istickedoff">bitSizesMap :: Map Natural BaseSizeView</span>
<span class="lineno"> 1384 </span><span class="spaces">    </span><span class="istickedoff">bitSizesMap = Map.fromList</span>
<span class="lineno"> 1385 </span><span class="spaces">      </span><span class="istickedoff">[ (W4.natValue (W4.knownNat @8),   <span class="nottickedoff">B8View</span>)</span>
<span class="lineno"> 1386 </span><span class="spaces">      </span><span class="istickedoff">, (W4.natValue (W4.knownNat @16),  <span class="nottickedoff">B16View</span>)</span>
<span class="lineno"> 1387 </span><span class="spaces">      </span><span class="istickedoff">, (W4.natValue (W4.knownNat @32),  <span class="nottickedoff">B32View</span>)</span>
<span class="lineno"> 1388 </span><span class="spaces">      </span><span class="istickedoff">, (W4.natValue (W4.knownNat @64),  B64View)</span>
<span class="lineno"> 1389 </span><span class="spaces">      </span><span class="istickedoff">, (W4.natValue (W4.knownNat @128), <span class="nottickedoff">B128View</span>)</span>
<span class="lineno"> 1390 </span><span class="spaces">      </span><span class="istickedoff">]</span></span>
<span class="lineno"> 1391 </span>
<span class="lineno"> 1392 </span>-- | Convert a 'Mir.Substs' value to a 'SubstsView' value.
<span class="lineno"> 1393 </span>substsView :: Mir.Substs -&gt; SubstsView
<span class="lineno"> 1394 </span><span class="decl"><span class="istickedoff">substsView (Mir.Substs tys) = SubstsView (map tyView tys)</span></span>
<span class="lineno"> 1395 </span>
<span class="lineno"> 1396 </span>-- | Convert a 'Mir.FnSig' value to a 'FnSigView' value.
<span class="lineno"> 1397 </span>fnSigView :: Mir.FnSig -&gt; FnSigView
<span class="lineno"> 1398 </span><span class="decl"><span class="nottickedoff">fnSigView (Mir.FnSig argTys retTy abi spreadarg) =</span>
<span class="lineno"> 1399 </span><span class="spaces">  </span><span class="nottickedoff">FnSigView (map tyView argTys) (tyView retTy) abi spreadarg</span></span>
<span class="lineno"> 1400 </span>
<span class="lineno"> 1401 </span>-- | Read the value out of a 'MaybeType' expression that is assumed to be
<span class="lineno"> 1402 </span>-- assigned to a value. If this assumption does not hold (i.e., if the value is
<span class="lineno"> 1403 </span>-- unassigned), then this function will raise an error.
<span class="lineno"> 1404 </span>readMaybeType ::
<span class="lineno"> 1405 </span>     IsSymInterface sym
<span class="lineno"> 1406 </span>  =&gt; sym
<span class="lineno"> 1407 </span>  -&gt; String
<span class="lineno"> 1408 </span>  -&gt; TypeRepr tp
<span class="lineno"> 1409 </span>  -&gt; RegValue sym (MaybeType tp)
<span class="lineno"> 1410 </span>  -&gt; RegValue sym tp
<span class="lineno"> 1411 </span><span class="decl"><span class="istickedoff">readMaybeType sym desc tpr rv =</span>
<span class="lineno"> 1412 </span><span class="spaces">  </span><span class="istickedoff">case readPartExprMaybe <span class="nottickedoff">sym</span> rv of</span>
<span class="lineno"> 1413 </span><span class="spaces">    </span><span class="istickedoff">Just x -&gt; x</span>
<span class="lineno"> 1414 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">error $ &quot;readMaybeType: accessed possibly-uninitialized &quot; ++ desc ++</span></span>
<span class="lineno"> 1415 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">&quot; of type &quot; ++ show tpr</span></span></span>
<span class="lineno"> 1416 </span>
<span class="lineno"> 1417 </span>readPartExprMaybe ::
<span class="lineno"> 1418 </span>     IsSymInterface sym
<span class="lineno"> 1419 </span>  =&gt; sym
<span class="lineno"> 1420 </span>  -&gt; W4.PartExpr (W4.Pred sym) a
<span class="lineno"> 1421 </span>  -&gt; Maybe a
<span class="lineno"> 1422 </span><span class="decl"><span class="istickedoff">readPartExprMaybe _sym W4.Unassigned = <span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 1423 </span><span class="spaces"></span><span class="istickedoff">readPartExprMaybe _sym (W4.PE p v)</span>
<span class="lineno"> 1424 </span><span class="spaces">  </span><span class="istickedoff">| Just True &lt;- W4.asConstantPred p = Just v</span>
<span class="lineno"> 1425 </span><span class="spaces">  </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> = <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno"> 1426 </span>
<span class="lineno"> 1427 </span>-- | Allocate memory for each 'mir_alloc', 'mir_alloc_mut',
<span class="lineno"> 1428 </span>-- 'mir_alloc_raw_ptr_const', or 'mir_alloc_raw_ptr_mut'.
<span class="lineno"> 1429 </span>doAlloc ::
<span class="lineno"> 1430 </span>     MIRCrucibleContext
<span class="lineno"> 1431 </span>  -&gt; SymGlobalState Sym
<span class="lineno"> 1432 </span>  -&gt; Some MirAllocSpec
<span class="lineno"> 1433 </span>  -&gt; IO (Some (MirPointer Sym), SymGlobalState Sym)
<span class="lineno"> 1434 </span><span class="decl"><span class="istickedoff">doAlloc cc globals (Some ma) =</span>
<span class="lineno"> 1435 </span><span class="spaces">  </span><span class="istickedoff">mccWithBackend cc $ \bak -&gt;</span>
<span class="lineno"> 1436 </span><span class="spaces">  </span><span class="istickedoff">do let col = cc ^. mccRustModule ^. Mir.rmCS ^. Mir.collection</span>
<span class="lineno"> 1437 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">halloc = cc^.mccHandleAllocator</span></span>
<span class="lineno"> 1438 </span><span class="spaces">     </span><span class="istickedoff">let sym = backendGetSym bak</span>
<span class="lineno"> 1439 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">iTypes = cc^.mccIntrinsicTypes</span></span>
<span class="lineno"> 1440 </span><span class="spaces">     </span><span class="istickedoff">Some tpr &lt;- pure $ Mir.tyToRepr col (ma^.maMirType)</span>
<span class="lineno"> 1441 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1442 </span><span class="spaces">     </span><span class="istickedoff">-- Create an uninitialized `MirVector_PartialVector` of length 1 and</span>
<span class="lineno"> 1443 </span><span class="spaces">     </span><span class="istickedoff">-- return a pointer to its element.</span>
<span class="lineno"> 1444 </span><span class="spaces">     </span><span class="istickedoff">let vecRepr = Mir.MirVectorRepr tpr</span>
<span class="lineno"> 1445 </span><span class="spaces">     </span><span class="istickedoff">ref &lt;- Mir.newMirRefIO sym <span class="nottickedoff">halloc</span> vecRepr</span>
<span class="lineno"> 1446 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1447 </span><span class="spaces">     </span><span class="istickedoff">one &lt;- W4.bvLit sym W4.knownRepr $ BV.mkBV W4.knownRepr 1</span>
<span class="lineno"> 1448 </span><span class="spaces">     </span><span class="istickedoff">vec &lt;- Mir.mirVector_uninitIO <span class="nottickedoff">bak</span> one</span>
<span class="lineno"> 1449 </span><span class="spaces">     </span><span class="istickedoff">globals' &lt;- Mir.writeMirRefIO <span class="nottickedoff">bak</span> globals <span class="nottickedoff">iTypes</span> vecRepr ref vec</span>
<span class="lineno"> 1450 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1451 </span><span class="spaces">     </span><span class="istickedoff">zero &lt;- W4.bvLit sym W4.knownRepr $ BV.mkBV W4.knownRepr 0</span>
<span class="lineno"> 1452 </span><span class="spaces">     </span><span class="istickedoff">ptr &lt;- Mir.subindexMirRefIO bak <span class="nottickedoff">iTypes</span> tpr ref zero</span>
<span class="lineno"> 1453 </span><span class="spaces">     </span><span class="istickedoff">let mirPtr = Some MirPointer</span>
<span class="lineno"> 1454 </span><span class="spaces">           </span><span class="istickedoff">{ _mpType = tpr</span>
<span class="lineno"> 1455 </span><span class="spaces">           </span><span class="istickedoff">, _mpKind = ma^.maPtrKind</span>
<span class="lineno"> 1456 </span><span class="spaces">           </span><span class="istickedoff">, _mpMutbl = ma^.maMutbl</span>
<span class="lineno"> 1457 </span><span class="spaces">           </span><span class="istickedoff">, _mpMirType = ma^.maMirType</span>
<span class="lineno"> 1458 </span><span class="spaces">           </span><span class="istickedoff">, _mpRef = ptr</span>
<span class="lineno"> 1459 </span><span class="spaces">           </span><span class="istickedoff">}</span>
<span class="lineno"> 1460 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1461 </span><span class="spaces">     </span><span class="istickedoff">pure (mirPtr, globals')</span></span>
<span class="lineno"> 1462 </span>
<span class="lineno"> 1463 </span>doPointsTo ::
<span class="lineno"> 1464 </span>     MS.CrucibleMethodSpecIR MIR
<span class="lineno"> 1465 </span>  -&gt; MIRCrucibleContext
<span class="lineno"> 1466 </span>  -&gt; Map MS.AllocIndex (Some (MirPointer Sym))
<span class="lineno"> 1467 </span>  -&gt; SymGlobalState Sym
<span class="lineno"> 1468 </span>  -&gt; MirPointsTo
<span class="lineno"> 1469 </span>  -&gt; IO (SymGlobalState Sym)
<span class="lineno"> 1470 </span><span class="decl"><span class="istickedoff">doPointsTo mspec cc env globals (MirPointsTo _ reference referents) =</span>
<span class="lineno"> 1471 </span><span class="spaces">  </span><span class="istickedoff">mccWithBackend cc $ \bak -&gt; do</span>
<span class="lineno"> 1472 </span><span class="spaces">    </span><span class="istickedoff">MIRVal referenceShp referenceVal &lt;-</span>
<span class="lineno"> 1473 </span><span class="spaces">      </span><span class="istickedoff">resolveSetupVal cc env <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span> reference</span>
<span class="lineno"> 1474 </span><span class="spaces">    </span><span class="istickedoff">-- By the time we reach here, we have already checked (in mir_points_to)</span>
<span class="lineno"> 1475 </span><span class="spaces">    </span><span class="istickedoff">-- that we are in fact dealing with a reference value, so the call to</span>
<span class="lineno"> 1476 </span><span class="spaces">    </span><span class="istickedoff">-- `testRefShape` below should always succeed.</span>
<span class="lineno"> 1477 </span><span class="spaces">    </span><span class="istickedoff">IsRefShape _ _ _ referenceInnerTy &lt;-</span>
<span class="lineno"> 1478 </span><span class="spaces">      </span><span class="istickedoff">case testRefShape referenceShp of</span>
<span class="lineno"> 1479 </span><span class="spaces">        </span><span class="istickedoff">Just irs -&gt; pure irs</span>
<span class="lineno"> 1480 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1481 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">panic &quot;doPointsTo&quot; [</span></span>
<span class="lineno"> 1482 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">&quot;Unexpected non-reference type: &quot;,</span></span>
<span class="lineno"> 1483 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">&quot;   &quot; &lt;&gt; Text.pack (show $ PP.pretty $ shapeMirTy referenceShp)</span></span>
<span class="lineno"> 1484 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1485 </span><span class="spaces">    </span><span class="istickedoff">referent &lt;- firstPointsToReferent referents</span>
<span class="lineno"> 1486 </span><span class="spaces">    </span><span class="istickedoff">MIRVal referentShp referentVal &lt;-</span>
<span class="lineno"> 1487 </span><span class="spaces">      </span><span class="istickedoff">resolveSetupVal cc <span class="nottickedoff">env</span> <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span> referent</span>
<span class="lineno"> 1488 </span><span class="spaces">    </span><span class="istickedoff">-- By the time we reach here, we have already checked (in mir_points_to)</span>
<span class="lineno"> 1489 </span><span class="spaces">    </span><span class="istickedoff">-- that the type of the reference is compatible with the right-hand side</span>
<span class="lineno"> 1490 </span><span class="spaces">    </span><span class="istickedoff">-- value, so the equality check below should never fail.</span>
<span class="lineno"> 1491 </span><span class="spaces">    </span><span class="istickedoff">Refl &lt;-</span>
<span class="lineno"> 1492 </span><span class="spaces">      </span><span class="istickedoff">case W4.testEquality referenceInnerTy (shapeType referentShp) of</span>
<span class="lineno"> 1493 </span><span class="spaces">        </span><span class="istickedoff">Just r -&gt; pure r</span>
<span class="lineno"> 1494 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1495 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">panic &quot;doPointsTo&quot; [</span></span>
<span class="lineno"> 1496 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">&quot;Unexpected type mismatch between reference and referent&quot;,</span></span>
<span class="lineno"> 1497 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">&quot;Reference type: &quot; &lt;&gt; Text.pack (show referenceInnerTy),</span></span>
<span class="lineno"> 1498 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">&quot;Referent type:  &quot; &lt;&gt; Text.pack (show (shapeType referentShp))</span></span>
<span class="lineno"> 1499 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1500 </span><span class="spaces">    </span><span class="istickedoff">Mir.writeMirRefIO bak globals <span class="nottickedoff">iTypes</span> referenceInnerTy referenceVal referentVal</span>
<span class="lineno"> 1501 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1502 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">iTypes = cc ^. mccIntrinsicTypes</span></span>
<span class="lineno"> 1503 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">tyenv = MS.csAllocations mspec</span></span>
<span class="lineno"> 1504 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">nameEnv = mspec ^. MS.csPreState . MS.csVarTypeNames</span></span></span>
<span class="lineno"> 1505 </span>
<span class="lineno"> 1506 </span>-- | @mir_points_to@ always creates a 'MirPointsTo' value with exactly one
<span class="lineno"> 1507 </span>-- referent on the right-hand side. As a result, this function should never
<span class="lineno"> 1508 </span>-- fail.
<span class="lineno"> 1509 </span>firstPointsToReferent ::
<span class="lineno"> 1510 </span>  MonadFail m =&gt; [MS.SetupValue MIR] -&gt; m (MS.SetupValue MIR)
<span class="lineno"> 1511 </span><span class="decl"><span class="istickedoff">firstPointsToReferent referents =</span>
<span class="lineno"> 1512 </span><span class="spaces">  </span><span class="istickedoff">case referents of</span>
<span class="lineno"> 1513 </span><span class="spaces">    </span><span class="istickedoff">[referent] -&gt; pure referent</span>
<span class="lineno"> 1514 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">fail $</span></span>
<span class="lineno"> 1515 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">&quot;Unexpected mir_points_to statement with &quot; ++ show (length referents) ++</span></span>
<span class="lineno"> 1516 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">&quot; referent(s)&quot;</span></span></span>
<span class="lineno"> 1517 </span>
<span class="lineno"> 1518 </span>-- | Construct an 'Mir.TyAdt' from an 'Mir.Adt'.
<span class="lineno"> 1519 </span>mirAdtToTy :: Mir.Adt -&gt; Mir.Ty
<span class="lineno"> 1520 </span><span class="decl"><span class="istickedoff">mirAdtToTy adt =</span>
<span class="lineno"> 1521 </span><span class="spaces">  </span><span class="istickedoff">Mir.TyAdt (adt ^. Mir.adtname) (adt ^. Mir.adtOrigDefId) (adt ^. Mir.adtOrigSubsts)</span></span>
<span class="lineno"> 1522 </span>
<span class="lineno"> 1523 </span>-- | Like 'findDefIdEither', but any errors are thrown with 'fail'.
<span class="lineno"> 1524 </span>findDefId :: MonadFail m =&gt; Mir.CollectionState -&gt; Text -&gt; m Mir.DefId
<span class="lineno"> 1525 </span><span class="decl"><span class="istickedoff">findDefId cs defName =</span>
<span class="lineno"> 1526 </span><span class="spaces">  </span><span class="istickedoff">either <span class="nottickedoff">fail</span> pure $ findDefIdEither cs defName</span></span>
<span class="lineno"> 1527 </span>
<span class="lineno"> 1528 </span>-- | Given a definition name @defName@, attempt to look up its corresponding
<span class="lineno"> 1529 </span>-- 'Mir.DefId'. If successful, return it with 'Right'. Currently, the following
<span class="lineno"> 1530 </span>-- types of definition names are permitted:
<span class="lineno"> 1531 </span>--
<span class="lineno"> 1532 </span>-- * @&lt;crate_name&gt;/&lt;disambiguator&gt;::&lt;def_name&gt;: A fully disambiguated name.
<span class="lineno"> 1533 </span>--
<span class="lineno"> 1534 </span>-- * @&lt;crate_name&gt;::&lt;def_name&gt;: A name without a disambiguator. In this
<span class="lineno"> 1535 </span>--   case, SAW will attempt to look up a disambiguator from the
<span class="lineno"> 1536 </span>--   'Mir.crateHashesMap'. If none can be found, or if there are multiple
<span class="lineno"> 1537 </span>--   disambiguators for the given @&lt;crate_name&gt;@, then this will return an error
<span class="lineno"> 1538 </span>--   message with 'Left'.
<span class="lineno"> 1539 </span>--
<span class="lineno"> 1540 </span>-- This also consults the 'Mir.langItems' so that if a user looks up the
<span class="lineno"> 1541 </span>-- original 'DefId' for a lang item (e.g., @core::option::Option@), then this
<span class="lineno"> 1542 </span>-- function will return the @$lang@-based 'DefId' instead (e.g.,
<span class="lineno"> 1543 </span>-- @$lang::Option@), as the latter 'DefId' is what will be used throughout the
<span class="lineno"> 1544 </span>-- rest of the MIR code.
<span class="lineno"> 1545 </span>findDefIdEither :: Mir.CollectionState -&gt; Text -&gt; Either String Mir.DefId
<span class="lineno"> 1546 </span><span class="decl"><span class="istickedoff">findDefIdEither cs defName = do</span>
<span class="lineno"> 1547 </span><span class="spaces">    </span><span class="istickedoff">(crate, path) &lt;-</span>
<span class="lineno"> 1548 </span><span class="spaces">      </span><span class="istickedoff">case edid of</span>
<span class="lineno"> 1549 </span><span class="spaces">        </span><span class="istickedoff">crate:path -&gt; pure (crate, path)</span>
<span class="lineno"> 1550 </span><span class="spaces">        </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">Left $ unlines</span></span>
<span class="lineno"> 1551 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The definition `&quot; ++ defNameStr ++ &quot;` lacks a crate.&quot;</span></span>
<span class="lineno"> 1552 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">, &quot;Consider providing one, e.g., `&lt;crate_name&gt;::&quot; ++ defNameStr ++ &quot;`.&quot;</span></span>
<span class="lineno"> 1553 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1554 </span><span class="spaces">    </span><span class="istickedoff">let <span class="nottickedoff">crateStr = Text.unpack crate</span></span>
<span class="lineno"> 1555 </span><span class="spaces">    </span><span class="istickedoff">origDefId &lt;-</span>
<span class="lineno"> 1556 </span><span class="spaces">      </span><span class="istickedoff">case Text.splitOn &quot;/&quot; crate of</span>
<span class="lineno"> 1557 </span><span class="spaces">        </span><span class="istickedoff">[crateNoDisambig, disambig] -&gt;</span>
<span class="lineno"> 1558 </span><span class="spaces">          </span><span class="istickedoff">Right $ Mir.textId $ Text.intercalate &quot;::&quot;</span>
<span class="lineno"> 1559 </span><span class="spaces">                </span><span class="istickedoff">$ (crateNoDisambig &lt;&gt; &quot;/&quot; &lt;&gt; disambig) : path</span>
<span class="lineno"> 1560 </span><span class="spaces">        </span><span class="istickedoff">[_] -&gt;</span>
<span class="lineno"> 1561 </span><span class="spaces">          </span><span class="istickedoff">case Map.lookup crate crateDisambigs of</span>
<span class="lineno"> 1562 </span><span class="spaces">              </span><span class="istickedoff">Just allDisambigs@(disambig :| otherDisambigs)</span>
<span class="lineno"> 1563 </span><span class="spaces">                </span><span class="istickedoff">|  <span class="tickonlytrue">F.null otherDisambigs</span></span>
<span class="lineno"> 1564 </span><span class="spaces">                </span><span class="istickedoff">-&gt; Right $ Mir.textId $ Text.intercalate &quot;::&quot;</span>
<span class="lineno"> 1565 </span><span class="spaces">                         </span><span class="istickedoff">$ (crate &lt;&gt; &quot;/&quot; &lt;&gt; disambig) : path</span>
<span class="lineno"> 1566 </span><span class="spaces">                </span><span class="istickedoff">|  <span class="nottickedoff">otherwise</span></span>
<span class="lineno"> 1567 </span><span class="spaces">                </span><span class="istickedoff">-&gt; <span class="nottickedoff">Left $ unlines $</span></span>
<span class="lineno"> 1568 </span><span class="spaces">                     </span><span class="istickedoff"><span class="nottickedoff">[ &quot;ambiguous crate &quot; ++ crateStr</span></span>
<span class="lineno"> 1569 </span><span class="spaces">                     </span><span class="istickedoff"><span class="nottickedoff">, &quot;crate disambiguators:&quot;</span></span>
<span class="lineno"> 1570 </span><span class="spaces">                     </span><span class="istickedoff"><span class="nottickedoff">] ++ F.toList (Text.unpack &lt;$&gt; allDisambigs)</span></span>
<span class="lineno"> 1571 </span><span class="spaces">              </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">Left $ &quot;unknown crate &quot; ++ crateStr</span></span>
<span class="lineno"> 1572 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">Left $ &quot;Malformed crate name: &quot; ++ show crateStr</span></span>
<span class="lineno"> 1573 </span><span class="spaces">    </span><span class="istickedoff">Right $ Map.findWithDefault origDefId origDefId langItemDefIds</span>
<span class="lineno"> 1574 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1575 </span><span class="spaces">    </span><span class="istickedoff">crateDisambigs = cs ^. Mir.crateHashesMap</span>
<span class="lineno"> 1576 </span><span class="spaces">    </span><span class="istickedoff">langItemDefIds = cs ^. Mir.collection . Mir.langItems</span>
<span class="lineno"> 1577 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1578 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">defNameStr = Text.unpack defName</span></span>
<span class="lineno"> 1579 </span><span class="spaces">    </span><span class="istickedoff">edid = Text.splitOn &quot;::&quot; defName</span></span>
<span class="lineno"> 1580 </span>
<span class="lineno"> 1581 </span>-- | Consult the given 'Mir.CollectionState' to find a 'Mir.Static' with the
<span class="lineno"> 1582 </span>-- given 'String' as an identifier. If such a 'Mir.Static' cannot be found, this
<span class="lineno"> 1583 </span>-- will raise an error.
<span class="lineno"> 1584 </span>findStatic :: X.MonadThrow m =&gt; Mir.CollectionState -&gt; Text -&gt; m Mir.Static
<span class="lineno"> 1585 </span><span class="decl"><span class="istickedoff">findStatic cs name = do</span>
<span class="lineno"> 1586 </span><span class="spaces">  </span><span class="istickedoff">did &lt;- case findDefIdEither cs name of</span>
<span class="lineno"> 1587 </span><span class="spaces">    </span><span class="istickedoff">Left err -&gt; <span class="nottickedoff">X.throwM $ MIRInvalidIdentifier err</span></span>
<span class="lineno"> 1588 </span><span class="spaces">    </span><span class="istickedoff">Right did -&gt; pure did</span>
<span class="lineno"> 1589 </span><span class="spaces">  </span><span class="istickedoff">case Map.lookup did (cs ^. Mir.collection . Mir.statics) of</span>
<span class="lineno"> 1590 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; X.throwM $ MIRStaticNotFound did</span>
<span class="lineno"> 1591 </span><span class="spaces">    </span><span class="istickedoff">Just static -&gt; pure static</span></span>
<span class="lineno"> 1592 </span>
<span class="lineno"> 1593 </span>-- | Consult the given 'MIRCrucibleContext' to find the 'MIRVal' used to
<span class="lineno"> 1594 </span>-- initialize a 'Mir.Static' value. If such a 'MIRVal' cannot be found, this
<span class="lineno"> 1595 </span>-- will raise an error.
<span class="lineno"> 1596 </span>findStaticInitializer ::
<span class="lineno"> 1597 </span>  X.MonadThrow m =&gt;
<span class="lineno"> 1598 </span>  MIRCrucibleContext -&gt;
<span class="lineno"> 1599 </span>  Mir.Static -&gt;
<span class="lineno"> 1600 </span>  m MIRVal
<span class="lineno"> 1601 </span><span class="decl"><span class="istickedoff">findStaticInitializer mcc static = do</span>
<span class="lineno"> 1602 </span><span class="spaces">  </span><span class="istickedoff">Mir.StaticVar gv &lt;- findStaticVar cs staticDefId</span>
<span class="lineno"> 1603 </span><span class="spaces">  </span><span class="istickedoff">let staticShp = tyToShapeEq <span class="nottickedoff">col</span> (static ^. Mir.sTy) (globalType gv)</span>
<span class="lineno"> 1604 </span><span class="spaces">  </span><span class="istickedoff">case MapF.lookup gv (mcc^.mccStaticInitializerMap) of</span>
<span class="lineno"> 1605 </span><span class="spaces">    </span><span class="istickedoff">Just (RV staticInitVal) -&gt;</span>
<span class="lineno"> 1606 </span><span class="spaces">      </span><span class="istickedoff">pure $ MIRVal staticShp staticInitVal</span>
<span class="lineno"> 1607 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1608 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">X.throwM $ MIRStaticNotFound staticDefId</span></span>
<span class="lineno"> 1609 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1610 </span><span class="spaces">    </span><span class="istickedoff">staticDefId = static ^. Mir.sName</span>
<span class="lineno"> 1611 </span><span class="spaces">    </span><span class="istickedoff">cs  = mcc ^. mccRustModule . Mir.rmCS</span>
<span class="lineno"> 1612 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">col = cs ^. Mir.collection</span></span></span>
<span class="lineno"> 1613 </span>
<span class="lineno"> 1614 </span>-- | Consult the given 'Mir.CollectionState' to find a 'Mir.StaticVar' with the
<span class="lineno"> 1615 </span>-- given 'Mir.DefId'. If such a 'Mir.StaticVar' cannot be found, this will raise
<span class="lineno"> 1616 </span>-- an error.
<span class="lineno"> 1617 </span>findStaticVar ::
<span class="lineno"> 1618 </span>  X.MonadThrow m =&gt;
<span class="lineno"> 1619 </span>  Mir.CollectionState -&gt;
<span class="lineno"> 1620 </span>  Mir.DefId -&gt;
<span class="lineno"> 1621 </span>  m Mir.StaticVar
<span class="lineno"> 1622 </span><span class="decl"><span class="istickedoff">findStaticVar cs staticDefId =</span>
<span class="lineno"> 1623 </span><span class="spaces">  </span><span class="istickedoff">case Map.lookup staticDefId (cs ^. Mir.staticMap) of</span>
<span class="lineno"> 1624 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">X.throwM $ MIRStaticNotFound staticDefId</span></span>
<span class="lineno"> 1625 </span><span class="spaces">    </span><span class="istickedoff">Just sv -&gt; pure sv</span></span>
<span class="lineno"> 1626 </span>
<span class="lineno"> 1627 </span>-- | Compute the 'Mir.Mutability' of a 'Mir.Static' value.
<span class="lineno"> 1628 </span>staticMutability :: Mir.Static -&gt; Mir.Mutability
<span class="lineno"> 1629 </span><span class="decl"><span class="istickedoff">staticMutability static</span>
<span class="lineno"> 1630 </span><span class="spaces">  </span><span class="istickedoff">| static ^. Mir.sMutable = Mir.Mut</span>
<span class="lineno"> 1631 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span>              = Mir.Immut</span></span>
<span class="lineno"> 1632 </span>
<span class="lineno"> 1633 </span>-- | Compute a 'Mir.MirReferenceMux' pointing to a static value's 'GlobalVar'.
<span class="lineno"> 1634 </span>staticRefMux ::
<span class="lineno"> 1635 </span>  W4.IsSymExprBuilder sym =&gt;
<span class="lineno"> 1636 </span>  sym -&gt;
<span class="lineno"> 1637 </span>  GlobalVar tp -&gt;
<span class="lineno"> 1638 </span>  Mir.MirReferenceMux sym
<span class="lineno"> 1639 </span><span class="decl"><span class="istickedoff">staticRefMux sym gv =</span>
<span class="lineno"> 1640 </span><span class="spaces">  </span><span class="istickedoff">Mir.MirReferenceMux $</span>
<span class="lineno"> 1641 </span><span class="spaces">  </span><span class="istickedoff">Mir.toFancyMuxTree sym $</span>
<span class="lineno"> 1642 </span><span class="spaces">  </span><span class="istickedoff">Mir.MirReference (globalType gv) (Mir.GlobalVar_RefRoot gv) Mir.Empty_RefPath</span></span>
<span class="lineno"> 1643 </span>
<span class="lineno"> 1644 </span>-- | Compute the 'Mir.Ty' of a reference to a 'Mir.Static' value.
<span class="lineno"> 1645 </span>staticTyRef :: Mir.Static -&gt; Mir.Ty
<span class="lineno"> 1646 </span><span class="decl"><span class="istickedoff">staticTyRef static =</span>
<span class="lineno"> 1647 </span><span class="spaces">  </span><span class="istickedoff">Mir.TyRef</span>
<span class="lineno"> 1648 </span><span class="spaces">    </span><span class="istickedoff">(static ^. Mir.sTy)</span>
<span class="lineno"> 1649 </span><span class="spaces">    </span><span class="istickedoff">(staticMutability static)</span></span>
<span class="lineno"> 1650 </span>
<span class="lineno"> 1651 </span>-- | Retrieve the discriminant corresponding to an enum variant. This function
<span class="lineno"> 1652 </span>-- will panic if the variant does not contain a discriminant.
<span class="lineno"> 1653 </span>getEnumVariantDiscr :: Mir.Variant -&gt; Integer
<span class="lineno"> 1654 </span><span class="decl"><span class="istickedoff">getEnumVariantDiscr variant =</span>
<span class="lineno"> 1655 </span><span class="spaces">  </span><span class="istickedoff">case variant ^. Mir.discrval of</span>
<span class="lineno"> 1656 </span><span class="spaces">    </span><span class="istickedoff">Just discr -&gt;</span>
<span class="lineno"> 1657 </span><span class="spaces">      </span><span class="istickedoff">discr</span>
<span class="lineno"> 1658 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1659 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">panic &quot;getEnumVariantDiscr&quot; [</span></span>
<span class="lineno"> 1660 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;discrval not set for variant: &quot; &lt;&gt; Text.pack (show (variant ^. Mir.vname))</span></span>
<span class="lineno"> 1661 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno"> 1662 </span>
<span class="lineno"> 1663 </span>-- | An enum's discriminant should have an integral type such as @isize@ or
<span class="lineno"> 1664 </span>-- @i8@, which this function checks. If this is not the case, this function will
<span class="lineno"> 1665 </span>-- panic.
<span class="lineno"> 1666 </span>testDiscriminantIsBV :: TypeShape shp -&gt; IsBVShape shp
<span class="lineno"> 1667 </span><span class="decl"><span class="istickedoff">testDiscriminantIsBV discrShp =</span>
<span class="lineno"> 1668 </span><span class="spaces">  </span><span class="istickedoff">case testBVShape discrShp of</span>
<span class="lineno"> 1669 </span><span class="spaces">    </span><span class="istickedoff">Just ibvs -&gt; ibvs</span>
<span class="lineno"> 1670 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1671 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">panic &quot;testDiscriminantIsBV&quot; [</span></span>
<span class="lineno"> 1672 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;Unexpected non-integral discriminant type:&quot;,</span></span>
<span class="lineno"> 1673 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;   &quot; &lt;&gt; Text.pack (show $ PP.pretty $ shapeMirTy discrShp)</span></span>
<span class="lineno"> 1674 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno"> 1675 </span>
<span class="lineno"> 1676 </span>-- | Compute the index of a variant as an 'Ctx.Index'. If the index is out of
<span class="lineno"> 1677 </span>-- range, this function will panic.
<span class="lineno"> 1678 </span>variantIntIndex ::
<span class="lineno"> 1679 </span>  Mir.DefId {-^ The enum identifier. (Only used for error messages.) -} -&gt;
<span class="lineno"> 1680 </span>  Int {-^ The index of the variant as an 'Int'. -} -&gt;
<span class="lineno"> 1681 </span>  Ctx.Size ctx {-^ The number of variants as a 'Ctx.Size'. -} -&gt;
<span class="lineno"> 1682 </span>  Some (Ctx.Index ctx)
<span class="lineno"> 1683 </span><span class="decl"><span class="istickedoff">variantIntIndex adtNm variantIdx variantsSize =</span>
<span class="lineno"> 1684 </span><span class="spaces">  </span><span class="istickedoff">case Ctx.intIndex variantIdx variantsSize of</span>
<span class="lineno"> 1685 </span><span class="spaces">    </span><span class="istickedoff">Just someIdx -&gt;</span>
<span class="lineno"> 1686 </span><span class="spaces">      </span><span class="istickedoff">someIdx</span>
<span class="lineno"> 1687 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1688 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">panic &quot;variantIntIndex&quot; [</span></span>
<span class="lineno"> 1689 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;Enum variant index out of range&quot;,</span></span>
<span class="lineno"> 1690 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;Enum: &quot; &lt;&gt; Text.pack (show adtNm),</span></span>
<span class="lineno"> 1691 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;Index: &quot; &lt;&gt; Text.pack (show variantIdx),</span></span>
<span class="lineno"> 1692 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;Number of variants: &quot; &lt;&gt; Text.pack (show variantsSize)</span></span>
<span class="lineno"> 1693 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>

</pre>
</body>
</html>
