<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# OPTIONS_GHC -Wall #-}
<span class="lineno">    2 </span>{-# LANGUAGE DoAndIfThenElse #-}
<span class="lineno">    3 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">    4 </span>{-# LANGUAGE PatternGuards #-}
<span class="lineno">    5 </span>{-# LANGUAGE ViewPatterns #-}
<span class="lineno">    6 </span>{-# LANGUAGE TupleSections #-}
<span class="lineno">    7 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">    8 </span>{-# LANGUAGE BangPatterns #-}
<span class="lineno">    9 </span>{-# LANGUAGE TemplateHaskell #-}
<span class="lineno">   10 </span>
<span class="lineno">   11 </span>{- |
<span class="lineno">   12 </span>Module      : CryptolSAWCore.Cryptol
<span class="lineno">   13 </span>Copyright   : Galois, Inc. 2012-2025
<span class="lineno">   14 </span>License     : BSD3
<span class="lineno">   15 </span>Maintainer  : huffman@galois.com
<span class="lineno">   16 </span>Stability   : experimental
<span class="lineno">   17 </span>Portability : non-portable (language extensions)
<span class="lineno">   18 </span>
<span class="lineno">   19 </span>This module \'imports\' various Cryptol elements (Name,Expr,...),
<span class="lineno">   20 </span>translating each to the comparable element of SAWCore.
<span class="lineno">   21 </span>-}
<span class="lineno">   22 </span>
<span class="lineno">   23 </span>module CryptolSAWCore.Cryptol
<span class="lineno">   24 </span>  ( scCryptolType
<span class="lineno">   25 </span>  , Env(..)
<span class="lineno">   26 </span>  , emptyEnv
<span class="lineno">   27 </span>
<span class="lineno">   28 </span>  , isErasedProp
<span class="lineno">   29 </span>  , proveProp
<span class="lineno">   30 </span>
<span class="lineno">   31 </span>  , ImportPrimitiveOptions(..)
<span class="lineno">   32 </span>  , importName
<span class="lineno">   33 </span>  , importExpr
<span class="lineno">   34 </span>  , importTopLevelDeclGroups
<span class="lineno">   35 </span>  , importDeclGroups
<span class="lineno">   36 </span>  , importType
<span class="lineno">   37 </span>  , importKind
<span class="lineno">   38 </span>  , importSchema
<span class="lineno">   39 </span>
<span class="lineno">   40 </span>  , defaultPrimitiveOptions
<span class="lineno">   41 </span>  , genNominalConstructors
<span class="lineno">   42 </span>  , exportValueWithSchema
<span class="lineno">   43 </span>
<span class="lineno">   44 </span>  ) where
<span class="lineno">   45 </span>
<span class="lineno">   46 </span>import Control.Monad (foldM, join, forM)
<span class="lineno">   47 </span>import Control.Exception (catch, SomeException)
<span class="lineno">   48 </span>import Data.Bifunctor (first)
<span class="lineno">   49 </span>import qualified Data.Foldable as Fold
<span class="lineno">   50 </span>import Data.List
<span class="lineno">   51 </span>import Data.List.NonEmpty (NonEmpty(..))
<span class="lineno">   52 </span>import Data.Maybe (fromMaybe)
<span class="lineno">   53 </span>import qualified Data.IntTrie as IntTrie
<span class="lineno">   54 </span>import Data.Map (Map)
<span class="lineno">   55 </span>import qualified Data.Map as Map
<span class="lineno">   56 </span>import Data.Text (Text)
<span class="lineno">   57 </span>import qualified Data.Text as Text
<span class="lineno">   58 </span>import qualified Data.Vector as Vector
<span class="lineno">   59 </span>import GHC.Stack
<span class="lineno">   60 </span>import Prelude ()
<span class="lineno">   61 </span>import Prelude.Compat
<span class="lineno">   62 </span>import Text.URI
<span class="lineno">   63 </span>
<span class="lineno">   64 </span>-- cryptol
<span class="lineno">   65 </span>import qualified Cryptol.Eval.Type as TV
<span class="lineno">   66 </span>import qualified Cryptol.Backend.Monad as V
<span class="lineno">   67 </span>import qualified Cryptol.Backend.SeqMap as V
<span class="lineno">   68 </span>import qualified Cryptol.Backend.WordValue as V
<span class="lineno">   69 </span>import qualified Cryptol.Eval.Value as V
<span class="lineno">   70 </span>import qualified Cryptol.Eval.Concrete as V
<span class="lineno">   71 </span>import Cryptol.Eval.Type (evalValType)
<span class="lineno">   72 </span>import qualified Cryptol.TypeCheck.AST as C
<span class="lineno">   73 </span>import qualified Cryptol.TypeCheck.Solver.InfNat as C (Nat'(..))
<span class="lineno">   74 </span>import qualified Cryptol.TypeCheck.Subst as C (Subst, apSubst, listSubst, singleTParamSubst)
<span class="lineno">   75 </span>import qualified Cryptol.ModuleSystem.Name as C
<span class="lineno">   76 </span>  (asPrim, nameUnique, nameIdent, nameInfo, NameInfo(..), asLocal)
<span class="lineno">   77 </span>import qualified Cryptol.Utils.Ident as C
<span class="lineno">   78 </span>  ( Ident, PrimIdent(..)
<span class="lineno">   79 </span>  , prelPrim, floatPrim, arrayPrim, suiteBPrim, primeECPrim
<span class="lineno">   80 </span>  , identText, interactiveName
<span class="lineno">   81 </span>  , ModPath(..), modPathSplit, ogModule, ogFromParam, Namespace(NSValue)
<span class="lineno">   82 </span>  , modNameChunksText
<span class="lineno">   83 </span>  )
<span class="lineno">   84 </span>import qualified Cryptol.Utils.RecordMap as C
<span class="lineno">   85 </span>import Cryptol.TypeCheck.Type as C (NominalType(..))
<span class="lineno">   86 </span>import Cryptol.TypeCheck.TypeOf (fastTypeOf, fastSchemaOf)
<span class="lineno">   87 </span>import Cryptol.Utils.PP (pretty)
<span class="lineno">   88 </span>
<span class="lineno">   89 </span>-- saw-core
<span class="lineno">   90 </span>import qualified SAWCore.Simulator.Concrete as SC
<span class="lineno">   91 </span>import qualified SAWCore.Simulator.Value as SC
<span class="lineno">   92 </span>import SAWCore.Prim (BitVector(..))
<span class="lineno">   93 </span>import SAWCore.SharedTerm
<span class="lineno">   94 </span>import SAWCore.Simulator.MonadLazy (force)
<span class="lineno">   95 </span>import SAWCore.TypedAST (mkSort, FieldName, LocalName)
<span class="lineno">   96 </span>
<span class="lineno">   97 </span>-- local modules:
<span class="lineno">   98 </span>import CryptolSAWCore.Panic
<span class="lineno">   99 </span>
<span class="lineno">  100 </span>
<span class="lineno">  101 </span>-- Type-check the Prelude, Cryptol, SpecM, and CryptolM modules at compile time
<span class="lineno">  102 </span>import Language.Haskell.TH
<span class="lineno">  103 </span>import CryptolSAWCore.Prelude
<span class="lineno">  104 </span>import CryptolSAWCore.PreludeM
<span class="lineno">  105 </span>
<span class="lineno">  106 </span>$(runIO (mkSharedContext &gt;&gt;= \sc -&gt;
<span class="lineno">  107 </span>          scLoadPreludeModule sc &gt;&gt; scLoadCryptolModule sc &gt;&gt;
<span class="lineno">  108 </span>          scLoadSpecMModule sc &gt;&gt; scLoadCryptolMModule sc &gt;&gt; return []))
<span class="lineno">  109 </span>
<span class="lineno">  110 </span>
<span class="lineno">  111 </span>--------------------------------------------------------------------------------
<span class="lineno">  112 </span>-- Type Environments
<span class="lineno">  113 </span>
<span class="lineno">  114 </span>-- | SharedTerms are paired with a deferred shift amount for loose variables
<span class="lineno">  115 </span>data Env = Env
<span class="lineno">  116 </span>  { <span class="istickedoff"><span class="decl"><span class="istickedoff">envT</span></span></span> :: Map Int    (Term, Int) -- ^ Type variables are referenced by unique id
<span class="lineno">  117 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">envE</span></span></span> :: Map C.Name (Term, Int) -- ^ Term variables are referenced by name
<span class="lineno">  118 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">envP</span></span></span> :: Map C.Prop (Term, [FieldName], Int)
<span class="lineno">  119 </span>              -- ^ Bound propositions are referenced implicitly by their types
<span class="lineno">  120 </span>              --   The actual class dictionary we need is obtained by applying the
<span class="lineno">  121 </span>              --   given field selectors (in reverse order!) to the term.
<span class="lineno">  122 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">envC</span></span></span> :: Map C.Name C.Schema    -- ^ Cryptol type environment
<span class="lineno">  123 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">envS</span></span></span> :: [Term]                 -- ^ SAW-Core bound variable environment (for type checking)
<span class="lineno">  124 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">envRefPrims</span></span></span> :: Map C.PrimIdent C.Expr
<span class="lineno">  125 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">envPrims</span></span></span> :: Map C.PrimIdent Term -- ^ Translations for other primitives
<span class="lineno">  126 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">envPrimTypes</span></span></span> :: Map C.PrimIdent Term -- ^ Translations for primitive types
<span class="lineno">  127 </span>  }
<span class="lineno">  128 </span>
<span class="lineno">  129 </span>emptyEnv :: Env
<span class="lineno">  130 </span><span class="decl"><span class="istickedoff">emptyEnv =</span>
<span class="lineno">  131 </span><span class="spaces">  </span><span class="istickedoff">Env Map.empty Map.empty Map.empty Map.empty <span class="nottickedoff">[]</span> <span class="nottickedoff">Map.empty</span> <span class="nottickedoff">Map.empty</span> <span class="nottickedoff">Map.empty</span></span></span>
<span class="lineno">  132 </span>
<span class="lineno">  133 </span>liftTerm :: (Term, Int) -&gt; (Term, Int)
<span class="lineno">  134 </span><span class="decl"><span class="istickedoff">liftTerm (t, j) = (t, j + 1)</span></span>
<span class="lineno">  135 </span>
<span class="lineno">  136 </span>liftProp :: (Term, [FieldName], Int) -&gt; (Term, [FieldName], Int)
<span class="lineno">  137 </span><span class="decl"><span class="istickedoff">liftProp (t, fns, j) = (t, fns, j + 1)</span></span>
<span class="lineno">  138 </span>
<span class="lineno">  139 </span>-- | Increment dangling bound variables of all types in environment.
<span class="lineno">  140 </span>liftEnv :: Env -&gt; Env
<span class="lineno">  141 </span><span class="decl"><span class="istickedoff">liftEnv env =</span>
<span class="lineno">  142 </span><span class="spaces">  </span><span class="istickedoff">Env { envT = fmap liftTerm (envT env)</span>
<span class="lineno">  143 </span><span class="spaces">      </span><span class="istickedoff">, envE = fmap liftTerm (envE env)</span>
<span class="lineno">  144 </span><span class="spaces">      </span><span class="istickedoff">, envP = fmap liftProp (envP env)</span>
<span class="lineno">  145 </span><span class="spaces">      </span><span class="istickedoff">, envC = envC env</span>
<span class="lineno">  146 </span><span class="spaces">      </span><span class="istickedoff">, envS = <span class="nottickedoff">envS env</span></span>
<span class="lineno">  147 </span><span class="spaces">      </span><span class="istickedoff">, envRefPrims = <span class="nottickedoff">envRefPrims env</span></span>
<span class="lineno">  148 </span><span class="spaces">      </span><span class="istickedoff">, envPrims = <span class="nottickedoff">envPrims env</span></span>
<span class="lineno">  149 </span><span class="spaces">      </span><span class="istickedoff">, envPrimTypes = <span class="nottickedoff">envPrimTypes env</span></span>
<span class="lineno">  150 </span><span class="spaces">      </span><span class="istickedoff">}</span></span>
<span class="lineno">  151 </span>
<span class="lineno">  152 </span>bindTParam :: SharedContext -&gt; C.TParam -&gt; Env -&gt; IO Env
<span class="lineno">  153 </span><span class="decl"><span class="istickedoff">bindTParam sc tp env = do</span>
<span class="lineno">  154 </span><span class="spaces">  </span><span class="istickedoff">let env' = liftEnv env</span>
<span class="lineno">  155 </span><span class="spaces">  </span><span class="istickedoff">v &lt;- scLocalVar sc 0</span>
<span class="lineno">  156 </span><span class="spaces">  </span><span class="istickedoff">k &lt;- importKind sc (C.tpKind tp)</span>
<span class="lineno">  157 </span><span class="spaces">  </span><span class="istickedoff">return $ env' { envT = Map.insert (C.tpUnique tp) (v, 0) (envT env')</span>
<span class="lineno">  158 </span><span class="spaces">                </span><span class="istickedoff">, envS = <span class="nottickedoff">k : envS env</span> }</span></span>
<span class="lineno">  159 </span>
<span class="lineno">  160 </span>bindName :: SharedContext -&gt; C.Name -&gt; C.Schema -&gt; Env -&gt; IO Env
<span class="lineno">  161 </span><span class="decl"><span class="istickedoff">bindName sc name schema env = do</span>
<span class="lineno">  162 </span><span class="spaces">  </span><span class="istickedoff">let env' = liftEnv env</span>
<span class="lineno">  163 </span><span class="spaces">  </span><span class="istickedoff">v &lt;- scLocalVar sc 0</span>
<span class="lineno">  164 </span><span class="spaces">  </span><span class="istickedoff">t &lt;- importSchema sc env schema</span>
<span class="lineno">  165 </span><span class="spaces">  </span><span class="istickedoff">return $ env' { envE = Map.insert name (v, 0) (envE env')</span>
<span class="lineno">  166 </span><span class="spaces">                </span><span class="istickedoff">, envC = Map.insert name schema (envC env')</span>
<span class="lineno">  167 </span><span class="spaces">                </span><span class="istickedoff">, envS = <span class="nottickedoff">t : envS env'</span></span>
<span class="lineno">  168 </span><span class="spaces">                </span><span class="istickedoff">}</span></span>
<span class="lineno">  169 </span>
<span class="lineno">  170 </span>bindProp :: SharedContext -&gt; C.Prop -&gt; Env -&gt; IO Env
<span class="lineno">  171 </span><span class="decl"><span class="istickedoff">bindProp sc prop env = do</span>
<span class="lineno">  172 </span><span class="spaces">  </span><span class="istickedoff">let env' = liftEnv env</span>
<span class="lineno">  173 </span><span class="spaces">  </span><span class="istickedoff">v &lt;- scLocalVar sc 0</span>
<span class="lineno">  174 </span><span class="spaces">  </span><span class="istickedoff">k &lt;- scSort sc (mkSort 0)</span>
<span class="lineno">  175 </span><span class="spaces">  </span><span class="istickedoff">return $ env' { envP = insertSupers prop [] v (envP env')</span>
<span class="lineno">  176 </span><span class="spaces">                </span><span class="istickedoff">, envS = <span class="nottickedoff">k : envS env'</span></span>
<span class="lineno">  177 </span><span class="spaces">                </span><span class="istickedoff">}</span></span>
<span class="lineno">  178 </span>
<span class="lineno">  179 </span>-- | When we insert a non-erasable prop into the environment, make
<span class="lineno">  180 </span>--   sure to also insert all its superclasses.  We arrange it so
<span class="lineno">  181 </span>--   that every class dictionary contains the implementation of its
<span class="lineno">  182 </span>--   superclass dictionaries, which can be extracted via field projections.
<span class="lineno">  183 </span>insertSupers ::
<span class="lineno">  184 </span>  C.Prop -&gt;
<span class="lineno">  185 </span>  [FieldName] {- Field names to project the associated class (in reverse order) -} -&gt;
<span class="lineno">  186 </span>  Term -&gt;
<span class="lineno">  187 </span>  Map C.Prop (Term, [FieldName], Int) -&gt;
<span class="lineno">  188 </span>  Map C.Prop (Term, [FieldName], Int)
<span class="lineno">  189 </span><span class="decl"><span class="istickedoff">insertSupers prop fs v m</span>
<span class="lineno">  190 </span><span class="spaces">  </span><span class="istickedoff">-- If the prop is already in the map, stop</span>
<span class="lineno">  191 </span><span class="spaces">  </span><span class="istickedoff">| Just _ &lt;- Map.lookup prop m = <span class="nottickedoff">m</span></span>
<span class="lineno">  192 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  193 </span><span class="spaces">  </span><span class="istickedoff">-- Insert the prop and check if it has any superclasses that also need to be added</span>
<span class="lineno">  194 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = Map.insert (normalizeProp prop) (v, fs, 0) $ go prop</span>
<span class="lineno">  195 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  196 </span><span class="spaces"> </span><span class="istickedoff">where</span>
<span class="lineno">  197 </span><span class="spaces"> </span><span class="istickedoff">super p f t = insertSupers (C.TCon (C.PC p) [t]) (f:fs) v</span>
<span class="lineno">  198 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  199 </span><span class="spaces"> </span><span class="istickedoff">go (C.TCon (C.PC p) [t]) =</span>
<span class="lineno">  200 </span><span class="spaces">    </span><span class="istickedoff">case p of</span>
<span class="lineno">  201 </span><span class="spaces">      </span><span class="istickedoff">C.PRing      -&gt; super C.PZero <span class="nottickedoff">&quot;ringZero&quot;</span> t m</span>
<span class="lineno">  202 </span><span class="spaces">      </span><span class="istickedoff">C.PLogic     -&gt; <span class="nottickedoff">super C.PZero &quot;logicZero&quot; t m</span></span>
<span class="lineno">  203 </span><span class="spaces">      </span><span class="istickedoff">C.PField     -&gt; <span class="nottickedoff">super C.PRing &quot;fieldRing&quot; t m</span></span>
<span class="lineno">  204 </span><span class="spaces">      </span><span class="istickedoff">C.PIntegral  -&gt; super C.PRing &quot;integralRing&quot; t m</span>
<span class="lineno">  205 </span><span class="spaces">      </span><span class="istickedoff">C.PRound     -&gt; <span class="nottickedoff">super C.PField &quot;roundField&quot; t . super C.PCmp &quot;roundCmp&quot; t $ m</span></span>
<span class="lineno">  206 </span><span class="spaces">      </span><span class="istickedoff">C.PCmp       -&gt; super C.PEq &quot;cmpEq&quot; t m</span>
<span class="lineno">  207 </span><span class="spaces">      </span><span class="istickedoff">C.PSignedCmp -&gt; super C.PEq <span class="nottickedoff">&quot;signedCmpEq&quot;</span> <span class="nottickedoff">t</span> m</span>
<span class="lineno">  208 </span><span class="spaces">      </span><span class="istickedoff">_ -&gt; m</span>
<span class="lineno">  209 </span><span class="spaces"> </span><span class="istickedoff">go _ = m</span></span>
<span class="lineno">  210 </span>
<span class="lineno">  211 </span>
<span class="lineno">  212 </span>-- | We normalize the first argument of 'Literal' class constraints
<span class="lineno">  213 </span>-- arbitrarily to 'inf', so that we can ignore that parameter when
<span class="lineno">  214 </span>-- matching dictionaries.
<span class="lineno">  215 </span>normalizeProp :: C.Prop -&gt; C.Prop
<span class="lineno">  216 </span><span class="decl"><span class="istickedoff">normalizeProp prop</span>
<span class="lineno">  217 </span><span class="spaces">  </span><span class="istickedoff">| Just (_, a) &lt;- C.pIsLiteral prop = C.pLiteral C.tInf a</span>
<span class="lineno">  218 </span><span class="spaces">  </span><span class="istickedoff">| Just (_, a) &lt;- C.pIsLiteralLessThan prop = C.pLiteralLessThan C.tInf a</span>
<span class="lineno">  219 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = prop</span></span>
<span class="lineno">  220 </span>
<span class="lineno">  221 </span>
<span class="lineno">  222 </span>--------------------------------------------------------------------------------
<span class="lineno">  223 </span>
<span class="lineno">  224 </span>importKind :: SharedContext -&gt; C.Kind -&gt; IO Term
<span class="lineno">  225 </span><span class="decl"><span class="istickedoff">importKind sc kind =</span>
<span class="lineno">  226 </span><span class="spaces">  </span><span class="istickedoff">case kind of</span>
<span class="lineno">  227 </span><span class="spaces">    </span><span class="istickedoff">C.KType       -&gt; scISort sc (mkSort 0)</span>
<span class="lineno">  228 </span><span class="spaces">    </span><span class="istickedoff">C.KNum        -&gt; scDataTypeApp sc &quot;Cryptol.Num&quot; []</span>
<span class="lineno">  229 </span><span class="spaces">    </span><span class="istickedoff">C.KProp       -&gt; <span class="nottickedoff">scSort sc (mkSort 0)</span></span>
<span class="lineno">  230 </span><span class="spaces">    </span><span class="istickedoff">(C.:-&gt;) k1 k2 -&gt; <span class="nottickedoff">join $ scFun sc &lt;$&gt; importKind sc k1 &lt;*&gt; importKind sc k2</span></span></span>
<span class="lineno">  231 </span>
<span class="lineno">  232 </span>importTFun :: SharedContext -&gt; C.TFun -&gt; IO Term
<span class="lineno">  233 </span><span class="decl"><span class="istickedoff">importTFun sc tf =</span>
<span class="lineno">  234 </span><span class="spaces">  </span><span class="istickedoff">case tf of</span>
<span class="lineno">  235 </span><span class="spaces">    </span><span class="istickedoff">C.TCWidth         -&gt; scGlobalDef sc &quot;Cryptol.tcWidth&quot;</span>
<span class="lineno">  236 </span><span class="spaces">    </span><span class="istickedoff">C.TCAdd           -&gt; scGlobalDef sc &quot;Cryptol.tcAdd&quot;</span>
<span class="lineno">  237 </span><span class="spaces">    </span><span class="istickedoff">C.TCSub           -&gt; scGlobalDef sc &quot;Cryptol.tcSub&quot;</span>
<span class="lineno">  238 </span><span class="spaces">    </span><span class="istickedoff">C.TCMul           -&gt; scGlobalDef sc &quot;Cryptol.tcMul&quot;</span>
<span class="lineno">  239 </span><span class="spaces">    </span><span class="istickedoff">C.TCDiv           -&gt; scGlobalDef sc &quot;Cryptol.tcDiv&quot;</span>
<span class="lineno">  240 </span><span class="spaces">    </span><span class="istickedoff">C.TCMod           -&gt; <span class="nottickedoff">scGlobalDef sc &quot;Cryptol.tcMod&quot;</span></span>
<span class="lineno">  241 </span><span class="spaces">    </span><span class="istickedoff">C.TCExp           -&gt; <span class="nottickedoff">scGlobalDef sc &quot;Cryptol.tcExp&quot;</span></span>
<span class="lineno">  242 </span><span class="spaces">    </span><span class="istickedoff">C.TCMin           -&gt; scGlobalDef sc &quot;Cryptol.tcMin&quot;</span>
<span class="lineno">  243 </span><span class="spaces">    </span><span class="istickedoff">C.TCMax           -&gt; <span class="nottickedoff">scGlobalDef sc &quot;Cryptol.tcMax&quot;</span></span>
<span class="lineno">  244 </span><span class="spaces">    </span><span class="istickedoff">C.TCCeilDiv       -&gt; scGlobalDef sc &quot;Cryptol.tcCeilDiv&quot;</span>
<span class="lineno">  245 </span><span class="spaces">    </span><span class="istickedoff">C.TCCeilMod       -&gt; scGlobalDef sc &quot;Cryptol.tcCeilMod&quot;</span>
<span class="lineno">  246 </span><span class="spaces">    </span><span class="istickedoff">C.TCLenFromThenTo -&gt; <span class="nottickedoff">scGlobalDef sc &quot;Cryptol.tcLenFromThenTo&quot;</span></span></span>
<span class="lineno">  247 </span>
<span class="lineno">  248 </span>-- | Precondition: @not ('isErasedProp' pc)@.
<span class="lineno">  249 </span>importPC :: SharedContext -&gt; C.PC -&gt; IO Term
<span class="lineno">  250 </span><span class="decl"><span class="istickedoff">importPC sc pc =</span>
<span class="lineno">  251 </span><span class="spaces">  </span><span class="istickedoff">case pc of</span>
<span class="lineno">  252 </span><span class="spaces">    </span><span class="istickedoff">C.PEqual           -&gt; <span class="nottickedoff">panic &quot;importPC PEqual&quot; []</span></span>
<span class="lineno">  253 </span><span class="spaces">    </span><span class="istickedoff">C.PNeq             -&gt; <span class="nottickedoff">panic &quot;importPC PNeq&quot; []</span></span>
<span class="lineno">  254 </span><span class="spaces">    </span><span class="istickedoff">C.PGeq             -&gt; <span class="nottickedoff">panic &quot;importPC PGeq&quot; []</span></span>
<span class="lineno">  255 </span><span class="spaces">    </span><span class="istickedoff">C.PFin             -&gt; <span class="nottickedoff">panic &quot;importPC PFin&quot; []</span></span>
<span class="lineno">  256 </span><span class="spaces">    </span><span class="istickedoff">C.PHas _           -&gt; <span class="nottickedoff">panic &quot;importPC PHas&quot; []</span></span>
<span class="lineno">  257 </span><span class="spaces">    </span><span class="istickedoff">C.PPrime           -&gt; <span class="nottickedoff">panic &quot;importPC PPrime&quot; []</span></span>
<span class="lineno">  258 </span><span class="spaces">    </span><span class="istickedoff">C.PZero            -&gt; scGlobalDef sc &quot;Cryptol.PZero&quot;</span>
<span class="lineno">  259 </span><span class="spaces">    </span><span class="istickedoff">C.PLogic           -&gt; <span class="nottickedoff">scGlobalDef sc &quot;Cryptol.PLogic&quot;</span></span>
<span class="lineno">  260 </span><span class="spaces">    </span><span class="istickedoff">C.PRing            -&gt; scGlobalDef sc &quot;Cryptol.PRing&quot;</span>
<span class="lineno">  261 </span><span class="spaces">    </span><span class="istickedoff">C.PIntegral        -&gt; scGlobalDef sc &quot;Cryptol.PIntegral&quot;</span>
<span class="lineno">  262 </span><span class="spaces">    </span><span class="istickedoff">C.PField           -&gt; <span class="nottickedoff">scGlobalDef sc &quot;Cryptol.PField&quot;</span></span>
<span class="lineno">  263 </span><span class="spaces">    </span><span class="istickedoff">C.PRound           -&gt; <span class="nottickedoff">scGlobalDef sc &quot;Cryptol.PRound&quot;</span></span>
<span class="lineno">  264 </span><span class="spaces">    </span><span class="istickedoff">C.PEq              -&gt; scGlobalDef sc &quot;Cryptol.PEq&quot;</span>
<span class="lineno">  265 </span><span class="spaces">    </span><span class="istickedoff">C.PCmp             -&gt; scGlobalDef sc &quot;Cryptol.PCmp&quot;</span>
<span class="lineno">  266 </span><span class="spaces">    </span><span class="istickedoff">C.PSignedCmp       -&gt; scGlobalDef sc &quot;Cryptol.PSignedCmp&quot;</span>
<span class="lineno">  267 </span><span class="spaces">    </span><span class="istickedoff">C.PLiteral         -&gt; <span class="nottickedoff">scGlobalDef sc &quot;Cryptol.PLiteral&quot;</span></span>
<span class="lineno">  268 </span><span class="spaces">    </span><span class="istickedoff">C.PLiteralLessThan -&gt; <span class="nottickedoff">scGlobalDef sc &quot;Cryptol.PLiteralLessThan&quot;</span></span>
<span class="lineno">  269 </span><span class="spaces">    </span><span class="istickedoff">C.PAnd             -&gt; <span class="nottickedoff">panic &quot;importPC PAnd&quot; []</span></span>
<span class="lineno">  270 </span><span class="spaces">    </span><span class="istickedoff">C.PTrue            -&gt; <span class="nottickedoff">panic &quot;importPC PTrue&quot; []</span></span>
<span class="lineno">  271 </span><span class="spaces">    </span><span class="istickedoff">C.PFLiteral        -&gt; <span class="nottickedoff">panic &quot;importPC PFLiteral&quot; []</span></span>
<span class="lineno">  272 </span><span class="spaces">    </span><span class="istickedoff">C.PValidFloat      -&gt; <span class="nottickedoff">panic &quot;importPC PValidFloat&quot; []</span></span></span>
<span class="lineno">  273 </span>
<span class="lineno">  274 </span>-- | Translate size types to SAW values of type Num, value types to SAW types of sort 0.
<span class="lineno">  275 </span>importType :: SharedContext -&gt; Env -&gt; C.Type -&gt; IO Term
<span class="lineno">  276 </span><span class="decl"><span class="istickedoff">importType sc env ty =</span>
<span class="lineno">  277 </span><span class="spaces">  </span><span class="istickedoff">case ty of</span>
<span class="lineno">  278 </span><span class="spaces">    </span><span class="istickedoff">C.TVar tvar -&gt;</span>
<span class="lineno">  279 </span><span class="spaces">      </span><span class="istickedoff">case tvar of</span>
<span class="lineno">  280 </span><span class="spaces">        </span><span class="istickedoff">C.TVFree{} {- Int Kind (Set TVar) Doc -} -&gt; <span class="nottickedoff">unimplemented &quot;TVFree&quot;</span></span>
<span class="lineno">  281 </span><span class="spaces">        </span><span class="istickedoff">C.TVBound v -&gt; case Map.lookup (C.tpUnique v) (envT env) of</span>
<span class="lineno">  282 </span><span class="spaces">                         </span><span class="istickedoff">Just (t, j) -&gt; incVars sc 0 j t</span>
<span class="lineno">  283 </span><span class="spaces">                         </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">panic &quot;importType TVBound&quot; []</span></span>
<span class="lineno">  284 </span><span class="spaces">    </span><span class="istickedoff">C.TUser _ _ t  -&gt; go t -- look through type synonyms</span>
<span class="lineno">  285 </span><span class="spaces">    </span><span class="istickedoff">C.TRec fm -&gt;</span>
<span class="lineno">  286 </span><span class="spaces">      </span><span class="istickedoff">importType sc env (C.tTuple (map snd (C.canonicalFields fm)))</span>
<span class="lineno">  287 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  288 </span><span class="spaces">    </span><span class="istickedoff">C.TNominal nt ts -&gt;</span>
<span class="lineno">  289 </span><span class="spaces">      </span><span class="istickedoff">do let <span class="nottickedoff">s = C.listSubst (zip (map C.TVBound (C.ntParams nt)) ts)</span></span>
<span class="lineno">  290 </span><span class="spaces">         </span><span class="istickedoff">let <span class="nottickedoff">n = C.ntName nt</span></span>
<span class="lineno">  291 </span><span class="spaces">         </span><span class="istickedoff">case ntDef nt of</span>
<span class="lineno">  292 </span><span class="spaces">           </span><span class="istickedoff">C.Struct stru -&gt; go (plainSubst <span class="nottickedoff">s</span> (C.TRec (C.ntFields stru)))</span>
<span class="lineno">  293 </span><span class="spaces">           </span><span class="istickedoff">C.Enum {} -&gt; <span class="nottickedoff">error &quot;importType: `enum` is not yet supported&quot;</span></span>
<span class="lineno">  294 </span><span class="spaces">           </span><span class="istickedoff">C.Abstract</span>
<span class="lineno">  295 </span><span class="spaces">             </span><span class="istickedoff">| Just prim' &lt;- <span class="nottickedoff">C.asPrim n</span></span>
<span class="lineno">  296 </span><span class="spaces">             </span><span class="istickedoff">, Just t &lt;- <span class="nottickedoff">Map.lookup prim' (envPrimTypes env)</span> -&gt;</span>
<span class="lineno">  297 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">scApplyAllBeta sc t =&lt;&lt; traverse go ts</span></span>
<span class="lineno">  298 </span><span class="spaces">             </span><span class="istickedoff">| <span class="nottickedoff">True</span> -&gt; <span class="nottickedoff">panic (&quot;importType: unknown primitive type: &quot; ++ show n) []</span></span>
<span class="lineno">  299 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  300 </span><span class="spaces">    </span><span class="istickedoff">C.TCon tcon tyargs -&gt;</span>
<span class="lineno">  301 </span><span class="spaces">      </span><span class="istickedoff">case tcon of</span>
<span class="lineno">  302 </span><span class="spaces">        </span><span class="istickedoff">C.TC tc -&gt;</span>
<span class="lineno">  303 </span><span class="spaces">          </span><span class="istickedoff">case tc of</span>
<span class="lineno">  304 </span><span class="spaces">            </span><span class="istickedoff">C.TCNum n    -&gt; scCtorApp sc &quot;Cryptol.TCNum&quot; =&lt;&lt; sequence [scNat sc (fromInteger n)]</span>
<span class="lineno">  305 </span><span class="spaces">            </span><span class="istickedoff">C.TCInf      -&gt; scCtorApp sc &quot;Cryptol.TCInf&quot; []</span>
<span class="lineno">  306 </span><span class="spaces">            </span><span class="istickedoff">C.TCBit      -&gt; scBoolType sc</span>
<span class="lineno">  307 </span><span class="spaces">            </span><span class="istickedoff">C.TCInteger  -&gt; scIntegerType sc</span>
<span class="lineno">  308 </span><span class="spaces">            </span><span class="istickedoff">C.TCIntMod   -&gt; scGlobalApply sc &quot;Cryptol.IntModNum&quot; =&lt;&lt; traverse go tyargs</span>
<span class="lineno">  309 </span><span class="spaces">            </span><span class="istickedoff">C.TCFloat    -&gt; <span class="nottickedoff">scGlobalApply sc &quot;Cryptol.TCFloat&quot;   =&lt;&lt; traverse go tyargs</span></span>
<span class="lineno">  310 </span><span class="spaces">            </span><span class="istickedoff">C.TCArray    -&gt; do a &lt;- go (tyargs !! 0)</span>
<span class="lineno">  311 </span><span class="spaces">                               </span><span class="istickedoff">b &lt;- go (tyargs !! 1)</span>
<span class="lineno">  312 </span><span class="spaces">                               </span><span class="istickedoff">scArrayType sc a b</span>
<span class="lineno">  313 </span><span class="spaces">            </span><span class="istickedoff">C.TCRational -&gt; <span class="nottickedoff">scGlobalApply sc &quot;Cryptol.Rational&quot; []</span></span>
<span class="lineno">  314 </span><span class="spaces">            </span><span class="istickedoff">C.TCSeq      -&gt; scGlobalApply sc &quot;Cryptol.seq&quot; =&lt;&lt; traverse go tyargs</span>
<span class="lineno">  315 </span><span class="spaces">            </span><span class="istickedoff">C.TCFun      -&gt; do a &lt;- go (tyargs !! 0)</span>
<span class="lineno">  316 </span><span class="spaces">                               </span><span class="istickedoff">b &lt;- go (tyargs !! 1)</span>
<span class="lineno">  317 </span><span class="spaces">                               </span><span class="istickedoff">scFun sc a b</span>
<span class="lineno">  318 </span><span class="spaces">            </span><span class="istickedoff">C.TCTuple _n -&gt; scTupleType sc =&lt;&lt; traverse go tyargs</span>
<span class="lineno">  319 </span><span class="spaces">        </span><span class="istickedoff">C.PC pc -&gt;</span>
<span class="lineno">  320 </span><span class="spaces">          </span><span class="istickedoff">case pc of</span>
<span class="lineno">  321 </span><span class="spaces">            </span><span class="istickedoff">C.PLiteral -&gt; -- we omit first argument to class Literal</span>
<span class="lineno">  322 </span><span class="spaces">              </span><span class="istickedoff">do a &lt;- go (tyargs !! 1)</span>
<span class="lineno">  323 </span><span class="spaces">                 </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PLiteral&quot; [a]</span>
<span class="lineno">  324 </span><span class="spaces">            </span><span class="istickedoff">C.PLiteralLessThan -&gt; -- we omit first argument to class LiteralLessThan</span>
<span class="lineno">  325 </span><span class="spaces">              </span><span class="istickedoff">do a &lt;- go (tyargs !! 1)</span>
<span class="lineno">  326 </span><span class="spaces">                 </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PLiteralLessThan&quot; [a]</span>
<span class="lineno">  327 </span><span class="spaces">            </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  328 </span><span class="spaces">              </span><span class="istickedoff">do pc' &lt;- importPC sc pc</span>
<span class="lineno">  329 </span><span class="spaces">                 </span><span class="istickedoff">tyargs' &lt;- traverse go tyargs</span>
<span class="lineno">  330 </span><span class="spaces">                 </span><span class="istickedoff">scApplyAll sc pc' tyargs'</span>
<span class="lineno">  331 </span><span class="spaces">        </span><span class="istickedoff">C.TF tf -&gt;</span>
<span class="lineno">  332 </span><span class="spaces">          </span><span class="istickedoff">do tf' &lt;- importTFun sc tf</span>
<span class="lineno">  333 </span><span class="spaces">             </span><span class="istickedoff">tyargs' &lt;- traverse go tyargs</span>
<span class="lineno">  334 </span><span class="spaces">             </span><span class="istickedoff">scApplyAll sc tf' tyargs'</span>
<span class="lineno">  335 </span><span class="spaces">        </span><span class="istickedoff">C.TError _k -&gt;</span>
<span class="lineno">  336 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importType TError&quot; []</span></span>
<span class="lineno">  337 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  338 </span><span class="spaces">    </span><span class="istickedoff">go = importType sc env</span></span>
<span class="lineno">  339 </span>
<span class="lineno">  340 </span>isErasedProp :: C.Prop -&gt; Bool
<span class="lineno">  341 </span><span class="decl"><span class="istickedoff">isErasedProp prop =</span>
<span class="lineno">  342 </span><span class="spaces">  </span><span class="istickedoff">case prop of</span>
<span class="lineno">  343 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PZero           ) _ -&gt; False</span>
<span class="lineno">  344 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PLogic          ) _ -&gt; False</span>
<span class="lineno">  345 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PRing           ) _ -&gt; False</span>
<span class="lineno">  346 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PIntegral       ) _ -&gt; False</span>
<span class="lineno">  347 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PField          ) _ -&gt; <span class="nottickedoff">False</span></span>
<span class="lineno">  348 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PRound          ) _ -&gt; <span class="nottickedoff">False</span></span>
<span class="lineno">  349 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PEq             ) _ -&gt; False</span>
<span class="lineno">  350 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PCmp            ) _ -&gt; False</span>
<span class="lineno">  351 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PSignedCmp      ) _ -&gt; False</span>
<span class="lineno">  352 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PLiteral        ) _ -&gt; False</span>
<span class="lineno">  353 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PLiteralLessThan) _ -&gt; False</span>
<span class="lineno">  354 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; True</span></span>
<span class="lineno">  355 </span>
<span class="lineno">  356 </span>-- | Translate a 'Prop' containing a numeric constraint to a 'Term' that tests
<span class="lineno">  357 </span>-- if the 'Prop' holds. This function will 'panic' for 'Prop's that are not
<span class="lineno">  358 </span>-- numeric constraints, such as @Integral@. In other words, this function
<span class="lineno">  359 </span>-- supports the same set of 'Prop's that constraint guards do.
<span class="lineno">  360 </span>importNumericConstraintAsBool :: SharedContext -&gt; Env -&gt; C.Prop -&gt; IO Term
<span class="lineno">  361 </span><span class="decl"><span class="istickedoff">importNumericConstraintAsBool sc env prop =</span>
<span class="lineno">  362 </span><span class="spaces">  </span><span class="istickedoff">case prop of</span>
<span class="lineno">  363 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PEqual) [lhs, rhs] -&gt; eqTerm lhs rhs</span>
<span class="lineno">  364 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PNeq) [lhs, rhs] -&gt; eqTerm lhs rhs &gt;&gt;= scNot sc</span>
<span class="lineno">  365 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PGeq) [lhs, rhs] -&gt; do</span>
<span class="lineno">  366 </span><span class="spaces">      </span><span class="istickedoff">-- Convert 'lhs &gt;= rhs' into '(rhs &lt; lhs) \/ (rhs == lhs)'</span>
<span class="lineno">  367 </span><span class="spaces">      </span><span class="istickedoff">lhs' &lt;- importType sc env lhs</span>
<span class="lineno">  368 </span><span class="spaces">      </span><span class="istickedoff">rhs' &lt;- importType sc env rhs</span>
<span class="lineno">  369 </span><span class="spaces">      </span><span class="istickedoff">lt &lt;- scGlobalApply sc &quot;Cryptol.tcLt&quot; [rhs', lhs']</span>
<span class="lineno">  370 </span><span class="spaces">      </span><span class="istickedoff">eq &lt;- scGlobalApply sc &quot;Cryptol.tcEqual&quot; [rhs', lhs']</span>
<span class="lineno">  371 </span><span class="spaces">      </span><span class="istickedoff">scOr sc lt eq</span>
<span class="lineno">  372 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PFin) [x] -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  373 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">x' &lt;- importType sc env x</span></span>
<span class="lineno">  374 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.tcFin&quot; [x']</span></span>
<span class="lineno">  375 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PAnd) [lhs, rhs] -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  376 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">lhs' &lt;- importType sc env lhs</span></span>
<span class="lineno">  377 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">rhs' &lt;- importType sc env rhs</span></span>
<span class="lineno">  378 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">scAnd sc lhs' rhs'</span></span>
<span class="lineno">  379 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PTrue) [] -&gt; <span class="nottickedoff">scBool sc True</span></span>
<span class="lineno">  380 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.TError _) _ -&gt; <span class="nottickedoff">scBool sc False</span></span>
<span class="lineno">  381 </span><span class="spaces">    </span><span class="istickedoff">C.TUser _ _ t -&gt; importNumericConstraintAsBool sc env t</span>
<span class="lineno">  382 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">panic</span></span>
<span class="lineno">  383 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">&quot;importNumericConstraintAsBool&quot;</span></span>
<span class="lineno">  384 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">[ &quot;importNumericConstraintAsBool called with non-numeric constraint:&quot;</span></span>
<span class="lineno">  385 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, pretty prop</span></span>
<span class="lineno">  386 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  387 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  388 </span><span class="spaces">    </span><span class="istickedoff">-- | Construct a term for equality of two types</span>
<span class="lineno">  389 </span><span class="spaces">    </span><span class="istickedoff">eqTerm :: C.Type -&gt; C.Type -&gt; IO Term</span>
<span class="lineno">  390 </span><span class="spaces">    </span><span class="istickedoff">eqTerm lhs rhs = do</span>
<span class="lineno">  391 </span><span class="spaces">      </span><span class="istickedoff">lhs' &lt;- importType sc env lhs</span>
<span class="lineno">  392 </span><span class="spaces">      </span><span class="istickedoff">rhs' &lt;- importType sc <span class="nottickedoff">env</span> rhs</span>
<span class="lineno">  393 </span><span class="spaces">      </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.tcEqual&quot; [lhs', rhs']</span></span>
<span class="lineno">  394 </span>
<span class="lineno">  395 </span>importPropsType :: SharedContext -&gt; Env -&gt; [C.Prop] -&gt; C.Type -&gt; IO Term
<span class="lineno">  396 </span><span class="decl"><span class="istickedoff">importPropsType sc env [] ty = importType sc env ty</span>
<span class="lineno">  397 </span><span class="spaces"></span><span class="istickedoff">importPropsType sc env (prop : props) ty</span>
<span class="lineno">  398 </span><span class="spaces">  </span><span class="istickedoff">| isErasedProp prop = importPropsType sc env props ty</span>
<span class="lineno">  399 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno">  400 </span><span class="spaces">    </span><span class="istickedoff">do p &lt;- importType sc env prop</span>
<span class="lineno">  401 </span><span class="spaces">       </span><span class="istickedoff">t &lt;- importPropsType sc env props ty</span>
<span class="lineno">  402 </span><span class="spaces">       </span><span class="istickedoff">scFun sc p t</span></span>
<span class="lineno">  403 </span>
<span class="lineno">  404 </span>nameToLocalName :: C.Name -&gt; LocalName
<span class="lineno">  405 </span><span class="decl"><span class="istickedoff">nameToLocalName = C.identText . C.nameIdent</span></span>
<span class="lineno">  406 </span>
<span class="lineno">  407 </span>nameToFieldName :: C.Name -&gt; FieldName
<span class="lineno">  408 </span><span class="decl"><span class="istickedoff">nameToFieldName = C.identText . C.nameIdent</span></span>
<span class="lineno">  409 </span>
<span class="lineno">  410 </span>tparamToLocalName :: C.TParam -&gt; LocalName
<span class="lineno">  411 </span><span class="decl"><span class="istickedoff">tparamToLocalName tp = maybe (Text.pack (&quot;u&quot; ++ show (C.tpUnique tp))) nameToLocalName (C.tpName tp)</span></span>
<span class="lineno">  412 </span>
<span class="lineno">  413 </span>importPolyType :: SharedContext -&gt; Env -&gt; [C.TParam] -&gt; [C.Prop] -&gt; C.Type -&gt; IO Term
<span class="lineno">  414 </span><span class="decl"><span class="istickedoff">importPolyType sc env [] props ty = importPropsType sc env props ty</span>
<span class="lineno">  415 </span><span class="spaces"></span><span class="istickedoff">importPolyType sc env (tp : tps) props ty =</span>
<span class="lineno">  416 </span><span class="spaces">  </span><span class="istickedoff">do k &lt;- importKind sc (C.tpKind tp)</span>
<span class="lineno">  417 </span><span class="spaces">     </span><span class="istickedoff">env' &lt;- bindTParam sc tp env</span>
<span class="lineno">  418 </span><span class="spaces">     </span><span class="istickedoff">t &lt;- importPolyType sc env' tps props ty</span>
<span class="lineno">  419 </span><span class="spaces">     </span><span class="istickedoff">scPi sc (tparamToLocalName tp) k t</span></span>
<span class="lineno">  420 </span>
<span class="lineno">  421 </span>importSchema :: SharedContext -&gt; Env -&gt; C.Schema -&gt; IO Term
<span class="lineno">  422 </span><span class="decl"><span class="istickedoff">importSchema sc env (C.Forall tparams props ty) = importPolyType sc env tparams props ty</span></span>
<span class="lineno">  423 </span>
<span class="lineno">  424 </span>-- entry point
<span class="lineno">  425 </span>proveProp :: HasCallStack =&gt; SharedContext -&gt; Env -&gt; C.Prop -&gt; IO Term
<span class="lineno">  426 </span><span class="decl"><span class="istickedoff">proveProp sc env prop = provePropRec sc env prop prop</span></span>
<span class="lineno">  427 </span>
<span class="lineno">  428 </span>-- internal recursive version
<span class="lineno">  429 </span>--
<span class="lineno">  430 </span>-- (we carry around the original prop when recursing as &quot;prop0&quot;, in
<span class="lineno">  431 </span>-- case we get stuck and need to bail out, at which point we want to
<span class="lineno">  432 </span>-- be able to print it)
<span class="lineno">  433 </span>provePropRec :: HasCallStack =&gt; SharedContext -&gt; Env -&gt; C.Prop -&gt; C.Prop -&gt; IO Term
<span class="lineno">  434 </span><span class="decl"><span class="istickedoff">provePropRec sc env prop0 prop =</span>
<span class="lineno">  435 </span><span class="spaces">  </span><span class="istickedoff">case Map.lookup (normalizeProp prop) (envP env) of</span>
<span class="lineno">  436 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  437 </span><span class="spaces">    </span><span class="istickedoff">-- Class dictionary was provided as an argument</span>
<span class="lineno">  438 </span><span class="spaces">    </span><span class="istickedoff">Just (prf, fs, j) -&gt;</span>
<span class="lineno">  439 </span><span class="spaces">       </span><span class="istickedoff">do -- shift deBruijn indicies by j</span>
<span class="lineno">  440 </span><span class="spaces">          </span><span class="istickedoff">v &lt;- incVars sc 0 j prf</span>
<span class="lineno">  441 </span><span class="spaces">          </span><span class="istickedoff">-- apply field projections as necessary to compute superclasses</span>
<span class="lineno">  442 </span><span class="spaces">          </span><span class="istickedoff">-- NB: reverse the order of the fields</span>
<span class="lineno">  443 </span><span class="spaces">          </span><span class="istickedoff">foldM (scRecordSelect sc) v (reverse fs)</span>
<span class="lineno">  444 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  445 </span><span class="spaces">    </span><span class="istickedoff">-- Class dictionary not provided, compute it from the structure of types</span>
<span class="lineno">  446 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  447 </span><span class="spaces">      </span><span class="istickedoff">case prop of</span>
<span class="lineno">  448 </span><span class="spaces">        </span><span class="istickedoff">-- instance Zero Bit</span>
<span class="lineno">  449 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsZero -&gt; Just (C.tIsBit -&gt; True))</span>
<span class="lineno">  450 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do scGlobalApply sc &quot;Cryptol.PZeroBit&quot; []</span>
<span class="lineno">  451 </span><span class="spaces">        </span><span class="istickedoff">-- instance Zero Integer</span>
<span class="lineno">  452 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsZero -&gt; Just (C.tIsInteger -&gt; True))</span>
<span class="lineno">  453 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do scGlobalApply sc &quot;Cryptol.PZeroInteger&quot; []</span>
<span class="lineno">  454 </span><span class="spaces">        </span><span class="istickedoff">-- instance Zero (Z n)</span>
<span class="lineno">  455 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsZero -&gt; Just (C.tIsIntMod -&gt; Just n))</span>
<span class="lineno">  456 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do n' &lt;- importType sc env n</span></span>
<span class="lineno">  457 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PZeroIntModNum&quot; [n']</span></span>
<span class="lineno">  458 </span><span class="spaces">        </span><span class="istickedoff">-- instance Zero Rational</span>
<span class="lineno">  459 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsZero -&gt; Just (C.tIsRational -&gt; True))</span>
<span class="lineno">  460 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PZeroRational&quot; []</span></span>
<span class="lineno">  461 </span><span class="spaces">        </span><span class="istickedoff">-- instance Zero [n]</span>
<span class="lineno">  462 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsZero -&gt; Just (C.tIsSeq -&gt; Just (n, C.tIsBit -&gt; True)))</span>
<span class="lineno">  463 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc env n</span>
<span class="lineno">  464 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PZeroSeqBool&quot; [n']</span>
<span class="lineno">  465 </span><span class="spaces">        </span><span class="istickedoff">-- instance ValidFloat e p =&gt; Zero (Float e p)</span>
<span class="lineno">  466 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsZero -&gt; Just (C.tIsFloat -&gt; Just (e, p)))</span>
<span class="lineno">  467 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do e' &lt;- importType sc env e</span></span>
<span class="lineno">  468 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">p' &lt;- importType sc env p</span></span>
<span class="lineno">  469 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PZeroFloat&quot; [e', p']</span></span>
<span class="lineno">  470 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Zero a) =&gt; Zero [n]a</span>
<span class="lineno">  471 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsZero -&gt; Just (C.tIsSeq -&gt; Just (n, a)))</span>
<span class="lineno">  472 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc env n</span>
<span class="lineno">  473 </span><span class="spaces">                </span><span class="istickedoff">a' &lt;- importType sc env a</span>
<span class="lineno">  474 </span><span class="spaces">                </span><span class="istickedoff">pa &lt;- provePropRec sc env <span class="nottickedoff">prop0</span> (C.pZero a)</span>
<span class="lineno">  475 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PZeroSeq&quot; [n', a', pa]</span>
<span class="lineno">  476 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Zero b) =&gt; Zero (a -&gt; b)</span>
<span class="lineno">  477 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsZero -&gt; Just (C.tIsFun -&gt; Just (a, b)))</span>
<span class="lineno">  478 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do a' &lt;- importType sc env a</span></span>
<span class="lineno">  479 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">b' &lt;- importType sc env b</span></span>
<span class="lineno">  480 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">pb &lt;- provePropRec sc env prop0 (C.pZero b)</span></span>
<span class="lineno">  481 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PZeroFun&quot; [a', b', pb]</span></span>
<span class="lineno">  482 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Zero a, Zero b, ...) =&gt; Zero (a, b, ...)</span>
<span class="lineno">  483 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsZero -&gt; Just (C.tIsTuple -&gt; Just ts))</span>
<span class="lineno">  484 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do ps &lt;- traverse (provePropRec sc env <span class="nottickedoff">prop0</span> . C.pZero) ts</span>
<span class="lineno">  485 </span><span class="spaces">                </span><span class="istickedoff">scTuple sc ps</span>
<span class="lineno">  486 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Zero a, Zero b, ...) =&gt; Zero { x : a, y : b, ... }</span>
<span class="lineno">  487 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsZero -&gt; Just (C.tIsRec -&gt; Just fm))</span>
<span class="lineno">  488 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do provePropRec sc env <span class="nottickedoff">prop0</span> (C.pZero (C.tTuple (map snd (C.canonicalFields fm))))</span>
<span class="lineno">  489 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  490 </span><span class="spaces">        </span><span class="istickedoff">-- instance Logic Bit</span>
<span class="lineno">  491 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLogic -&gt; Just (C.tIsBit -&gt; True))</span>
<span class="lineno">  492 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do scGlobalApply sc &quot;Cryptol.PLogicBit&quot; []</span>
<span class="lineno">  493 </span><span class="spaces">        </span><span class="istickedoff">-- instance Logic [n]</span>
<span class="lineno">  494 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLogic -&gt; Just (C.tIsSeq -&gt; Just (n, C.tIsBit -&gt; True)))</span>
<span class="lineno">  495 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc env n</span>
<span class="lineno">  496 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PLogicSeqBool&quot; [n']</span>
<span class="lineno">  497 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Logic a) =&gt; Logic [n]a</span>
<span class="lineno">  498 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLogic -&gt; Just (C.tIsSeq -&gt; Just (n, a)))</span>
<span class="lineno">  499 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc env n</span>
<span class="lineno">  500 </span><span class="spaces">                </span><span class="istickedoff">a' &lt;- importType sc <span class="nottickedoff">env</span> a</span>
<span class="lineno">  501 </span><span class="spaces">                </span><span class="istickedoff">pa &lt;- provePropRec sc env <span class="nottickedoff">prop0</span> (C.pLogic a)</span>
<span class="lineno">  502 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PLogicSeq&quot; [n', a', pa]</span>
<span class="lineno">  503 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Logic b) =&gt; Logic (a -&gt; b)</span>
<span class="lineno">  504 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLogic -&gt; Just (C.tIsFun -&gt; Just (a, b)))</span>
<span class="lineno">  505 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do a' &lt;- importType sc env a</span></span>
<span class="lineno">  506 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">b' &lt;- importType sc env b</span></span>
<span class="lineno">  507 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">pb &lt;- provePropRec sc env prop0 (C.pLogic b)</span></span>
<span class="lineno">  508 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PLogicFun&quot; [a', b', pb]</span></span>
<span class="lineno">  509 </span><span class="spaces">        </span><span class="istickedoff">-- instance Logic ()</span>
<span class="lineno">  510 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLogic -&gt; Just (C.tIsTuple -&gt; Just []))</span>
<span class="lineno">  511 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PLogicUnit&quot; []</span></span>
<span class="lineno">  512 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Logic a, Logic b) =&gt; Logic (a, b)</span>
<span class="lineno">  513 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLogic -&gt; Just (C.tIsTuple -&gt; Just [t]))</span>
<span class="lineno">  514 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do provePropRec sc env prop0 (C.pLogic t)</span></span>
<span class="lineno">  515 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLogic -&gt; Just (C.tIsTuple -&gt; Just (t : ts)))</span>
<span class="lineno">  516 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do a &lt;- importType sc env t</span></span>
<span class="lineno">  517 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">b &lt;- importType sc env (C.tTuple ts)</span></span>
<span class="lineno">  518 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">pa &lt;- provePropRec sc env prop0 (C.pLogic t)</span></span>
<span class="lineno">  519 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">pb &lt;- provePropRec sc env prop0 (C.pLogic (C.tTuple ts))</span></span>
<span class="lineno">  520 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PLogicPair&quot; [a, b, pa, pb]</span></span>
<span class="lineno">  521 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Logic a, Logic b, ...) =&gt; instance Logic { x : a, y : b, ... }</span>
<span class="lineno">  522 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLogic -&gt; Just (C.tIsRec -&gt; Just fm))</span>
<span class="lineno">  523 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do provePropRec sc env prop0 (C.pLogic (C.tTuple (map snd (C.canonicalFields fm))))</span></span>
<span class="lineno">  524 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  525 </span><span class="spaces">        </span><span class="istickedoff">-- instance Ring Integer</span>
<span class="lineno">  526 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsRing -&gt; Just (C.tIsInteger -&gt; True))</span>
<span class="lineno">  527 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do scGlobalApply sc &quot;Cryptol.PRingInteger&quot; []</span>
<span class="lineno">  528 </span><span class="spaces">        </span><span class="istickedoff">-- instance Ring (Z n)</span>
<span class="lineno">  529 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsRing -&gt; Just (C.tIsIntMod -&gt; Just n))</span>
<span class="lineno">  530 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc <span class="nottickedoff">env</span> n</span>
<span class="lineno">  531 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PRingIntModNum&quot; [n']</span>
<span class="lineno">  532 </span><span class="spaces">        </span><span class="istickedoff">-- instance Ring Rational</span>
<span class="lineno">  533 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsRing -&gt; Just (C.tIsRational -&gt; True))</span>
<span class="lineno">  534 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PRingRational&quot; []</span></span>
<span class="lineno">  535 </span><span class="spaces">        </span><span class="istickedoff">-- instance (fin n) =&gt; Ring [n]</span>
<span class="lineno">  536 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsRing -&gt; Just (C.tIsSeq -&gt; Just (n, C.tIsBit -&gt; True)))</span>
<span class="lineno">  537 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc env n</span>
<span class="lineno">  538 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PRingSeqBool&quot; [n']</span>
<span class="lineno">  539 </span><span class="spaces">        </span><span class="istickedoff">-- instance ValidFloat e p =&gt; Ring (Float e p)</span>
<span class="lineno">  540 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsRing -&gt; Just (C.tIsFloat -&gt; Just (e, p)))</span>
<span class="lineno">  541 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do e' &lt;- importType sc env e</span></span>
<span class="lineno">  542 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">p' &lt;- importType sc env p</span></span>
<span class="lineno">  543 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PRingFloat&quot; [e', p']</span></span>
<span class="lineno">  544 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Ring a) =&gt; Ring [n]a</span>
<span class="lineno">  545 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsRing -&gt; Just (C.tIsSeq -&gt; Just (n, a)))</span>
<span class="lineno">  546 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc env n</span>
<span class="lineno">  547 </span><span class="spaces">                </span><span class="istickedoff">a' &lt;- importType sc env a</span>
<span class="lineno">  548 </span><span class="spaces">                </span><span class="istickedoff">pa &lt;- provePropRec sc env prop0 (C.pRing a)</span>
<span class="lineno">  549 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PRingSeq&quot; [n', a', pa]</span>
<span class="lineno">  550 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Ring b) =&gt; Ring (a -&gt; b)</span>
<span class="lineno">  551 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsRing -&gt; Just (C.tIsFun -&gt; Just (a, b)))</span>
<span class="lineno">  552 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do a' &lt;- importType sc env a</span></span>
<span class="lineno">  553 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">b' &lt;- importType sc env b</span></span>
<span class="lineno">  554 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">pb &lt;- provePropRec sc env prop0 (C.pRing b)</span></span>
<span class="lineno">  555 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PRingFun&quot; [a', b', pb]</span></span>
<span class="lineno">  556 </span><span class="spaces">        </span><span class="istickedoff">-- instance Ring ()</span>
<span class="lineno">  557 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsRing -&gt; Just (C.tIsTuple -&gt; Just []))</span>
<span class="lineno">  558 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PRingUnit&quot; []</span></span>
<span class="lineno">  559 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Ring a, Ring b) =&gt; Ring (a, b)</span>
<span class="lineno">  560 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsRing -&gt; Just (C.tIsTuple -&gt; Just [t]))</span>
<span class="lineno">  561 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do provePropRec sc env prop0 (C.pRing t)</span></span>
<span class="lineno">  562 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsRing -&gt; Just (C.tIsTuple -&gt; Just (t : ts)))</span>
<span class="lineno">  563 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do a &lt;- importType sc env t</span></span>
<span class="lineno">  564 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">b &lt;- importType sc env (C.tTuple ts)</span></span>
<span class="lineno">  565 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">pa &lt;- provePropRec sc env prop0 (C.pRing t)</span></span>
<span class="lineno">  566 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">pb &lt;- provePropRec sc env prop0 (C.pRing (C.tTuple ts))</span></span>
<span class="lineno">  567 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PRingPair&quot; [a, b, pa, pb]</span></span>
<span class="lineno">  568 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Ring a, Ring b, ...) =&gt; instance Ring { x : a, y : b, ... }</span>
<span class="lineno">  569 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsRing -&gt; Just (C.tIsRec -&gt; Just fm))</span>
<span class="lineno">  570 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do provePropRec sc env prop0 (C.pRing (C.tTuple (map snd (C.canonicalFields fm))))</span></span>
<span class="lineno">  571 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  572 </span><span class="spaces">        </span><span class="istickedoff">-- instance Integral Integer</span>
<span class="lineno">  573 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsIntegral -&gt; Just (C.tIsInteger -&gt; True))</span>
<span class="lineno">  574 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do scGlobalApply sc &quot;Cryptol.PIntegralInteger&quot; []</span>
<span class="lineno">  575 </span><span class="spaces">        </span><span class="istickedoff">-- instance Integral [n]</span>
<span class="lineno">  576 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsIntegral -&gt; Just (C.tIsSeq -&gt; (Just (n, C.tIsBit -&gt; True))))</span>
<span class="lineno">  577 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc env n</span>
<span class="lineno">  578 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PIntegralSeqBool&quot; [n']</span>
<span class="lineno">  579 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  580 </span><span class="spaces">        </span><span class="istickedoff">-- instance Field Rational</span>
<span class="lineno">  581 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsField -&gt; Just (C.tIsRational -&gt; True))</span>
<span class="lineno">  582 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PFieldRational&quot; []</span></span>
<span class="lineno">  583 </span><span class="spaces">        </span><span class="istickedoff">-- instance (prime p) =&gt; Field (Z p)</span>
<span class="lineno">  584 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsField -&gt; Just (C.tIsIntMod -&gt; Just n))</span>
<span class="lineno">  585 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do n' &lt;- importType sc env n</span></span>
<span class="lineno">  586 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PFieldIntModNum&quot; [n']</span></span>
<span class="lineno">  587 </span><span class="spaces">        </span><span class="istickedoff">-- instance (ValidFloat e p) =&gt; Field (Float e p)</span>
<span class="lineno">  588 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsField -&gt; Just (C.tIsFloat -&gt; Just (e, p)))</span>
<span class="lineno">  589 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do e' &lt;- importType sc env e</span></span>
<span class="lineno">  590 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">p' &lt;- importType sc env p</span></span>
<span class="lineno">  591 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PFieldFloat&quot; [e', p']</span></span>
<span class="lineno">  592 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  593 </span><span class="spaces">        </span><span class="istickedoff">-- instance Round Rational</span>
<span class="lineno">  594 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsRound -&gt; Just (C.tIsRational -&gt; True))</span>
<span class="lineno">  595 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PRoundRational&quot; []</span></span>
<span class="lineno">  596 </span><span class="spaces">        </span><span class="istickedoff">-- instance (ValidFloat e p) =&gt; Round (Float e p)</span>
<span class="lineno">  597 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsRound -&gt; Just (C.tIsFloat -&gt; Just (e, p)))</span>
<span class="lineno">  598 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do e' &lt;- importType sc env e</span></span>
<span class="lineno">  599 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">p' &lt;- importType sc env p</span></span>
<span class="lineno">  600 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PRoundFloat&quot; [e', p']</span></span>
<span class="lineno">  601 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  602 </span><span class="spaces">        </span><span class="istickedoff">-- instance Eq Bit</span>
<span class="lineno">  603 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsEq -&gt; Just (C.tIsBit -&gt; True))</span>
<span class="lineno">  604 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do scGlobalApply sc &quot;Cryptol.PEqBit&quot; []</span>
<span class="lineno">  605 </span><span class="spaces">        </span><span class="istickedoff">-- instance Eq Integer</span>
<span class="lineno">  606 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsEq -&gt; Just (C.tIsInteger -&gt; True))</span>
<span class="lineno">  607 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do scGlobalApply sc &quot;Cryptol.PEqInteger&quot; []</span>
<span class="lineno">  608 </span><span class="spaces">        </span><span class="istickedoff">-- instance Eq (Z n)</span>
<span class="lineno">  609 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsEq -&gt; Just (C.tIsIntMod -&gt; Just n))</span>
<span class="lineno">  610 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc <span class="nottickedoff">env</span> n</span>
<span class="lineno">  611 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PEqIntModNum&quot; [n']</span>
<span class="lineno">  612 </span><span class="spaces">        </span><span class="istickedoff">-- instance Eq Rational</span>
<span class="lineno">  613 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsEq -&gt; Just (C.tIsRational -&gt; True))</span>
<span class="lineno">  614 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PEqRational&quot; []</span></span>
<span class="lineno">  615 </span><span class="spaces">        </span><span class="istickedoff">-- instance Eq (Float e p)</span>
<span class="lineno">  616 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsEq -&gt; Just (C.tIsFloat -&gt; Just (e, p)))</span>
<span class="lineno">  617 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do e' &lt;- importType sc env e</span></span>
<span class="lineno">  618 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">p' &lt;- importType sc env p</span></span>
<span class="lineno">  619 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PEqFloat&quot; [e', p']</span></span>
<span class="lineno">  620 </span><span class="spaces">        </span><span class="istickedoff">-- instance (fin n) =&gt; Eq [n]</span>
<span class="lineno">  621 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsEq -&gt; Just (C.tIsSeq -&gt; Just (n, C.tIsBit -&gt; True)))</span>
<span class="lineno">  622 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc env n</span>
<span class="lineno">  623 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PEqSeqBool&quot; [n']</span>
<span class="lineno">  624 </span><span class="spaces">        </span><span class="istickedoff">-- instance (fin n, Eq a) =&gt; Eq [n]a</span>
<span class="lineno">  625 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsEq -&gt; Just (C.tIsSeq -&gt; Just (n, a)))</span>
<span class="lineno">  626 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc <span class="nottickedoff">env</span> n</span>
<span class="lineno">  627 </span><span class="spaces">                </span><span class="istickedoff">a' &lt;- importType sc <span class="nottickedoff">env</span> a</span>
<span class="lineno">  628 </span><span class="spaces">                </span><span class="istickedoff">pa &lt;- provePropRec sc env <span class="nottickedoff">prop0</span> (C.pEq a)</span>
<span class="lineno">  629 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PEqSeq&quot; [n', a', pa]</span>
<span class="lineno">  630 </span><span class="spaces">        </span><span class="istickedoff">-- instance Eq ()</span>
<span class="lineno">  631 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsEq -&gt; Just (C.tIsTuple -&gt; Just []))</span>
<span class="lineno">  632 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do scGlobalApply sc &quot;Cryptol.PEqUnit&quot; []</span>
<span class="lineno">  633 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Eq a, Eq b) =&gt; Eq (a, b)</span>
<span class="lineno">  634 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsEq -&gt; Just (C.tIsTuple -&gt; Just [t]))</span>
<span class="lineno">  635 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do provePropRec sc env <span class="nottickedoff">prop0</span> (C.pEq t)</span>
<span class="lineno">  636 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsEq -&gt; Just (C.tIsTuple -&gt; Just (t : ts)))</span>
<span class="lineno">  637 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do a &lt;- importType sc <span class="nottickedoff">env</span> t</span>
<span class="lineno">  638 </span><span class="spaces">                </span><span class="istickedoff">b &lt;- importType sc <span class="nottickedoff">env</span> (C.tTuple ts)</span>
<span class="lineno">  639 </span><span class="spaces">                </span><span class="istickedoff">pa &lt;- provePropRec sc env <span class="nottickedoff">prop0</span> (C.pEq t)</span>
<span class="lineno">  640 </span><span class="spaces">                </span><span class="istickedoff">pb &lt;- provePropRec sc env <span class="nottickedoff">prop0</span> (C.pEq (C.tTuple ts))</span>
<span class="lineno">  641 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PEqPair&quot; [a, b, pa, pb]</span>
<span class="lineno">  642 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Eq a, Eq b, ...) =&gt; instance Eq { x : a, y : b, ... }</span>
<span class="lineno">  643 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsEq -&gt; Just (C.tIsRec -&gt; Just fm))</span>
<span class="lineno">  644 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do provePropRec sc env <span class="nottickedoff">prop0</span> (C.pEq (C.tTuple (map snd (C.canonicalFields fm))))</span>
<span class="lineno">  645 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  646 </span><span class="spaces">        </span><span class="istickedoff">-- instance Cmp Bit</span>
<span class="lineno">  647 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsCmp -&gt; Just (C.tIsBit -&gt; True))</span>
<span class="lineno">  648 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PCmpBit&quot; []</span></span>
<span class="lineno">  649 </span><span class="spaces">        </span><span class="istickedoff">-- instance Cmp Integer</span>
<span class="lineno">  650 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsCmp -&gt; Just (C.tIsInteger -&gt; True))</span>
<span class="lineno">  651 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do scGlobalApply sc &quot;Cryptol.PCmpInteger&quot; []</span>
<span class="lineno">  652 </span><span class="spaces">        </span><span class="istickedoff">-- instance Cmp Rational</span>
<span class="lineno">  653 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsCmp -&gt; Just (C.tIsRational -&gt; True))</span>
<span class="lineno">  654 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PCmpRational&quot; []</span></span>
<span class="lineno">  655 </span><span class="spaces">        </span><span class="istickedoff">-- instance Cmp (Float e p)</span>
<span class="lineno">  656 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsCmp -&gt; Just (C.tIsFloat -&gt; Just (e, p)))</span>
<span class="lineno">  657 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do e' &lt;- importType sc env e</span></span>
<span class="lineno">  658 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">p' &lt;- importType sc env p</span></span>
<span class="lineno">  659 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PCmpFloat&quot; [e', p']</span></span>
<span class="lineno">  660 </span><span class="spaces">        </span><span class="istickedoff">-- instance (fin n) =&gt; Cmp [n]</span>
<span class="lineno">  661 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsCmp -&gt; Just (C.tIsSeq -&gt; Just (n, C.tIsBit -&gt; True)))</span>
<span class="lineno">  662 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc env n</span>
<span class="lineno">  663 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PCmpSeqBool&quot; [n']</span>
<span class="lineno">  664 </span><span class="spaces">        </span><span class="istickedoff">-- instance (fin n, Cmp a) =&gt; Cmp [n]a</span>
<span class="lineno">  665 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsCmp -&gt; Just (C.tIsSeq -&gt; Just (n, a)))</span>
<span class="lineno">  666 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do n' &lt;- importType sc env n</span></span>
<span class="lineno">  667 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">a' &lt;- importType sc env a</span></span>
<span class="lineno">  668 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">pa &lt;- provePropRec sc env prop0 (C.pCmp a)</span></span>
<span class="lineno">  669 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PCmpSeq&quot; [n', a', pa]</span></span>
<span class="lineno">  670 </span><span class="spaces">        </span><span class="istickedoff">-- instance Cmp ()</span>
<span class="lineno">  671 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsCmp -&gt; Just (C.tIsTuple -&gt; Just []))</span>
<span class="lineno">  672 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PCmpUnit&quot; []</span></span>
<span class="lineno">  673 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Cmp a, Cmp b) =&gt; Cmp (a, b)</span>
<span class="lineno">  674 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsCmp -&gt; Just (C.tIsTuple -&gt; Just [t]))</span>
<span class="lineno">  675 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do provePropRec sc env prop0 (C.pCmp t)</span></span>
<span class="lineno">  676 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsCmp -&gt; Just (C.tIsTuple -&gt; Just (t : ts)))</span>
<span class="lineno">  677 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do a &lt;- importType sc env t</span></span>
<span class="lineno">  678 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">b &lt;- importType sc env (C.tTuple ts)</span></span>
<span class="lineno">  679 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">pa &lt;- provePropRec sc env prop0 (C.pCmp t)</span></span>
<span class="lineno">  680 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">pb &lt;- provePropRec sc env prop0 (C.pCmp (C.tTuple ts))</span></span>
<span class="lineno">  681 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PCmpPair&quot; [a, b, pa, pb]</span></span>
<span class="lineno">  682 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Cmp a, Cmp b, ...) =&gt; instance Cmp { x : a, y : b, ... }</span>
<span class="lineno">  683 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsCmp -&gt; Just (C.tIsRec -&gt; Just fm))</span>
<span class="lineno">  684 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do provePropRec sc env prop0 (C.pCmp (C.tTuple (map snd (C.canonicalFields fm))))</span></span>
<span class="lineno">  685 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  686 </span><span class="spaces">        </span><span class="istickedoff">-- instance (fin n) =&gt; SignedCmp [n]</span>
<span class="lineno">  687 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsSignedCmp -&gt; Just (C.tIsSeq -&gt; Just (n, C.tIsBit -&gt; True)))</span>
<span class="lineno">  688 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc env n</span>
<span class="lineno">  689 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PSignedCmpSeqBool&quot; [n']</span>
<span class="lineno">  690 </span><span class="spaces">        </span><span class="istickedoff">-- instance (fin n, SignedCmp a) =&gt; SignedCmp [n]a</span>
<span class="lineno">  691 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsSignedCmp -&gt; Just (C.tIsSeq -&gt; Just (n, a)))</span>
<span class="lineno">  692 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do n' &lt;- importType sc env n</span></span>
<span class="lineno">  693 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">a' &lt;- importType sc env a</span></span>
<span class="lineno">  694 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">pa &lt;- provePropRec sc env prop0 (C.pSignedCmp a)</span></span>
<span class="lineno">  695 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PSignedCmpSeq&quot; [n', a', pa]</span></span>
<span class="lineno">  696 </span><span class="spaces">        </span><span class="istickedoff">-- instance SignedCmp ()</span>
<span class="lineno">  697 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsSignedCmp -&gt; Just (C.tIsTuple -&gt; Just []))</span>
<span class="lineno">  698 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PSignedCmpUnit&quot; []</span></span>
<span class="lineno">  699 </span><span class="spaces">        </span><span class="istickedoff">-- instance (SignedCmp a, SignedCmp b) =&gt; SignedCmp (a, b)</span>
<span class="lineno">  700 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsSignedCmp -&gt; Just (C.tIsTuple -&gt; Just [t]))</span>
<span class="lineno">  701 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do provePropRec sc env prop0 (C.pSignedCmp t)</span></span>
<span class="lineno">  702 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsSignedCmp -&gt; Just (C.tIsTuple -&gt; Just (t : ts)))</span>
<span class="lineno">  703 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do a &lt;- importType sc env t</span></span>
<span class="lineno">  704 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">b &lt;- importType sc env (C.tTuple ts)</span></span>
<span class="lineno">  705 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">pa &lt;- provePropRec sc env prop0 (C.pSignedCmp t)</span></span>
<span class="lineno">  706 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">pb &lt;- provePropRec sc env prop0 (C.pSignedCmp (C.tTuple ts))</span></span>
<span class="lineno">  707 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PSignedCmpPair&quot; [a, b, pa, pb]</span></span>
<span class="lineno">  708 </span><span class="spaces">        </span><span class="istickedoff">-- instance (SignedCmp a, SignedCmp b, ...) =&gt; instance SignedCmp { x : a, y : b, ... }</span>
<span class="lineno">  709 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsSignedCmp -&gt; Just (C.tIsRec -&gt; Just fm))</span>
<span class="lineno">  710 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do provePropRec sc env prop0 (C.pSignedCmp (C.tTuple (map snd (C.canonicalFields fm))))</span></span>
<span class="lineno">  711 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  712 </span><span class="spaces">        </span><span class="istickedoff">-- instance Literal val Bit</span>
<span class="lineno">  713 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLiteral -&gt; Just (_, C.tIsBit -&gt; True))</span>
<span class="lineno">  714 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do scGlobalApply sc &quot;Cryptol.PLiteralBit&quot; []</span>
<span class="lineno">  715 </span><span class="spaces">        </span><span class="istickedoff">-- instance Literal val Integer</span>
<span class="lineno">  716 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLiteral -&gt; Just (_, C.tIsInteger -&gt; True))</span>
<span class="lineno">  717 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do scGlobalApply sc &quot;Cryptol.PLiteralInteger&quot; []</span>
<span class="lineno">  718 </span><span class="spaces">        </span><span class="istickedoff">-- instance Literal val (Z n)</span>
<span class="lineno">  719 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLiteral -&gt; Just (_, C.tIsIntMod -&gt; Just n))</span>
<span class="lineno">  720 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc <span class="nottickedoff">env</span> n</span>
<span class="lineno">  721 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PLiteralIntModNum&quot; [n']</span>
<span class="lineno">  722 </span><span class="spaces">        </span><span class="istickedoff">-- instance Literal val Rational</span>
<span class="lineno">  723 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLiteral -&gt; Just (_, C.tIsRational -&gt; True))</span>
<span class="lineno">  724 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PLiteralRational&quot; []</span></span>
<span class="lineno">  725 </span><span class="spaces">        </span><span class="istickedoff">-- instance (fin n, n &gt;= width val) =&gt; Literal val [n]</span>
<span class="lineno">  726 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLiteral -&gt; Just (_, C.tIsSeq -&gt; Just (n, C.tIsBit -&gt; True)))</span>
<span class="lineno">  727 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc env n</span>
<span class="lineno">  728 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PLiteralSeqBool&quot; [n']</span>
<span class="lineno">  729 </span><span class="spaces">        </span><span class="istickedoff">-- instance ValidFloat e p =&gt; Literal val (Float e p) (with extra constraints)</span>
<span class="lineno">  730 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLiteral -&gt; Just (_, C.tIsFloat -&gt; Just (e, p)))</span>
<span class="lineno">  731 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do e' &lt;- importType sc env e</span></span>
<span class="lineno">  732 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">p' &lt;- importType sc env p</span></span>
<span class="lineno">  733 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PLiteralFloat&quot; [e', p']</span></span>
<span class="lineno">  734 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  735 </span><span class="spaces">        </span><span class="istickedoff">-- instance (2 &gt;= val) =&gt; LiteralLessThan val Bit</span>
<span class="lineno">  736 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLiteralLessThan -&gt; Just (_, C.tIsBit -&gt; True))</span>
<span class="lineno">  737 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PLiteralBit&quot; []</span></span>
<span class="lineno">  738 </span><span class="spaces">        </span><span class="istickedoff">-- instance LiteralLessThan val Integer</span>
<span class="lineno">  739 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLiteralLessThan -&gt; Just (_, C.tIsInteger -&gt; True))</span>
<span class="lineno">  740 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PLiteralInteger&quot; []</span></span>
<span class="lineno">  741 </span><span class="spaces">        </span><span class="istickedoff">-- instance (fin n, n &gt;= 1, n &gt;= val) LiteralLessThan val (Z n)</span>
<span class="lineno">  742 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLiteralLessThan -&gt; Just (_, C.tIsIntMod -&gt; Just n))</span>
<span class="lineno">  743 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do n' &lt;- importType sc env n</span></span>
<span class="lineno">  744 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PLiteralIntModNum&quot; [n']</span></span>
<span class="lineno">  745 </span><span class="spaces">        </span><span class="istickedoff">-- instance Literal val Rational</span>
<span class="lineno">  746 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLiteralLessThan -&gt; Just (_, C.tIsRational -&gt; True))</span>
<span class="lineno">  747 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PLiteralRational&quot; []</span></span>
<span class="lineno">  748 </span><span class="spaces">        </span><span class="istickedoff">-- instance (fin n, n &gt;= lg2 val) =&gt; Literal val [n]</span>
<span class="lineno">  749 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLiteralLessThan -&gt; Just (_, C.tIsSeq -&gt; Just (n, C.tIsBit -&gt; True)))</span>
<span class="lineno">  750 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc <span class="nottickedoff">env</span> n</span>
<span class="lineno">  751 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PLiteralSeqBool&quot; [n']</span>
<span class="lineno">  752 </span><span class="spaces">        </span><span class="istickedoff">-- instance ValidFloat e p =&gt; Literal val (Float e p) (with extra constraints)</span>
<span class="lineno">  753 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLiteralLessThan -&gt; Just (_, C.tIsFloat -&gt; Just (e, p)))</span>
<span class="lineno">  754 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do e' &lt;- importType sc env e</span></span>
<span class="lineno">  755 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">p' &lt;- importType sc env p</span></span>
<span class="lineno">  756 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PLiteralFloat&quot; [e', p']</span></span>
<span class="lineno">  757 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  758 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; do</span>
<span class="lineno">  759 </span><span class="spaces">            </span><span class="istickedoff">let prop0' = &quot;   &quot; ++ pretty prop0</span>
<span class="lineno">  760 </span><span class="spaces">                </span><span class="istickedoff">prop' = &quot;   &quot; ++ pretty prop</span>
<span class="lineno">  761 </span><span class="spaces">                </span><span class="istickedoff">env' = map (\p -&gt; &quot;   &quot; ++ pretty p) $ Map.keys $ envP env</span>
<span class="lineno">  762 </span><span class="spaces">                </span><span class="istickedoff">message = [</span>
<span class="lineno">  763 </span><span class="spaces">                    </span><span class="istickedoff">&quot;Cannot find or infer typeclass instance&quot;,</span>
<span class="lineno">  764 </span><span class="spaces">                    </span><span class="istickedoff">&quot;Property needed:&quot;,</span>
<span class="lineno">  765 </span><span class="spaces">                    </span><span class="istickedoff">prop',</span>
<span class="lineno">  766 </span><span class="spaces">                    </span><span class="istickedoff">&quot;Original property:&quot;,</span>
<span class="lineno">  767 </span><span class="spaces">                    </span><span class="istickedoff">prop0',</span>
<span class="lineno">  768 </span><span class="spaces">                    </span><span class="istickedoff">&quot;Available propositions in the environment:&quot;</span>
<span class="lineno">  769 </span><span class="spaces">                 </span><span class="istickedoff">] ++ env'</span>
<span class="lineno">  770 </span><span class="spaces">            </span><span class="istickedoff">panic &quot;proveProp&quot; message</span></span>
<span class="lineno">  771 </span>
<span class="lineno">  772 </span>importPrimitive :: SharedContext -&gt; ImportPrimitiveOptions -&gt; Env -&gt; C.Name -&gt; C.Schema -&gt; IO Term
<span class="lineno">  773 </span><span class="decl"><span class="istickedoff">importPrimitive sc primOpts env n sch</span>
<span class="lineno">  774 </span><span class="spaces">  </span><span class="istickedoff">-- lookup primitive in the main primitive lookup table</span>
<span class="lineno">  775 </span><span class="spaces">  </span><span class="istickedoff">| Just nm &lt;- C.asPrim n, Just term &lt;- Map.lookup nm allPrims = term sc</span>
<span class="lineno">  776 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  777 </span><span class="spaces">  </span><span class="istickedoff">-- lookup primitive in the main reference implementation lookup table</span>
<span class="lineno">  778 </span><span class="spaces">  </span><span class="istickedoff">| Just nm &lt;- C.asPrim n, Just expr &lt;- Map.lookup nm (envRefPrims env) =</span>
<span class="lineno">  779 </span><span class="spaces">      </span><span class="istickedoff">do t &lt;- importSchema sc env sch</span>
<span class="lineno">  780 </span><span class="spaces">         </span><span class="istickedoff">e &lt;- importExpr sc env expr</span>
<span class="lineno">  781 </span><span class="spaces">         </span><span class="istickedoff">nmi &lt;- importName n</span>
<span class="lineno">  782 </span><span class="spaces">         </span><span class="istickedoff">scConstant' sc nmi e t</span>
<span class="lineno">  783 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  784 </span><span class="spaces">  </span><span class="istickedoff">-- lookup primitive in the extra primitive lookup table</span>
<span class="lineno">  785 </span><span class="spaces">  </span><span class="istickedoff">| Just nm &lt;- <span class="nottickedoff">C.asPrim n</span>, Just t &lt;- <span class="nottickedoff">Map.lookup nm (envPrims env)</span> = <span class="nottickedoff">return t</span></span>
<span class="lineno">  786 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  787 </span><span class="spaces">  </span><span class="istickedoff">-- Optionally, create an opaque constant representing the primitive</span>
<span class="lineno">  788 </span><span class="spaces">  </span><span class="istickedoff">-- if it doesn't match one of the ones we know about.</span>
<span class="lineno">  789 </span><span class="spaces">  </span><span class="istickedoff">| Just _ &lt;- <span class="nottickedoff">C.asPrim n</span>, <span class="nottickedoff">allowUnknownPrimitives primOpts</span> =</span>
<span class="lineno">  790 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">importOpaque sc env n sch</span></span>
<span class="lineno">  791 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  792 </span><span class="spaces">  </span><span class="istickedoff">-- Panic if we don't know the given primitive (TODO? probably shouldn't be a panic)</span>
<span class="lineno">  793 </span><span class="spaces">  </span><span class="istickedoff">| Just nm &lt;- <span class="nottickedoff">C.asPrim n</span> = <span class="nottickedoff">panic &quot;Unknown Cryptol primitive name&quot; [show nm]</span></span>
<span class="lineno">  794 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  795 </span><span class="spaces">  </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> = <span class="nottickedoff">panic &quot;Improper Cryptol primitive name&quot; [show n]</span></span></span>
<span class="lineno">  796 </span>
<span class="lineno">  797 </span>-- | Create an opaque constant with the given name and schema
<span class="lineno">  798 </span>importOpaque :: SharedContext -&gt; Env -&gt; C.Name -&gt; C.Schema -&gt; IO Term
<span class="lineno">  799 </span><span class="decl"><span class="istickedoff">importOpaque sc env n sch = do</span>
<span class="lineno">  800 </span><span class="spaces">  </span><span class="istickedoff">t &lt;- importSchema sc <span class="nottickedoff">env</span> sch</span>
<span class="lineno">  801 </span><span class="spaces">  </span><span class="istickedoff">nmi &lt;- importName n</span>
<span class="lineno">  802 </span><span class="spaces">  </span><span class="istickedoff">scOpaqueConstant sc nmi t</span></span>
<span class="lineno">  803 </span>
<span class="lineno">  804 </span>importConstant :: SharedContext -&gt; Env -&gt; C.Name -&gt; C.Schema -&gt; Term -&gt; IO Term
<span class="lineno">  805 </span><span class="decl"><span class="istickedoff">importConstant sc env n sch rhs = do</span>
<span class="lineno">  806 </span><span class="spaces">  </span><span class="istickedoff">nmi &lt;- importName n</span>
<span class="lineno">  807 </span><span class="spaces">  </span><span class="istickedoff">t &lt;- importSchema sc env sch</span>
<span class="lineno">  808 </span><span class="spaces">  </span><span class="istickedoff">scConstant' sc nmi rhs t</span></span>
<span class="lineno">  809 </span>
<span class="lineno">  810 </span>allPrims :: Map C.PrimIdent (SharedContext -&gt; IO Term)
<span class="lineno">  811 </span><span class="decl"><span class="istickedoff">allPrims = prelPrims &lt;&gt; arrayPrims &lt;&gt; floatPrims &lt;&gt; suiteBPrims &lt;&gt; primeECPrims</span></span>
<span class="lineno">  812 </span>
<span class="lineno">  813 </span>prelPrims :: Map C.PrimIdent (SharedContext -&gt; IO Term)
<span class="lineno">  814 </span><span class="decl"><span class="istickedoff">prelPrims =</span>
<span class="lineno">  815 </span><span class="spaces">  </span><span class="istickedoff">Map.fromList $</span>
<span class="lineno">  816 </span><span class="spaces">  </span><span class="istickedoff">first C.prelPrim &lt;$&gt;</span>
<span class="lineno">  817 </span><span class="spaces">  </span><span class="istickedoff">[ (&quot;True&quot;,         flip scBool True)</span>
<span class="lineno">  818 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;False&quot;,        flip scBool False)</span>
<span class="lineno">  819 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;number&quot;,       flip scGlobalDef &quot;Cryptol.ecNumber&quot;)      -- Converts a numeric type into its corresponding value.</span>
<span class="lineno">  820 </span><span class="spaces">     </span><span class="istickedoff">--                                                        -- {val, a} (Literal val a) =&gt; a</span>
<span class="lineno">  821 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  822 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fromZ&quot;,        flip scGlobalDef &quot;Cryptol.ecFromZ&quot;)       -- {n} (fin n, n &gt;= 1) =&gt; Z n -&gt; Integer</span>
<span class="lineno">  823 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  824 </span><span class="spaces">    </span><span class="istickedoff">-- -- Zero</span>
<span class="lineno">  825 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;zero&quot;,         flip scGlobalDef &quot;Cryptol.ecZero&quot;)        -- {a} (Zero a) =&gt; a</span>
<span class="lineno">  826 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  827 </span><span class="spaces">    </span><span class="istickedoff">-- -- Logic</span>
<span class="lineno">  828 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;&amp;&amp;&quot;,           flip scGlobalDef &quot;Cryptol.ecAnd&quot;)         -- {a} (Logic a) =&gt; a -&gt; a -&gt; a</span>
<span class="lineno">  829 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;||&quot;,           flip scGlobalDef &quot;Cryptol.ecOr&quot;)          -- {a} (Logic a) =&gt; a -&gt; a -&gt; a</span>
<span class="lineno">  830 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;^&quot;,            flip scGlobalDef &quot;Cryptol.ecXor&quot;)         -- {a} (Logic a) =&gt; a -&gt; a -&gt; a</span>
<span class="lineno">  831 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;complement&quot;,   flip scGlobalDef &quot;Cryptol.ecCompl&quot;)       -- {a} (Logic a) =&gt; a -&gt; a</span>
<span class="lineno">  832 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  833 </span><span class="spaces">    </span><span class="istickedoff">-- -- Ring</span>
<span class="lineno">  834 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fromInteger&quot;,  flip scGlobalDef &quot;Cryptol.ecFromInteger&quot;) -- {a} (Ring a) =&gt; Integer -&gt; a</span>
<span class="lineno">  835 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;+&quot;,            flip scGlobalDef &quot;Cryptol.ecPlus&quot;)        -- {a} (Ring a) =&gt; a -&gt; a -&gt; a</span>
<span class="lineno">  836 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;-&quot;,            flip scGlobalDef &quot;Cryptol.ecMinus&quot;)       -- {a} (Ring a) =&gt; a -&gt; a -&gt; a</span>
<span class="lineno">  837 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;*&quot;,            flip scGlobalDef &quot;Cryptol.ecMul&quot;)         -- {a} (Ring a) =&gt; a -&gt; a -&gt; a</span>
<span class="lineno">  838 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;negate&quot;,       flip scGlobalDef &quot;Cryptol.ecNeg&quot;)         -- {a} (Ring a) =&gt; a -&gt; a</span>
<span class="lineno">  839 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  840 </span><span class="spaces">    </span><span class="istickedoff">-- -- Integral</span>
<span class="lineno">  841 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;toInteger&quot;,    flip scGlobalDef &quot;Cryptol.ecToInteger&quot;)   -- {a} (Integral a) =&gt; a -&gt; Integer</span>
<span class="lineno">  842 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;/&quot;,            flip scGlobalDef &quot;Cryptol.ecDiv&quot;)         -- {a} (Integral a) =&gt; a -&gt; a -&gt; a</span>
<span class="lineno">  843 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;%&quot;,            flip scGlobalDef &quot;Cryptol.ecMod&quot;)         -- {a} (Integral a) =&gt; a -&gt; a -&gt; a</span>
<span class="lineno">  844 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;^^&quot;,           flip scGlobalDef &quot;Cryptol.ecExp&quot;)         -- {a} (Ring a, Integral b) =&gt; a -&gt; b -&gt; a</span>
<span class="lineno">  845 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;infFrom&quot;,      flip scGlobalDef &quot;Cryptol.ecInfFrom&quot;)     -- {a} (Integral a) =&gt; a -&gt; [inf]a</span>
<span class="lineno">  846 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;infFromThen&quot;,  flip scGlobalDef &quot;Cryptol.ecInfFromThen&quot;) -- {a} (Integral a) =&gt; a -&gt; a -&gt; [inf]a</span>
<span class="lineno">  847 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  848 </span><span class="spaces">    </span><span class="istickedoff">-- -- Field</span>
<span class="lineno">  849 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;recip&quot;,        flip scGlobalDef &quot;Cryptol.ecRecip&quot;)       -- {a} (Field a) =&gt; a -&gt; a</span>
<span class="lineno">  850 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;/.&quot;,           flip scGlobalDef &quot;Cryptol.ecFieldDiv&quot;)    -- {a} (Field a) =&gt; a -&gt; a -&gt; a</span>
<span class="lineno">  851 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  852 </span><span class="spaces">    </span><span class="istickedoff">-- -- Round</span>
<span class="lineno">  853 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;ceiling&quot;,      flip scGlobalDef &quot;Cryptol.ecCeiling&quot;)     -- {a} (Round a) =&gt; a -&gt; Integer</span>
<span class="lineno">  854 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;floor&quot;,        flip scGlobalDef &quot;Cryptol.ecFloor&quot;)       -- {a} (Round a) =&gt; a -&gt; Integer</span>
<span class="lineno">  855 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;trunc&quot;,        flip scGlobalDef &quot;Cryptol.ecTruncate&quot;)    -- {a} (Round a) =&gt; a -&gt; Integer</span>
<span class="lineno">  856 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;roundAway&quot;,    flip scGlobalDef &quot;Cryptol.ecRoundAway&quot;)   -- {a} (Round a) =&gt; a -&gt; Integer</span>
<span class="lineno">  857 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;roundToEven&quot;,  flip scGlobalDef &quot;Cryptol.ecRoundToEven&quot;) -- {a} (Round a) =&gt; a -&gt; Integer</span>
<span class="lineno">  858 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  859 </span><span class="spaces">    </span><span class="istickedoff">-- -- Eq</span>
<span class="lineno">  860 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;==&quot;,           flip scGlobalDef &quot;Cryptol.ecEq&quot;)          -- {a} (Eq a) =&gt; a -&gt; a -&gt; Bit</span>
<span class="lineno">  861 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;!=&quot;,           flip scGlobalDef &quot;Cryptol.ecNotEq&quot;)       -- {a} (Eq a) =&gt; a -&gt; a -&gt; Bit</span>
<span class="lineno">  862 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  863 </span><span class="spaces">    </span><span class="istickedoff">-- -- Cmp</span>
<span class="lineno">  864 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;&lt;&quot;,            flip scGlobalDef &quot;Cryptol.ecLt&quot;)          -- {a} (Cmp a) =&gt; a -&gt; a -&gt; Bit</span>
<span class="lineno">  865 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;&gt;&quot;,            flip scGlobalDef &quot;Cryptol.ecGt&quot;)          -- {a} (Cmp a) =&gt; a -&gt; a -&gt; Bit</span>
<span class="lineno">  866 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;&lt;=&quot;,           flip scGlobalDef &quot;Cryptol.ecLtEq&quot;)        -- {a} (Cmp a) =&gt; a -&gt; a -&gt; Bit</span>
<span class="lineno">  867 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;&gt;=&quot;,           flip scGlobalDef &quot;Cryptol.ecGtEq&quot;)        -- {a} (Cmp a) =&gt; a -&gt; a -&gt; Bit</span>
<span class="lineno">  868 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  869 </span><span class="spaces">    </span><span class="istickedoff">-- -- SignedCmp</span>
<span class="lineno">  870 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;&lt;$&quot;,           flip scGlobalDef &quot;Cryptol.ecSLt&quot;)         -- {a} (SignedCmp a) =&gt; a -&gt; a -&gt; Bit</span>
<span class="lineno">  871 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  872 </span><span class="spaces">    </span><span class="istickedoff">-- -- Bitvector primitives</span>
<span class="lineno">  873 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;/$&quot;,           flip scGlobalDef &quot;Cryptol.ecSDiv&quot;)        -- {n} (fin n, n&gt;=1) =&gt; [n] -&gt; [n] -&gt; [n]</span>
<span class="lineno">  874 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;%$&quot;,           flip scGlobalDef &quot;Cryptol.ecSMod&quot;)        -- {n} (fin n, n&gt;=1) =&gt; [n] -&gt; [n] -&gt; [n]</span>
<span class="lineno">  875 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;lg2&quot;,          flip scGlobalDef &quot;Cryptol.ecLg2&quot;)         -- {n} (fin n) =&gt; [n] -&gt; [n]</span>
<span class="lineno">  876 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;&gt;&gt;$&quot;,          flip scGlobalDef &quot;Cryptol.ecSShiftR&quot;)     -- {n, ix} (fin n, n &gt;= 1, Integral ix) =&gt; [n] -&gt; ix -&gt; [n]</span>
<span class="lineno">  877 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;toSignedInteger&quot;,</span>
<span class="lineno">  878 </span><span class="spaces">                     </span><span class="istickedoff">flip scGlobalDef &quot;Cryptol.toSignedInteger&quot;) -- {n} (fin n, n &gt;= 1) =&gt; [n] -&gt; Integer</span>
<span class="lineno">  879 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  880 </span><span class="spaces">    </span><span class="istickedoff">-- -- Rational primitives</span>
<span class="lineno">  881 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;ratio&quot;,        flip scGlobalDef &quot;Cryptol.ecRatio&quot;)       -- Integer -&gt; Integer -&gt; Rational</span>
<span class="lineno">  882 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  883 </span><span class="spaces">    </span><span class="istickedoff">-- -- FLiteral</span>
<span class="lineno">  884 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fraction&quot;,     flip scGlobalDef &quot;Cryptol.ecFraction&quot;)    -- {m, n, r, a} FLiteral m n r a =&gt; a</span>
<span class="lineno">  885 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  886 </span><span class="spaces">    </span><span class="istickedoff">-- -- Shifts/rotates</span>
<span class="lineno">  887 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;&lt;&lt;&quot;,           flip scGlobalDef &quot;Cryptol.ecShiftL&quot;)      -- {n, ix, a} (Integral ix, Zero a) =&gt; [n]a -&gt; ix -&gt; [n]a</span>
<span class="lineno">  888 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;&gt;&gt;&quot;,           flip scGlobalDef &quot;Cryptol.ecShiftR&quot;)      -- {n, ix, a} (Integral ix, Zero a) =&gt; [n]a -&gt; ix -&gt; [n]a</span>
<span class="lineno">  889 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;&lt;&lt;&lt;&quot;,          flip scGlobalDef &quot;Cryptol.ecRotL&quot;)        -- {n, ix, a} (fin n, Integral ix) =&gt; [n]a -&gt; ix -&gt; [n]a</span>
<span class="lineno">  890 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;&gt;&gt;&gt;&quot;,          flip scGlobalDef &quot;Cryptol.ecRotR&quot;)        -- {n, ix, a} (fin n, Integral ix) =&gt; [n]a -&gt; ix -&gt; [n]a</span>
<span class="lineno">  891 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  892 </span><span class="spaces">    </span><span class="istickedoff">-- -- Sequences primitives</span>
<span class="lineno">  893 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;#&quot;,            flip scGlobalDef &quot;Cryptol.ecCat&quot;)         -- {a,b,d} (fin a) =&gt; [a] d -&gt; [b] d -&gt; [a + b] d</span>
<span class="lineno">  894 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;take&quot;,         flip scGlobalDef &quot;Cryptol.ecTake&quot;)        -- {front, back, a} [front + back]a -&gt; [front]a</span>
<span class="lineno">  895 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;drop&quot;,         flip scGlobalDef &quot;Cryptol.ecDrop&quot;)        -- {front, back, a} (fin front) =&gt; [front + back]a -&gt; [back]a</span>
<span class="lineno">  896 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;join&quot;,         flip scGlobalDef &quot;Cryptol.ecJoin&quot;)        -- {a,b,c} (fin b) =&gt; [a][b]c -&gt; [a * b]c</span>
<span class="lineno">  897 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;split&quot;,        flip scGlobalDef &quot;Cryptol.ecSplit&quot;)       -- {a,b,c} (fin b) =&gt; [a * b] c -&gt; [a][b] c</span>
<span class="lineno">  898 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;reverse&quot;,      flip scGlobalDef &quot;Cryptol.ecReverse&quot;)     -- {a,b} (fin a) =&gt; [a] b -&gt; [a] b</span>
<span class="lineno">  899 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;transpose&quot;,    flip scGlobalDef &quot;Cryptol.ecTranspose&quot;)   -- {a,b,c} [a][b]c -&gt; [b][a]c</span>
<span class="lineno">  900 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;@&quot;,            flip scGlobalDef &quot;Cryptol.ecAt&quot;)          -- {n, a, ix} (Integral ix) =&gt; [n]a -&gt; ix -&gt; a</span>
<span class="lineno">  901 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;!&quot;,            flip scGlobalDef &quot;Cryptol.ecAtBack&quot;)      -- {n, a, ix} (fin n, Integral ix) =&gt; [n]a -&gt; ix -&gt; a</span>
<span class="lineno">  902 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;update&quot;,       flip scGlobalDef &quot;Cryptol.ecUpdate&quot;)      -- {n, a, ix} (Integral ix) =&gt; [n]a -&gt; ix -&gt; a -&gt; [n]a</span>
<span class="lineno">  903 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;updateEnd&quot;,    flip scGlobalDef &quot;Cryptol.ecUpdateEnd&quot;)   -- {n, a, ix} (fin n, Integral ix) =&gt; [n]a -&gt; ix -&gt; a -&gt; [n]a</span>
<span class="lineno">  904 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  905 </span><span class="spaces">    </span><span class="istickedoff">-- -- Enumerations</span>
<span class="lineno">  906 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fromTo&quot;,         flip scGlobalDef &quot;Cryptol.ecFromTo&quot;)</span>
<span class="lineno">  907 </span><span class="spaces">                                  </span><span class="istickedoff">-- fromTo : {first, last, bits, a}</span>
<span class="lineno">  908 </span><span class="spaces">                                  </span><span class="istickedoff">--           ( fin last, fin bits, last &gt;== first,</span>
<span class="lineno">  909 </span><span class="spaces">                                  </span><span class="istickedoff">--             Literal first a, Literal last a)</span>
<span class="lineno">  910 </span><span class="spaces">                                  </span><span class="istickedoff">--        =&gt; [1 + (last - first)]a</span>
<span class="lineno">  911 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fromToLessThan&quot;, flip scGlobalDef &quot;Cryptol.ecFromToLessThan&quot;)</span>
<span class="lineno">  912 </span><span class="spaces">                                  </span><span class="istickedoff">-- fromToLessThan : {first, bound, a}</span>
<span class="lineno">  913 </span><span class="spaces">                                  </span><span class="istickedoff">--                   ( fin first, bound &gt;= first,</span>
<span class="lineno">  914 </span><span class="spaces">                                  </span><span class="istickedoff">--                     LiteralLessThan bound a)</span>
<span class="lineno">  915 </span><span class="spaces">                                  </span><span class="istickedoff">--                =&gt; [bound - first]a</span>
<span class="lineno">  916 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fromThenTo&quot;,     flip scGlobalDef &quot;Cryptol.ecFromThenTo&quot;)</span>
<span class="lineno">  917 </span><span class="spaces">                                  </span><span class="istickedoff">-- fromThenTo : {first, next, last, a, len}</span>
<span class="lineno">  918 </span><span class="spaces">                                  </span><span class="istickedoff">--              ( fin first, fin next, fin last</span>
<span class="lineno">  919 </span><span class="spaces">                                  </span><span class="istickedoff">--              , Literal first a, Literal next a, Literal last a</span>
<span class="lineno">  920 </span><span class="spaces">                                  </span><span class="istickedoff">--              , first != next</span>
<span class="lineno">  921 </span><span class="spaces">                                  </span><span class="istickedoff">--              , lengthFromThenTo first next last == len) =&gt; [len]a</span>
<span class="lineno">  922 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fromToBy&quot;,       flip scGlobalDef &quot;Cryptol.ecFromToBy&quot;)</span>
<span class="lineno">  923 </span><span class="spaces">                                  </span><span class="istickedoff">-- fromToBy : {first, last, stride, a}</span>
<span class="lineno">  924 </span><span class="spaces">                                  </span><span class="istickedoff">--   (fin last, fin stride, stride &gt;= 1, last &gt;= first, Literal last a) =&gt;</span>
<span class="lineno">  925 </span><span class="spaces">                                  </span><span class="istickedoff">--   [1 + (last - first)/stride]a</span>
<span class="lineno">  926 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fromToByLessThan&quot;, flip scGlobalDef &quot;Cryptol.ecFromToByLessThan&quot;)</span>
<span class="lineno">  927 </span><span class="spaces">                                  </span><span class="istickedoff">-- fromToByLessThan : {first, bound, stride, a}</span>
<span class="lineno">  928 </span><span class="spaces">                                  </span><span class="istickedoff">--   (fin first, fin stride, stride &gt;= 1, bound &gt;= first, LiteralLessThan bound a) =&gt;</span>
<span class="lineno">  929 </span><span class="spaces">                                  </span><span class="istickedoff">--   [(bound - first)/^stride]a</span>
<span class="lineno">  930 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fromToDownBy&quot;, flip scGlobalDef &quot;Cryptol.ecFromToDownBy&quot;)</span>
<span class="lineno">  931 </span><span class="spaces">                                  </span><span class="istickedoff">-- fromToDownBy : {first, last, stride, a}</span>
<span class="lineno">  932 </span><span class="spaces">                                  </span><span class="istickedoff">--   (fin first, fin stride, stride &gt;= 1, first &gt;= last, Literal first a) =&gt;</span>
<span class="lineno">  933 </span><span class="spaces">                                  </span><span class="istickedoff">--   [1 + (first - last)/stride]a</span>
<span class="lineno">  934 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fromToDownByGreaterThan&quot;, flip scGlobalDef &quot;Cryptol.ecFromToDownByGreaterThan&quot;)</span>
<span class="lineno">  935 </span><span class="spaces">                                  </span><span class="istickedoff">-- fromToDownByGreaterThan : {first, bound, stride, a}</span>
<span class="lineno">  936 </span><span class="spaces">                                  </span><span class="istickedoff">--   (fin first, fin stride, stride &gt;= 1, first &gt;= bound, Literal first a) =&gt;</span>
<span class="lineno">  937 </span><span class="spaces">                                  </span><span class="istickedoff">--   [(first - bound)/^stride]a</span>
<span class="lineno">  938 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  939 </span><span class="spaces">    </span><span class="istickedoff">-- Evaluation primitives: deepseq, parmap</span>
<span class="lineno">  940 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;deepseq&quot;,      flip scGlobalDef &quot;Cryptol.ecDeepseq&quot;)     -- {a, b} (Eq b) =&gt; a -&gt; b -&gt; b</span>
<span class="lineno">  941 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;parmap&quot;,       flip scGlobalDef &quot;Cryptol.ecParmap&quot;)      -- {a, b, n} (Eq b, fin n) =&gt; (a -&gt; b) -&gt; [n]a -&gt; [n]b</span>
<span class="lineno">  942 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;foldl&quot;,        flip scGlobalDef &quot;Cryptol.ecFoldl&quot;)       -- {n, a, b} (fin n) =&gt; (a -&gt; b -&gt; a) -&gt; a -&gt; [n]b -&gt; a</span>
<span class="lineno">  943 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;foldl'&quot;,       flip scGlobalDef &quot;Cryptol.ecFoldlPrime&quot;)  -- {n, a, b} (fin n, Eq a) =&gt; (a -&gt; b -&gt; a) -&gt; a -&gt; [n]b -&gt; a</span>
<span class="lineno">  944 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;scanl&quot;,        flip scGlobalDef &quot;Cryptol.ecScanl&quot;)       -- {n, a, b}  (a -&gt; b -&gt; a) -&gt; a -&gt; [n]b -&gt; [1+n]a</span>
<span class="lineno">  945 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;error&quot;,        flip scGlobalDef &quot;Cryptol.ecError&quot;)       -- {at,len} (fin len) =&gt; [len][8] -&gt; at -- Run-time error</span>
<span class="lineno">  946 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;random&quot;,       flip scGlobalDef &quot;Cryptol.ecRandom&quot;)      -- {a} =&gt; [32] -&gt; a -- Random values</span>
<span class="lineno">  947 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;trace&quot;,        flip scGlobalDef &quot;Cryptol.ecTrace&quot;)       -- {n,a,b} [n][8] -&gt; a -&gt; b -&gt; b</span>
<span class="lineno">  948 </span><span class="spaces">  </span><span class="istickedoff">]</span></span>
<span class="lineno">  949 </span>
<span class="lineno">  950 </span>arrayPrims :: Map C.PrimIdent (SharedContext -&gt; IO Term)
<span class="lineno">  951 </span><span class="decl"><span class="istickedoff">arrayPrims =</span>
<span class="lineno">  952 </span><span class="spaces">  </span><span class="istickedoff">Map.fromList $</span>
<span class="lineno">  953 </span><span class="spaces">  </span><span class="istickedoff">first C.arrayPrim &lt;$&gt;</span>
<span class="lineno">  954 </span><span class="spaces">  </span><span class="istickedoff">[ (&quot;arrayConstant&quot;, flip scGlobalDef &quot;Cryptol.ecArrayConstant&quot;) -- {a,b} b -&gt; Array a b</span>
<span class="lineno">  955 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;arrayLookup&quot;,   flip scGlobalDef &quot;Cryptol.ecArrayLookup&quot;) -- {a,b} Array a b -&gt; a -&gt; b</span>
<span class="lineno">  956 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;arrayUpdate&quot;,   flip scGlobalDef &quot;Cryptol.ecArrayUpdate&quot;) -- {a,b} Array a b -&gt; a -&gt; b -&gt; Array a b</span>
<span class="lineno">  957 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;arrayCopy&quot;, flip scGlobalDef &quot;Cryptol.ecArrayCopy&quot;) -- {n,a} Array [n] a -&gt; [n] -&gt; Array [n] a -&gt; [n] -&gt; [n] -&gt; Array [n] a</span>
<span class="lineno">  958 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;arrayEq&quot;, flip scGlobalDef &quot;Cryptol.ecArrayEq&quot;)     -- {a, b} (Array a b) -&gt; (Array a b) -&gt; Bool</span>
<span class="lineno">  959 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;arraySet&quot;, flip scGlobalDef &quot;Cryptol.ecArraySet&quot;) -- {n,a} Array [n] a -&gt; [n] -&gt; a -&gt; [n] -&gt; Array [n] a</span>
<span class="lineno">  960 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;arrayRangeEqual&quot;, flip scGlobalDef &quot;Cryptol.ecArrayRangeEq&quot;) -- {n,a} Array [n] a -&gt; [n] -&gt; Array [n] a -&gt; [n] -&gt; [n] -&gt; Bit</span>
<span class="lineno">  961 </span><span class="spaces">  </span><span class="istickedoff">]</span></span>
<span class="lineno">  962 </span>
<span class="lineno">  963 </span>floatPrims :: Map C.PrimIdent (SharedContext -&gt; IO Term)
<span class="lineno">  964 </span><span class="decl"><span class="istickedoff">floatPrims =</span>
<span class="lineno">  965 </span><span class="spaces">  </span><span class="istickedoff">Map.fromList $</span>
<span class="lineno">  966 </span><span class="spaces">  </span><span class="istickedoff">first C.floatPrim &lt;$&gt;</span>
<span class="lineno">  967 </span><span class="spaces">  </span><span class="istickedoff">[ (&quot;fpNaN&quot;,          <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ecFpNaN&quot;</span>)</span>
<span class="lineno">  968 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpPosInf&quot;,       <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ecFpPosInf&quot;</span>)</span>
<span class="lineno">  969 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpFromBits&quot;,     <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ecFpFromBits&quot;</span>)</span>
<span class="lineno">  970 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpToBits&quot;,       <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ecFpToBits&quot;</span>)</span>
<span class="lineno">  971 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;=.=&quot;,            <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ecFpEq&quot;</span>)</span>
<span class="lineno">  972 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpAdd&quot;,          <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ecFpAdd&quot;</span>)</span>
<span class="lineno">  973 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpSub&quot;,          <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ecFpSub&quot;</span>)</span>
<span class="lineno">  974 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpMul&quot;,          <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ecFpMul&quot;</span>)</span>
<span class="lineno">  975 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpDiv&quot;,          <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ecFpDiv&quot;</span>)</span>
<span class="lineno">  976 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpToRational&quot;,   <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ecFpToRational&quot;</span>)</span>
<span class="lineno">  977 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpFromRational&quot;, <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ecFpFromRational&quot;</span>)</span>
<span class="lineno">  978 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpIsNaN&quot;,        <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.fpIsNaN&quot;</span>)</span>
<span class="lineno">  979 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpIsInf&quot;,        <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.fpIsInf&quot;</span>)</span>
<span class="lineno">  980 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpIsZero&quot;,       <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.fpIsZero&quot;</span>)</span>
<span class="lineno">  981 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpIsNeg&quot;,        <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.fpIsNeg&quot;</span>)</span>
<span class="lineno">  982 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpIsNormal&quot;,     <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.fpIsNormal&quot;</span>)</span>
<span class="lineno">  983 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpIsSubnormal&quot;,  <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.fpIsSubnormal&quot;</span>)</span>
<span class="lineno">  984 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpFMA&quot;,          <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.fpFMA&quot;</span>)</span>
<span class="lineno">  985 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpAbs&quot;,          <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.fpAbs&quot;</span>)</span>
<span class="lineno">  986 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpSqrt&quot;,         <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.fpSqrt&quot;</span>)</span>
<span class="lineno">  987 </span><span class="spaces">  </span><span class="istickedoff">]</span></span>
<span class="lineno">  988 </span>
<span class="lineno">  989 </span>suiteBPrims :: Map C.PrimIdent (SharedContext -&gt; IO Term)
<span class="lineno">  990 </span><span class="decl"><span class="istickedoff">suiteBPrims =</span>
<span class="lineno">  991 </span><span class="spaces">  </span><span class="istickedoff">Map.fromList $</span>
<span class="lineno">  992 </span><span class="spaces">  </span><span class="istickedoff">first C.suiteBPrim &lt;$&gt;</span>
<span class="lineno">  993 </span><span class="spaces">  </span><span class="istickedoff">[ (&quot;AESEncRound&quot;,      <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.AESEncRound&quot;</span>)</span>
<span class="lineno">  994 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;AESEncFinalRound&quot;, <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.AESEncFinalRound&quot;</span>)</span>
<span class="lineno">  995 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;AESDecRound&quot;,      <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.AESDecRound&quot;</span>)</span>
<span class="lineno">  996 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;AESDecFinalRound&quot;, <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.AESDecFinalRound&quot;</span>)</span>
<span class="lineno">  997 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;AESInvMixColumns&quot;, <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.AESInvMixColumns&quot;</span>)</span>
<span class="lineno">  998 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;AESKeyExpand&quot;,     <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.AESKeyExpand&quot;</span>)</span>
<span class="lineno">  999 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;processSHA2_224&quot;,  <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.processSHA2_224&quot;</span>)</span>
<span class="lineno"> 1000 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;processSHA2_256&quot;,  <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.processSHA2_256&quot;</span>)</span>
<span class="lineno"> 1001 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;processSHA2_384&quot;,  <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.processSHA2_384&quot;</span>)</span>
<span class="lineno"> 1002 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;processSHA2_512&quot;,  <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.processSHA2_512&quot;</span>)</span>
<span class="lineno"> 1003 </span><span class="spaces">  </span><span class="istickedoff">]</span></span>
<span class="lineno"> 1004 </span>
<span class="lineno"> 1005 </span>primeECPrims :: Map C.PrimIdent (SharedContext -&gt; IO Term)
<span class="lineno"> 1006 </span><span class="decl"><span class="istickedoff">primeECPrims =</span>
<span class="lineno"> 1007 </span><span class="spaces">  </span><span class="istickedoff">Map.fromList $</span>
<span class="lineno"> 1008 </span><span class="spaces">  </span><span class="istickedoff">first C.primeECPrim &lt;$&gt;</span>
<span class="lineno"> 1009 </span><span class="spaces">  </span><span class="istickedoff">[ (&quot;ec_double&quot;,      <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ec_double&quot;</span>)</span>
<span class="lineno"> 1010 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;ec_add_nonzero&quot;, <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ec_add_nonzero&quot;</span>)</span>
<span class="lineno"> 1011 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;ec_mult&quot;,        <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ec_mult&quot;</span>)</span>
<span class="lineno"> 1012 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;ec_twin_mult&quot;,   <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ec_twin_mult&quot;</span>)</span>
<span class="lineno"> 1013 </span><span class="spaces">  </span><span class="istickedoff">]</span></span>
<span class="lineno"> 1014 </span>
<span class="lineno"> 1015 </span>-- | Convert a Cryptol expression to a SAW-Core term. Calling
<span class="lineno"> 1016 </span>-- 'scTypeOf' on the result of @'importExpr' sc env expr@ must yield a
<span class="lineno"> 1017 </span>-- type that is equivalent (i.e. convertible) with the one returned by
<span class="lineno"> 1018 </span>-- @'importSchema' sc env ('fastTypeOf' ('envC' env) expr)@.
<span class="lineno"> 1019 </span>importExpr :: SharedContext -&gt; Env -&gt; C.Expr -&gt; IO Term
<span class="lineno"> 1020 </span><span class="decl"><span class="istickedoff">importExpr sc env expr =</span>
<span class="lineno"> 1021 </span><span class="spaces">  </span><span class="istickedoff">case expr of</span>
<span class="lineno"> 1022 </span><span class="spaces">    </span><span class="istickedoff">C.EList es t -&gt;</span>
<span class="lineno"> 1023 </span><span class="spaces">      </span><span class="istickedoff">do t' &lt;- importType sc env t</span>
<span class="lineno"> 1024 </span><span class="spaces">         </span><span class="istickedoff">es' &lt;- traverse (importExpr' sc env (C.tMono t)) es</span>
<span class="lineno"> 1025 </span><span class="spaces">         </span><span class="istickedoff">scVector sc t' es'</span>
<span class="lineno"> 1026 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1027 </span><span class="spaces">    </span><span class="istickedoff">C.ETuple es -&gt;</span>
<span class="lineno"> 1028 </span><span class="spaces">      </span><span class="istickedoff">do es' &lt;- traverse (importExpr sc env) es</span>
<span class="lineno"> 1029 </span><span class="spaces">         </span><span class="istickedoff">scTuple sc es'</span>
<span class="lineno"> 1030 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1031 </span><span class="spaces">    </span><span class="istickedoff">C.ERec fm -&gt;</span>
<span class="lineno"> 1032 </span><span class="spaces">      </span><span class="istickedoff">do es' &lt;- traverse (importExpr sc env . snd) (C.canonicalFields fm)</span>
<span class="lineno"> 1033 </span><span class="spaces">         </span><span class="istickedoff">scTuple sc es'</span>
<span class="lineno"> 1034 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1035 </span><span class="spaces">    </span><span class="istickedoff">C.ESel e sel -&gt;</span>
<span class="lineno"> 1036 </span><span class="spaces">      </span><span class="istickedoff">-- Elimination for tuple/record/list</span>
<span class="lineno"> 1037 </span><span class="spaces">      </span><span class="istickedoff">case sel of</span>
<span class="lineno"> 1038 </span><span class="spaces">        </span><span class="istickedoff">C.TupleSel i _maybeLen -&gt;</span>
<span class="lineno"> 1039 </span><span class="spaces">          </span><span class="istickedoff">do e' &lt;- importExpr sc env e</span>
<span class="lineno"> 1040 </span><span class="spaces">             </span><span class="istickedoff">let t = fastTypeOf (envC env) e</span>
<span class="lineno"> 1041 </span><span class="spaces">             </span><span class="istickedoff">case C.tIsTuple t of</span>
<span class="lineno"> 1042 </span><span class="spaces">               </span><span class="istickedoff">Just ts -&gt; scTupleSelector sc e' (i+1) (length ts)</span>
<span class="lineno"> 1043 </span><span class="spaces">               </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">panic &quot;importExpr&quot; [&quot;invalid tuple selector&quot;, show i, pretty t]</span></span>
<span class="lineno"> 1044 </span><span class="spaces">        </span><span class="istickedoff">C.RecordSel x _ -&gt;</span>
<span class="lineno"> 1045 </span><span class="spaces">          </span><span class="istickedoff">do e' &lt;- importExpr sc env e</span>
<span class="lineno"> 1046 </span><span class="spaces">             </span><span class="istickedoff">let t = fastTypeOf (envC env) e</span>
<span class="lineno"> 1047 </span><span class="spaces">             </span><span class="istickedoff">case C.tNoUser t of</span>
<span class="lineno"> 1048 </span><span class="spaces">               </span><span class="istickedoff">C.TRec fm -&gt;</span>
<span class="lineno"> 1049 </span><span class="spaces">                 </span><span class="istickedoff">do i &lt;- the</span>
<span class="lineno"> 1050 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">(&quot;Expected filed &quot; ++ show x ++ &quot; in normal RecordSel&quot;)</span></span>
<span class="lineno"> 1051 </span><span class="spaces">                      </span><span class="istickedoff">(elemIndex x (map fst (C.canonicalFields fm)))</span>
<span class="lineno"> 1052 </span><span class="spaces">                    </span><span class="istickedoff">scTupleSelector sc e' (i+1) (length (C.canonicalFields fm))</span>
<span class="lineno"> 1053 </span><span class="spaces">               </span><span class="istickedoff">C.TNominal nt _args -&gt;</span>
<span class="lineno"> 1054 </span><span class="spaces">                 </span><span class="istickedoff">do let fs = case C.ntDef nt of</span>
<span class="lineno"> 1055 </span><span class="spaces">                               </span><span class="istickedoff">C.Struct s -&gt; C.ntFields s</span>
<span class="lineno"> 1056 </span><span class="spaces">                               </span><span class="istickedoff">C.Enum {} -&gt;</span>
<span class="lineno"> 1057 </span><span class="spaces">                                 </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importExpr&quot; [&quot;Select from enum&quot;]</span></span>
<span class="lineno"> 1058 </span><span class="spaces">                               </span><span class="istickedoff">C.Abstract -&gt;</span>
<span class="lineno"> 1059 </span><span class="spaces">                                 </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importExpr&quot; [&quot;Select from abstract type&quot;]</span></span>
<span class="lineno"> 1060 </span><span class="spaces">                    </span><span class="istickedoff">i &lt;- the <span class="nottickedoff">(&quot;Expected field &quot; ++ show x ++ &quot; in Newtype Record Sel&quot;)</span></span>
<span class="lineno"> 1061 </span><span class="spaces">                          </span><span class="istickedoff">(elemIndex x (map fst (C.canonicalFields fs)))</span>
<span class="lineno"> 1062 </span><span class="spaces">                    </span><span class="istickedoff">scTupleSelector sc e' (i+1) (length (C.canonicalFields fs))</span>
<span class="lineno"> 1063 </span><span class="spaces">               </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">panic &quot;importExpr&quot; [&quot;invalid record selector&quot;, pretty x, pretty t]</span></span>
<span class="lineno"> 1064 </span><span class="spaces">        </span><span class="istickedoff">C.ListSel i _maybeLen -&gt;</span>
<span class="lineno"> 1065 </span><span class="spaces">          </span><span class="istickedoff">do let t = fastTypeOf (envC env) e</span>
<span class="lineno"> 1066 </span><span class="spaces">             </span><span class="istickedoff">(n, a) &lt;-</span>
<span class="lineno"> 1067 </span><span class="spaces">               </span><span class="istickedoff">case C.tIsSeq t of</span>
<span class="lineno"> 1068 </span><span class="spaces">                 </span><span class="istickedoff">Just (n, a) -&gt; return (n, a)</span>
<span class="lineno"> 1069 </span><span class="spaces">                 </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">panic &quot;importExpr&quot; [&quot;ListSel: not a list type&quot;]</span></span>
<span class="lineno"> 1070 </span><span class="spaces">             </span><span class="istickedoff">a' &lt;- importType sc <span class="nottickedoff">env</span> a</span>
<span class="lineno"> 1071 </span><span class="spaces">             </span><span class="istickedoff">n' &lt;- importType sc <span class="nottickedoff">env</span> n</span>
<span class="lineno"> 1072 </span><span class="spaces">             </span><span class="istickedoff">e' &lt;- importExpr <span class="nottickedoff">sc</span> env e</span>
<span class="lineno"> 1073 </span><span class="spaces">             </span><span class="istickedoff">i' &lt;- scNat sc (fromIntegral i)</span>
<span class="lineno"> 1074 </span><span class="spaces">             </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.eListSel&quot; [a', n', e', i']</span>
<span class="lineno"> 1075 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1076 </span><span class="spaces">    </span><span class="istickedoff">C.ESet _ e1 sel e2 -&gt;</span>
<span class="lineno"> 1077 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">case sel of</span></span>
<span class="lineno"> 1078 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">C.TupleSel i _maybeLen -&gt;</span></span>
<span class="lineno"> 1079 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">do e1' &lt;- importExpr sc env e1</span></span>
<span class="lineno"> 1080 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">e2' &lt;- importExpr sc env e2</span></span>
<span class="lineno"> 1081 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">let t1 = fastTypeOf (envC env) e1</span></span>
<span class="lineno"> 1082 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">case C.tIsTuple t1 of</span></span>
<span class="lineno"> 1083 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt; panic &quot;importExpr&quot; [&quot;ESet/TupleSel: not a tuple type&quot;]</span></span>
<span class="lineno"> 1084 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">Just ts -&gt;</span></span>
<span class="lineno"> 1085 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">do ts' &lt;- traverse (importType sc env) ts</span></span>
<span class="lineno"> 1086 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">let t2' = ts' !! i</span></span>
<span class="lineno"> 1087 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">f &lt;- scGlobalApply sc &quot;Cryptol.const&quot; [t2', t2', e2']</span></span>
<span class="lineno"> 1088 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">g &lt;- tupleUpdate sc f i ts'</span></span>
<span class="lineno"> 1089 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">scApply sc g e1'</span></span>
<span class="lineno"> 1090 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">C.RecordSel x _ -&gt;</span></span>
<span class="lineno"> 1091 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">do e1' &lt;- importExpr sc env e1</span></span>
<span class="lineno"> 1092 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">e2' &lt;- importExpr sc env e2</span></span>
<span class="lineno"> 1093 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">let t1 = fastTypeOf (envC env) e1</span></span>
<span class="lineno"> 1094 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">case C.tIsRec t1 of</span></span>
<span class="lineno"> 1095 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt; panic &quot;importExpr&quot; [&quot;ESet/RecordSel: not a record type&quot;]</span></span>
<span class="lineno"> 1096 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">Just tm -&gt;</span></span>
<span class="lineno"> 1097 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">do i &lt;- the (&quot;Expected a field &quot; ++ show x ++ &quot; RecordSel&quot;)</span></span>
<span class="lineno"> 1098 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">(elemIndex x (map fst (C.canonicalFields tm)))</span></span>
<span class="lineno"> 1099 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">ts' &lt;- traverse (importType sc env . snd) (C.canonicalFields tm)</span></span>
<span class="lineno"> 1100 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">let t2' = ts' !! i</span></span>
<span class="lineno"> 1101 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">f &lt;- scGlobalApply sc &quot;Cryptol.const&quot; [t2', t2', e2']</span></span>
<span class="lineno"> 1102 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">g &lt;- tupleUpdate sc f i ts'</span></span>
<span class="lineno"> 1103 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">scApply sc g e1'</span></span>
<span class="lineno"> 1104 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">C.ListSel _i _maybeLen -&gt;</span></span>
<span class="lineno"> 1105 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importExpr&quot; [&quot;ESet/ListSel: unsupported&quot;]</span></span>
<span class="lineno"> 1106 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1107 </span><span class="spaces">    </span><span class="istickedoff">C.EIf e1 e2 e3 -&gt;</span>
<span class="lineno"> 1108 </span><span class="spaces">      </span><span class="istickedoff">do let ty = fastTypeOf (envC env) e2</span>
<span class="lineno"> 1109 </span><span class="spaces">         </span><span class="istickedoff">ty' &lt;- importType sc env ty</span>
<span class="lineno"> 1110 </span><span class="spaces">         </span><span class="istickedoff">e1' &lt;- importExpr sc env e1</span>
<span class="lineno"> 1111 </span><span class="spaces">         </span><span class="istickedoff">e2' &lt;- importExpr sc env e2</span>
<span class="lineno"> 1112 </span><span class="spaces">         </span><span class="istickedoff">e3' &lt;- importExpr' sc env (C.tMono ty) e3</span>
<span class="lineno"> 1113 </span><span class="spaces">         </span><span class="istickedoff">scGlobalApply sc &quot;Prelude.ite&quot; [ty', e1', e2', e3']</span>
<span class="lineno"> 1114 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1115 </span><span class="spaces">    </span><span class="istickedoff">C.EComp len eltty e mss -&gt;</span>
<span class="lineno"> 1116 </span><span class="spaces">      </span><span class="istickedoff">importComp sc env len eltty e mss</span>
<span class="lineno"> 1117 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1118 </span><span class="spaces">    </span><span class="istickedoff">C.EVar qname -&gt;</span>
<span class="lineno"> 1119 </span><span class="spaces">      </span><span class="istickedoff">case Map.lookup qname (envE env) of</span>
<span class="lineno"> 1120 </span><span class="spaces">        </span><span class="istickedoff">Just (e', j) -&gt; incVars sc 0 j e'</span>
<span class="lineno"> 1121 </span><span class="spaces">        </span><span class="istickedoff">Nothing      -&gt; <span class="nottickedoff">panic &quot;importExpr&quot; [&quot;unknown variable: &quot; ++ show qname]</span></span>
<span class="lineno"> 1122 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1123 </span><span class="spaces">    </span><span class="istickedoff">C.ETAbs tp e -&gt;</span>
<span class="lineno"> 1124 </span><span class="spaces">      </span><span class="istickedoff">do env' &lt;- bindTParam sc tp env</span>
<span class="lineno"> 1125 </span><span class="spaces">         </span><span class="istickedoff">k &lt;- importKind sc (C.tpKind tp)</span>
<span class="lineno"> 1126 </span><span class="spaces">         </span><span class="istickedoff">e' &lt;- importExpr sc env' e</span>
<span class="lineno"> 1127 </span><span class="spaces">         </span><span class="istickedoff">scLambda sc (tparamToLocalName tp) k e'</span>
<span class="lineno"> 1128 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1129 </span><span class="spaces">    </span><span class="istickedoff">C.ETApp e t -&gt;</span>
<span class="lineno"> 1130 </span><span class="spaces">      </span><span class="istickedoff">do e' &lt;- importExpr sc env e</span>
<span class="lineno"> 1131 </span><span class="spaces">         </span><span class="istickedoff">t' &lt;- importType sc env t</span>
<span class="lineno"> 1132 </span><span class="spaces">         </span><span class="istickedoff">scApply sc e' t'</span>
<span class="lineno"> 1133 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1134 </span><span class="spaces">    </span><span class="istickedoff">C.EApp e1 e2 -&gt;</span>
<span class="lineno"> 1135 </span><span class="spaces">      </span><span class="istickedoff">do e1' &lt;- importExpr sc env e1</span>
<span class="lineno"> 1136 </span><span class="spaces">         </span><span class="istickedoff">let t1 = fastTypeOf (envC env) e1</span>
<span class="lineno"> 1137 </span><span class="spaces">         </span><span class="istickedoff">t1a &lt;-</span>
<span class="lineno"> 1138 </span><span class="spaces">           </span><span class="istickedoff">case C.tIsFun t1 of</span>
<span class="lineno"> 1139 </span><span class="spaces">             </span><span class="istickedoff">Just (a, _) -&gt; return a</span>
<span class="lineno"> 1140 </span><span class="spaces">             </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">panic &quot;importExpr&quot; [&quot;expected function type&quot;]</span></span>
<span class="lineno"> 1141 </span><span class="spaces">         </span><span class="istickedoff">e2' &lt;- importExpr' sc env (C.tMono t1a) e2</span>
<span class="lineno"> 1142 </span><span class="spaces">         </span><span class="istickedoff">scApply sc e1' e2'</span>
<span class="lineno"> 1143 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1144 </span><span class="spaces">    </span><span class="istickedoff">C.EAbs x t e -&gt;</span>
<span class="lineno"> 1145 </span><span class="spaces">      </span><span class="istickedoff">do t' &lt;- importType sc env t</span>
<span class="lineno"> 1146 </span><span class="spaces">         </span><span class="istickedoff">env' &lt;- bindName sc x (C.tMono t) env</span>
<span class="lineno"> 1147 </span><span class="spaces">         </span><span class="istickedoff">e' &lt;- importExpr sc env' e</span>
<span class="lineno"> 1148 </span><span class="spaces">         </span><span class="istickedoff">scLambda sc (nameToLocalName x) t' e'</span>
<span class="lineno"> 1149 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1150 </span><span class="spaces">    </span><span class="istickedoff">C.EProofAbs prop e</span>
<span class="lineno"> 1151 </span><span class="spaces">      </span><span class="istickedoff">| isErasedProp prop -&gt; importExpr sc env e</span>
<span class="lineno"> 1152 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt;</span>
<span class="lineno"> 1153 </span><span class="spaces">        </span><span class="istickedoff">do p' &lt;- importType sc env prop</span>
<span class="lineno"> 1154 </span><span class="spaces">           </span><span class="istickedoff">env' &lt;- bindProp sc prop env</span>
<span class="lineno"> 1155 </span><span class="spaces">           </span><span class="istickedoff">e' &lt;- importExpr sc env' e</span>
<span class="lineno"> 1156 </span><span class="spaces">           </span><span class="istickedoff">scLambda sc &quot;_P&quot; p' e'</span>
<span class="lineno"> 1157 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1158 </span><span class="spaces">    </span><span class="istickedoff">C.EProofApp e -&gt;</span>
<span class="lineno"> 1159 </span><span class="spaces">      </span><span class="istickedoff">case fastSchemaOf (envC env) e of</span>
<span class="lineno"> 1160 </span><span class="spaces">        </span><span class="istickedoff">C.Forall [] (p : _ps) _ty</span>
<span class="lineno"> 1161 </span><span class="spaces">          </span><span class="istickedoff">| isErasedProp p -&gt; importExpr sc env e</span>
<span class="lineno"> 1162 </span><span class="spaces">          </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt;</span>
<span class="lineno"> 1163 </span><span class="spaces">            </span><span class="istickedoff">do e' &lt;- importExpr sc env e</span>
<span class="lineno"> 1164 </span><span class="spaces">               </span><span class="istickedoff">prf &lt;- proveProp sc env p</span>
<span class="lineno"> 1165 </span><span class="spaces">               </span><span class="istickedoff">scApply sc e' prf</span>
<span class="lineno"> 1166 </span><span class="spaces">        </span><span class="istickedoff">s -&gt; <span class="nottickedoff">panic &quot;importExpr&quot; [&quot;EProofApp: invalid type: &quot; ++ show (e, s)]</span></span>
<span class="lineno"> 1167 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1168 </span><span class="spaces">    </span><span class="istickedoff">C.EWhere e dgs -&gt;</span>
<span class="lineno"> 1169 </span><span class="spaces">      </span><span class="istickedoff">do env' &lt;- importDeclGroups sc env dgs</span>
<span class="lineno"> 1170 </span><span class="spaces">         </span><span class="istickedoff">importExpr sc env' e</span>
<span class="lineno"> 1171 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1172 </span><span class="spaces">    </span><span class="istickedoff">C.ELocated _ e -&gt;</span>
<span class="lineno"> 1173 </span><span class="spaces">      </span><span class="istickedoff">importExpr sc env e</span>
<span class="lineno"> 1174 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1175 </span><span class="spaces">    </span><span class="istickedoff">C.EPropGuards arms typ -&gt; do</span>
<span class="lineno"> 1176 </span><span class="spaces">      </span><span class="istickedoff">-- Convert prop guards to nested if-then-elses</span>
<span class="lineno"> 1177 </span><span class="spaces">      </span><span class="istickedoff">typ' &lt;- importType sc env typ</span>
<span class="lineno"> 1178 </span><span class="spaces">      </span><span class="istickedoff">errMsg &lt;- scString sc &quot;No constraints satisfied in constraint guard&quot;</span>
<span class="lineno"> 1179 </span><span class="spaces">      </span><span class="istickedoff">err &lt;- scGlobalApply sc &quot;Prelude.error&quot; [typ', errMsg]</span>
<span class="lineno"> 1180 </span><span class="spaces">      </span><span class="istickedoff">-- NOTE: Must use a right fold to maintain order of prop guards in</span>
<span class="lineno"> 1181 </span><span class="spaces">      </span><span class="istickedoff">-- generated if-then-else</span>
<span class="lineno"> 1182 </span><span class="spaces">      </span><span class="istickedoff">Fold.foldrM (propGuardToIte typ') err arms</span>
<span class="lineno"> 1183 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1184 </span><span class="spaces">    </span><span class="istickedoff">C.ECase {} -&gt; <span class="nottickedoff">panic &quot;importExpr&quot;</span></span>
<span class="lineno"> 1185 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">[&quot;`case` expressions are not yet supported&quot;]</span></span>
<span class="lineno"> 1186 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1187 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1188 </span><span class="spaces">    </span><span class="istickedoff">the :: String -&gt; Maybe a -&gt; IO a</span>
<span class="lineno"> 1189 </span><span class="spaces">    </span><span class="istickedoff">the what = maybe <span class="nottickedoff">(panic &quot;importExpr&quot; [&quot;internal type error&quot;, what])</span> return</span>
<span class="lineno"> 1190 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1191 </span><span class="spaces">    </span><span class="istickedoff">-- | Translate an erased 'Prop' to a term and return the conjunction of the</span>
<span class="lineno"> 1192 </span><span class="spaces">    </span><span class="istickedoff">-- translated term and 'mt' if 'mt' is 'Just'. Otherwise, return the</span>
<span class="lineno"> 1193 </span><span class="spaces">    </span><span class="istickedoff">-- translated 'Prop'.  This function is intended to be used in a fold,</span>
<span class="lineno"> 1194 </span><span class="spaces">    </span><span class="istickedoff">-- taking a 'Maybe' in the first argument to avoid creating an unnecessary</span>
<span class="lineno"> 1195 </span><span class="spaces">    </span><span class="istickedoff">-- conjunction over singleton lists.</span>
<span class="lineno"> 1196 </span><span class="spaces">    </span><span class="istickedoff">conjoinErasedProps :: Maybe Term -&gt; C.Prop -&gt; IO (Maybe Term)</span>
<span class="lineno"> 1197 </span><span class="spaces">    </span><span class="istickedoff">conjoinErasedProps mt p = do</span>
<span class="lineno"> 1198 </span><span class="spaces">      </span><span class="istickedoff">p' &lt;- importNumericConstraintAsBool sc env p</span>
<span class="lineno"> 1199 </span><span class="spaces">      </span><span class="istickedoff">case mt of</span>
<span class="lineno"> 1200 </span><span class="spaces">        </span><span class="istickedoff">Just t -&gt; Just &lt;$&gt; scAnd sc t p'</span>
<span class="lineno"> 1201 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; pure $ Just p'</span>
<span class="lineno"> 1202 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1203 </span><span class="spaces">    </span><span class="istickedoff">-- | A helper function to be used in a fold converting a prop guard to an</span>
<span class="lineno"> 1204 </span><span class="spaces">    </span><span class="istickedoff">-- if-then-else. In order, the arguments of the function are:</span>
<span class="lineno"> 1205 </span><span class="spaces">    </span><span class="istickedoff">-- 1. The type of the prop guard</span>
<span class="lineno"> 1206 </span><span class="spaces">    </span><span class="istickedoff">-- 2. An arm of the prop guard</span>
<span class="lineno"> 1207 </span><span class="spaces">    </span><span class="istickedoff">-- 3. A term representing the else branch of the if-then-else</span>
<span class="lineno"> 1208 </span><span class="spaces">    </span><span class="istickedoff">propGuardToIte :: Term -&gt; ([C.Prop], C.Expr) -&gt; Term -&gt; IO Term</span>
<span class="lineno"> 1209 </span><span class="spaces">    </span><span class="istickedoff">propGuardToIte typ (props, body) falseBranch = do</span>
<span class="lineno"> 1210 </span><span class="spaces">      </span><span class="istickedoff">mCondition &lt;- Fold.foldlM conjoinErasedProps Nothing props</span>
<span class="lineno"> 1211 </span><span class="spaces">      </span><span class="istickedoff">condition &lt;- maybe (scBool sc True) pure mCondition</span>
<span class="lineno"> 1212 </span><span class="spaces">      </span><span class="istickedoff">trueBranch &lt;- importExpr sc env body</span>
<span class="lineno"> 1213 </span><span class="spaces">      </span><span class="istickedoff">scGlobalApply sc &quot;Prelude.ite&quot; [typ, condition, trueBranch, falseBranch]</span></span>
<span class="lineno"> 1214 </span>
<span class="lineno"> 1215 </span>
<span class="lineno"> 1216 </span>-- | Convert a Cryptol expression with the given type schema to a
<span class="lineno"> 1217 </span>-- SAW-Core term. Calling 'scTypeOf' on the result of @'importExpr''
<span class="lineno"> 1218 </span>-- sc env schema expr@ must yield a type that is equivalent (i.e.
<span class="lineno"> 1219 </span>-- convertible) with the one returned by @'importSchema' sc env
<span class="lineno"> 1220 </span>-- schema@.
<span class="lineno"> 1221 </span>--
<span class="lineno"> 1222 </span>-- Essentially, this function should be used when the expression's type is known
<span class="lineno"> 1223 </span>-- (such as with a type annotation), and 'importExpr' should be used when the
<span class="lineno"> 1224 </span>-- type must be inferred.
<span class="lineno"> 1225 </span>importExpr' :: SharedContext -&gt; Env -&gt; C.Schema -&gt; C.Expr -&gt; IO Term
<span class="lineno"> 1226 </span><span class="decl"><span class="istickedoff">importExpr' sc env schema expr =</span>
<span class="lineno"> 1227 </span><span class="spaces">  </span><span class="istickedoff">case expr of</span>
<span class="lineno"> 1228 </span><span class="spaces">    </span><span class="istickedoff">C.ETuple es -&gt;</span>
<span class="lineno"> 1229 </span><span class="spaces">      </span><span class="istickedoff">do ty &lt;- the <span class="nottickedoff">&quot;Expected a mono type in ETuple&quot;</span> (C.isMono schema)</span>
<span class="lineno"> 1230 </span><span class="spaces">         </span><span class="istickedoff">ts &lt;- the <span class="nottickedoff">&quot;Expected a tuple type in ETuple&quot;</span> (C.tIsTuple ty)</span>
<span class="lineno"> 1231 </span><span class="spaces">         </span><span class="istickedoff">es' &lt;- sequence (zipWith go ts es)</span>
<span class="lineno"> 1232 </span><span class="spaces">         </span><span class="istickedoff">scTuple sc es'</span>
<span class="lineno"> 1233 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1234 </span><span class="spaces">    </span><span class="istickedoff">C.ERec fm -&gt;</span>
<span class="lineno"> 1235 </span><span class="spaces">      </span><span class="istickedoff">do ty &lt;- the <span class="nottickedoff">&quot;Expected a mono type in ERec&quot;</span> (C.isMono schema)</span>
<span class="lineno"> 1236 </span><span class="spaces">         </span><span class="istickedoff">tm &lt;- the <span class="nottickedoff">&quot;Expected a record type in ERec&quot;</span> (C.tIsRec ty)</span>
<span class="lineno"> 1237 </span><span class="spaces">         </span><span class="istickedoff">es' &lt;- sequence (zipWith go (map snd (C.canonicalFields tm)) (map snd (C.canonicalFields fm)))</span>
<span class="lineno"> 1238 </span><span class="spaces">         </span><span class="istickedoff">scTuple sc es'</span>
<span class="lineno"> 1239 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1240 </span><span class="spaces">    </span><span class="istickedoff">C.EIf e1 e2 e3 -&gt;</span>
<span class="lineno"> 1241 </span><span class="spaces">      </span><span class="istickedoff">do ty  &lt;- the <span class="nottickedoff">&quot;Expected a mono type in EIf&quot;</span> (C.isMono schema)</span>
<span class="lineno"> 1242 </span><span class="spaces">         </span><span class="istickedoff">ty' &lt;- importType sc env ty</span>
<span class="lineno"> 1243 </span><span class="spaces">         </span><span class="istickedoff">e1' &lt;- importExpr sc env e1</span>
<span class="lineno"> 1244 </span><span class="spaces">         </span><span class="istickedoff">e2' &lt;- importExpr' sc env schema e2</span>
<span class="lineno"> 1245 </span><span class="spaces">         </span><span class="istickedoff">e3' &lt;- importExpr' sc env schema e3</span>
<span class="lineno"> 1246 </span><span class="spaces">         </span><span class="istickedoff">scGlobalApply sc &quot;Prelude.ite&quot; [ty', e1', e2', e3']</span>
<span class="lineno"> 1247 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1248 </span><span class="spaces">    </span><span class="istickedoff">C.ETAbs tp e -&gt;</span>
<span class="lineno"> 1249 </span><span class="spaces">      </span><span class="istickedoff">do schema' &lt;-</span>
<span class="lineno"> 1250 </span><span class="spaces">           </span><span class="istickedoff">case schema of</span>
<span class="lineno"> 1251 </span><span class="spaces">             </span><span class="istickedoff">C.Forall (tp1 : tparams) props ty -&gt;</span>
<span class="lineno"> 1252 </span><span class="spaces">               </span><span class="istickedoff">let s = C.singleTParamSubst tp1 (C.TVar (C.TVBound tp))</span>
<span class="lineno"> 1253 </span><span class="spaces">               </span><span class="istickedoff">in return (C.Forall tparams (map (plainSubst s) props) (plainSubst s ty))</span>
<span class="lineno"> 1254 </span><span class="spaces">             </span><span class="istickedoff">C.Forall [] _ _ -&gt; <span class="nottickedoff">panic &quot;importExpr'&quot; [&quot;internal error: unexpected type abstraction&quot;]</span></span>
<span class="lineno"> 1255 </span><span class="spaces">         </span><span class="istickedoff">env' &lt;- bindTParam sc tp env</span>
<span class="lineno"> 1256 </span><span class="spaces">         </span><span class="istickedoff">k &lt;- importKind sc (C.tpKind tp)</span>
<span class="lineno"> 1257 </span><span class="spaces">         </span><span class="istickedoff">e' &lt;- importExpr' sc env' schema' e</span>
<span class="lineno"> 1258 </span><span class="spaces">         </span><span class="istickedoff">scLambda sc (tparamToLocalName tp) k e'</span>
<span class="lineno"> 1259 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1260 </span><span class="spaces">    </span><span class="istickedoff">C.EAbs x _ e -&gt;</span>
<span class="lineno"> 1261 </span><span class="spaces">      </span><span class="istickedoff">do ty &lt;- the <span class="nottickedoff">&quot;expected a mono schema in EAbs&quot;</span> (C.isMono schema)</span>
<span class="lineno"> 1262 </span><span class="spaces">         </span><span class="istickedoff">(a, b) &lt;- the <span class="nottickedoff">&quot;expected a function type in EAbs&quot;</span> (C.tIsFun ty)</span>
<span class="lineno"> 1263 </span><span class="spaces">         </span><span class="istickedoff">a' &lt;- importType sc env a</span>
<span class="lineno"> 1264 </span><span class="spaces">         </span><span class="istickedoff">env' &lt;- bindName sc x (C.tMono a) env</span>
<span class="lineno"> 1265 </span><span class="spaces">         </span><span class="istickedoff">e' &lt;- importExpr' sc env' (C.tMono b) e</span>
<span class="lineno"> 1266 </span><span class="spaces">         </span><span class="istickedoff">scLambda sc (nameToLocalName x) a' e'</span>
<span class="lineno"> 1267 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1268 </span><span class="spaces">    </span><span class="istickedoff">C.EProofAbs _ e -&gt;</span>
<span class="lineno"> 1269 </span><span class="spaces">      </span><span class="istickedoff">do (prop, schema') &lt;-</span>
<span class="lineno"> 1270 </span><span class="spaces">           </span><span class="istickedoff">case schema of</span>
<span class="lineno"> 1271 </span><span class="spaces">             </span><span class="istickedoff">C.Forall [] (p : ps) ty -&gt; return (p, C.Forall [] ps ty)</span>
<span class="lineno"> 1272 </span><span class="spaces">             </span><span class="istickedoff">C.Forall as ps _ -&gt;</span>
<span class="lineno"> 1273 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importExpr&quot;</span></span>
<span class="lineno"> 1274 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">[&quot;internal type error&quot;</span></span>
<span class="lineno"> 1275 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">, &quot;expected a schema with no variables and a predicate&quot;</span></span>
<span class="lineno"> 1276 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">, &quot;found: &quot; ++ (if null as then &quot;&quot; else &quot; variables&quot;)</span></span>
<span class="lineno"> 1277 </span><span class="spaces">                              </span><span class="istickedoff"><span class="nottickedoff">++ (if null ps then &quot; no predicate&quot; else &quot;&quot;)</span></span>
<span class="lineno"> 1278 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1279 </span><span class="spaces">         </span><span class="istickedoff">if isErasedProp prop</span>
<span class="lineno"> 1280 </span><span class="spaces">           </span><span class="istickedoff">then importExpr' sc env schema' e</span>
<span class="lineno"> 1281 </span><span class="spaces">           </span><span class="istickedoff">else do p' &lt;- importType sc env prop</span>
<span class="lineno"> 1282 </span><span class="spaces">                   </span><span class="istickedoff">env' &lt;- bindProp sc prop env</span>
<span class="lineno"> 1283 </span><span class="spaces">                   </span><span class="istickedoff">e' &lt;- importExpr' sc env' schema' e</span>
<span class="lineno"> 1284 </span><span class="spaces">                   </span><span class="istickedoff">scLambda sc &quot;_P&quot; p' e'</span>
<span class="lineno"> 1285 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1286 </span><span class="spaces">    </span><span class="istickedoff">C.EWhere e dgs -&gt;</span>
<span class="lineno"> 1287 </span><span class="spaces">      </span><span class="istickedoff">do env' &lt;- importDeclGroups sc env dgs</span>
<span class="lineno"> 1288 </span><span class="spaces">         </span><span class="istickedoff">importExpr' sc env' schema e</span>
<span class="lineno"> 1289 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1290 </span><span class="spaces">    </span><span class="istickedoff">C.ELocated _ e -&gt;</span>
<span class="lineno"> 1291 </span><span class="spaces">      </span><span class="istickedoff">importExpr' sc env schema e</span>
<span class="lineno"> 1292 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1293 </span><span class="spaces">    </span><span class="istickedoff">C.ECase {} -&gt; <span class="nottickedoff">panic &quot;importExpr&quot; [&quot;`case` is not yet supported&quot;]</span></span>
<span class="lineno"> 1294 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1295 </span><span class="spaces">    </span><span class="istickedoff">C.EList     {} -&gt; fallback</span>
<span class="lineno"> 1296 </span><span class="spaces">    </span><span class="istickedoff">C.ESel      {} -&gt; fallback</span>
<span class="lineno"> 1297 </span><span class="spaces">    </span><span class="istickedoff">C.ESet      {} -&gt; <span class="nottickedoff">fallback</span></span>
<span class="lineno"> 1298 </span><span class="spaces">    </span><span class="istickedoff">C.EComp     {} -&gt; fallback</span>
<span class="lineno"> 1299 </span><span class="spaces">    </span><span class="istickedoff">C.EVar      {} -&gt; fallback</span>
<span class="lineno"> 1300 </span><span class="spaces">    </span><span class="istickedoff">C.EApp      {} -&gt; fallback</span>
<span class="lineno"> 1301 </span><span class="spaces">    </span><span class="istickedoff">C.ETApp     {} -&gt; fallback</span>
<span class="lineno"> 1302 </span><span class="spaces">    </span><span class="istickedoff">C.EProofApp {} -&gt; fallback</span>
<span class="lineno"> 1303 </span><span class="spaces">    </span><span class="istickedoff">C.EPropGuards {} -&gt; fallback</span>
<span class="lineno"> 1304 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1305 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1306 </span><span class="spaces">    </span><span class="istickedoff">go :: C.Type -&gt; C.Expr -&gt; IO Term</span>
<span class="lineno"> 1307 </span><span class="spaces">    </span><span class="istickedoff">go t = importExpr' sc env (C.tMono t)</span>
<span class="lineno"> 1308 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1309 </span><span class="spaces">    </span><span class="istickedoff">the :: String -&gt; Maybe a -&gt; IO a</span>
<span class="lineno"> 1310 </span><span class="spaces">    </span><span class="istickedoff">the what = maybe <span class="nottickedoff">(panic &quot;importExpr&quot; [&quot;internal type error&quot;,what])</span> return</span>
<span class="lineno"> 1311 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1312 </span><span class="spaces">    </span><span class="istickedoff">fallback :: IO Term</span>
<span class="lineno"> 1313 </span><span class="spaces">    </span><span class="istickedoff">fallback =</span>
<span class="lineno"> 1314 </span><span class="spaces">      </span><span class="istickedoff">do let t1 = fastTypeOf (envC env) expr</span>
<span class="lineno"> 1315 </span><span class="spaces">         </span><span class="istickedoff">t2 &lt;- the <span class="nottickedoff">&quot;falback: schema is not mono&quot;</span> (C.isMono schema)</span>
<span class="lineno"> 1316 </span><span class="spaces">         </span><span class="istickedoff">expr' &lt;- importExpr sc env expr</span>
<span class="lineno"> 1317 </span><span class="spaces">         </span><span class="istickedoff">coerceTerm sc env t1 t2 expr'</span></span>
<span class="lineno"> 1318 </span>
<span class="lineno"> 1319 </span>tupleUpdate :: SharedContext -&gt; Term -&gt; Int -&gt; [Term] -&gt; IO Term
<span class="lineno"> 1320 </span><span class="decl"><span class="nottickedoff">tupleUpdate _ f 0 [_] = return f</span>
<span class="lineno"> 1321 </span><span class="spaces"></span><span class="nottickedoff">tupleUpdate sc f 0 (a : ts) =</span>
<span class="lineno"> 1322 </span><span class="spaces">  </span><span class="nottickedoff">do b &lt;- scTupleType sc ts</span>
<span class="lineno"> 1323 </span><span class="spaces">     </span><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.updFst&quot; [a, b, f]</span>
<span class="lineno"> 1324 </span><span class="spaces"></span><span class="nottickedoff">tupleUpdate sc f n (a : ts) =</span>
<span class="lineno"> 1325 </span><span class="spaces">  </span><span class="nottickedoff">do g &lt;- tupleUpdate sc f (n - 1) ts</span>
<span class="lineno"> 1326 </span><span class="spaces">     </span><span class="nottickedoff">b &lt;- scTupleType sc ts</span>
<span class="lineno"> 1327 </span><span class="spaces">     </span><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.updSnd&quot; [a, b, g]</span>
<span class="lineno"> 1328 </span><span class="spaces"></span><span class="nottickedoff">tupleUpdate _ _ _ [] = panic &quot;tupleUpdate&quot; [&quot;empty tuple&quot;]</span></span>
<span class="lineno"> 1329 </span>
<span class="lineno"> 1330 </span>-- | Apply a substitution to a type *without* simplifying
<span class="lineno"> 1331 </span>-- constraints like @Ring [n]a@ to @Ring a@. (This is in contrast to
<span class="lineno"> 1332 </span>-- 'apSubst', which performs simplifications wherever possible.)
<span class="lineno"> 1333 </span>plainSubst :: C.Subst -&gt; C.Type -&gt; C.Type
<span class="lineno"> 1334 </span><span class="decl"><span class="istickedoff">plainSubst s ty =</span>
<span class="lineno"> 1335 </span><span class="spaces">  </span><span class="istickedoff">case ty of</span>
<span class="lineno"> 1336 </span><span class="spaces">    </span><span class="istickedoff">C.TCon tc ts   -&gt; C.TCon tc (map (plainSubst s) ts)</span>
<span class="lineno"> 1337 </span><span class="spaces">    </span><span class="istickedoff">C.TUser f ts t -&gt; C.TUser f (map <span class="nottickedoff">(plainSubst s)</span> ts) (plainSubst s t)</span>
<span class="lineno"> 1338 </span><span class="spaces">    </span><span class="istickedoff">C.TRec fs      -&gt; C.TRec (fmap (plainSubst s) fs)</span>
<span class="lineno"> 1339 </span><span class="spaces">    </span><span class="istickedoff">C.TVar x       -&gt; C.apSubst s (C.TVar x)</span>
<span class="lineno"> 1340 </span><span class="spaces">    </span><span class="istickedoff">C.TNominal nt ts -&gt; <span class="nottickedoff">C.TNominal nt (fmap (plainSubst s) ts)</span></span></span>
<span class="lineno"> 1341 </span>
<span class="lineno"> 1342 </span>
<span class="lineno"> 1343 </span>-- | Generate a URI representing a cryptol name from a sequence of
<span class="lineno"> 1344 </span>--   name parts representing the fully-qualified name.  If a \&quot;unique\&quot;
<span class="lineno"> 1345 </span>--   value is given, this represents a dynamically bound name in
<span class="lineno"> 1346 </span>--   the \&quot;\&lt;interactive\&gt;\&quot; pseudo-module, and the unique value will
<span class="lineno"> 1347 </span>--   be incorporated into the name as a fragment identifier.
<span class="lineno"> 1348 </span>--   At least one name component must be supplied.
<span class="lineno"> 1349 </span>--
<span class="lineno"> 1350 </span>--   Some examples:
<span class="lineno"> 1351 </span>--
<span class="lineno"> 1352 </span>--   * @Cryptol::foldl@ ---&gt; @cryptol:\/Cryptol\/foldl@
<span class="lineno"> 1353 </span>--   * @MyModule::SubModule::name@ ---&gt; @cryptol:\/MyModule\/SubModule\/name@
<span class="lineno"> 1354 </span>--   * @\&lt;interactive\&gt;::f@ ---&gt; @cryptol:f#1234@
<span class="lineno"> 1355 </span>--
<span class="lineno"> 1356 </span>--   In the above example, 1234 is the unique integer value provided with the name.
<span class="lineno"> 1357 </span>
<span class="lineno"> 1358 </span>cryptolURI ::
<span class="lineno"> 1359 </span>  [Text] {- ^ Name components  -} -&gt;
<span class="lineno"> 1360 </span>  Maybe Int {- ^ unique integer for dynamic names -} -&gt;
<span class="lineno"> 1361 </span>  URI
<span class="lineno"> 1362 </span><span class="decl"><span class="istickedoff">cryptolURI [] _ = <span class="nottickedoff">panic &quot;cryptolURI&quot; [&quot;Could not make URI from empty path&quot;]</span></span>
<span class="lineno"> 1363 </span><span class="spaces"></span><span class="istickedoff">cryptolURI (p:ps) Nothing =</span>
<span class="lineno"> 1364 </span><span class="spaces">  </span><span class="istickedoff">fromMaybe <span class="nottickedoff">(panic &quot;cryptolURI&quot; [&quot;Could not make URI from the given path&quot;, show (p:ps)])</span> $</span>
<span class="lineno"> 1365 </span><span class="spaces">  </span><span class="istickedoff">do sch &lt;- mkScheme &quot;cryptol&quot;</span>
<span class="lineno"> 1366 </span><span class="spaces">     </span><span class="istickedoff">path' &lt;- mapM mkPathPiece (p:|ps)</span>
<span class="lineno"> 1367 </span><span class="spaces">     </span><span class="istickedoff">pure URI</span>
<span class="lineno"> 1368 </span><span class="spaces">       </span><span class="istickedoff">{ uriScheme = Just sch</span>
<span class="lineno"> 1369 </span><span class="spaces">       </span><span class="istickedoff">, uriAuthority = Left True -- absolute path</span>
<span class="lineno"> 1370 </span><span class="spaces">       </span><span class="istickedoff">, uriPath = Just (False, path')</span>
<span class="lineno"> 1371 </span><span class="spaces">       </span><span class="istickedoff">, uriQuery = []</span>
<span class="lineno"> 1372 </span><span class="spaces">       </span><span class="istickedoff">, uriFragment = Nothing</span>
<span class="lineno"> 1373 </span><span class="spaces">       </span><span class="istickedoff">}</span>
<span class="lineno"> 1374 </span><span class="spaces"></span><span class="istickedoff">cryptolURI (p:ps) (Just uniq) =</span>
<span class="lineno"> 1375 </span><span class="spaces">  </span><span class="istickedoff">fromMaybe <span class="nottickedoff">(panic &quot;cryptolURI&quot; [&quot;Could not make URI from the given path&quot;, show (p:ps), show uniq])</span> $</span>
<span class="lineno"> 1376 </span><span class="spaces">  </span><span class="istickedoff">do sch &lt;- mkScheme &quot;cryptol&quot;</span>
<span class="lineno"> 1377 </span><span class="spaces">     </span><span class="istickedoff">path' &lt;- mapM mkPathPiece (p:|ps)</span>
<span class="lineno"> 1378 </span><span class="spaces">     </span><span class="istickedoff">frag &lt;- mkFragment (Text.pack (show uniq))</span>
<span class="lineno"> 1379 </span><span class="spaces">     </span><span class="istickedoff">pure URI</span>
<span class="lineno"> 1380 </span><span class="spaces">       </span><span class="istickedoff">{ uriScheme = Just sch</span>
<span class="lineno"> 1381 </span><span class="spaces">       </span><span class="istickedoff">, uriAuthority = Left False -- relative path</span>
<span class="lineno"> 1382 </span><span class="spaces">       </span><span class="istickedoff">, uriPath = Just (False, path')</span>
<span class="lineno"> 1383 </span><span class="spaces">       </span><span class="istickedoff">, uriQuery = []</span>
<span class="lineno"> 1384 </span><span class="spaces">       </span><span class="istickedoff">, uriFragment = Just frag</span>
<span class="lineno"> 1385 </span><span class="spaces">       </span><span class="istickedoff">}</span></span>
<span class="lineno"> 1386 </span>
<span class="lineno"> 1387 </span>
<span class="lineno"> 1388 </span>importName :: C.Name -&gt; IO NameInfo
<span class="lineno"> 1389 </span><span class="decl"><span class="istickedoff">importName cnm =</span>
<span class="lineno"> 1390 </span><span class="spaces">  </span><span class="istickedoff">case C.nameInfo cnm of</span>
<span class="lineno"> 1391 </span><span class="spaces">    </span><span class="istickedoff">C.LocalName {} -&gt; <span class="nottickedoff">fail (&quot;Cannot import non-top-level name: &quot; ++ show cnm)</span></span>
<span class="lineno"> 1392 </span><span class="spaces">    </span><span class="istickedoff">C.GlobalName _ns og</span>
<span class="lineno"> 1393 </span><span class="spaces">      </span><span class="istickedoff">| C.ogModule og == C.TopModule C.interactiveName -&gt;</span>
<span class="lineno"> 1394 </span><span class="spaces">          </span><span class="istickedoff">let shortNm = C.identText (C.nameIdent cnm)</span>
<span class="lineno"> 1395 </span><span class="spaces">              </span><span class="istickedoff">aliases = [shortNm]</span>
<span class="lineno"> 1396 </span><span class="spaces">              </span><span class="istickedoff">uri = cryptolURI [shortNm] (Just (C.nameUnique cnm))</span>
<span class="lineno"> 1397 </span><span class="spaces">           </span><span class="istickedoff">in pure (ImportedName uri aliases)</span>
<span class="lineno"> 1398 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1399 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt;</span>
<span class="lineno"> 1400 </span><span class="spaces">          </span><span class="istickedoff">let (topMod, nested) = C.modPathSplit (C.ogModule og)</span>
<span class="lineno"> 1401 </span><span class="spaces">              </span><span class="istickedoff">topChunks = C.modNameChunksText topMod</span>
<span class="lineno"> 1402 </span><span class="spaces">              </span><span class="istickedoff">modNms    = topChunks ++ map C.identText nested</span>
<span class="lineno"> 1403 </span><span class="spaces">              </span><span class="istickedoff">-- If the name came from a module parameter, add the module</span>
<span class="lineno"> 1404 </span><span class="spaces">              </span><span class="istickedoff">-- parameter identifier to distinguish between names that have the</span>
<span class="lineno"> 1405 </span><span class="spaces">              </span><span class="istickedoff">-- same identifier but come from different module parameters (see</span>
<span class="lineno"> 1406 </span><span class="spaces">              </span><span class="istickedoff">-- #1892)</span>
<span class="lineno"> 1407 </span><span class="spaces">              </span><span class="istickedoff">ifaceNms  = case C.ogFromParam og of</span>
<span class="lineno"> 1408 </span><span class="spaces">                            </span><span class="istickedoff">Just i  -&gt; [C.identText i]</span>
<span class="lineno"> 1409 </span><span class="spaces">                            </span><span class="istickedoff">Nothing -&gt; []</span>
<span class="lineno"> 1410 </span><span class="spaces">              </span><span class="istickedoff">shortNm   = C.identText (C.nameIdent cnm)</span>
<span class="lineno"> 1411 </span><span class="spaces">              </span><span class="istickedoff">nmParts   = modNms ++ ifaceNms ++ [shortNm]</span>
<span class="lineno"> 1412 </span><span class="spaces">              </span><span class="istickedoff">longNm    = Text.intercalate &quot;::&quot; nmParts</span>
<span class="lineno"> 1413 </span><span class="spaces">              </span><span class="istickedoff">aliases   = [shortNm, longNm]</span>
<span class="lineno"> 1414 </span><span class="spaces">              </span><span class="istickedoff">uri       = cryptolURI nmParts Nothing</span>
<span class="lineno"> 1415 </span><span class="spaces">           </span><span class="istickedoff">in pure (ImportedName uri aliases)</span></span>
<span class="lineno"> 1416 </span>
<span class="lineno"> 1417 </span>-- | Currently this imports declaration groups by inlining all the
<span class="lineno"> 1418 </span>-- definitions. (With subterm sharing, this is not as bad as it might
<span class="lineno"> 1419 </span>-- seem.) We might want to think about generating let or where
<span class="lineno"> 1420 </span>-- expressions instead.
<span class="lineno"> 1421 </span>--
<span class="lineno"> 1422 </span>-- For Cryptol @foreign@ declarations, we import them as regular
<span class="lineno"> 1423 </span>-- Cryptol expressions if a Cryptol implementation exists, and as an
<span class="lineno"> 1424 </span>-- opaque constant otherwise.
<span class="lineno"> 1425 </span>importDeclGroup :: DeclGroupOptions -&gt; SharedContext -&gt; Env -&gt; C.DeclGroup -&gt; IO Env
<span class="lineno"> 1426 </span>
<span class="lineno"> 1427 </span><span class="decl"><span class="istickedoff">importDeclGroup declOpts sc env (C.Recursive decls) =</span>
<span class="lineno"> 1428 </span><span class="spaces">  </span><span class="istickedoff">case decls of</span>
<span class="lineno"> 1429 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1430 </span><span class="spaces">    </span><span class="istickedoff">[decl] -&gt;</span>
<span class="lineno"> 1431 </span><span class="spaces">      </span><span class="istickedoff">case C.dDefinition decl of</span>
<span class="lineno"> 1432 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1433 </span><span class="spaces">        </span><span class="istickedoff">C.DPrim -&gt;</span>
<span class="lineno"> 1434 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importDeclGroup&quot;</span></span>
<span class="lineno"> 1435 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">[&quot;Primitive declarations cannot be recursive:&quot;, show (C.dName decl)]</span></span>
<span class="lineno"> 1436 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1437 </span><span class="spaces">        </span><span class="istickedoff">C.DForeign _ mexpr -&gt;</span>
<span class="lineno"> 1438 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">case mexpr of</span></span>
<span class="lineno"> 1439 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt; panicForeignNoExpr decl</span></span>
<span class="lineno"> 1440 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">Just expr -&gt; addExpr expr</span></span>
<span class="lineno"> 1441 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1442 </span><span class="spaces">        </span><span class="istickedoff">C.DExpr expr -&gt; addExpr expr</span>
<span class="lineno"> 1443 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1444 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno"> 1445 </span><span class="spaces">      </span><span class="istickedoff">addExpr expr = do</span>
<span class="lineno"> 1446 </span><span class="spaces">        </span><span class="istickedoff">env1 &lt;- bindName sc (C.dName decl) (C.dSignature decl) env</span>
<span class="lineno"> 1447 </span><span class="spaces">        </span><span class="istickedoff">t' &lt;- importSchema sc env (C.dSignature decl)</span>
<span class="lineno"> 1448 </span><span class="spaces">        </span><span class="istickedoff">e' &lt;- importExpr' sc env1 (C.dSignature decl) expr</span>
<span class="lineno"> 1449 </span><span class="spaces">        </span><span class="istickedoff">let x = nameToLocalName (C.dName decl)</span>
<span class="lineno"> 1450 </span><span class="spaces">        </span><span class="istickedoff">f' &lt;- scLambda sc x t' e'</span>
<span class="lineno"> 1451 </span><span class="spaces">        </span><span class="istickedoff">rhs &lt;- scGlobalApply sc &quot;Prelude.fix&quot; [t', f']</span>
<span class="lineno"> 1452 </span><span class="spaces">        </span><span class="istickedoff">rhs' &lt;- case declOpts of</span>
<span class="lineno"> 1453 </span><span class="spaces">                  </span><span class="istickedoff">TopLevelDeclGroup _ -&gt;</span>
<span class="lineno"> 1454 </span><span class="spaces">                    </span><span class="istickedoff">do nmi &lt;- importName (C.dName decl)</span>
<span class="lineno"> 1455 </span><span class="spaces">                       </span><span class="istickedoff">scConstant' sc nmi rhs t'</span>
<span class="lineno"> 1456 </span><span class="spaces">                  </span><span class="istickedoff">NestedDeclGroup -&gt; return rhs</span>
<span class="lineno"> 1457 </span><span class="spaces">        </span><span class="istickedoff">let env' = env { envE = Map.insert (C.dName decl) (rhs', 0) (envE env)</span>
<span class="lineno"> 1458 </span><span class="spaces">                       </span><span class="istickedoff">, envC = Map.insert (C.dName decl) (C.dSignature decl) (envC env) }</span>
<span class="lineno"> 1459 </span><span class="spaces">        </span><span class="istickedoff">return env'</span>
<span class="lineno"> 1460 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1461 </span><span class="spaces">    </span><span class="istickedoff">-- - A group of mutually-recursive declarations -</span>
<span class="lineno"> 1462 </span><span class="spaces">    </span><span class="istickedoff">-- We handle this by &quot;tupling up&quot; all the declarations using a record and</span>
<span class="lineno"> 1463 </span><span class="spaces">    </span><span class="istickedoff">-- taking the fixpoint at this record type.  The desired declarations are</span>
<span class="lineno"> 1464 </span><span class="spaces">    </span><span class="istickedoff">-- then achieved by projecting the field names from this record.</span>
<span class="lineno"> 1465 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; do</span>
<span class="lineno"> 1466 </span><span class="spaces">      </span><span class="istickedoff">-- build the environment for the declaration bodies</span>
<span class="lineno"> 1467 </span><span class="spaces">      </span><span class="istickedoff">let dm = Map.fromList [ (C.dName d, d) | d &lt;- decls ]</span>
<span class="lineno"> 1468 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1469 </span><span class="spaces">      </span><span class="istickedoff">-- grab a reference to the outermost variable; this will be the record in the body</span>
<span class="lineno"> 1470 </span><span class="spaces">      </span><span class="istickedoff">-- of the lambda we build later</span>
<span class="lineno"> 1471 </span><span class="spaces">      </span><span class="istickedoff">v0 &lt;- scLocalVar sc 0</span>
<span class="lineno"> 1472 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1473 </span><span class="spaces">      </span><span class="istickedoff">-- build a list of projections from a record variable</span>
<span class="lineno"> 1474 </span><span class="spaces">      </span><span class="istickedoff">vm &lt;- traverse (scRecordSelect sc v0 . nameToFieldName . C.dName) dm</span>
<span class="lineno"> 1475 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1476 </span><span class="spaces">      </span><span class="istickedoff">-- the types of the declarations</span>
<span class="lineno"> 1477 </span><span class="spaces">      </span><span class="istickedoff">tm &lt;- traverse (importSchema sc env . C.dSignature) dm</span>
<span class="lineno"> 1478 </span><span class="spaces">      </span><span class="istickedoff">-- the type of the recursive record</span>
<span class="lineno"> 1479 </span><span class="spaces">      </span><span class="istickedoff">rect &lt;- scRecordType sc (Map.assocs $ Map.mapKeys nameToFieldName tm)</span>
<span class="lineno"> 1480 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1481 </span><span class="spaces">      </span><span class="istickedoff">let env1 = liftEnv env</span>
<span class="lineno"> 1482 </span><span class="spaces">      </span><span class="istickedoff">let env2 = env1 { envE = Map.union (fmap (\v -&gt; (v, 0)) vm) (envE env1)</span>
<span class="lineno"> 1483 </span><span class="spaces">                      </span><span class="istickedoff">, envC = Map.union (fmap C.dSignature dm) (envC env1)</span>
<span class="lineno"> 1484 </span><span class="spaces">                      </span><span class="istickedoff">, envS = <span class="nottickedoff">rect : envS env1</span> }</span>
<span class="lineno"> 1485 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1486 </span><span class="spaces">      </span><span class="istickedoff">let extractDeclExpr decl =</span>
<span class="lineno"> 1487 </span><span class="spaces">            </span><span class="istickedoff">case C.dDefinition decl of</span>
<span class="lineno"> 1488 </span><span class="spaces">              </span><span class="istickedoff">C.DExpr expr -&gt; importExpr' sc env2 (C.dSignature decl) expr</span>
<span class="lineno"> 1489 </span><span class="spaces">              </span><span class="istickedoff">C.DForeign _ mexpr -&gt;</span>
<span class="lineno"> 1490 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">case mexpr of</span></span>
<span class="lineno"> 1491 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt; panicForeignNoExpr decl</span></span>
<span class="lineno"> 1492 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">Just expr -&gt;</span></span>
<span class="lineno"> 1493 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">importExpr' sc env2 (C.dSignature decl) expr</span></span>
<span class="lineno"> 1494 </span><span class="spaces">              </span><span class="istickedoff">C.DPrim -&gt;</span>
<span class="lineno"> 1495 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importDeclGroup&quot;</span></span>
<span class="lineno"> 1496 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Primitive declarations cannot be recursive:&quot;</span></span>
<span class="lineno"> 1497 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">, show (C.dName decl)</span></span>
<span class="lineno"> 1498 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1499 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1500 </span><span class="spaces">      </span><span class="istickedoff">-- the raw imported bodies of the declarations</span>
<span class="lineno"> 1501 </span><span class="spaces">      </span><span class="istickedoff">em &lt;- traverse extractDeclExpr dm</span>
<span class="lineno"> 1502 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1503 </span><span class="spaces">      </span><span class="istickedoff">-- the body of the recursive record</span>
<span class="lineno"> 1504 </span><span class="spaces">      </span><span class="istickedoff">recv &lt;- scRecord sc (Map.mapKeys nameToFieldName em)</span>
<span class="lineno"> 1505 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1506 </span><span class="spaces">      </span><span class="istickedoff">-- build a lambda from the record body...</span>
<span class="lineno"> 1507 </span><span class="spaces">      </span><span class="istickedoff">f &lt;- scLambda sc &quot;fixRecord&quot; rect recv</span>
<span class="lineno"> 1508 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1509 </span><span class="spaces">      </span><span class="istickedoff">-- and take its fixpoint</span>
<span class="lineno"> 1510 </span><span class="spaces">      </span><span class="istickedoff">rhs &lt;- scGlobalApply sc &quot;Prelude.fix&quot; [rect, f]</span>
<span class="lineno"> 1511 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1512 </span><span class="spaces">      </span><span class="istickedoff">-- finally, build projections from the fixed record to shove into the environment</span>
<span class="lineno"> 1513 </span><span class="spaces">      </span><span class="istickedoff">-- if toplevel, then wrap each binding with a Constant constructor</span>
<span class="lineno"> 1514 </span><span class="spaces">      </span><span class="istickedoff">let mkRhs d t =</span>
<span class="lineno"> 1515 </span><span class="spaces">            </span><span class="istickedoff">do let s = nameToFieldName (C.dName d)</span>
<span class="lineno"> 1516 </span><span class="spaces">               </span><span class="istickedoff">r &lt;- scRecordSelect sc rhs s</span>
<span class="lineno"> 1517 </span><span class="spaces">               </span><span class="istickedoff">case declOpts of</span>
<span class="lineno"> 1518 </span><span class="spaces">                 </span><span class="istickedoff">TopLevelDeclGroup _ -&gt;</span>
<span class="lineno"> 1519 </span><span class="spaces">                   </span><span class="istickedoff">do nmi &lt;- importName (C.dName d)</span>
<span class="lineno"> 1520 </span><span class="spaces">                      </span><span class="istickedoff">scConstant' sc nmi r t</span>
<span class="lineno"> 1521 </span><span class="spaces">                 </span><span class="istickedoff">NestedDeclGroup -&gt; <span class="nottickedoff">return r</span></span>
<span class="lineno"> 1522 </span><span class="spaces">      </span><span class="istickedoff">rhss &lt;- sequence (Map.intersectionWith mkRhs dm tm)</span>
<span class="lineno"> 1523 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1524 </span><span class="spaces">      </span><span class="istickedoff">let env' = env { envE = Map.union (fmap (\v -&gt; (v, 0)) rhss) (envE env)</span>
<span class="lineno"> 1525 </span><span class="spaces">                     </span><span class="istickedoff">, envC = Map.union (fmap C.dSignature dm) (envC env)</span>
<span class="lineno"> 1526 </span><span class="spaces">                     </span><span class="istickedoff">}</span>
<span class="lineno"> 1527 </span><span class="spaces">      </span><span class="istickedoff">return env'</span>
<span class="lineno"> 1528 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1529 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1530 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">panicForeignNoExpr decl = panic &quot;importDeclGroup&quot;</span></span>
<span class="lineno"> 1531 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Foreign declaration without Cryptol body in recursive group:&quot;</span></span>
<span class="lineno"> 1532 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, show (C.dName decl)</span></span>
<span class="lineno"> 1533 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1534 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1535 </span><span class="spaces"></span><span class="istickedoff">importDeclGroup declOpts sc env (C.NonRecursive decl) = do</span>
<span class="lineno"> 1536 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1537 </span><span class="spaces">  </span><span class="istickedoff">rhs &lt;- case C.dDefinition decl of</span>
<span class="lineno"> 1538 </span><span class="spaces">    </span><span class="istickedoff">C.DForeign _ mexpr</span>
<span class="lineno"> 1539 </span><span class="spaces">      </span><span class="istickedoff">| TopLevelDeclGroup _ &lt;- declOpts -&gt;</span>
<span class="lineno"> 1540 </span><span class="spaces">        </span><span class="istickedoff">case mexpr of</span>
<span class="lineno"> 1541 </span><span class="spaces">          </span><span class="istickedoff">Nothing -&gt; importOpaque sc <span class="nottickedoff">env</span> (C.dName decl) (C.dSignature decl)</span>
<span class="lineno"> 1542 </span><span class="spaces">          </span><span class="istickedoff">Just expr -&gt; do</span>
<span class="lineno"> 1543 </span><span class="spaces">            </span><span class="istickedoff">rhs &lt;- importExpr' sc env (C.dSignature decl) expr</span>
<span class="lineno"> 1544 </span><span class="spaces">            </span><span class="istickedoff">importConstant sc env (C.dName decl) (C.dSignature decl) rhs</span>
<span class="lineno"> 1545 </span><span class="spaces">      </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> -&gt;</span>
<span class="lineno"> 1546 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importDeclGroup&quot;</span></span>
<span class="lineno"> 1547 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">[&quot;Foreign declarations only allowed at top-level:&quot;, show (C.dName decl)]</span></span>
<span class="lineno"> 1548 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1549 </span><span class="spaces">    </span><span class="istickedoff">C.DPrim</span>
<span class="lineno"> 1550 </span><span class="spaces">      </span><span class="istickedoff">| TopLevelDeclGroup primOpts &lt;- declOpts -&gt;</span>
<span class="lineno"> 1551 </span><span class="spaces">        </span><span class="istickedoff">importPrimitive sc <span class="nottickedoff">primOpts</span> env (C.dName decl) (C.dSignature decl)</span>
<span class="lineno"> 1552 </span><span class="spaces">      </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno"> 1553 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importDeclGroup&quot; [&quot;Primitive declarations only allowed at top-level:&quot;, show (C.dName decl)]</span></span>
<span class="lineno"> 1554 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1555 </span><span class="spaces">    </span><span class="istickedoff">C.DExpr expr -&gt; do</span>
<span class="lineno"> 1556 </span><span class="spaces">      </span><span class="istickedoff">rhs &lt;- importExpr' sc env (C.dSignature decl) expr</span>
<span class="lineno"> 1557 </span><span class="spaces">      </span><span class="istickedoff">case declOpts of</span>
<span class="lineno"> 1558 </span><span class="spaces">        </span><span class="istickedoff">TopLevelDeclGroup _ -&gt;</span>
<span class="lineno"> 1559 </span><span class="spaces">          </span><span class="istickedoff">importConstant sc env (C.dName decl) (C.dSignature decl) rhs</span>
<span class="lineno"> 1560 </span><span class="spaces">        </span><span class="istickedoff">NestedDeclGroup -&gt; return rhs</span>
<span class="lineno"> 1561 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1562 </span><span class="spaces">  </span><span class="istickedoff">pure env { envE = Map.insert (C.dName decl) (rhs, 0) (envE env)</span>
<span class="lineno"> 1563 </span><span class="spaces">           </span><span class="istickedoff">, envC = Map.insert (C.dName decl) (C.dSignature decl) (envC env)</span>
<span class="lineno"> 1564 </span><span class="spaces">           </span><span class="istickedoff">}</span></span>
<span class="lineno"> 1565 </span>
<span class="lineno"> 1566 </span>
<span class="lineno"> 1567 </span>data ImportPrimitiveOptions =
<span class="lineno"> 1568 </span>  ImportPrimitiveOptions
<span class="lineno"> 1569 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">allowUnknownPrimitives</span></span></span> :: Bool
<span class="lineno"> 1570 </span>    -- ^ Should unknown primitives be translated as fresh external constants?
<span class="lineno"> 1571 </span>  }
<span class="lineno"> 1572 </span>
<span class="lineno"> 1573 </span>defaultPrimitiveOptions :: ImportPrimitiveOptions
<span class="lineno"> 1574 </span><span class="decl"><span class="nottickedoff">defaultPrimitiveOptions =</span>
<span class="lineno"> 1575 </span><span class="spaces">  </span><span class="nottickedoff">ImportPrimitiveOptions</span>
<span class="lineno"> 1576 </span><span class="spaces">  </span><span class="nottickedoff">{ allowUnknownPrimitives = True</span>
<span class="lineno"> 1577 </span><span class="spaces">  </span><span class="nottickedoff">}</span></span>
<span class="lineno"> 1578 </span>
<span class="lineno"> 1579 </span>data DeclGroupOptions
<span class="lineno"> 1580 </span>  = TopLevelDeclGroup ImportPrimitiveOptions
<span class="lineno"> 1581 </span>  | NestedDeclGroup
<span class="lineno"> 1582 </span>
<span class="lineno"> 1583 </span>importDeclGroups :: SharedContext -&gt; Env -&gt; [C.DeclGroup] -&gt; IO Env
<span class="lineno"> 1584 </span><span class="decl"><span class="istickedoff">importDeclGroups sc = foldM (importDeclGroup NestedDeclGroup sc)</span></span>
<span class="lineno"> 1585 </span>
<span class="lineno"> 1586 </span>importTopLevelDeclGroups :: SharedContext -&gt; ImportPrimitiveOptions -&gt; Env -&gt; [C.DeclGroup] -&gt; IO Env
<span class="lineno"> 1587 </span><span class="decl"><span class="istickedoff">importTopLevelDeclGroups sc primOpts = foldM (importDeclGroup (TopLevelDeclGroup <span class="nottickedoff">primOpts</span>) sc)</span></span>
<span class="lineno"> 1588 </span>
<span class="lineno"> 1589 </span>coerceTerm :: SharedContext -&gt; Env -&gt; C.Type -&gt; C.Type -&gt; Term -&gt; IO Term
<span class="lineno"> 1590 </span><span class="decl"><span class="istickedoff">coerceTerm sc env t1 t2 e</span>
<span class="lineno"> 1591 </span><span class="spaces">  </span><span class="istickedoff">| t1 == t2 = do return e</span>
<span class="lineno"> 1592 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno"> 1593 </span><span class="spaces">    </span><span class="istickedoff">do t1' &lt;- importType sc env t1</span>
<span class="lineno"> 1594 </span><span class="spaces">       </span><span class="istickedoff">t2' &lt;- importType sc env t2</span>
<span class="lineno"> 1595 </span><span class="spaces">       </span><span class="istickedoff">q &lt;- proveEq sc env t1 t2</span>
<span class="lineno"> 1596 </span><span class="spaces">       </span><span class="istickedoff">scGlobalApply sc &quot;Prelude.coerce&quot; [t1', t2', q, e]</span></span>
<span class="lineno"> 1597 </span>
<span class="lineno"> 1598 </span>proveEq :: SharedContext -&gt; Env -&gt; C.Type -&gt; C.Type -&gt; IO Term
<span class="lineno"> 1599 </span><span class="decl"><span class="istickedoff">proveEq sc env t1 t2</span>
<span class="lineno"> 1600 </span><span class="spaces">  </span><span class="istickedoff">| t1 == t2 =</span>
<span class="lineno"> 1601 </span><span class="spaces">    </span><span class="istickedoff">do s &lt;- scSort sc (mkSort 0)</span>
<span class="lineno"> 1602 </span><span class="spaces">       </span><span class="istickedoff">t' &lt;- importType sc env t1</span>
<span class="lineno"> 1603 </span><span class="spaces">       </span><span class="istickedoff">scCtorApp sc &quot;Prelude.Refl&quot; [s, t']</span>
<span class="lineno"> 1604 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno"> 1605 </span><span class="spaces">    </span><span class="istickedoff">case (tNoUser t1, tNoUser t2) of</span>
<span class="lineno"> 1606 </span><span class="spaces">      </span><span class="istickedoff">(C.tIsSeq -&gt; Just (n1, a1), C.tIsSeq -&gt; Just (n2, a2)) -&gt;</span>
<span class="lineno"> 1607 </span><span class="spaces">        </span><span class="istickedoff">do n1' &lt;- importType sc env n1</span>
<span class="lineno"> 1608 </span><span class="spaces">           </span><span class="istickedoff">n2' &lt;- importType sc env n2</span>
<span class="lineno"> 1609 </span><span class="spaces">           </span><span class="istickedoff">a1' &lt;- importType sc env a1</span>
<span class="lineno"> 1610 </span><span class="spaces">           </span><span class="istickedoff">a2' &lt;- importType sc env a2</span>
<span class="lineno"> 1611 </span><span class="spaces">           </span><span class="istickedoff">num &lt;- scDataTypeApp sc &quot;Cryptol.Num&quot; []</span>
<span class="lineno"> 1612 </span><span class="spaces">           </span><span class="istickedoff">nEq &lt;- if n1 == n2</span>
<span class="lineno"> 1613 </span><span class="spaces">                  </span><span class="istickedoff">then scCtorApp sc &quot;Prelude.Refl&quot; [num, n1']</span>
<span class="lineno"> 1614 </span><span class="spaces">                  </span><span class="istickedoff">else scGlobalApply sc &quot;Prelude.unsafeAssert&quot; [num, n1', n2']</span>
<span class="lineno"> 1615 </span><span class="spaces">           </span><span class="istickedoff">aEq &lt;- proveEq sc env a1 a2</span>
<span class="lineno"> 1616 </span><span class="spaces">           </span><span class="istickedoff">if a1 == a2</span>
<span class="lineno"> 1617 </span><span class="spaces">             </span><span class="istickedoff">then scGlobalApply sc &quot;Cryptol.seq_cong1&quot; [n1', n2', a1', nEq]</span>
<span class="lineno"> 1618 </span><span class="spaces">             </span><span class="istickedoff">else scGlobalApply sc &quot;Cryptol.seq_cong&quot; [n1', n2', a1', a2', nEq, aEq]</span>
<span class="lineno"> 1619 </span><span class="spaces">      </span><span class="istickedoff">(C.tIsIntMod -&gt; Just n1, C.tIsIntMod -&gt; Just n2) -&gt;</span>
<span class="lineno"> 1620 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">do n1' &lt;- importType sc env n1</span></span>
<span class="lineno"> 1621 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">n2' &lt;- importType sc env n2</span></span>
<span class="lineno"> 1622 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">num &lt;- scDataTypeApp sc &quot;Cryptol.Num&quot; []</span></span>
<span class="lineno"> 1623 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">nEq &lt;- if n1 == n2</span></span>
<span class="lineno"> 1624 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">then scCtorApp sc &quot;Prelude.Refl&quot; [num, n1']</span></span>
<span class="lineno"> 1625 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">else scGlobalApply sc &quot;Prelude.unsafeAssert&quot; [num, n1', n2']</span></span>
<span class="lineno"> 1626 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.IntModNum_cong&quot; [n1', n2', nEq]</span></span>
<span class="lineno"> 1627 </span><span class="spaces">      </span><span class="istickedoff">(C.tIsFun -&gt; Just (a1, b1), C.tIsFun -&gt; Just (a2, b2)) -&gt;</span>
<span class="lineno"> 1628 </span><span class="spaces">        </span><span class="istickedoff">do a1' &lt;- importType sc env a1</span>
<span class="lineno"> 1629 </span><span class="spaces">           </span><span class="istickedoff">a2' &lt;- importType sc env a2</span>
<span class="lineno"> 1630 </span><span class="spaces">           </span><span class="istickedoff">b1' &lt;- importType sc env b1</span>
<span class="lineno"> 1631 </span><span class="spaces">           </span><span class="istickedoff">b2' &lt;- importType sc env b2</span>
<span class="lineno"> 1632 </span><span class="spaces">           </span><span class="istickedoff">aEq &lt;- proveEq sc env a1 a2</span>
<span class="lineno"> 1633 </span><span class="spaces">           </span><span class="istickedoff">bEq &lt;- proveEq sc env b1 b2</span>
<span class="lineno"> 1634 </span><span class="spaces">           </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.fun_cong&quot; [a1', a2', b1', b2', aEq, bEq]</span>
<span class="lineno"> 1635 </span><span class="spaces">      </span><span class="istickedoff">(tIsPair -&gt; Just (a1, b1), tIsPair -&gt; Just (a2, b2)) -&gt;</span>
<span class="lineno"> 1636 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">do a1' &lt;- importType sc env a1</span></span>
<span class="lineno"> 1637 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">a2' &lt;- importType sc env a2</span></span>
<span class="lineno"> 1638 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">b1' &lt;- importType sc env b1</span></span>
<span class="lineno"> 1639 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">b2' &lt;- importType sc env b2</span></span>
<span class="lineno"> 1640 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">aEq &lt;- proveEq sc env a1 a2</span></span>
<span class="lineno"> 1641 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">bEq &lt;- proveEq sc env b1 b2</span></span>
<span class="lineno"> 1642 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">if b1 == b2</span></span>
<span class="lineno"> 1643 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">then scGlobalApply sc &quot;Cryptol.pair_cong1&quot; [a1', a2', b1', aEq]</span></span>
<span class="lineno"> 1644 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">else if a1 == a2</span></span>
<span class="lineno"> 1645 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">then scGlobalApply sc &quot;Cryptol.pair_cong2&quot; [a1', b1', b2', bEq]</span></span>
<span class="lineno"> 1646 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">else scGlobalApply sc &quot;Cryptol.pair_cong&quot; [a1', a2', b1', b2', aEq, bEq]</span></span>
<span class="lineno"> 1647 </span><span class="spaces">      </span><span class="istickedoff">(C.tIsRec -&gt; Just tm1, C.tIsRec -&gt; Just tm2)</span>
<span class="lineno"> 1648 </span><span class="spaces">        </span><span class="istickedoff">| <span class="nottickedoff">map fst (C.canonicalFields tm1) == map fst (C.canonicalFields tm2)</span> -&gt;</span>
<span class="lineno"> 1649 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">proveEq sc env (C.tTuple (map snd (C.canonicalFields tm1))) (C.tTuple (map snd (C.canonicalFields tm2)))</span></span>
<span class="lineno"> 1650 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1651 </span><span class="spaces">      </span><span class="istickedoff">-- XXX: add a case for `enum`</span>
<span class="lineno"> 1652 </span><span class="spaces">      </span><span class="istickedoff">-- 1. Match constructors by names, and prove fields as tuples</span>
<span class="lineno"> 1653 </span><span class="spaces">      </span><span class="istickedoff">-- 2. We need some way to combine the proofs of equality of</span>
<span class="lineno"> 1654 </span><span class="spaces">      </span><span class="istickedoff">-- the fields, into a proof for equality of the whole type</span>
<span class="lineno"> 1655 </span><span class="spaces">      </span><span class="istickedoff">-- for sums</span>
<span class="lineno"> 1656 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1657 </span><span class="spaces">      </span><span class="istickedoff">(_, _) -&gt;</span>
<span class="lineno"> 1658 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">panic &quot;proveEq&quot; [&quot;Internal type error:&quot;, pretty t1, pretty t2]</span></span></span>
<span class="lineno"> 1659 </span>
<span class="lineno"> 1660 </span>
<span class="lineno"> 1661 </span>-- | Resolve user types (type aliases and newtypes) to their simpler SAW-compatible forms.
<span class="lineno"> 1662 </span>tNoUser :: C.Type -&gt; C.Type
<span class="lineno"> 1663 </span><span class="decl"><span class="istickedoff">tNoUser initialTy =</span>
<span class="lineno"> 1664 </span><span class="spaces">  </span><span class="istickedoff">case C.tNoUser initialTy of</span>
<span class="lineno"> 1665 </span><span class="spaces">    </span><span class="istickedoff">C.TNominal nt params</span>
<span class="lineno"> 1666 </span><span class="spaces">      </span><span class="istickedoff">| C.Struct fs &lt;- <span class="nottickedoff">C.ntDef nt</span> -&gt;</span>
<span class="lineno"> 1667 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">if null params then C.TRec (C.ntFields fs)</span></span>
<span class="lineno"> 1668 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">else panic &quot;tNoUser&quot; [&quot;Nominal type with parameters&quot;]</span></span>
<span class="lineno"> 1669 </span><span class="spaces">                        </span><span class="istickedoff">-- XXX: We should instantiate, see #2019</span>
<span class="lineno"> 1670 </span><span class="spaces">    </span><span class="istickedoff">t -&gt; t</span></span>
<span class="lineno"> 1671 </span>
<span class="lineno"> 1672 </span>
<span class="lineno"> 1673 </span>-- | Deconstruct a cryptol tuple type as a pair according to the
<span class="lineno"> 1674 </span>-- saw-core tuple type encoding.
<span class="lineno"> 1675 </span>tIsPair :: C.Type -&gt; Maybe (C.Type, C.Type)
<span class="lineno"> 1676 </span><span class="decl"><span class="nottickedoff">tIsPair t =</span>
<span class="lineno"> 1677 </span><span class="spaces">  </span><span class="nottickedoff">do ts &lt;- C.tIsTuple t</span>
<span class="lineno"> 1678 </span><span class="spaces">     </span><span class="nottickedoff">case ts of</span>
<span class="lineno"> 1679 </span><span class="spaces">       </span><span class="nottickedoff">[] -&gt; Nothing</span>
<span class="lineno"> 1680 </span><span class="spaces">       </span><span class="nottickedoff">[t1, t2] -&gt; Just (t1, t2)</span>
<span class="lineno"> 1681 </span><span class="spaces">       </span><span class="nottickedoff">t1 : ts' -&gt; Just (t1, C.tTuple ts')</span></span>
<span class="lineno"> 1682 </span>
<span class="lineno"> 1683 </span>
<span class="lineno"> 1684 </span>--------------------------------------------------------------------------------
<span class="lineno"> 1685 </span>-- List comprehensions
<span class="lineno"> 1686 </span>
<span class="lineno"> 1687 </span>importComp :: SharedContext -&gt; Env -&gt; C.Type -&gt; C.Type -&gt; C.Expr -&gt; [[C.Match]] -&gt; IO Term
<span class="lineno"> 1688 </span><span class="decl"><span class="istickedoff">importComp sc env lenT elemT expr mss =</span>
<span class="lineno"> 1689 </span><span class="spaces">  </span><span class="istickedoff">do let zipAll [] = <span class="nottickedoff">panic &quot;importComp&quot; [&quot;zero-branch list comprehension&quot;]</span></span>
<span class="lineno"> 1690 </span><span class="spaces">         </span><span class="istickedoff">zipAll [branch] =</span>
<span class="lineno"> 1691 </span><span class="spaces">           </span><span class="istickedoff">do (xs, len, ty, args) &lt;- importMatches sc env branch</span>
<span class="lineno"> 1692 </span><span class="spaces">              </span><span class="istickedoff">m &lt;- importType sc env len</span>
<span class="lineno"> 1693 </span><span class="spaces">              </span><span class="istickedoff">a &lt;- importType sc env ty</span>
<span class="lineno"> 1694 </span><span class="spaces">              </span><span class="istickedoff">return (xs, m, a, [args], len)</span>
<span class="lineno"> 1695 </span><span class="spaces">         </span><span class="istickedoff">zipAll (branch : branches) =</span>
<span class="lineno"> 1696 </span><span class="spaces">           </span><span class="istickedoff">do (xs, len, ty, args) &lt;- importMatches sc env branch</span>
<span class="lineno"> 1697 </span><span class="spaces">              </span><span class="istickedoff">m &lt;- importType sc env len</span>
<span class="lineno"> 1698 </span><span class="spaces">              </span><span class="istickedoff">a &lt;- importType sc env ty</span>
<span class="lineno"> 1699 </span><span class="spaces">              </span><span class="istickedoff">(ys, n, b, argss, len') &lt;- zipAll branches</span>
<span class="lineno"> 1700 </span><span class="spaces">              </span><span class="istickedoff">ab &lt;- scTupleType sc [a, b]</span>
<span class="lineno"> 1701 </span><span class="spaces">              </span><span class="istickedoff">if len == len' then</span>
<span class="lineno"> 1702 </span><span class="spaces">                </span><span class="istickedoff">do zs &lt;- scGlobalApply sc &quot;Cryptol.seqZipSame&quot; [a, b, m, xs, ys]</span>
<span class="lineno"> 1703 </span><span class="spaces">                   </span><span class="istickedoff">return (zs, m, ab, args : argss, len)</span>
<span class="lineno"> 1704 </span><span class="spaces">              </span><span class="istickedoff">else</span>
<span class="lineno"> 1705 </span><span class="spaces">                </span><span class="istickedoff">do zs &lt;- scGlobalApply sc &quot;Cryptol.seqZip&quot; [a, b, m, n, xs, ys]</span>
<span class="lineno"> 1706 </span><span class="spaces">                   </span><span class="istickedoff">mn &lt;- scGlobalApply sc &quot;Cryptol.tcMin&quot; [m, n]</span>
<span class="lineno"> 1707 </span><span class="spaces">                   </span><span class="istickedoff">return (zs, mn, ab, args : argss, C.tMin len len')</span>
<span class="lineno"> 1708 </span><span class="spaces">     </span><span class="istickedoff">(xs, n, a, argss, lenT') &lt;- zipAll mss</span>
<span class="lineno"> 1709 </span><span class="spaces">     </span><span class="istickedoff">f &lt;- lambdaTuples sc env elemT expr argss</span>
<span class="lineno"> 1710 </span><span class="spaces">     </span><span class="istickedoff">b &lt;- importType sc env elemT</span>
<span class="lineno"> 1711 </span><span class="spaces">     </span><span class="istickedoff">ys &lt;- scGlobalApply sc &quot;Cryptol.seqMap&quot; [a, b, n, f, xs]</span>
<span class="lineno"> 1712 </span><span class="spaces">     </span><span class="istickedoff">-- The resulting type might not match the annotation, so we coerce</span>
<span class="lineno"> 1713 </span><span class="spaces">     </span><span class="istickedoff">coerceTerm sc env (C.tSeq lenT' elemT) (C.tSeq lenT elemT) ys</span></span>
<span class="lineno"> 1714 </span>
<span class="lineno"> 1715 </span>lambdaTuples :: SharedContext -&gt; Env -&gt; C.Type -&gt; C.Expr -&gt; [[(C.Name, C.Type)]] -&gt; IO Term
<span class="lineno"> 1716 </span><span class="decl"><span class="istickedoff">lambdaTuples sc env _ty expr [] = importExpr sc env expr</span>
<span class="lineno"> 1717 </span><span class="spaces"></span><span class="istickedoff">lambdaTuples sc env ty expr (args : argss) =</span>
<span class="lineno"> 1718 </span><span class="spaces">  </span><span class="istickedoff">do f &lt;- lambdaTuple sc env ty expr argss args</span>
<span class="lineno"> 1719 </span><span class="spaces">     </span><span class="istickedoff">if null args || null argss</span>
<span class="lineno"> 1720 </span><span class="spaces">       </span><span class="istickedoff">then return f</span>
<span class="lineno"> 1721 </span><span class="spaces">       </span><span class="istickedoff">else do a &lt;- importType sc env (tNestedTuple (map snd args))</span>
<span class="lineno"> 1722 </span><span class="spaces">               </span><span class="istickedoff">b &lt;- importType sc env (tNestedTuple (map (tNestedTuple . map snd) argss))</span>
<span class="lineno"> 1723 </span><span class="spaces">               </span><span class="istickedoff">c &lt;- importType sc env ty</span>
<span class="lineno"> 1724 </span><span class="spaces">               </span><span class="istickedoff">scGlobalApply sc &quot;Prelude.uncurry&quot; [a, b, c, f]</span></span>
<span class="lineno"> 1725 </span>
<span class="lineno"> 1726 </span>lambdaTuple :: SharedContext -&gt; Env -&gt; C.Type -&gt; C.Expr -&gt; [[(C.Name, C.Type)]] -&gt; [(C.Name, C.Type)] -&gt; IO Term
<span class="lineno"> 1727 </span><span class="decl"><span class="istickedoff">lambdaTuple sc env ty expr argss [] = lambdaTuples sc env ty expr argss</span>
<span class="lineno"> 1728 </span><span class="spaces"></span><span class="istickedoff">lambdaTuple sc env ty expr argss ((x, t) : args) =</span>
<span class="lineno"> 1729 </span><span class="spaces">  </span><span class="istickedoff">do a &lt;- importType sc env t</span>
<span class="lineno"> 1730 </span><span class="spaces">     </span><span class="istickedoff">env' &lt;- bindName sc x (C.Forall [] [] t) env</span>
<span class="lineno"> 1731 </span><span class="spaces">     </span><span class="istickedoff">e &lt;- lambdaTuple sc env' ty expr argss args</span>
<span class="lineno"> 1732 </span><span class="spaces">     </span><span class="istickedoff">f &lt;- scLambda sc (nameToLocalName x) a e</span>
<span class="lineno"> 1733 </span><span class="spaces">     </span><span class="istickedoff">if null args</span>
<span class="lineno"> 1734 </span><span class="spaces">        </span><span class="istickedoff">then return f</span>
<span class="lineno"> 1735 </span><span class="spaces">        </span><span class="istickedoff">else do b &lt;- importType sc env (tNestedTuple (map snd args))</span>
<span class="lineno"> 1736 </span><span class="spaces">                </span><span class="istickedoff">let <span class="nottickedoff">tuple = tNestedTuple (map (tNestedTuple . map snd) argss)</span></span>
<span class="lineno"> 1737 </span><span class="spaces">                </span><span class="istickedoff">c &lt;- importType sc env (if <span class="tickonlytrue">null argss</span> then ty else <span class="nottickedoff">C.tFun tuple ty</span>)</span>
<span class="lineno"> 1738 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Prelude.uncurry&quot; [a, b, c, f]</span></span>
<span class="lineno"> 1739 </span>
<span class="lineno"> 1740 </span>tNestedTuple :: [C.Type] -&gt; C.Type
<span class="lineno"> 1741 </span><span class="decl"><span class="istickedoff">tNestedTuple [] = <span class="nottickedoff">C.tTuple []</span></span>
<span class="lineno"> 1742 </span><span class="spaces"></span><span class="istickedoff">tNestedTuple [t] = t</span>
<span class="lineno"> 1743 </span><span class="spaces"></span><span class="istickedoff">tNestedTuple (t : ts) = C.tTuple [t, tNestedTuple ts]</span></span>
<span class="lineno"> 1744 </span>
<span class="lineno"> 1745 </span>
<span class="lineno"> 1746 </span>-- | Returns the shared term, length type, element tuple type, bound
<span class="lineno"> 1747 </span>-- variables.
<span class="lineno"> 1748 </span>importMatches :: SharedContext -&gt; Env -&gt; [C.Match]
<span class="lineno"> 1749 </span>              -&gt; IO (Term, C.Type, C.Type, [(C.Name, C.Type)])
<span class="lineno"> 1750 </span><span class="decl"><span class="istickedoff">importMatches _sc _env [] = <span class="nottickedoff">panic &quot;importMatches&quot; [&quot;importMatches: empty comprehension branch&quot;]</span></span>
<span class="lineno"> 1751 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1752 </span><span class="spaces"></span><span class="istickedoff">importMatches sc env [C.From name _len _eltty expr] = do</span>
<span class="lineno"> 1753 </span><span class="spaces">  </span><span class="istickedoff">(len, ty) &lt;- case C.tIsSeq (fastTypeOf (envC env) expr) of</span>
<span class="lineno"> 1754 </span><span class="spaces">                 </span><span class="istickedoff">Just x -&gt; return x</span>
<span class="lineno"> 1755 </span><span class="spaces">                 </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">panic &quot;importMatches&quot; [&quot;type mismatch from: &quot; ++ show (fastTypeOf (envC env) expr)]</span></span>
<span class="lineno"> 1756 </span><span class="spaces">  </span><span class="istickedoff">xs &lt;- importExpr sc env expr</span>
<span class="lineno"> 1757 </span><span class="spaces">  </span><span class="istickedoff">return (xs, len, ty, [(name, ty)])</span>
<span class="lineno"> 1758 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1759 </span><span class="spaces"></span><span class="istickedoff">importMatches sc env (C.From name _len _eltty expr : matches) = do</span>
<span class="lineno"> 1760 </span><span class="spaces">  </span><span class="istickedoff">(len1, ty1) &lt;- case C.tIsSeq (fastTypeOf (envC env) expr) of</span>
<span class="lineno"> 1761 </span><span class="spaces">                   </span><span class="istickedoff">Just x -&gt; return x</span>
<span class="lineno"> 1762 </span><span class="spaces">                   </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">panic &quot;importMatches&quot; [&quot;type mismatch from: &quot; ++ show (fastTypeOf (envC env) expr)]</span></span>
<span class="lineno"> 1763 </span><span class="spaces">  </span><span class="istickedoff">m &lt;- importType sc env len1</span>
<span class="lineno"> 1764 </span><span class="spaces">  </span><span class="istickedoff">a &lt;- importType sc env ty1</span>
<span class="lineno"> 1765 </span><span class="spaces">  </span><span class="istickedoff">xs &lt;- importExpr sc env expr</span>
<span class="lineno"> 1766 </span><span class="spaces">  </span><span class="istickedoff">env' &lt;- bindName sc name (C.Forall [] [] ty1) env</span>
<span class="lineno"> 1767 </span><span class="spaces">  </span><span class="istickedoff">(body, len2, ty2, args) &lt;- importMatches sc env' matches</span>
<span class="lineno"> 1768 </span><span class="spaces">  </span><span class="istickedoff">n &lt;- importType sc env len2</span>
<span class="lineno"> 1769 </span><span class="spaces">  </span><span class="istickedoff">b &lt;- importType sc env ty2</span>
<span class="lineno"> 1770 </span><span class="spaces">  </span><span class="istickedoff">f &lt;- scLambda sc (nameToLocalName name) a body</span>
<span class="lineno"> 1771 </span><span class="spaces">  </span><span class="istickedoff">result &lt;- scGlobalApply sc &quot;Cryptol.from&quot; [a, b, m, n, xs, f]</span>
<span class="lineno"> 1772 </span><span class="spaces">  </span><span class="istickedoff">return (result, C.tMul len1 len2, C.tTuple [ty1, ty2], (name, ty1) : args)</span>
<span class="lineno"> 1773 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1774 </span><span class="spaces"></span><span class="istickedoff">importMatches sc env [C.Let decl]</span>
<span class="lineno"> 1775 </span><span class="spaces">  </span><span class="istickedoff">| C.DPrim &lt;- C.dDefinition decl = <span class="nottickedoff">do</span></span>
<span class="lineno"> 1776 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importMatches&quot; [&quot;Primitive declarations not allowed in 'let':&quot;, show (C.dName decl)]</span></span>
<span class="lineno"> 1777 </span><span class="spaces">  </span><span class="istickedoff">| C.DExpr expr &lt;- C.dDefinition decl = do</span>
<span class="lineno"> 1778 </span><span class="spaces">     </span><span class="istickedoff">e &lt;- importExpr sc env expr</span>
<span class="lineno"> 1779 </span><span class="spaces">     </span><span class="istickedoff">ty1 &lt;- case C.dSignature decl of</span>
<span class="lineno"> 1780 </span><span class="spaces">              </span><span class="istickedoff">C.Forall [] [] ty1 -&gt; return ty1</span>
<span class="lineno"> 1781 </span><span class="spaces">              </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">unimplemented &quot;polymorphic Let&quot;</span></span>
<span class="lineno"> 1782 </span><span class="spaces">     </span><span class="istickedoff">a &lt;- importType sc env ty1</span>
<span class="lineno"> 1783 </span><span class="spaces">     </span><span class="istickedoff">result &lt;- scGlobalApply sc &quot;Prelude.single&quot; [a, e]</span>
<span class="lineno"> 1784 </span><span class="spaces">     </span><span class="istickedoff">return (result, C.tOne, ty1, [(C.dName decl, ty1)])</span>
<span class="lineno"> 1785 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1786 </span><span class="spaces"></span><span class="istickedoff">importMatches sc env (C.Let decl : matches) =</span>
<span class="lineno"> 1787 </span><span class="spaces">  </span><span class="istickedoff">case C.dDefinition decl of</span>
<span class="lineno"> 1788 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1789 </span><span class="spaces">    </span><span class="istickedoff">C.DForeign {} -&gt;</span>
<span class="lineno"> 1790 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importMatches&quot; [&quot;Foreign declarations not allowed in 'let':&quot;, show (C.dName decl)]</span></span>
<span class="lineno"> 1791 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1792 </span><span class="spaces">    </span><span class="istickedoff">C.DPrim -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno"> 1793 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importMatches&quot; [&quot;Primitive declarations not allowed in 'let':&quot;, show (C.dName decl)]</span></span>
<span class="lineno"> 1794 </span><span class="spaces">    </span><span class="istickedoff">C.DExpr expr -&gt; do</span>
<span class="lineno"> 1795 </span><span class="spaces">     </span><span class="istickedoff">e &lt;- importExpr sc env expr</span>
<span class="lineno"> 1796 </span><span class="spaces">     </span><span class="istickedoff">ty1 &lt;- case C.dSignature decl of</span>
<span class="lineno"> 1797 </span><span class="spaces">              </span><span class="istickedoff">C.Forall [] [] ty1 -&gt; return ty1</span>
<span class="lineno"> 1798 </span><span class="spaces">              </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">unimplemented &quot;polymorphic Let&quot;</span></span>
<span class="lineno"> 1799 </span><span class="spaces">     </span><span class="istickedoff">a &lt;- importType sc env ty1</span>
<span class="lineno"> 1800 </span><span class="spaces">     </span><span class="istickedoff">env' &lt;- bindName sc (C.dName decl) (C.dSignature decl) env</span>
<span class="lineno"> 1801 </span><span class="spaces">     </span><span class="istickedoff">(body, len, ty2, args) &lt;- importMatches sc env' matches</span>
<span class="lineno"> 1802 </span><span class="spaces">     </span><span class="istickedoff">n &lt;- importType sc env len</span>
<span class="lineno"> 1803 </span><span class="spaces">     </span><span class="istickedoff">b &lt;- importType sc env ty2</span>
<span class="lineno"> 1804 </span><span class="spaces">     </span><span class="istickedoff">f &lt;- scLambda sc (nameToLocalName (C.dName decl)) a body</span>
<span class="lineno"> 1805 </span><span class="spaces">     </span><span class="istickedoff">result &lt;- scGlobalApply sc &quot;Cryptol.mlet&quot; [a, b, n, e, f]</span>
<span class="lineno"> 1806 </span><span class="spaces">     </span><span class="istickedoff">return (result, len, C.tTuple [ty1, ty2], (C.dName decl, ty1) : args)</span></span>
<span class="lineno"> 1807 </span>
<span class="lineno"> 1808 </span>
<span class="lineno"> 1809 </span>--------------------------------------------------------------------------------
<span class="lineno"> 1810 </span>-- Utilities
<span class="lineno"> 1811 </span>
<span class="lineno"> 1812 </span>asCryptolTypeValue :: SC.TValue SC.Concrete -&gt; Maybe (Either C.Kind C.Type)
<span class="lineno"> 1813 </span><span class="decl"><span class="istickedoff">asCryptolTypeValue v =</span>
<span class="lineno"> 1814 </span><span class="spaces">  </span><span class="istickedoff">case v of</span>
<span class="lineno"> 1815 </span><span class="spaces">    </span><span class="istickedoff">SC.VBoolType -&gt; return (Right C.tBit)</span>
<span class="lineno"> 1816 </span><span class="spaces">    </span><span class="istickedoff">SC.VIntType -&gt; <span class="nottickedoff">return (Right C.tInteger)</span></span>
<span class="lineno"> 1817 </span><span class="spaces">    </span><span class="istickedoff">SC.VIntModType n -&gt; <span class="nottickedoff">return (Right (C.tIntMod (C.tNum n)))</span></span>
<span class="lineno"> 1818 </span><span class="spaces">    </span><span class="istickedoff">SC.VArrayType v1 v2 -&gt; do</span>
<span class="lineno"> 1819 </span><span class="spaces">      </span><span class="istickedoff">Right t1 &lt;- asCryptolTypeValue v1</span>
<span class="lineno"> 1820 </span><span class="spaces">      </span><span class="istickedoff">Right t2 &lt;- asCryptolTypeValue v2</span>
<span class="lineno"> 1821 </span><span class="spaces">      </span><span class="istickedoff">return (Right (C.tArray t1 t2))</span>
<span class="lineno"> 1822 </span><span class="spaces">    </span><span class="istickedoff">SC.VVecType n v2 -&gt; do</span>
<span class="lineno"> 1823 </span><span class="spaces">      </span><span class="istickedoff">Right t2 &lt;- asCryptolTypeValue v2</span>
<span class="lineno"> 1824 </span><span class="spaces">      </span><span class="istickedoff">return (Right (C.tSeq (C.tNum n) t2))</span>
<span class="lineno"> 1825 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1826 </span><span class="spaces">    </span><span class="istickedoff">SC.VDataType (primName -&gt; &quot;Prelude.Stream&quot;) [SC.TValue v1] [] -&gt;</span>
<span class="lineno"> 1827 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">do Right t1 &lt;- asCryptolTypeValue v1</span></span>
<span class="lineno"> 1828 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">return (Right (C.tSeq C.tInf t1))</span></span>
<span class="lineno"> 1829 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1830 </span><span class="spaces">    </span><span class="istickedoff">SC.VDataType (primName -&gt; &quot;Cryptol.Num&quot;) [] [] -&gt;</span>
<span class="lineno"> 1831 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">return (Left C.KNum)</span></span>
<span class="lineno"> 1832 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1833 </span><span class="spaces">    </span><span class="istickedoff">SC.VDataType _ _ _ -&gt; Nothing</span>
<span class="lineno"> 1834 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1835 </span><span class="spaces">    </span><span class="istickedoff">SC.VUnitType -&gt; return (Right <span class="nottickedoff">(C.tTuple [])</span>)</span>
<span class="lineno"> 1836 </span><span class="spaces">    </span><span class="istickedoff">SC.VPairType v1 v2 -&gt; do</span>
<span class="lineno"> 1837 </span><span class="spaces">      </span><span class="istickedoff">Right t1 &lt;- asCryptolTypeValue v1</span>
<span class="lineno"> 1838 </span><span class="spaces">      </span><span class="istickedoff">Right t2 &lt;- asCryptolTypeValue v2</span>
<span class="lineno"> 1839 </span><span class="spaces">      </span><span class="istickedoff">case C.tIsTuple t2 of</span>
<span class="lineno"> 1840 </span><span class="spaces">        </span><span class="istickedoff">Just ts -&gt; return (Right <span class="nottickedoff">(C.tTuple (t1 : ts))</span>)</span>
<span class="lineno"> 1841 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; return (Right (C.tTuple [t1, t2]))</span>
<span class="lineno"> 1842 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1843 </span><span class="spaces">    </span><span class="istickedoff">SC.VPiType _nm v1 (SC.VNondependentPi v2) -&gt;</span>
<span class="lineno"> 1844 </span><span class="spaces">      </span><span class="istickedoff">do Right t1 &lt;- asCryptolTypeValue v1</span>
<span class="lineno"> 1845 </span><span class="spaces">         </span><span class="istickedoff">Right t2 &lt;- asCryptolTypeValue v2</span>
<span class="lineno"> 1846 </span><span class="spaces">         </span><span class="istickedoff">return (Right (C.tFun t1 t2))</span>
<span class="lineno"> 1847 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1848 </span><span class="spaces">    </span><span class="istickedoff">SC.VSort s</span>
<span class="lineno"> 1849 </span><span class="spaces">      </span><span class="istickedoff">| s == mkSort 0 -&gt; return (Left <span class="nottickedoff">C.KType</span>)</span>
<span class="lineno"> 1850 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span>     -&gt; Nothing</span>
<span class="lineno"> 1851 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1852 </span><span class="spaces">    </span><span class="istickedoff">-- TODO?</span>
<span class="lineno"> 1853 </span><span class="spaces">    </span><span class="istickedoff">SC.VPiType _nm _v1 (SC.VDependentPi _) -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 1854 </span><span class="spaces">    </span><span class="istickedoff">SC.VStringType -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 1855 </span><span class="spaces">    </span><span class="istickedoff">SC.VRecordType{} -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 1856 </span><span class="spaces">    </span><span class="istickedoff">SC.VRecursorType{} -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 1857 </span><span class="spaces">    </span><span class="istickedoff">SC.VTyTerm{} -&gt; <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno"> 1858 </span>
<span class="lineno"> 1859 </span>
<span class="lineno"> 1860 </span>scCryptolType :: SharedContext -&gt; Term -&gt; IO (Maybe (Either C.Kind C.Type))
<span class="lineno"> 1861 </span><span class="decl"><span class="istickedoff">scCryptolType sc t =</span>
<span class="lineno"> 1862 </span><span class="spaces">  </span><span class="istickedoff">do modmap &lt;- scGetModuleMap sc</span>
<span class="lineno"> 1863 </span><span class="spaces">     </span><span class="istickedoff">catch</span>
<span class="lineno"> 1864 </span><span class="spaces">       </span><span class="istickedoff">(case SC.evalSharedTerm <span class="nottickedoff">modmap</span> Map.empty <span class="nottickedoff">Map.empty</span> t of</span>
<span class="lineno"> 1865 </span><span class="spaces">           </span><span class="istickedoff">-- NOTE: we make sure that asCryptolTypeValue gets evaluated, to</span>
<span class="lineno"> 1866 </span><span class="spaces">           </span><span class="istickedoff">-- ensure that any panics in the simulator get caught here</span>
<span class="lineno"> 1867 </span><span class="spaces">           </span><span class="istickedoff">SC.TValue tv</span>
<span class="lineno"> 1868 </span><span class="spaces">             </span><span class="istickedoff">| Just !ret &lt;- asCryptolTypeValue tv -&gt; return $ Just ret</span>
<span class="lineno"> 1869 </span><span class="spaces">           </span><span class="istickedoff">_ -&gt; return Nothing)</span>
<span class="lineno"> 1870 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">(\ (_::SomeException) -&gt; return Nothing)</span></span></span>
<span class="lineno"> 1871 </span>
<span class="lineno"> 1872 </span>-- | Convert from SAWCore's Value type to Cryptol's, guided by the
<span class="lineno"> 1873 </span>-- Cryptol type schema.
<span class="lineno"> 1874 </span>exportValueWithSchema :: C.Schema -&gt; SC.CValue -&gt; V.Eval V.Value
<span class="lineno"> 1875 </span><span class="decl"><span class="istickedoff">exportValueWithSchema (C.Forall [] [] ty) v = exportValue (evalValType <span class="nottickedoff">mempty</span> ty) v</span>
<span class="lineno"> 1876 </span><span class="spaces"></span><span class="istickedoff">exportValueWithSchema _ _ = <span class="nottickedoff">pure (V.VPoly mempty (error &quot;exportValueWithSchema&quot;))</span></span></span>
<span class="lineno"> 1877 </span>-- TODO: proper support for polymorphic values
<span class="lineno"> 1878 </span>
<span class="lineno"> 1879 </span>exportValue :: TV.TValue -&gt; SC.CValue -&gt; V.Eval V.Value
<span class="lineno"> 1880 </span><span class="decl"><span class="istickedoff">exportValue ty v = case ty of</span>
<span class="lineno"> 1881 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1882 </span><span class="spaces">  </span><span class="istickedoff">TV.TVBit -&gt;</span>
<span class="lineno"> 1883 </span><span class="spaces">    </span><span class="istickedoff">pure (V.VBit (SC.toBool v))</span>
<span class="lineno"> 1884 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1885 </span><span class="spaces">  </span><span class="istickedoff">TV.TVInteger -&gt;</span>
<span class="lineno"> 1886 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">pure (V.VInteger (case v of SC.VInt x -&gt; x; _ -&gt; error &quot;exportValue: expected integer&quot;))</span></span>
<span class="lineno"> 1887 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1888 </span><span class="spaces">  </span><span class="istickedoff">TV.TVIntMod _modulus -&gt;</span>
<span class="lineno"> 1889 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">pure (V.VInteger (case v of SC.VIntMod _ x -&gt; x; _ -&gt; error &quot;exportValue: expected intmod&quot;))</span></span>
<span class="lineno"> 1890 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1891 </span><span class="spaces">  </span><span class="istickedoff">TV.TVArray{} -&gt; <span class="nottickedoff">error $ &quot;exportValue: (on array type &quot; ++ show ty ++ &quot;)&quot;</span></span>
<span class="lineno"> 1892 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1893 </span><span class="spaces">  </span><span class="istickedoff">TV.TVRational -&gt; <span class="nottickedoff">error &quot;exportValue: Not yet implemented: Rational&quot;</span></span>
<span class="lineno"> 1894 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1895 </span><span class="spaces">  </span><span class="istickedoff">TV.TVFloat _ _ -&gt; <span class="nottickedoff">panic &quot;exportValue: Not yet implemented: Float&quot; []</span></span>
<span class="lineno"> 1896 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1897 </span><span class="spaces">  </span><span class="istickedoff">TV.TVSeq _ e -&gt;</span>
<span class="lineno"> 1898 </span><span class="spaces">    </span><span class="istickedoff">case v of</span>
<span class="lineno"> 1899 </span><span class="spaces">      </span><span class="istickedoff">SC.VWord w -&gt; V.word <span class="nottickedoff">V.Concrete</span> (toInteger (width w)) (unsigned w)</span>
<span class="lineno"> 1900 </span><span class="spaces">      </span><span class="istickedoff">SC.VVector xs</span>
<span class="lineno"> 1901 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlytrue">TV.isTBit e</span> -&gt; V.VWord &lt;$&gt;</span>
<span class="lineno"> 1902 </span><span class="spaces">            </span><span class="istickedoff">V.bitmapWordVal <span class="nottickedoff">V.Concrete</span> (toInteger (Vector.length xs))</span>
<span class="lineno"> 1903 </span><span class="spaces">                 </span><span class="istickedoff">(V.finiteSeqMap <span class="nottickedoff">V.Concrete</span> . map (V.ready . SC.toBool . SC.runIdentity . force) $ Fold.toList xs)</span>
<span class="lineno"> 1904 </span><span class="spaces">        </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span>   -&gt; <span class="nottickedoff">V.mkSeq V.Concrete (C.Nat (toInteger (Vector.length xs))) e $ V.finiteSeqMap V.Concrete $</span></span>
<span class="lineno"> 1905 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">map (\x -&gt; exportValue e (SC.runIdentity (force x))) (Vector.toList xs)</span></span>
<span class="lineno"> 1906 </span><span class="spaces">      </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">error $ &quot;exportValue (on seq type &quot; ++ show ty ++ &quot;)&quot;</span></span>
<span class="lineno"> 1907 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1908 </span><span class="spaces">  </span><span class="istickedoff">-- infinite streams</span>
<span class="lineno"> 1909 </span><span class="spaces">  </span><span class="istickedoff">TV.TVStream e -&gt;</span>
<span class="lineno"> 1910 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">case v of</span></span>
<span class="lineno"> 1911 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">SC.VExtra (SC.CStream trie) -&gt; pure $ V.VStream (V.indexSeqMap $ \i -&gt; exportValue e (IntTrie.apply trie i))</span></span>
<span class="lineno"> 1912 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; error $ &quot;exportValue (on seq type &quot; ++ show ty ++ &quot;)&quot;</span></span>
<span class="lineno"> 1913 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1914 </span><span class="spaces">  </span><span class="istickedoff">-- tuples</span>
<span class="lineno"> 1915 </span><span class="spaces">  </span><span class="istickedoff">TV.TVTuple etys -&gt; <span class="nottickedoff">pure $ V.VTuple $ exportTupleValue etys v</span></span>
<span class="lineno"> 1916 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1917 </span><span class="spaces">  </span><span class="istickedoff">-- records</span>
<span class="lineno"> 1918 </span><span class="spaces">  </span><span class="istickedoff">TV.TVRec fields -&gt;</span>
<span class="lineno"> 1919 </span><span class="spaces">      </span><span class="istickedoff">pure . V.VRecord . C.recordFromFieldsWithDisplay (C.displayOrder fields) $ exportRecordValue (C.canonicalFields fields) v</span>
<span class="lineno"> 1920 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1921 </span><span class="spaces">  </span><span class="istickedoff">-- functions</span>
<span class="lineno"> 1922 </span><span class="spaces">  </span><span class="istickedoff">TV.TVFun _aty _bty -&gt;</span>
<span class="lineno"> 1923 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">pure $ V.VFun mempty (error &quot;exportValue: TODO functions&quot;)</span></span>
<span class="lineno"> 1924 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1925 </span><span class="spaces">  </span><span class="istickedoff">-- nominal types</span>
<span class="lineno"> 1926 </span><span class="spaces">  </span><span class="istickedoff">TV.TVNominal _ _ fields -&gt;</span>
<span class="lineno"> 1927 </span><span class="spaces">    </span><span class="istickedoff">case fields of</span>
<span class="lineno"> 1928 </span><span class="spaces">      </span><span class="istickedoff">TV.TVStruct fs   -&gt; exportValue (TV.TVRec fs) v</span>
<span class="lineno"> 1929 </span><span class="spaces">      </span><span class="istickedoff">TV.TVEnum {}     -&gt; <span class="nottickedoff">error &quot;exportValue: TODO enum&quot;</span></span>
<span class="lineno"> 1930 </span><span class="spaces">      </span><span class="istickedoff">TV.TVAbstract {} -&gt; <span class="nottickedoff">error &quot;exportValue: TODO abstract types&quot;</span></span></span>
<span class="lineno"> 1931 </span>
<span class="lineno"> 1932 </span>
<span class="lineno"> 1933 </span>exportTupleValue :: [TV.TValue] -&gt; SC.CValue -&gt; [V.Eval V.Value]
<span class="lineno"> 1934 </span><span class="decl"><span class="nottickedoff">exportTupleValue tys v =</span>
<span class="lineno"> 1935 </span><span class="spaces">  </span><span class="nottickedoff">case (tys, v) of</span>
<span class="lineno"> 1936 </span><span class="spaces">    </span><span class="nottickedoff">([]    , SC.VUnit    ) -&gt; []</span>
<span class="lineno"> 1937 </span><span class="spaces">    </span><span class="nottickedoff">([t]   , _           ) -&gt; [exportValue t v]</span>
<span class="lineno"> 1938 </span><span class="spaces">    </span><span class="nottickedoff">(t : ts, SC.VPair x y) -&gt; (exportValue t (run x)) : exportTupleValue ts (run y)</span>
<span class="lineno"> 1939 </span><span class="spaces">    </span><span class="nottickedoff">_                      -&gt; error $ &quot;exportValue: expected tuple&quot;</span>
<span class="lineno"> 1940 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno"> 1941 </span><span class="spaces">    </span><span class="nottickedoff">run = SC.runIdentity . force</span></span>
<span class="lineno"> 1942 </span>
<span class="lineno"> 1943 </span>exportRecordValue :: [(C.Ident, TV.TValue)] -&gt; SC.CValue -&gt; [(C.Ident, V.Eval V.Value)]
<span class="lineno"> 1944 </span><span class="decl"><span class="istickedoff">exportRecordValue fields v =</span>
<span class="lineno"> 1945 </span><span class="spaces">  </span><span class="istickedoff">case (fields, <span class="nottickedoff">v</span>) of</span>
<span class="lineno"> 1946 </span><span class="spaces">    </span><span class="istickedoff">([]         , SC.VUnit    ) -&gt; <span class="nottickedoff">[]</span></span>
<span class="lineno"> 1947 </span><span class="spaces">    </span><span class="istickedoff">([(n, t)]   , _           ) -&gt; [(n, exportValue t v)]</span>
<span class="lineno"> 1948 </span><span class="spaces">    </span><span class="istickedoff">((n, t) : ts, SC.VPair x y) -&gt; <span class="nottickedoff">(n, exportValue t (run x)) : exportRecordValue ts (run y)</span></span>
<span class="lineno"> 1949 </span><span class="spaces">    </span><span class="istickedoff">(_, SC.VRecordValue (alistAllFields</span>
<span class="lineno"> 1950 </span><span class="spaces">                         </span><span class="istickedoff">(map (C.identText . fst) fields) -&gt; Just ths)) -&gt;</span>
<span class="lineno"> 1951 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">zipWith (\(n,t) x -&gt; (n, exportValue t (run x))) fields ths</span></span>
<span class="lineno"> 1952 </span><span class="spaces">    </span><span class="istickedoff">_                              -&gt; <span class="nottickedoff">error $ &quot;exportValue: expected record&quot;</span></span>
<span class="lineno"> 1953 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1954 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">run = SC.runIdentity . force</span></span></span>
<span class="lineno"> 1955 </span>
<span class="lineno"> 1956 </span>-- | Generate functions to construct nominal values in the term environment.
<span class="lineno"> 1957 </span>-- For structs, make identity functions that take the record the newtype wraps.
<span class="lineno"> 1958 </span>-- Abstract types do not produce any functions.
<span class="lineno"> 1959 </span>genNominalConstructors :: SharedContext -&gt; Map C.Name NominalType -&gt; Env -&gt; IO Env
<span class="lineno"> 1960 </span><span class="decl"><span class="istickedoff">genNominalConstructors sc nominal env0 =</span>
<span class="lineno"> 1961 </span><span class="spaces">  </span><span class="istickedoff">foldM genConstr env0 nominal</span>
<span class="lineno"> 1962 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1963 </span><span class="spaces">    </span><span class="istickedoff">genConstr :: Env -&gt; NominalType -&gt; IO Env</span>
<span class="lineno"> 1964 </span><span class="spaces">    </span><span class="istickedoff">genConstr env nt = do</span>
<span class="lineno"> 1965 </span><span class="spaces">      </span><span class="istickedoff">let conTs = C.nominalTypeConTypes nt</span>
<span class="lineno"> 1966 </span><span class="spaces">      </span><span class="istickedoff">constrs &lt;- forM (nominalConstrs nt) $ \(x,e) -&gt;</span>
<span class="lineno"> 1967 </span><span class="spaces">        </span><span class="istickedoff">do e' &lt;- importExpr sc env e</span>
<span class="lineno"> 1968 </span><span class="spaces">           </span><span class="istickedoff">pure (x,(e',0))</span>
<span class="lineno"> 1969 </span><span class="spaces">      </span><span class="istickedoff">let env' = env { envE = foldr (uncurry Map.insert) (envE env) constrs</span>
<span class="lineno"> 1970 </span><span class="spaces">                     </span><span class="istickedoff">, envC = foldr (uncurry Map.insert) (envC env) conTs</span>
<span class="lineno"> 1971 </span><span class="spaces">                     </span><span class="istickedoff">}</span>
<span class="lineno"> 1972 </span><span class="spaces">      </span><span class="istickedoff">return env'</span>
<span class="lineno"> 1973 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1974 </span><span class="spaces">    </span><span class="istickedoff">nominalConstrs :: NominalType -&gt; [(C.Name,C.Expr)]</span>
<span class="lineno"> 1975 </span><span class="spaces">    </span><span class="istickedoff">nominalConstrs nt =</span>
<span class="lineno"> 1976 </span><span class="spaces">      </span><span class="istickedoff">case C.ntDef nt of</span>
<span class="lineno"> 1977 </span><span class="spaces">        </span><span class="istickedoff">C.Struct fs -&gt;</span>
<span class="lineno"> 1978 </span><span class="spaces">          </span><span class="istickedoff">let recTy = C.TRec (C.ntFields fs)</span>
<span class="lineno"> 1979 </span><span class="spaces">              </span><span class="istickedoff">fn    = C.EAbs paramName recTy (C.EVar paramName)</span>
<span class="lineno"> 1980 </span><span class="spaces">              </span><span class="istickedoff">con   = C.ntConName fs</span>
<span class="lineno"> 1981 </span><span class="spaces">              </span><span class="istickedoff">paramName = C.asLocal <span class="nottickedoff">C.NSValue</span> con</span>
<span class="lineno"> 1982 </span><span class="spaces">           </span><span class="istickedoff">in [(con, foldr <span class="nottickedoff">tFn</span> fn (C.ntParams nt))]</span>
<span class="lineno"> 1983 </span><span class="spaces">        </span><span class="istickedoff">C.Abstract -&gt; <span class="nottickedoff">[]</span></span>
<span class="lineno"> 1984 </span><span class="spaces">        </span><span class="istickedoff">C.Enum {} -&gt; error &quot;genNominalConstrurctors: `enum` is not yet supported&quot;</span>
<span class="lineno"> 1985 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno"> 1986 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1987 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">tFn tp body =</span></span>
<span class="lineno"> 1988 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">if elem (C.tpKind tp) [C.KType, C.KNum]</span></span>
<span class="lineno"> 1989 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">then C.ETAbs tp body</span></span>
<span class="lineno"> 1990 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">else panic &quot;genNominalConstructors&quot; [&quot;illegal nominal type parameter kind&quot;, show (C.tpKind tp)]</span></span></span>

</pre>
</body>
</html>
