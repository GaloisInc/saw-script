<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE GADTs #-}
<span class="lineno">    2 </span>{-# LANGUAGE MultiParamTypeClasses #-}
<span class="lineno">    3 </span>{-# LANGUAGE FlexibleContexts #-}
<span class="lineno">    4 </span>{-# LANGUAGE FlexibleInstances #-}
<span class="lineno">    5 </span>{-# LANGUAGE UndecidableInstances #-}
<span class="lineno">    6 </span>{-# LANGUAGE KindSignatures #-}
<span class="lineno">    7 </span>{-# LANGUAGE DataKinds #-}
<span class="lineno">    8 </span>{-# LANGUAGE PolyKinds #-}
<span class="lineno">    9 </span>{-# LANGUAGE TypeFamilies #-}
<span class="lineno">   10 </span>{-# LANGUAGE TypeOperators #-}
<span class="lineno">   11 </span>{-# LANGUAGE RankNTypes #-}
<span class="lineno">   12 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">   13 </span>{-# LANGUAGE TypeApplications #-}
<span class="lineno">   14 </span>{-# LANGUAGE FunctionalDependencies #-}
<span class="lineno">   15 </span>{-# LANGUAGE ViewPatterns #-}
<span class="lineno">   16 </span>{-# LANGUAGE PartialTypeSignatures #-}
<span class="lineno">   17 </span>{-# LANGUAGE TemplateHaskell #-}
<span class="lineno">   18 </span>{-# LANGUAGE QuasiQuotes #-}
<span class="lineno">   19 </span>{-# LANGUAGE PatternSynonyms #-}
<span class="lineno">   20 </span>{-# LANGUAGE PatternGuards #-}
<span class="lineno">   21 </span>{-# LANGUAGE EmptyCase #-}
<span class="lineno">   22 </span>{-# LANGUAGE TupleSections #-}
<span class="lineno">   23 </span>{-# LANGUAGE RecordWildCards #-}
<span class="lineno">   24 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">   25 </span>{-# LANGUAGE StandaloneDeriving #-}
<span class="lineno">   26 </span>{-# LANGUAGE EmptyDataDecls #-}
<span class="lineno">   27 </span>{-# OPTIONS_GHC -Wno-orphans #-}
<span class="lineno">   28 </span>module Heapster.Permissions where
<span class="lineno">   29 </span>
<span class="lineno">   30 </span>import Prelude hiding (pred)
<span class="lineno">   31 </span>
<span class="lineno">   32 </span>import Data.Char
<span class="lineno">   33 </span>import Data.Word
<span class="lineno">   34 </span>import Data.Maybe
<span class="lineno">   35 </span>import Data.Either
<span class="lineno">   36 </span>import Data.List hiding (sort)
<span class="lineno">   37 </span>import Data.List.NonEmpty (NonEmpty(..))
<span class="lineno">   38 </span>import qualified Data.List.NonEmpty as NonEmpty
<span class="lineno">   39 </span>import Data.String
<span class="lineno">   40 </span>import Data.Proxy
<span class="lineno">   41 </span>import Data.Reflection
<span class="lineno">   42 </span>import Data.Functor.Constant
<span class="lineno">   43 </span>import Data.Functor.Compose
<span class="lineno">   44 </span>import qualified Data.BitVector.Sized as BV
<span class="lineno">   45 </span>import Data.BitVector.Sized (BV)
<span class="lineno">   46 </span>import Numeric.Natural
<span class="lineno">   47 </span>import GHC.TypeLits (KnownNat, natVal)
<span class="lineno">   48 </span>import Data.Kind
<span class="lineno">   49 </span>import Data.Map.Strict (Map)
<span class="lineno">   50 </span>import qualified Data.Map.Strict as Map
<span class="lineno">   51 </span>import Data.Set (Set)
<span class="lineno">   52 </span>import qualified Data.Set as Set
<span class="lineno">   53 </span>import Control.Applicative hiding (empty)
<span class="lineno">   54 </span>import Control.Monad (MonadPlus(..), (&gt;=&gt;))
<span class="lineno">   55 </span>import Control.Monad.Extra (concatMapM)
<span class="lineno">   56 </span>import Control.Monad.Identity ()
<span class="lineno">   57 </span>import Control.Monad.Reader (MonadReader(..), Reader, ReaderT(..), runReader)
<span class="lineno">   58 </span>import Control.Monad.State (MonadState(..), State, evalState, modify)
<span class="lineno">   59 </span>import Control.Lens hiding ((:&gt;), Index, Empty, ix, op)
<span class="lineno">   60 </span>
<span class="lineno">   61 </span>import Data.Binding.Hobbits hiding (sym)
<span class="lineno">   62 </span>import Data.Type.RList (append, memberElem, mapRAssign, mapToList, Eq1(..))
<span class="lineno">   63 </span>import qualified Data.Type.RList as RL
<span class="lineno">   64 </span>import Data.Binding.Hobbits.MonadBind as MB
<span class="lineno">   65 </span>import Data.Binding.Hobbits.NameMap (NameMap, NameAndElem(..))
<span class="lineno">   66 </span>import qualified Data.Binding.Hobbits.NameMap as NameMap
<span class="lineno">   67 </span>import Data.Binding.Hobbits.NameSet (NameSet, SomeName(..), toList,
<span class="lineno">   68 </span>                                     SomeRAssign(..), namesListToNames,
<span class="lineno">   69 </span>                                     nameSetIsSubsetOf)
<span class="lineno">   70 </span>import qualified Data.Binding.Hobbits.NameSet as NameSet
<span class="lineno">   71 </span>
<span class="lineno">   72 </span>import Data.Parameterized.Context (Assignment, AssignView(..),
<span class="lineno">   73 </span>                                   pattern Empty, viewAssign)
<span class="lineno">   74 </span>import qualified Data.Parameterized.Context as Ctx
<span class="lineno">   75 </span>import Data.Parameterized.BoolRepr
<span class="lineno">   76 </span>import Data.Parameterized.NatRepr
<span class="lineno">   77 </span>import Data.Parameterized.Pair
<span class="lineno">   78 </span>
<span class="lineno">   79 </span>import Prettyprinter as PP
<span class="lineno">   80 </span>import Prettyprinter.Render.String (renderString)
<span class="lineno">   81 </span>
<span class="lineno">   82 </span>import SAWCore.Utils (panic) -- XXX why is this using another library's panic hook?
<span class="lineno">   83 </span>import Lang.Crucible.Types
<span class="lineno">   84 </span>import Lang.Crucible.FunctionHandle
<span class="lineno">   85 </span>import Lang.Crucible.LLVM.DataLayout
<span class="lineno">   86 </span>import Lang.Crucible.LLVM.MemModel
<span class="lineno">   87 </span>import Lang.Crucible.LLVM.Bytes
<span class="lineno">   88 </span>import Lang.Crucible.CFG.Core
<span class="lineno">   89 </span>import SAWCore.SharedTerm hiding (Constant)
<span class="lineno">   90 </span>import SAWCore.OpenTerm
<span class="lineno">   91 </span>import Heapster.NamedMb
<span class="lineno">   92 </span>
<span class="lineno">   93 </span>import Heapster.CruUtil
<span class="lineno">   94 </span>
<span class="lineno">   95 </span>import GHC.Stack
<span class="lineno">   96 </span>import Debug.Trace
<span class="lineno">   97 </span>
<span class="lineno">   98 </span>
<span class="lineno">   99 </span>-- * Helper functions (should be moved to Hobbits)
<span class="lineno">  100 </span>
<span class="lineno">  101 </span>-- | Append two existentially quantified 'RAssign' lists
<span class="lineno">  102 </span>apSomeRAssign :: Some (RAssign f) -&gt; Some (RAssign f) -&gt; Some (RAssign f)
<span class="lineno">  103 </span><span class="decl"><span class="nottickedoff">apSomeRAssign (Some x) (Some y) = Some (RL.append x y)</span></span>
<span class="lineno">  104 </span>
<span class="lineno">  105 </span>-- | Concatenate a list of existentially quantified 'RAssign' lists
<span class="lineno">  106 </span>concatSomeRAssign :: [Some (RAssign f)] -&gt; Some (RAssign f)
<span class="lineno">  107 </span><span class="decl"><span class="nottickedoff">concatSomeRAssign = foldl apSomeRAssign (Some MNil)</span></span>
<span class="lineno">  108 </span>-- foldl is intentional, appending RAssign matches on the second argument
<span class="lineno">  109 </span>
<span class="lineno">  110 </span>-- | Map a monadic function over an 'RAssign' list from left to right while
<span class="lineno">  111 </span>-- maintaining an \&quot;accumulator\&quot; that is threaded through the mapping
<span class="lineno">  112 </span>rlMapMWithAccum :: Monad m =&gt; (forall a. accum -&gt; f a -&gt; m (g a, accum)) -&gt;
<span class="lineno">  113 </span>                   accum -&gt; RAssign f tps -&gt; m (RAssign g tps, accum)
<span class="lineno">  114 </span><span class="decl"><span class="nottickedoff">rlMapMWithAccum _ accum MNil = return (MNil, accum)</span>
<span class="lineno">  115 </span><span class="spaces"></span><span class="nottickedoff">rlMapMWithAccum f accum (xs :&gt;: x) =</span>
<span class="lineno">  116 </span><span class="spaces">  </span><span class="nottickedoff">do (ys,accum') &lt;- rlMapMWithAccum f accum xs</span>
<span class="lineno">  117 </span><span class="spaces">     </span><span class="nottickedoff">(y,accum'') &lt;- f accum' x</span>
<span class="lineno">  118 </span><span class="spaces">     </span><span class="nottickedoff">return (ys :&gt;: y, accum'')</span></span>
<span class="lineno">  119 </span>
<span class="lineno">  120 </span>-- | Map a monomorphic binary function across a pair of 'RAssign's to create a
<span class="lineno">  121 </span>-- standard list, similarly to 'zipWith'
<span class="lineno">  122 </span>mapToList2 :: (forall a. f a -&gt; g a -&gt; b) -&gt;
<span class="lineno">  123 </span>              RAssign f tps -&gt; RAssign g tps -&gt; [b]
<span class="lineno">  124 </span><span class="decl"><span class="nottickedoff">mapToList2 f fs gs = RL.toList $ RL.map2 (\x y -&gt; Constant $ f x y) fs gs</span></span>
<span class="lineno">  125 </span>
<span class="lineno">  126 </span>-- | Convert any 'RAssign' sequence to a sequence of 'Proxy' objects
<span class="lineno">  127 </span>rlToProxies :: RAssign f ctx -&gt; RAssign Proxy ctx
<span class="lineno">  128 </span><span class="decl"><span class="nottickedoff">rlToProxies = RL.map (const Proxy)</span></span>
<span class="lineno">  129 </span>
<span class="lineno">  130 </span>-- | Extend the context of a name-binding to the left with multiple types
<span class="lineno">  131 </span>extMbMultiL :: RAssign Proxy ctx1 -&gt; Mb ctx2 a -&gt; Mb (ctx1 :++: ctx2) a
<span class="lineno">  132 </span><span class="decl"><span class="nottickedoff">extMbMultiL vars mb_a =</span>
<span class="lineno">  133 </span><span class="spaces">  </span><span class="nottickedoff">mbCombine (mbToProxy mb_a) $ nuMulti vars $ const mb_a</span></span>
<span class="lineno">  134 </span>
<span class="lineno">  135 </span>
<span class="lineno">  136 </span>----------------------------------------------------------------------
<span class="lineno">  137 </span>-- * Data types and related types
<span class="lineno">  138 </span>----------------------------------------------------------------------
<span class="lineno">  139 </span>
<span class="lineno">  140 </span>-- | The Haskell type of expression variables
<span class="lineno">  141 </span>type ExprVar = (Name :: CrucibleType -&gt; Type)
<span class="lineno">  142 </span>
<span class="lineno">  143 </span>-- | Crucible type for lifetimes; we give them a Crucible type so they can be
<span class="lineno">  144 </span>-- existentially bound in the same way as other Crucible objects
<span class="lineno">  145 </span>type LifetimeType = IntrinsicType &quot;Lifetime&quot; EmptyCtx
<span class="lineno">  146 </span>
<span class="lineno">  147 </span>-- | Crucible type for read/write modalities; we give them a Crucible type so
<span class="lineno">  148 </span>-- they can be used as variables in recursive permission definitions
<span class="lineno">  149 </span>type RWModalityType = IntrinsicType &quot;RWModality&quot; EmptyCtx
<span class="lineno">  150 </span>
<span class="lineno">  151 </span>-- | Crucible type for lists of expressions and permissions on them
<span class="lineno">  152 </span>type PermListType = IntrinsicType &quot;PermList&quot; EmptyCtx
<span class="lineno">  153 </span>
<span class="lineno">  154 </span>-- | Crucible type for LLVM stack frame objects
<span class="lineno">  155 </span>type LLVMFrameType w = IntrinsicType &quot;LLVMFrame&quot; (EmptyCtx ::&gt; BVType w)
<span class="lineno">  156 </span>
<span class="lineno">  157 </span>-- | Crucible type for value permissions themselves
<span class="lineno">  158 </span>type ValuePermType a = IntrinsicType &quot;Perm&quot; (EmptyCtx ::&gt; a)
<span class="lineno">  159 </span>
<span class="lineno">  160 </span>-- | Crucible type for LLVM shapes
<span class="lineno">  161 </span>type LLVMShapeType w = IntrinsicType &quot;LLVMShape&quot; (EmptyCtx ::&gt; BVType w)
<span class="lineno">  162 </span>
<span class="lineno">  163 </span>-- | Crucible type for LLVM memory blocks
<span class="lineno">  164 </span>type LLVMBlockType w = IntrinsicType &quot;LLVMBlock&quot; (EmptyCtx ::&gt; BVType w)
<span class="lineno">  165 </span>
<span class="lineno">  166 </span>-- | Expressions that are considered \&quot;pure\&quot; for use in permissions. Note that
<span class="lineno">  167 </span>-- these are in a normal form, that makes them easier to analyze.
<span class="lineno">  168 </span>data PermExpr (a :: CrucibleType) where
<span class="lineno">  169 </span>  -- | A variable of any type
<span class="lineno">  170 </span>  PExpr_Var :: ExprVar a -&gt; PermExpr a
<span class="lineno">  171 </span>
<span class="lineno">  172 </span>  -- | A unit literal
<span class="lineno">  173 </span>  PExpr_Unit :: PermExpr UnitType
<span class="lineno">  174 </span>
<span class="lineno">  175 </span>  -- | A literal Boolean number
<span class="lineno">  176 </span>  PExpr_Bool :: Bool -&gt; PermExpr BoolType
<span class="lineno">  177 </span>
<span class="lineno">  178 </span>  -- | A literal natural number
<span class="lineno">  179 </span>  PExpr_Nat :: Natural -&gt; PermExpr NatType
<span class="lineno">  180 </span>
<span class="lineno">  181 </span>  -- | A literal string
<span class="lineno">  182 </span>  PExpr_String :: String -&gt; PermExpr (StringType Unicode)
<span class="lineno">  183 </span>
<span class="lineno">  184 </span>  -- | A bitvector expression is a linear expression in @N@ variables, i.e., sum
<span class="lineno">  185 </span>  -- of constant times variable factors plus a constant
<span class="lineno">  186 </span>  --
<span class="lineno">  187 </span>  -- FIXME: make the offset a 'Natural'
<span class="lineno">  188 </span>  PExpr_BV :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno">  189 </span>              [BVFactor w] -&gt; BV w -&gt; PermExpr (BVType w)
<span class="lineno">  190 </span>
<span class="lineno">  191 </span>  -- | A struct expression is an expression for each argument of the struct type
<span class="lineno">  192 </span>  PExpr_Struct :: PermExprs (CtxToRList args) -&gt; PermExpr (StructType args)
<span class="lineno">  193 </span>
<span class="lineno">  194 </span>  -- | The @always@ lifetime that is always current
<span class="lineno">  195 </span>  PExpr_Always :: PermExpr LifetimeType
<span class="lineno">  196 </span>
<span class="lineno">  197 </span>  -- | An LLVM value that represents a word, i.e., whose region identifier is 0
<span class="lineno">  198 </span>  PExpr_LLVMWord :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (BVType w) -&gt;
<span class="lineno">  199 </span>                    PermExpr (LLVMPointerType w)
<span class="lineno">  200 </span>
<span class="lineno">  201 </span>  -- | An LLVM value built by adding an offset to an LLVM variable
<span class="lineno">  202 </span>  PExpr_LLVMOffset :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno">  203 </span>                      ExprVar (LLVMPointerType w) -&gt;
<span class="lineno">  204 </span>                      PermExpr (BVType w) -&gt;
<span class="lineno">  205 </span>                      PermExpr (LLVMPointerType w)
<span class="lineno">  206 </span>
<span class="lineno">  207 </span>  -- | A literal function pointer
<span class="lineno">  208 </span>  PExpr_Fun :: FnHandle args ret -&gt; PermExpr (FunctionHandleType args ret)
<span class="lineno">  209 </span>
<span class="lineno">  210 </span>  -- | An empty permission list
<span class="lineno">  211 </span>  PExpr_PermListNil :: PermExpr PermListType
<span class="lineno">  212 </span>
<span class="lineno">  213 </span>  -- | A cons of an expression and a permission on it to a permission list
<span class="lineno">  214 </span>  PExpr_PermListCons :: TypeRepr a -&gt; PermExpr a -&gt; ValuePerm a -&gt;
<span class="lineno">  215 </span>                        PermExpr PermListType -&gt; PermExpr PermListType
<span class="lineno">  216 </span>
<span class="lineno">  217 </span>  -- | A read/write modality
<span class="lineno">  218 </span>  PExpr_RWModality :: RWModality -&gt; PermExpr RWModalityType
<span class="lineno">  219 </span>
<span class="lineno">  220 </span>  -- | The empty / vacuously true shape
<span class="lineno">  221 </span>  PExpr_EmptyShape :: PermExpr (LLVMShapeType w)
<span class="lineno">  222 </span>
<span class="lineno">  223 </span>  -- | A named shape along with arguments for it, with optional read/write and
<span class="lineno">  224 </span>  -- lifetime modalities that are applied to the body of the shape
<span class="lineno">  225 </span>  PExpr_NamedShape :: KnownNat w =&gt; Maybe (PermExpr RWModalityType) -&gt;
<span class="lineno">  226 </span>                      Maybe (PermExpr LifetimeType) -&gt;
<span class="lineno">  227 </span>                      NamedShape b args w -&gt; PermExprs args -&gt;
<span class="lineno">  228 </span>                      PermExpr (LLVMShapeType w)
<span class="lineno">  229 </span>
<span class="lineno">  230 </span>  -- | The equality shape, which describes some @N@ bytes of memory that are
<span class="lineno">  231 </span>  -- equal to a given LLVM block
<span class="lineno">  232 </span>  PExpr_EqShape :: PermExpr (BVType w) -&gt; PermExpr (LLVMBlockType w) -&gt;
<span class="lineno">  233 </span>                   PermExpr (LLVMShapeType w)
<span class="lineno">  234 </span>
<span class="lineno">  235 </span>  -- | A shape for a pointer to another memory block, i.e., a @memblock@
<span class="lineno">  236 </span>  -- permission, with a given shape. This @memblock@ permission will have the
<span class="lineno">  237 </span>  -- same read/write and lifetime modalities as the @memblock@ permission
<span class="lineno">  238 </span>  -- containing this pointer shape, unless they are specifically overridden by
<span class="lineno">  239 </span>  -- the pointer shape; i.e., we have that
<span class="lineno">  240 </span>  --
<span class="lineno">  241 </span>  -- &gt; [l]memblock(rw,off,len,ptrsh(rw',l',sh)) =
<span class="lineno">  242 </span>  -- &gt;   [l]memblock(rw,off,len,fieldsh([l']memblock(rw',0,len(sh),sh)))
<span class="lineno">  243 </span>  --
<span class="lineno">  244 </span>  -- where @rw'@ and/or @l'@ can be 'Nothing', in which case they default to
<span class="lineno">  245 </span>  -- @rw@ and @l@, respectively.
<span class="lineno">  246 </span>  PExpr_PtrShape :: Maybe (PermExpr RWModalityType) -&gt;
<span class="lineno">  247 </span>                    Maybe (PermExpr LifetimeType) -&gt;
<span class="lineno">  248 </span>                    PermExpr (LLVMShapeType w) -&gt; PermExpr (LLVMShapeType w)
<span class="lineno">  249 </span>
<span class="lineno">  250 </span>  -- | A shape for a single field with a given permission
<span class="lineno">  251 </span>  PExpr_FieldShape :: (1 &lt;= w, KnownNat w) =&gt; LLVMFieldShape w -&gt;
<span class="lineno">  252 </span>                      PermExpr (LLVMShapeType w)
<span class="lineno">  253 </span>
<span class="lineno">  254 </span>  -- | A shape for an array of @len@ individual regions of memory, called
<span class="lineno">  255 </span>  -- \&quot;array cells\&quot;; the size of each cell in bytes is given by the array
<span class="lineno">  256 </span>  -- stride, which must be known statically, and each cell has shape given by
<span class="lineno">  257 </span>  -- the supplied LLVM shape, also called the cell shape
<span class="lineno">  258 </span>  PExpr_ArrayShape :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno">  259 </span>                      PermExpr (BVType w) -&gt; Bytes -&gt;
<span class="lineno">  260 </span>                      PermExpr (LLVMShapeType w) -&gt;
<span class="lineno">  261 </span>                      PermExpr (LLVMShapeType w)
<span class="lineno">  262 </span>
<span class="lineno">  263 </span>  -- | The explicit tupling of the translation of a shape into a tuple type
<span class="lineno">  264 </span>  PExpr_TupShape :: PermExpr (LLVMShapeType w) -&gt; PermExpr (LLVMShapeType w)
<span class="lineno">  265 </span>
<span class="lineno">  266 </span>  -- | A sequence of two shapes
<span class="lineno">  267 </span>  PExpr_SeqShape :: PermExpr (LLVMShapeType w) -&gt; PermExpr (LLVMShapeType w) -&gt;
<span class="lineno">  268 </span>                    PermExpr (LLVMShapeType w)
<span class="lineno">  269 </span>
<span class="lineno">  270 </span>  -- | A disjunctive shape
<span class="lineno">  271 </span>  PExpr_OrShape :: PermExpr (LLVMShapeType w) -&gt; PermExpr (LLVMShapeType w) -&gt;
<span class="lineno">  272 </span>                   PermExpr (LLVMShapeType w)
<span class="lineno">  273 </span>
<span class="lineno">  274 </span>  -- | An existential shape
<span class="lineno">  275 </span>  PExpr_ExShape :: KnownRepr TypeRepr a =&gt;
<span class="lineno">  276 </span>                   Binding a (PermExpr (LLVMShapeType w)) -&gt;
<span class="lineno">  277 </span>                   PermExpr (LLVMShapeType w)
<span class="lineno">  278 </span>
<span class="lineno">  279 </span>  -- | A false shape
<span class="lineno">  280 </span>  PExpr_FalseShape :: PermExpr (LLVMShapeType w)
<span class="lineno">  281 </span>
<span class="lineno">  282 </span>  -- | A permission as an expression
<span class="lineno">  283 </span>  PExpr_ValPerm :: ValuePerm a -&gt; PermExpr (ValuePermType a)
<span class="lineno">  284 </span>
<span class="lineno">  285 </span>-- | A sequence of permission expressions
<span class="lineno">  286 </span>type PermExprs = RAssign PermExpr
<span class="lineno">  287 </span>
<span class="lineno">  288 </span>{-
<span class="lineno">  289 </span>data PermExprs (as :: RList CrucibleType) where
<span class="lineno">  290 </span>  PExprs_Nil :: PermExprs RNil
<span class="lineno">  291 </span>  PExprs_Cons :: PermExprs as -&gt; PermExpr a -&gt; PermExprs (as :&gt; a)
<span class="lineno">  292 </span>-}
<span class="lineno">  293 </span>
<span class="lineno">  294 </span>-- | A bitvector variable, possibly multiplied by a constant
<span class="lineno">  295 </span>data BVFactor w where
<span class="lineno">  296 </span>  -- | A variable of type @'BVType' w@ multiplied by a constant @i@, which
<span class="lineno">  297 </span>  -- should be in the range @0 &lt;= i &lt; 2^w@
<span class="lineno">  298 </span>  BVFactor :: (1 &lt;= w, KnownNat w) =&gt; BV w -&gt; ExprVar (BVType w) -&gt;
<span class="lineno">  299 </span>              BVFactor w
<span class="lineno">  300 </span>
<span class="lineno">  301 </span>-- | Whether a permission allows reads or writes
<span class="lineno">  302 </span>data RWModality
<span class="lineno">  303 </span>  = Write
<span class="lineno">  304 </span>  | Read
<span class="lineno">  305 </span>  deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>
<span class="lineno">  306 </span>
<span class="lineno">  307 </span>-- | The Haskell type of permission variables, that is, variables that range
<span class="lineno">  308 </span>-- over 'ValuePerm's
<span class="lineno">  309 </span>type PermVar (a :: CrucibleType) = Name (ValuePermType a)
<span class="lineno">  310 </span>
<span class="lineno">  311 </span>-- | Ranges @[off,off+len)@ of bitvector values @x@ equal to @off+y@ for some
<span class="lineno">  312 </span>-- unsigned @y &lt; len@. Note that ranges are allowed to wrap around 0, meaning
<span class="lineno">  313 </span>-- @off+y@ can overflow when testing whether @x@ is in the range. Thus, @x@ is
<span class="lineno">  314 </span>-- in range @[off,off+len)@ iff @x-off@ is unsigned less than @len@.
<span class="lineno">  315 </span>data BVRange w = BVRange { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">bvRangeOffset</span></span></span> :: PermExpr (BVType w),
<span class="lineno">  316 </span>                           <span class="nottickedoff"><span class="decl"><span class="nottickedoff">bvRangeLength</span></span></span> :: PermExpr (BVType w) }
<span class="lineno">  317 </span>
<span class="lineno">  318 </span>-- | A range of offsets, possibly inside bindings for zero or more existential
<span class="lineno">  319 </span>-- variables, that makes sense for a given Crucible type, along with read/write
<span class="lineno">  320 </span>-- and lifetime modalities
<span class="lineno">  321 </span>data MbRangeForType a where
<span class="lineno">  322 </span>  MbRangeForLLVMType ::
<span class="lineno">  323 </span>    (1 &lt;= w, KnownNat w) =&gt; CruCtx vars -&gt;
<span class="lineno">  324 </span>    Mb vars (PermExpr RWModalityType) -&gt; Mb vars (PermExpr LifetimeType) -&gt;
<span class="lineno">  325 </span>    Mb vars (BVRange w) -&gt; MbRangeForType (LLVMPointerType w)
<span class="lineno">  326 </span>
<span class="lineno">  327 </span>-- | Build an 'MbRangeForType' from a 'BVRange'
<span class="lineno">  328 </span>rangeForLLVMType :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno">  329 </span>                    PermExpr RWModalityType -&gt; PermExpr LifetimeType -&gt;
<span class="lineno">  330 </span>                    BVRange w -&gt; MbRangeForType (LLVMPointerType w)
<span class="lineno">  331 </span><span class="decl"><span class="nottickedoff">rangeForLLVMType rw l rng =</span>
<span class="lineno">  332 </span><span class="spaces">  </span><span class="nottickedoff">MbRangeForLLVMType CruCtxNil (emptyMb rw) (emptyMb l) (emptyMb rng)</span></span>
<span class="lineno">  333 </span>
<span class="lineno">  334 </span>-- | A name-binding over some list of typed existential variables
<span class="lineno">  335 </span>data SomeTypedMb a where
<span class="lineno">  336 </span>  SomeTypedMb :: CruCtx ctx -&gt; Mb ctx a -&gt; SomeTypedMb a
<span class="lineno">  337 </span>
<span class="lineno">  338 </span>
<span class="lineno">  339 </span>-- | Propositions about bitvectors
<span class="lineno">  340 </span>data BVProp w
<span class="lineno">  341 </span>    -- | True iff the two expressions are equal
<span class="lineno">  342 </span>  = BVProp_Eq (PermExpr (BVType w)) (PermExpr (BVType w))
<span class="lineno">  343 </span>    -- | True iff the two expressions are not equal
<span class="lineno">  344 </span>  | BVProp_Neq (PermExpr (BVType w)) (PermExpr (BVType w))
<span class="lineno">  345 </span>    -- | True iff the first expression is unsigned less-than the second
<span class="lineno">  346 </span>  | BVProp_ULt (PermExpr (BVType w)) (PermExpr (BVType w))
<span class="lineno">  347 </span>    -- | True iff the first expression is unsigned @&lt;=@ the second
<span class="lineno">  348 </span>  | BVProp_ULeq (PermExpr (BVType w)) (PermExpr (BVType w))
<span class="lineno">  349 </span>    -- | True iff the first expression is unsigned @&lt;=@ the difference of the
<span class="lineno">  350 </span>    -- second minus the third
<span class="lineno">  351 </span>  | (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno">  352 </span>    BVProp_ULeq_Diff (PermExpr (BVType w)) (PermExpr (BVType w))
<span class="lineno">  353 </span>    (PermExpr (BVType w))
<span class="lineno">  354 </span>
<span class="lineno">  355 </span>-- | An atomic permission is a value permission that is not one of the compound
<span class="lineno">  356 </span>-- constructs in the 'ValuePerm' type; i.e., not a disjunction, existential,
<span class="lineno">  357 </span>-- recursive, or equals permission. These are the permissions that we can put
<span class="lineno">  358 </span>-- together with separating conjuctions.
<span class="lineno">  359 </span>data AtomicPerm (a :: CrucibleType) where
<span class="lineno">  360 </span>  -- | Gives permissions to a single field pointed to by an LLVM pointer
<span class="lineno">  361 </span>  Perm_LLVMField :: (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno">  362 </span>                    LLVMFieldPerm w sz -&gt;
<span class="lineno">  363 </span>                    AtomicPerm (LLVMPointerType w)
<span class="lineno">  364 </span>
<span class="lineno">  365 </span>  -- | Gives permissions to an array pointer to by an LLVM pointer
<span class="lineno">  366 </span>  Perm_LLVMArray :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;
<span class="lineno">  367 </span>                    AtomicPerm (LLVMPointerType w)
<span class="lineno">  368 </span>
<span class="lineno">  369 </span>  -- | Gives read or write access to a memory block, whose contents also give
<span class="lineno">  370 </span>  -- some permissions
<span class="lineno">  371 </span>  Perm_LLVMBlock :: (1 &lt;= w, KnownNat w) =&gt; LLVMBlockPerm w -&gt;
<span class="lineno">  372 </span>                    AtomicPerm (LLVMPointerType w)
<span class="lineno">  373 </span>
<span class="lineno">  374 </span>  -- | Says that we have permission to free the memory pointed at by this
<span class="lineno">  375 </span>  -- pointer if we have write permission to @e@ words of size @w@
<span class="lineno">  376 </span>  Perm_LLVMFree :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (BVType w) -&gt;
<span class="lineno">  377 </span>                   AtomicPerm (LLVMPointerType w)
<span class="lineno">  378 </span>
<span class="lineno">  379 </span>  -- | Says that we know an LLVM value is a function pointer whose function has
<span class="lineno">  380 </span>  -- the given permissions
<span class="lineno">  381 </span>  Perm_LLVMFunPtr :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno">  382 </span>                     TypeRepr (FunctionHandleType cargs ret) -&gt;
<span class="lineno">  383 </span>                     ValuePerm (FunctionHandleType cargs ret) -&gt;
<span class="lineno">  384 </span>                     AtomicPerm (LLVMPointerType w)
<span class="lineno">  385 </span>
<span class="lineno">  386 </span>  -- | Says that a memory block has a given shape
<span class="lineno">  387 </span>  Perm_LLVMBlockShape :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (LLVMShapeType w) -&gt;
<span class="lineno">  388 </span>                         AtomicPerm (LLVMBlockType w)
<span class="lineno">  389 </span>
<span class="lineno">  390 </span>  -- | Says we know an LLVM value is a pointer value, meaning that its block
<span class="lineno">  391 </span>  -- value is non-zero. Note that this does not say the pointer is allocated.
<span class="lineno">  392 </span>  Perm_IsLLVMPtr :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno">  393 </span>                    AtomicPerm (LLVMPointerType w)
<span class="lineno">  394 </span>
<span class="lineno">  395 </span>  -- | A named conjunctive permission
<span class="lineno">  396 </span>  Perm_NamedConj :: NameSortIsConj ns ~ 'True =&gt;
<span class="lineno">  397 </span>                    NamedPermName ns args a -&gt; PermExprs args -&gt;
<span class="lineno">  398 </span>                    PermOffset a -&gt; AtomicPerm a
<span class="lineno">  399 </span>
<span class="lineno">  400 </span>  -- | Permission to allocate (via @alloca@) on an LLVM stack frame, and
<span class="lineno">  401 </span>  -- permission to delete that stack frame if we have exclusive permissions to
<span class="lineno">  402 </span>  -- all the given LLVM pointer objects
<span class="lineno">  403 </span>  Perm_LLVMFrame :: (1 &lt;= w, KnownNat w) =&gt; LLVMFramePerm w -&gt;
<span class="lineno">  404 </span>                    AtomicPerm (LLVMFrameType w)
<span class="lineno">  405 </span>
<span class="lineno">  406 </span>  -- | Ownership permission for a lifetime, including an assertion that it is
<span class="lineno">  407 </span>  -- still current and permission to end that lifetime. A lifetime also
<span class="lineno">  408 </span>  -- represents a permission \&quot;borrow\&quot; of some sub-permissions out of some
<span class="lineno">  409 </span>  -- larger permissions. For example, we might borrow a portion of an array, or
<span class="lineno">  410 </span>  -- a portion of a larger data structure. When the lifetime is ended, you have
<span class="lineno">  411 </span>  -- to give back to sub-permissions to get back the larger permissions.
<span class="lineno">  412 </span>  -- Together, these are a form of permission implication, so we write lifetime
<span class="lineno">  413 </span>  -- ownership permissions as @lowned(Pin -o Pout)@. Intuitively, @Pin@ must be
<span class="lineno">  414 </span>  -- given back before the lifetime is ended, and @Pout@ is returned afterwards.
<span class="lineno">  415 </span>  -- Additionally, a lifetime may contain some other lifetimes, meaning the all
<span class="lineno">  416 </span>  -- must end before the current one can be ended.
<span class="lineno">  417 </span>  Perm_LOwned :: [PermExpr LifetimeType] -&gt;
<span class="lineno">  418 </span>                 CruCtx ps_in -&gt; CruCtx ps_out -&gt;
<span class="lineno">  419 </span>                 ExprPerms ps_in -&gt; ExprPerms ps_out -&gt;
<span class="lineno">  420 </span>                 AtomicPerm LifetimeType
<span class="lineno">  421 </span>
<span class="lineno">  422 </span>  -- | A simplified version of @lowned@, written just @lowned(ps)@, which
<span class="lineno">  423 </span>  -- represents a lifetime where the permissions @ps@ have been borrowed and no
<span class="lineno">  424 </span>  -- simplifications have been done. Semantically, this is logically equivalent
<span class="lineno">  425 </span>  -- to @lowned ([l](R)ps -o ps)@, i.e., an @lowned@ permissions where the input
<span class="lineno">  426 </span>  -- and output permissions are the same except that the input permissions are
<span class="lineno">  427 </span>  -- the minimal possible versions of @ps@ in lifetime @l@ that could be given
<span class="lineno">  428 </span>  -- back when @l@ is ended.
<span class="lineno">  429 </span>  Perm_LOwnedSimple :: CruCtx ps -&gt; ExprPerms ps -&gt; AtomicPerm LifetimeType
<span class="lineno">  430 </span>
<span class="lineno">  431 </span>  -- | Assertion that a lifetime is current during another lifetime;
<span class="lineno">  432 </span>  -- @l1:lcurrent l2@ can also be read as @l1@ contains @l2@ as a sub-lifetime
<span class="lineno">  433 </span>  Perm_LCurrent :: PermExpr LifetimeType -&gt; AtomicPerm LifetimeType
<span class="lineno">  434 </span>
<span class="lineno">  435 </span>  -- | Assertion that a lifetime has finished
<span class="lineno">  436 </span>  Perm_LFinished :: AtomicPerm LifetimeType
<span class="lineno">  437 </span>
<span class="lineno">  438 </span>  -- | A struct permission = a sequence of permissions for each field
<span class="lineno">  439 </span>  Perm_Struct :: RAssign ValuePerm (CtxToRList ctx) -&gt;
<span class="lineno">  440 </span>                 AtomicPerm (StructType ctx)
<span class="lineno">  441 </span>
<span class="lineno">  442 </span>  -- | A function permission
<span class="lineno">  443 </span>  Perm_Fun :: FunPerm ghosts (CtxToRList cargs) gouts ret -&gt;
<span class="lineno">  444 </span>              AtomicPerm (FunctionHandleType cargs ret)
<span class="lineno">  445 </span>
<span class="lineno">  446 </span>  -- | An LLVM permission that asserts a proposition about bitvectors
<span class="lineno">  447 </span>  Perm_BVProp :: (1 &lt;= w, KnownNat w) =&gt; BVProp w -&gt;
<span class="lineno">  448 </span>                 AtomicPerm (LLVMPointerType w)
<span class="lineno">  449 </span>
<span class="lineno">  450 </span>  -- | A false / unsatisfiable permission from which any permission can be
<span class="lineno">  451 </span>  -- proved. This is different from the false permission because it translated
<span class="lineno">  452 </span>  -- to the unit type instead of the empty type in specifications, and is used
<span class="lineno">  453 </span>  -- in cases where the empty type cannot be proved in specifications
<span class="lineno">  454 </span>  Perm_Any :: AtomicPerm a
<span class="lineno">  455 </span>
<span class="lineno">  456 </span>
<span class="lineno">  457 </span>-- | A value permission is a permission to do something with a value, such as
<span class="lineno">  458 </span>-- use it as a pointer. This also includes a limited set of predicates on values
<span class="lineno">  459 </span>-- (you can think about this as \&quot;permission to assume the value satisfies this
<span class="lineno">  460 </span>-- predicate\&quot; if you like).
<span class="lineno">  461 </span>data ValuePerm (a :: CrucibleType) where
<span class="lineno">  462 </span>
<span class="lineno">  463 </span>  -- | Says that a value is equal to a known static expression
<span class="lineno">  464 </span>  ValPerm_Eq :: PermExpr a -&gt; ValuePerm a
<span class="lineno">  465 </span>
<span class="lineno">  466 </span>  -- | The disjunction of two value permissions
<span class="lineno">  467 </span>  ValPerm_Or :: ValuePerm a -&gt; ValuePerm a -&gt; ValuePerm a
<span class="lineno">  468 </span>
<span class="lineno">  469 </span>  -- | An existential binding of a value in a value permission
<span class="lineno">  470 </span>  --
<span class="lineno">  471 </span>  -- FIXME: turn the 'KnownRepr' constraint into a normal 'TypeRepr' argument
<span class="lineno">  472 </span>  ValPerm_Exists :: KnownRepr TypeRepr a =&gt;
<span class="lineno">  473 </span>                    Binding a (ValuePerm b) -&gt;
<span class="lineno">  474 </span>                    ValuePerm b
<span class="lineno">  475 </span>
<span class="lineno">  476 </span>  -- | A named permission
<span class="lineno">  477 </span>  ValPerm_Named :: NamedPermName ns args a -&gt; PermExprs args -&gt;
<span class="lineno">  478 </span>                   PermOffset a -&gt; ValuePerm a
<span class="lineno">  479 </span>
<span class="lineno">  480 </span>  -- | A permission variable plus an offset
<span class="lineno">  481 </span>  ValPerm_Var :: PermVar a -&gt; PermOffset a -&gt; ValuePerm a
<span class="lineno">  482 </span>
<span class="lineno">  483 </span>  -- | A separating conjuction of 0 or more atomic permissions, where 0
<span class="lineno">  484 </span>  -- permissions is the trivially true permission
<span class="lineno">  485 </span>  ValPerm_Conj :: [AtomicPerm a] -&gt; ValuePerm a
<span class="lineno">  486 </span>
<span class="lineno">  487 </span>  -- | The false / unsatisfiable permission
<span class="lineno">  488 </span>  ValPerm_False :: ValuePerm a
<span class="lineno">  489 </span>
<span class="lineno">  490 </span>-- | A sequence of value permissions
<span class="lineno">  491 </span>type ValuePerms = RAssign ValuePerm
<span class="lineno">  492 </span>
<span class="lineno">  493 </span>-- | A binding of 0 or more variables, each with permissions
<span class="lineno">  494 </span>type MbValuePerms ctx = Mb ctx (ValuePerms ctx)
<span class="lineno">  495 </span>
<span class="lineno">  496 </span>-- | A frame permission is a list of the pointers that have been allocated in
<span class="lineno">  497 </span>-- the frame and their corresponding allocation sizes in words of size
<span class="lineno">  498 </span>-- @w@. Write permissions of the given sizes are required to these pointers in
<span class="lineno">  499 </span>-- order to delete the frame.
<span class="lineno">  500 </span>type LLVMFramePerm w = [(PermExpr (LLVMPointerType w), Integer)]
<span class="lineno">  501 </span>
<span class="lineno">  502 </span>-- | A permission for a pointer to a specific field of a given size
<span class="lineno">  503 </span>data LLVMFieldPerm w sz =
<span class="lineno">  504 </span>  LLVMFieldPerm { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">llvmFieldRW</span></span></span> :: PermExpr RWModalityType,
<span class="lineno">  505 </span>                  -- ^ Whether this is a read or write permission
<span class="lineno">  506 </span>                  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">llvmFieldLifetime</span></span></span> :: PermExpr LifetimeType,
<span class="lineno">  507 </span>                  -- ^ The lifetime during which this field permission is active
<span class="lineno">  508 </span>                  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">llvmFieldOffset</span></span></span> :: PermExpr (BVType w),
<span class="lineno">  509 </span>                  -- ^ The offset from the pointer in bytes of this field
<span class="lineno">  510 </span>                  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">llvmFieldContents</span></span></span> :: ValuePerm (LLVMPointerType sz)
<span class="lineno">  511 </span>                  -- ^ The permissions we get for the value read from this field
<span class="lineno">  512 </span>                }
<span class="lineno">  513 </span>
<span class="lineno">  514 </span>-- | Helper type to represent byte offsets
<span class="lineno">  515 </span>--
<span class="lineno">  516 </span>-- &gt; stride * ix + off
<span class="lineno">  517 </span>--
<span class="lineno">  518 </span>-- from the beginning of an array permission. Such an expression refers to
<span class="lineno">  519 </span>-- offset @off@, which must be a statically-known constant, in array cell @ix@.
<span class="lineno">  520 </span>data LLVMArrayIndex w =
<span class="lineno">  521 </span>  LLVMArrayIndex { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">llvmArrayIndexCell</span></span></span> :: PermExpr (BVType w),
<span class="lineno">  522 </span>                   <span class="nottickedoff"><span class="decl"><span class="nottickedoff">llvmArrayIndexOffset</span></span></span> :: BV w }
<span class="lineno">  523 </span>
<span class="lineno">  524 </span>-- | A permission to an array of @len@ individual regions of memory, called
<span class="lineno">  525 </span>-- \&quot;array cells\&quot;. The size of each cell in bytes is given by the array /stride/,
<span class="lineno">  526 </span>-- which must be known statically, and each cell has shape given by the supplied
<span class="lineno">  527 </span>-- LLVM shape, also called the cell shape.
<span class="lineno">  528 </span>data LLVMArrayPerm w =
<span class="lineno">  529 </span>  LLVMArrayPerm { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">llvmArrayRW</span></span></span> :: PermExpr RWModalityType,
<span class="lineno">  530 </span>                  -- ^ Whether this array gives read or write access
<span class="lineno">  531 </span>                  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">llvmArrayLifetime</span></span></span> :: PermExpr LifetimeType,
<span class="lineno">  532 </span>                  -- ^ The lifetime during which this array permission is valid
<span class="lineno">  533 </span>                  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">llvmArrayOffset</span></span></span> :: PermExpr (BVType w),
<span class="lineno">  534 </span>                  -- ^ The offset from the pointer in bytes of this array
<span class="lineno">  535 </span>                  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">llvmArrayLen</span></span></span> :: PermExpr (BVType w),
<span class="lineno">  536 </span>                  -- ^ The number of array blocks
<span class="lineno">  537 </span>                  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">llvmArrayStride</span></span></span> :: Bytes,
<span class="lineno">  538 </span>                  -- ^ The array stride in bytes
<span class="lineno">  539 </span>                  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">llvmArrayCellShape</span></span></span> :: PermExpr (LLVMShapeType w),
<span class="lineno">  540 </span>                  -- ^ The shape of each cell in the array
<span class="lineno">  541 </span>                  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">llvmArrayBorrows</span></span></span> :: [LLVMArrayBorrow w]
<span class="lineno">  542 </span>                  -- ^ Indices or index ranges that are missing from this array
<span class="lineno">  543 </span>                }
<span class="lineno">  544 </span>
<span class="lineno">  545 </span>-- | An index or range of indices that are missing from an array perm
<span class="lineno">  546 </span>--
<span class="lineno">  547 </span>-- FIXME: think about calling the just @LLVMArrayIndexSet@
<span class="lineno">  548 </span>data LLVMArrayBorrow w
<span class="lineno">  549 </span>  = FieldBorrow (PermExpr (BVType w))
<span class="lineno">  550 </span>    -- ^ Borrow a specific cell of an array permission
<span class="lineno">  551 </span>  | RangeBorrow (BVRange w)
<span class="lineno">  552 </span>    -- ^ Borrow a range of array cells, where each cell is 'llvmArrayStride'
<span class="lineno">  553 </span>    -- bytes long
<span class="lineno">  554 </span>
<span class="lineno">  555 </span>-- | An LLVM block permission is read or write access to the memory at a given
<span class="lineno">  556 </span>-- offset with a given length with a given shape
<span class="lineno">  557 </span>data LLVMBlockPerm w =
<span class="lineno">  558 </span>  LLVMBlockPerm { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">llvmBlockRW</span></span></span> :: PermExpr RWModalityType,
<span class="lineno">  559 </span>                  -- ^ Whether this is a read or write block permission
<span class="lineno">  560 </span>                  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">llvmBlockLifetime</span></span></span> :: PermExpr LifetimeType,
<span class="lineno">  561 </span>                  -- ^ The lifetime during with this block permission is active
<span class="lineno">  562 </span>                  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">llvmBlockOffset</span></span></span> :: PermExpr (BVType w),
<span class="lineno">  563 </span>                  -- ^ The offset of the block from the pointer in bytes
<span class="lineno">  564 </span>                  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">llvmBlockLen</span></span></span> :: PermExpr (BVType w),
<span class="lineno">  565 </span>                  -- ^ The length of the block in bytes
<span class="lineno">  566 </span>                  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">llvmBlockShape</span></span></span> :: PermExpr (LLVMShapeType w)
<span class="lineno">  567 </span>                  -- ^ The shape of the permissions in the block
<span class="lineno">  568 </span>                }
<span class="lineno">  569 </span>
<span class="lineno">  570 </span>-- | An LLVM shape for a single pointer field of unknown size
<span class="lineno">  571 </span>data LLVMFieldShape w =
<span class="lineno">  572 </span>  forall sz. (1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno">  573 </span>  LLVMFieldShape (ValuePerm (LLVMPointerType sz))
<span class="lineno">  574 </span>
<span class="lineno">  575 </span>-- | A pair of an epxression and its permission; we give it its own datatype to
<span class="lineno">  576 </span>-- make certain typeclass instances (like pretty-printing) specific to it
<span class="lineno">  577 </span>data ExprAndPerm a =
<span class="lineno">  578 </span>  ExprAndPerm { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">exprAndPermExpr</span></span></span> :: PermExpr a,
<span class="lineno">  579 </span>                <span class="nottickedoff"><span class="decl"><span class="nottickedoff">exprAndPermPerm</span></span></span> :: ValuePerm a }
<span class="lineno">  580 </span>
<span class="lineno">  581 </span>-- | A list of expressions and associated permissions; different from
<span class="lineno">  582 </span>-- 'DistPerms' because the expressions need not be variables
<span class="lineno">  583 </span>type ExprPerms = RAssign ExprAndPerm
<span class="lineno">  584 </span>
<span class="lineno">  585 </span>-- | A function permission is a set of input and output permissions inside a
<span class="lineno">  586 </span>-- context of ghost variables @ghosts@ with an additional context of output
<span class="lineno">  587 </span>-- ghost variables @gouts@
<span class="lineno">  588 </span>data FunPerm ghosts args gouts ret where
<span class="lineno">  589 </span>  FunPerm :: CruCtx ghosts -&gt; CruCtx args -&gt; CruCtx gouts -&gt; TypeRepr ret -&gt;
<span class="lineno">  590 </span>             MbValuePerms (ghosts :++: args) -&gt;
<span class="lineno">  591 </span>             MbValuePerms ((ghosts :++: args) :++: gouts :&gt; ret) -&gt;
<span class="lineno">  592 </span>             FunPerm ghosts args gouts ret
<span class="lineno">  593 </span>
<span class="lineno">  594 </span>-- | A function permission that existentially quantifies the ghost types
<span class="lineno">  595 </span>data SomeFunPerm args ret where
<span class="lineno">  596 </span>  SomeFunPerm :: FunPerm ghosts args gouts ret -&gt; SomeFunPerm args ret
<span class="lineno">  597 </span>
<span class="lineno">  598 </span>-- | The different sorts of name, each of which comes with a 'Bool' flag
<span class="lineno">  599 </span>-- indicating whether the name can be used as an atomic permission. A recursive
<span class="lineno">  600 </span>-- sort also comes with a second flag indicating whether it is a reachability
<span class="lineno">  601 </span>-- permission.
<span class="lineno">  602 </span>data NameSort = DefinedSort Bool | OpaqueSort Bool | RecursiveSort Bool Bool
<span class="lineno">  603 </span>
<span class="lineno">  604 </span>type DefinedSort   = 'DefinedSort
<span class="lineno">  605 </span>type OpaqueSort    = 'OpaqueSort
<span class="lineno">  606 </span>type RecursiveSort = 'RecursiveSort
<span class="lineno">  607 </span>
<span class="lineno">  608 </span>-- | Test whether a name of a given 'NameSort' is conjoinable
<span class="lineno">  609 </span>type family NameSortIsConj (ns::NameSort) :: Bool where
<span class="lineno">  610 </span>  NameSortIsConj (DefinedSort b) = b
<span class="lineno">  611 </span>  NameSortIsConj (OpaqueSort b) = b
<span class="lineno">  612 </span>  NameSortIsConj (RecursiveSort b _) = b
<span class="lineno">  613 </span>
<span class="lineno">  614 </span>-- | Test whether a name of a given 'NameSort' is a reachability permission
<span class="lineno">  615 </span>type family IsReachabilityName (ns::NameSort) :: Bool where
<span class="lineno">  616 </span>  IsReachabilityName (DefinedSort _) = 'False
<span class="lineno">  617 </span>  IsReachabilityName (OpaqueSort _) = 'False
<span class="lineno">  618 </span>  IsReachabilityName (RecursiveSort _ reach) = reach
<span class="lineno">  619 </span>
<span class="lineno">  620 </span>-- | A singleton representation of 'NameSort'
<span class="lineno">  621 </span>data NameSortRepr (ns::NameSort) where
<span class="lineno">  622 </span>  DefinedSortRepr :: BoolRepr b -&gt; NameSortRepr (DefinedSort b)
<span class="lineno">  623 </span>  OpaqueSortRepr :: BoolRepr b -&gt; NameSortRepr (OpaqueSort b)
<span class="lineno">  624 </span>  RecursiveSortRepr :: BoolRepr b -&gt; BoolRepr reach -&gt;
<span class="lineno">  625 </span>                       NameSortRepr (RecursiveSort b reach)
<span class="lineno">  626 </span>
<span class="lineno">  627 </span>-- | A constraint that the last argument of a reachability permission is a
<span class="lineno">  628 </span>-- permission argument
<span class="lineno">  629 </span>data NameReachConstr ns args a where
<span class="lineno">  630 </span>  NameReachConstr :: (IsReachabilityName ns ~ 'True) =&gt;
<span class="lineno">  631 </span>                     NameReachConstr ns (args :&gt; a) a
<span class="lineno">  632 </span>  NameNonReachConstr :: (IsReachabilityName ns ~ 'False) =&gt;
<span class="lineno">  633 </span>                        NameReachConstr ns args a
<span class="lineno">  634 </span>
<span class="lineno">  635 </span>-- | A name for a named permission
<span class="lineno">  636 </span>data NamedPermName ns args a = NamedPermName {
<span class="lineno">  637 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">namedPermNameName</span></span></span> :: String,
<span class="lineno">  638 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">namedPermNameType</span></span></span> :: TypeRepr a,
<span class="lineno">  639 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">namedPermNameArgs</span></span></span> :: CruCtx args,
<span class="lineno">  640 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">namedPermNameSort</span></span></span> :: NameSortRepr ns,
<span class="lineno">  641 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">namedPermNameReachConstr</span></span></span> :: NameReachConstr ns args a
<span class="lineno">  642 </span>  }
<span class="lineno">  643 </span>
<span class="lineno">  644 </span>-- | An existentially quantified 'NamedPermName'
<span class="lineno">  645 </span>data SomeNamedPermName where
<span class="lineno">  646 </span>  SomeNamedPermName :: NamedPermName ns args a -&gt; SomeNamedPermName
<span class="lineno">  647 </span>
<span class="lineno">  648 </span>-- | A named LLVM shape is a name, a list of arguments, and a body, where the
<span class="lineno">  649 </span>-- Boolean flag @b@ determines whether the shape can be unfolded or not
<span class="lineno">  650 </span>data NamedShape b args w = NamedShape {
<span class="lineno">  651 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">namedShapeName</span></span></span> :: String,
<span class="lineno">  652 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">namedShapeArgs</span></span></span> :: CruCtx args,
<span class="lineno">  653 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">namedShapeBody</span></span></span> :: NamedShapeBody b args w
<span class="lineno">  654 </span>  }
<span class="lineno">  655 </span>
<span class="lineno">  656 </span>data NamedShapeBody b args w where
<span class="lineno">  657 </span>  -- | A defined shape is just a definition in terms of the arguments
<span class="lineno">  658 </span>  DefinedShapeBody :: Mb args (PermExpr (LLVMShapeType w)) -&gt;
<span class="lineno">  659 </span>                      NamedShapeBody 'True args w
<span class="lineno">  660 </span>
<span class="lineno">  661 </span>  -- | An opaque shape has no body, just a length and a translation to two
<span class="lineno">  662 </span>  -- identifiers, the first for a function from translations of the @args@ to
<span class="lineno">  663 </span>  -- the type to use as the translation of the opaque shape applied to @args@ and
<span class="lineno">  664 </span>  -- one for a type description with @args@ as free variables
<span class="lineno">  665 </span>  OpaqueShapeBody :: Mb args (PermExpr (BVType w)) -&gt; Ident -&gt; Ident -&gt;
<span class="lineno">  666 </span>                     NamedShapeBody 'False args w
<span class="lineno">  667 </span>
<span class="lineno">  668 </span>  -- | A recursive shape body has a one-step unfolding to a shape, which can
<span class="lineno">  669 </span>  -- refer to the shape itself via the last bound variable. It also has two
<span class="lineno">  670 </span>  -- identifiers, one for a function from translations of the @args@ to the type
<span class="lineno">  671 </span>  -- to use as the translation of the shape applied to @args@ and one for a type
<span class="lineno">  672 </span>  -- description with @args@ plus a variable for the shape itself (for
<span class="lineno">  673 </span>  -- recursively referring to itself) as free variables.
<span class="lineno">  674 </span>  RecShapeBody :: Mb (args :&gt; LLVMShapeType w) (PermExpr (LLVMShapeType w)) -&gt;
<span class="lineno">  675 </span>                  Ident -&gt; Ident -&gt; NamedShapeBody 'True args w
<span class="lineno">  676 </span>
<span class="lineno">  677 </span>-- | An offset that is added to a permission. Only makes sense for llvm
<span class="lineno">  678 </span>-- permissions (at least for now...?)
<span class="lineno">  679 </span>data PermOffset a where
<span class="lineno">  680 </span>  NoPermOffset :: PermOffset a
<span class="lineno">  681 </span>  -- | NOTE: the invariant is that the bitvector offset is non-zero
<span class="lineno">  682 </span>  LLVMPermOffset :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (BVType w) -&gt;
<span class="lineno">  683 </span>                    PermOffset (LLVMPointerType w)
<span class="lineno">  684 </span>
<span class="lineno">  685 </span>-- | The semantics of a named permission, which can can either be an opaque
<span class="lineno">  686 </span>-- named permission, a recursive named permission, a defined permission, or an
<span class="lineno">  687 </span>-- LLVM shape
<span class="lineno">  688 </span>data NamedPerm ns args a where
<span class="lineno">  689 </span>  NamedPerm_Opaque :: OpaquePerm b args a -&gt; NamedPerm (OpaqueSort b) args a
<span class="lineno">  690 </span>  NamedPerm_Rec :: RecPerm b reach args a -&gt;
<span class="lineno">  691 </span>                   NamedPerm (RecursiveSort b reach) args a
<span class="lineno">  692 </span>  NamedPerm_Defined :: DefinedPerm b args a -&gt; NamedPerm (DefinedSort b) args a
<span class="lineno">  693 </span>
<span class="lineno">  694 </span>-- | An opaque named permission is just a name and a SAW core type given by
<span class="lineno">  695 </span>-- identifier that it is translated to
<span class="lineno">  696 </span>data OpaquePerm b args a = OpaquePerm {
<span class="lineno">  697 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">opaquePermName</span></span></span> :: NamedPermName (OpaqueSort b) args a,
<span class="lineno">  698 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">opaquePermTrans</span></span></span> :: Ident,
<span class="lineno">  699 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">opaquePermTransDesc</span></span></span> :: Ident
<span class="lineno">  700 </span>  }
<span class="lineno">  701 </span>
<span class="lineno">  702 </span>-- | The interpretation of a recursive permission as a reachability permission.
<span class="lineno">  703 </span>-- Reachability permissions are recursive permissions of the form
<span class="lineno">  704 </span>--
<span class="lineno">  705 </span>-- &gt; reach&lt;args,x&gt; = eq(x)  |  p
<span class="lineno">  706 </span>--
<span class="lineno">  707 </span>-- where @reach@ occurs exactly once in @p@ in the form @reach&lt;args,x&gt;@ and @x@
<span class="lineno">  708 </span>-- does not occur at all in @p@. This means their interpretations look like a
<span class="lineno">  709 </span>-- list type, where the @eq(x)@ is the nil constructor and the @p@ is the
<span class="lineno">  710 </span>-- cons. To support the transitivity rule, we need an append function for these
<span class="lineno">  711 </span>-- lists, which is given by the transitivity method listed here, which has type
<span class="lineno">  712 </span>--
<span class="lineno">  713 </span>-- &gt; trans : forall args (x y:A), t args x -&gt; t args y -&gt; t args y
<span class="lineno">  714 </span>--
<span class="lineno">  715 </span>-- where @args@ are the arguments and @A@ is the translation of type @a@ (which
<span class="lineno">  716 </span>-- may correspond to 0 or more arguments)
<span class="lineno">  717 </span>data ReachMethods reach args a where
<span class="lineno">  718 </span>  ReachMethods :: {
<span class="lineno">  719 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">reachMethodTrans</span></span></span> :: Ident
<span class="lineno">  720 </span>    } -&gt; ReachMethods (args :&gt; a) a 'True
<span class="lineno">  721 </span>  NoReachMethods :: ReachMethods args a 'False
<span class="lineno">  722 </span>
<span class="lineno">  723 </span>-- | A recursive permission is a permission that can recursively refer to
<span class="lineno">  724 </span>-- itself. This is represented as a \&quot;body\&quot; of the recursive permission that has
<span class="lineno">  725 </span>-- free variables for a list of arguments along with an extra free variable to
<span class="lineno">  726 </span>-- recursively refer to the permission. The @b@ flag indicates whether this
<span class="lineno">  727 </span>-- recursive permission can be used as an atomic permission, which should be
<span class="lineno">  728 </span>-- 'True' iff 'isConjPerm' is for all substitution instances of the body. A
<span class="lineno">  729 </span>-- recursive permission also has two SAW core identifiers that cache the
<span class="lineno">  730 </span>-- translation of its body to a type and to a type description:
<span class="lineno">  731 </span>-- 'recPermTransType' is a function that maps (translations of) the arguments to
<span class="lineno">  732 </span>-- the translation of its body with these arguments to a type; while
<span class="lineno">  733 </span>-- 'recPermTransDesc' is a type description with free deBruijn variable 0 for
<span class="lineno">  734 </span>-- recursive instances of the recursive permission itself and free variables
<span class="lineno">  735 </span>-- starting at 1 for all the arguments. If the recursive permission is a
<span class="lineno">  736 </span>-- reachability permission, then it also has a 'ReachMethods' structure.
<span class="lineno">  737 </span>data RecPerm b reach args a = RecPerm {
<span class="lineno">  738 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">recPermName</span></span></span> :: NamedPermName (RecursiveSort b reach) args a,
<span class="lineno">  739 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">recPermTransType</span></span></span> :: Ident,
<span class="lineno">  740 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">recPermTransDesc</span></span></span> :: Ident,
<span class="lineno">  741 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">recPermReachMethods</span></span></span> :: ReachMethods args a reach,
<span class="lineno">  742 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">recPermBody</span></span></span> :: Mb (args :&gt; ValuePermType a) (ValuePerm a)
<span class="lineno">  743 </span>  }
<span class="lineno">  744 </span>
<span class="lineno">  745 </span>-- | A defined permission is a name and a permission to which it is
<span class="lineno">  746 </span>-- equivalent. The @b@ flag indicates whether this permission can be used as an
<span class="lineno">  747 </span>-- atomic permission, which should be 'True' iff the associated permission is a
<span class="lineno">  748 </span>-- conjunctive permission as in 'isConjPerm'.
<span class="lineno">  749 </span>data DefinedPerm b args a = DefinedPerm {
<span class="lineno">  750 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">definedPermName</span></span></span> :: NamedPermName (DefinedSort b) args a,
<span class="lineno">  751 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">definedPermDef</span></span></span> :: Mb args (ValuePerm a)
<span class="lineno">  752 </span>}
<span class="lineno">  753 </span>
<span class="lineno">  754 </span>-- | A pair of a variable and its permission; we give it its own datatype to
<span class="lineno">  755 </span>-- make certain typeclass instances (like pretty-printing) specific to it
<span class="lineno">  756 </span>data VarAndPerm a = VarAndPerm (ExprVar a) (ValuePerm a)
<span class="lineno">  757 </span>
<span class="lineno">  758 </span>-- | A list of \&quot;distinguished\&quot; permissions to named variables
<span class="lineno">  759 </span>-- FIXME: just call these VarsAndPerms or something like that...
<span class="lineno">  760 </span>type DistPerms = RAssign VarAndPerm
<span class="lineno">  761 </span>
<span class="lineno">  762 </span>-- | A special-purpose 'DistPerms' that specifies a list of permissions needed
<span class="lineno">  763 </span>-- to prove that a lifetime is current
<span class="lineno">  764 </span>data LifetimeCurrentPerms ps_l where
<span class="lineno">  765 </span>  -- | The @always@ lifetime needs no proof that it is current
<span class="lineno">  766 </span>  AlwaysCurrentPerms :: LifetimeCurrentPerms RNil
<span class="lineno">  767 </span>  -- | A variable @l@ that is @lowned@ is current, requiring perms
<span class="lineno">  768 </span>  --
<span class="lineno">  769 </span>  -- &gt; l:lowned[ls](ps_in -o ps_out)
<span class="lineno">  770 </span>  LOwnedCurrentPerms :: ExprVar LifetimeType -&gt; [PermExpr LifetimeType] -&gt;
<span class="lineno">  771 </span>                        CruCtx ps_in -&gt; CruCtx ps_out -&gt;
<span class="lineno">  772 </span>                        ExprPerms ps_in -&gt; ExprPerms ps_out -&gt;
<span class="lineno">  773 </span>                        LifetimeCurrentPerms (RNil :&gt; LifetimeType)
<span class="lineno">  774 </span>  -- | A variable @l@ with a simple @lowned@ perm is also current
<span class="lineno">  775 </span>  LOwnedSimpleCurrentPerms :: ExprVar LifetimeType -&gt;
<span class="lineno">  776 </span>                              CruCtx ps -&gt; ExprPerms ps -&gt;
<span class="lineno">  777 </span>                              LifetimeCurrentPerms (RNil :&gt; LifetimeType)
<span class="lineno">  778 </span>
<span class="lineno">  779 </span>  -- | A variable @l@ that is @lcurrent@ during another lifetime @l'@ is
<span class="lineno">  780 </span>  -- current, i.e., if @ps@ ensure @l'@ is current then we need perms
<span class="lineno">  781 </span>  --
<span class="lineno">  782 </span>  -- &gt; ps, l:lcurrent(l')
<span class="lineno">  783 </span>  CurrentTransPerms :: LifetimeCurrentPerms ps_l -&gt; ExprVar LifetimeType -&gt;
<span class="lineno">  784 </span>                       LifetimeCurrentPerms (ps_l :&gt; LifetimeType)
<span class="lineno">  785 </span>
<span class="lineno">  786 </span>-- | A lifetime functor is a function from a lifetime plus a set of 0 or more
<span class="lineno">  787 </span>-- rwmodalities to a permission that satisfies a number of properties discussed
<span class="lineno">  788 </span>-- in Issue #62 (FIXME: copy those here). Rather than try to enforce these
<span class="lineno">  789 </span>-- properties, we syntactically restrict lifetime functors to one of a few forms
<span class="lineno">  790 </span>-- that are guaranteed to satisfy the properties. The @args@ type lists all
<span class="lineno">  791 </span>-- arguments (which should all be rwmodalities) other than the lifetime
<span class="lineno">  792 </span>-- argument.
<span class="lineno">  793 </span>data LifetimeFunctor args a where
<span class="lineno">  794 </span>  -- | The functor @\(l,rw) -&gt; [l]ptr((rw,off) |-&gt; p)@
<span class="lineno">  795 </span>  LTFunctorField :: (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno">  796 </span>                    PermExpr (BVType w) -&gt; ValuePerm (LLVMPointerType sz) -&gt;
<span class="lineno">  797 </span>                    LifetimeFunctor (RNil :&gt; RWModalityType) (LLVMPointerType w)
<span class="lineno">  798 </span>
<span class="lineno">  799 </span>  -- | The functor @\(l,rw) -&gt; [l]array(rw,off,&lt;len,*stride,sh,bs)@
<span class="lineno">  800 </span>  LTFunctorArray :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (BVType w) -&gt;
<span class="lineno">  801 </span>                    PermExpr (BVType w) -&gt; Bytes -&gt;
<span class="lineno">  802 </span>                    PermExpr (LLVMShapeType w) -&gt; [LLVMArrayBorrow w] -&gt;
<span class="lineno">  803 </span>                    LifetimeFunctor (RNil :&gt; RWModalityType) (LLVMPointerType w)
<span class="lineno">  804 </span>
<span class="lineno">  805 </span>  -- | The functor @\(l,rw) -&gt; [l]memblock(rw,off,len,sh)
<span class="lineno">  806 </span>  LTFunctorBlock :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno">  807 </span>                    PermExpr (BVType w) -&gt; PermExpr (BVType w) -&gt;
<span class="lineno">  808 </span>                    PermExpr (LLVMShapeType w) -&gt;
<span class="lineno">  809 </span>                    LifetimeFunctor (RNil :&gt; RWModalityType) (LLVMPointerType w)
<span class="lineno">  810 </span>
<span class="lineno">  811 </span>  -- FIXME: add functors for arrays and named permissions
<span class="lineno">  812 </span>
<span class="lineno">  813 </span>-- | An 'LLVMBlockPerm' with a proof that its type is valid
<span class="lineno">  814 </span>data SomeLLVMBlockPerm a where
<span class="lineno">  815 </span>  SomeLLVMBlockPerm :: (1 &lt;= w, KnownNat w) =&gt; LLVMBlockPerm w -&gt;
<span class="lineno">  816 </span>                       SomeLLVMBlockPerm (LLVMPointerType w)
<span class="lineno">  817 </span>
<span class="lineno">  818 </span>-- | A block permission in a binding at some unknown type
<span class="lineno">  819 </span>data SomeBindingLLVMBlockPerm w =
<span class="lineno">  820 </span>  forall a. SomeBindingLLVMBlockPerm (Binding a (LLVMBlockPerm w))
<span class="lineno">  821 </span>
<span class="lineno">  822 </span>-- | A tagged union shape is a shape of the form
<span class="lineno">  823 </span>--
<span class="lineno">  824 </span>-- &gt; sh1 orsh sh2 orsh ... orsh shn
<span class="lineno">  825 </span>--
<span class="lineno">  826 </span>-- where each @shi@ is equivalent up to associativity of the @;@ operator to a
<span class="lineno">  827 </span>-- shape of the form
<span class="lineno">  828 </span>--
<span class="lineno">  829 </span>-- &gt; fieldsh(eq(llvmword(bvi)));shi'
<span class="lineno">  830 </span>--
<span class="lineno">  831 </span>-- That is, each disjunct of the shape starts with an equality permission that
<span class="lineno">  832 </span>-- determines which disjunct should be used. These shapes are represented as a
<span class="lineno">  833 </span>-- list of the disjuncts, which are tagged with the bitvector values @bvi@ used
<span class="lineno">  834 </span>-- in the equality permission.
<span class="lineno">  835 </span>data TaggedUnionShape w sz
<span class="lineno">  836 </span>  = TaggedUnionShape (NonEmpty (BV sz, PermExpr (LLVMShapeType w)))
<span class="lineno">  837 </span>
<span class="lineno">  838 </span>-- | A 'TaggedUnionShape' with existentially quantified tag size
<span class="lineno">  839 </span>data SomeTaggedUnionShape w
<span class="lineno">  840 </span>  = forall sz. (1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno">  841 </span>    SomeTaggedUnionShape (TaggedUnionShape w sz)
<span class="lineno">  842 </span>
<span class="lineno">  843 </span>-- | Like a substitution but assigns variables instead of arbitrary expressions
<span class="lineno">  844 </span>-- to bound variables
<span class="lineno">  845 </span>data PermVarSubst (ctx :: RList CrucibleType) where
<span class="lineno">  846 </span>  PermVarSubst_Nil :: PermVarSubst RNil
<span class="lineno">  847 </span>  PermVarSubst_Cons :: PermVarSubst ctx -&gt; Name tp -&gt; PermVarSubst (ctx :&gt; tp)
<span class="lineno">  848 </span>
<span class="lineno">  849 </span>-- | An entry in a permission environment that associates a permission and
<span class="lineno">  850 </span>-- translation with a Crucible function handle
<span class="lineno">  851 </span>data PermEnvFunEntry where
<span class="lineno">  852 </span>  PermEnvFunEntry :: args ~ CtxToRList cargs =&gt; FnHandle cargs ret -&gt;
<span class="lineno">  853 </span>                     FunPerm ghosts args gouts ret -&gt; Ident -&gt;
<span class="lineno">  854 </span>                     PermEnvFunEntry
<span class="lineno">  855 </span>
<span class="lineno">  856 </span>-- | An existentially quantified 'NamedPerm'
<span class="lineno">  857 </span>data SomeNamedPerm where
<span class="lineno">  858 </span>  SomeNamedPerm :: NamedPerm ns args a -&gt; SomeNamedPerm
<span class="lineno">  859 </span>
<span class="lineno">  860 </span>-- | An existentially quantified LLVM shape with arguments
<span class="lineno">  861 </span>data SomeNamedShape where
<span class="lineno">  862 </span>  SomeNamedShape :: (1 &lt;= w, KnownNat w) =&gt; NamedShape b args w -&gt;
<span class="lineno">  863 </span>                    SomeNamedShape
<span class="lineno">  864 </span>
<span class="lineno">  865 </span>-- | The result of translating a global symbol to SAW core terms, whose types
<span class="lineno">  866 </span>-- should be the result of translating the permissions associated with the
<span class="lineno">  867 </span>-- global symbol to SAW core types
<span class="lineno">  868 </span>newtype GlobalTrans = GlobalTrans { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">globalTransTerms</span></span></span> :: [OpenTerm] }
<span class="lineno">  869 </span>
<span class="lineno">  870 </span>-- | An entry in a permission environment that associates a 'GlobalSymbol' with
<span class="lineno">  871 </span>-- a permission and a translation of that permission to either a list of terms
<span class="lineno">  872 </span>-- or a recursive call to the @n@th function in the most recently bound frame of
<span class="lineno">  873 </span>-- recursive functions
<span class="lineno">  874 </span>data PermEnvGlobalEntry where
<span class="lineno">  875 </span>  PermEnvGlobalEntry :: (1 &lt;= w, KnownNat w) =&gt; GlobalSymbol -&gt;
<span class="lineno">  876 </span>                        ValuePerm (LLVMPointerType w) -&gt;
<span class="lineno">  877 </span>                        GlobalTrans -&gt; PermEnvGlobalEntry
<span class="lineno">  878 </span>
<span class="lineno">  879 </span>-- | The different sorts hints for blocks
<span class="lineno">  880 </span>data BlockHintSort args where
<span class="lineno">  881 </span>  -- | This hint specifies the ghost args and input permissions for a block
<span class="lineno">  882 </span>  BlockEntryHintSort ::
<span class="lineno">  883 </span>    CruCtx top_args -&gt; CruCtx ghosts -&gt;
<span class="lineno">  884 </span>    MbValuePerms ((top_args :++: CtxToRList args) :++: ghosts) -&gt;
<span class="lineno">  885 </span>    BlockHintSort args
<span class="lineno">  886 </span>
<span class="lineno">  887 </span>  -- | This hint says that the input perms for a block should be generalized
<span class="lineno">  888 </span>  GenPermsHintSort :: BlockHintSort args
<span class="lineno">  889 </span>
<span class="lineno">  890 </span>  -- | This hint says that a block should be a join point
<span class="lineno">  891 </span>  JoinPointHintSort :: BlockHintSort args
<span class="lineno">  892 </span>
<span class="lineno">  893 </span>-- | A hint for a block
<span class="lineno">  894 </span>data BlockHint blocks init ret args where
<span class="lineno">  895 </span>  BlockHint :: FnHandle init ret -&gt; Assignment CtxRepr blocks -&gt;
<span class="lineno">  896 </span>               BlockID blocks args -&gt; BlockHintSort args -&gt;
<span class="lineno">  897 </span>               BlockHint blocks init ret args
<span class="lineno">  898 </span>
<span class="lineno">  899 </span>-- | A \&quot;hint\&quot; from the user for type-checking
<span class="lineno">  900 </span>data Hint where
<span class="lineno">  901 </span>  Hint_Block :: BlockHint blocks init ret args -&gt; Hint
<span class="lineno">  902 </span>
<span class="lineno">  903 </span>-- | A permission environment that maps function names, permission names, and
<span class="lineno">  904 </span>-- 'GlobalSymbols' to their respective permission structures
<span class="lineno">  905 </span>data PermEnv = PermEnv {
<span class="lineno">  906 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">permEnvFunPerms</span></span></span> :: [PermEnvFunEntry],
<span class="lineno">  907 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">permEnvNamedPerms</span></span></span> :: [SomeNamedPerm],
<span class="lineno">  908 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">permEnvNamedShapes</span></span></span> :: [SomeNamedShape],
<span class="lineno">  909 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">permEnvGlobalSyms</span></span></span> :: [PermEnvGlobalEntry],
<span class="lineno">  910 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">permEnvHints</span></span></span> :: [Hint],
<span class="lineno">  911 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">permEnvEventType</span></span></span> :: EventType
<span class="lineno">  912 </span>  }
<span class="lineno">  913 </span>
<span class="lineno">  914 </span>-- | Get the 'EventType' of a 'PermEnv' as a SAW core term
<span class="lineno">  915 </span>permEnvEventTypeTerm :: PermEnv -&gt; OpenTerm
<span class="lineno">  916 </span><span class="decl"><span class="nottickedoff">permEnvEventTypeTerm = evTypeTerm . permEnvEventType</span></span>
<span class="lineno">  917 </span>
<span class="lineno">  918 </span>
<span class="lineno">  919 </span>----------------------------------------------------------------------
<span class="lineno">  920 </span>-- * Template Haskellgenerated instances
<span class="lineno">  921 </span>----------------------------------------------------------------------
<span class="lineno">  922 </span>
<span class="lineno">  923 </span>-- Many of these types are mutually recursive. Moreover, Template Haskell
<span class="lineno">  924 </span>-- declaration splices strictly separate top-level groups, so if we were to
<span class="lineno">  925 </span>-- write each $(mkNuMatching [t| ... |]) splice individually, the splices
<span class="lineno">  926 </span>-- involving mutually recursive types would not typecheck. As a result, we
<span class="lineno">  927 </span>-- must put everything into a single splice so that it forms a single top-level
<span class="lineno">  928 </span>-- group.
<span class="lineno">  929 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">(concatMapM mkNuMatching</span>
<span class="lineno">  930 </span><span class="spaces">  </span><span class="nottickedoff">[ [t| forall a . BVFactor a |]</span>
<span class="lineno">  931 </span><span class="spaces">  </span><span class="nottickedoff">, [t| RWModality |]</span>
<span class="lineno">  932 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall b args w. NamedShapeBody b args w |]</span>
<span class="lineno">  933 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall b args w. NamedShape b args w |]</span>
<span class="lineno">  934 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall w . LLVMFieldShape w |]</span>
<span class="lineno">  935 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall a . PermExpr a |]</span>
<span class="lineno">  936 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall w. BVRange w |]</span>
<span class="lineno">  937 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall a. MbRangeForType a |]</span>
<span class="lineno">  938 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall a. NuMatching a =&gt; SomeTypedMb a |]</span>
<span class="lineno">  939 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall w. BVProp w |]</span>
<span class="lineno">  940 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall w sz . LLVMFieldPerm w sz |]</span>
<span class="lineno">  941 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall w . LLVMArrayBorrow w |]</span>
<span class="lineno">  942 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall w . LLVMArrayPerm w |]</span>
<span class="lineno">  943 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall w . LLVMBlockPerm w |]</span>
<span class="lineno">  944 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall ns. NameSortRepr ns |]</span>
<span class="lineno">  945 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall ns args a. NameReachConstr ns args a |]</span>
<span class="lineno">  946 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall ns args a. NamedPermName ns args a |]</span>
<span class="lineno">  947 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall a. PermOffset a |]</span>
<span class="lineno">  948 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall ghosts args gouts ret. FunPerm ghosts args gouts ret |]</span>
<span class="lineno">  949 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall a . AtomicPerm a |]</span>
<span class="lineno">  950 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall a . ValuePerm a |]</span>
<span class="lineno">  951 </span><span class="spaces">  </span><span class="nottickedoff">-- , [t| forall as. ValuePerms as |]</span>
<span class="lineno">  952 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall a . VarAndPerm a |]</span>
<span class="lineno">  953 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall a . ExprAndPerm a |]</span>
<span class="lineno">  954 </span><span class="spaces">  </span><span class="nottickedoff">])</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno">  955 </span>
<span class="lineno">  956 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall w . LLVMArrayIndex w |])</span></span></span>
<span class="lineno">  957 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall args ret. SomeFunPerm args ret |])</span></span></span>
<span class="lineno">  958 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| SomeNamedPermName |])</span></span></span>
<span class="lineno">  959 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall b args a. OpaquePerm b args a |])</span></span></span>
<span class="lineno">  960 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall args a reach. ReachMethods args a reach |])</span></span></span>
<span class="lineno">  961 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall b reach args a. RecPerm b reach args a |])</span></span></span>
<span class="lineno">  962 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall b args a. DefinedPerm b args a |])</span></span></span>
<span class="lineno">  963 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall ns args a. NamedPerm ns args a |])</span></span></span>
<span class="lineno">  964 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall args a. LifetimeFunctor args a |])</span></span></span>
<span class="lineno">  965 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall ps. LifetimeCurrentPerms ps |])</span></span></span>
<span class="lineno">  966 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall a. SomeLLVMBlockPerm a |])</span></span></span>
<span class="lineno">  967 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall w. SomeBindingLLVMBlockPerm w |])</span></span></span>
<span class="lineno">  968 </span>
<span class="lineno">  969 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall w sz. TaggedUnionShape w sz |])</span></span></span>
<span class="lineno">  970 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall w. SomeTaggedUnionShape w |])</span></span></span>
<span class="lineno">  971 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall ctx. PermVarSubst ctx |])</span></span></span>
<span class="lineno">  972 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| PermEnvFunEntry |])</span></span></span>
<span class="lineno">  973 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| SomeNamedPerm |])</span></span></span>
<span class="lineno">  974 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| SomeNamedShape |])</span></span></span>
<span class="lineno">  975 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| GlobalTrans |])</span></span></span>
<span class="lineno">  976 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| PermEnvGlobalEntry |])</span></span></span>
<span class="lineno">  977 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall args. BlockHintSort args |])</span></span></span>
<span class="lineno">  978 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall blocks init ret args.</span>
<span class="lineno">  979 </span><span class="spaces">                </span><span class="nottickedoff">BlockHint blocks init ret args |])</span></span></span>
<span class="lineno">  980 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| Hint |])</span></span></span>
<span class="lineno">  981 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| EventType |])</span></span></span>
<span class="lineno">  982 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| PermEnv |])</span></span></span>
<span class="lineno">  983 </span>
<span class="lineno">  984 </span>-- NOTE: this instance would require a NuMatching instance for NameMap...
<span class="lineno">  985 </span>-- $(mkNuMatching [t| forall ps. PermSet ps |])
<span class="lineno">  986 </span>
<span class="lineno">  987 </span>
<span class="lineno">  988 </span>----------------------------------------------------------------------
<span class="lineno">  989 </span>-- * Utility Functions and Definitions
<span class="lineno">  990 </span>----------------------------------------------------------------------
<span class="lineno">  991 </span>
<span class="lineno">  992 </span>-- | Call 'RL.split' twice to split a nested appended 'RAssign' into three
<span class="lineno">  993 </span>rlSplit3 :: prx1 ctx1 -&gt; RAssign prx2 ctx2 -&gt; RAssign prx3 ctx3 -&gt;
<span class="lineno">  994 </span>            RAssign f ((ctx1 :++: ctx2) :++: ctx3) -&gt;
<span class="lineno">  995 </span>            (RAssign f ctx1, RAssign f ctx2, RAssign f ctx3)
<span class="lineno">  996 </span><span class="decl"><span class="nottickedoff">rlSplit3 (ctx1 :: prx1 ctx1) (ctx2 :: RAssign prx2 ctx2) ctx3 fs123 =</span>
<span class="lineno">  997 </span><span class="spaces">  </span><span class="nottickedoff">let (fs12, fs3) = RL.split (Proxy :: Proxy (ctx1 :++: ctx2)) ctx3 fs123 in</span>
<span class="lineno">  998 </span><span class="spaces">  </span><span class="nottickedoff">let (fs1, fs2) = RL.split ctx1 ctx2 fs12 in</span>
<span class="lineno">  999 </span><span class="spaces">  </span><span class="nottickedoff">(fs1, fs2, fs3)</span></span>
<span class="lineno"> 1000 </span>
<span class="lineno"> 1001 </span>-- | Take the ceiling of a division
<span class="lineno"> 1002 </span>ceil_div :: Integral a =&gt; a -&gt; a -&gt; a
<span class="lineno"> 1003 </span><span class="decl"><span class="nottickedoff">ceil_div a b = (a + b - fromInteger 1) `div` b</span></span>
<span class="lineno"> 1004 </span>
<span class="lineno"> 1005 </span>-- | Replace the body of a binding with a constant
<span class="lineno"> 1006 </span>mbConst :: a -&gt; Mb ctx b -&gt; Mb ctx a
<span class="lineno"> 1007 </span><span class="decl"><span class="nottickedoff">mbConst a = fmap $ const a</span></span>
<span class="lineno"> 1008 </span>
<span class="lineno"> 1009 </span>-- | Get the first element of a pair in a binding
<span class="lineno"> 1010 </span>mbFst :: NuMatching a =&gt; NuMatching b =&gt; Mb ctx (a,b) -&gt; Mb ctx a
<span class="lineno"> 1011 </span><span class="decl"><span class="nottickedoff">mbFst = mbMapCl $(mkClosed [| fst |])</span></span>
<span class="lineno"> 1012 </span>
<span class="lineno"> 1013 </span>-- | Get the second element of a pair in a binding
<span class="lineno"> 1014 </span>mbSnd :: NuMatching a =&gt; NuMatching b =&gt; Mb ctx (a,b) -&gt; Mb ctx b
<span class="lineno"> 1015 </span><span class="decl"><span class="nottickedoff">mbSnd = mbMapCl $(mkClosed [| snd |])</span></span>
<span class="lineno"> 1016 </span>
<span class="lineno"> 1017 </span>-- | Get the first element of a triple in a binding
<span class="lineno"> 1018 </span>mbFst3 :: NuMatching a =&gt; NuMatching b =&gt; NuMatching c =&gt;
<span class="lineno"> 1019 </span>          Mb ctx (a,b,c) -&gt; Mb ctx a
<span class="lineno"> 1020 </span><span class="decl"><span class="nottickedoff">mbFst3 = mbMapCl $(mkClosed [| \(a,_,_) -&gt; a |])</span></span>
<span class="lineno"> 1021 </span>
<span class="lineno"> 1022 </span>-- | Get the first element of a triple in a binding
<span class="lineno"> 1023 </span>mbSnd3 :: NuMatching a =&gt; NuMatching b =&gt; NuMatching c =&gt;
<span class="lineno"> 1024 </span>          Mb ctx (a,b,c) -&gt; Mb ctx b
<span class="lineno"> 1025 </span><span class="decl"><span class="nottickedoff">mbSnd3 = mbMapCl $(mkClosed [| \(_,b,_) -&gt; b |])</span></span>
<span class="lineno"> 1026 </span>
<span class="lineno"> 1027 </span>-- | Get the first element of a triple in a binding
<span class="lineno"> 1028 </span>mbThd3 :: NuMatching a =&gt; NuMatching b =&gt; NuMatching c =&gt;
<span class="lineno"> 1029 </span>          Mb ctx (a,b,c) -&gt; Mb ctx c
<span class="lineno"> 1030 </span><span class="decl"><span class="nottickedoff">mbThd3 = mbMapCl $(mkClosed [| \(_,_,c) -&gt; c |])</span></span>
<span class="lineno"> 1031 </span>
<span class="lineno"> 1032 </span>-- | FIXME: put this somewhere more appropriate
<span class="lineno"> 1033 </span>subNat' :: NatRepr m -&gt; NatRepr n -&gt; Maybe (NatRepr (m-n))
<span class="lineno"> 1034 </span><span class="decl"><span class="nottickedoff">subNat' m n</span>
<span class="lineno"> 1035 </span><span class="spaces">  </span><span class="nottickedoff">| Left leq &lt;- decideLeq n m =</span>
<span class="lineno"> 1036 </span><span class="spaces">    </span><span class="nottickedoff">Just $ withLeqProof leq $ subNat m n</span>
<span class="lineno"> 1037 </span><span class="spaces"></span><span class="nottickedoff">subNat' _ _ = Nothing</span></span>
<span class="lineno"> 1038 </span>
<span class="lineno"> 1039 </span>-- | Delete the nth element of a list
<span class="lineno"> 1040 </span>deleteNth :: Int -&gt; [a] -&gt; [a]
<span class="lineno"> 1041 </span><span class="decl"><span class="nottickedoff">deleteNth i xs | i &gt;= length xs = error &quot;deleteNth&quot;</span>
<span class="lineno"> 1042 </span><span class="spaces"></span><span class="nottickedoff">deleteNth i xs = take i xs ++ drop (i+1) xs</span></span>
<span class="lineno"> 1043 </span>
<span class="lineno"> 1044 </span>-- | Apply 'deleteNth' inside a name-binding
<span class="lineno"> 1045 </span>mbDeleteNth :: NuMatching a =&gt; Int -&gt; Mb ctx [a] -&gt; Mb ctx [a]
<span class="lineno"> 1046 </span><span class="decl"><span class="nottickedoff">mbDeleteNth i = mbMapCl ($(mkClosed [| deleteNth |]) `clApply` toClosed i)</span></span>
<span class="lineno"> 1047 </span>
<span class="lineno"> 1048 </span>-- | Replace the nth element of a list
<span class="lineno"> 1049 </span>replaceNth :: Int -&gt; a -&gt; [a] -&gt; [a]
<span class="lineno"> 1050 </span><span class="decl"><span class="nottickedoff">replaceNth i _ xs | i &gt;= length xs = error &quot;replaceNth&quot;</span>
<span class="lineno"> 1051 </span><span class="spaces"></span><span class="nottickedoff">replaceNth i x xs = take i xs ++ x : drop (i+1) xs</span></span>
<span class="lineno"> 1052 </span>
<span class="lineno"> 1053 </span>-- | Insert an element at the nth location in a list
<span class="lineno"> 1054 </span>insertNth :: Int -&gt; a -&gt; [a] -&gt; [a]
<span class="lineno"> 1055 </span><span class="decl"><span class="nottickedoff">insertNth i x xs = take i xs ++ x : drop i xs</span></span>
<span class="lineno"> 1056 </span>
<span class="lineno"> 1057 </span>-- | Find the @n@th element of a list in a binding
<span class="lineno"> 1058 </span>mbNth :: NuMatching a =&gt; Int -&gt; Mb ctx [a] -&gt; Mb ctx a
<span class="lineno"> 1059 </span><span class="decl"><span class="nottickedoff">mbNth i = mbMapCl ($(mkClosed [| flip (!!) |]) `clApply` toClosed i)</span></span>
<span class="lineno"> 1060 </span>
<span class="lineno"> 1061 </span>-- | Find all elements of list @l@ where @f@ returns a value and return that
<span class="lineno"> 1062 </span>-- value plus its index into @l@
<span class="lineno"> 1063 </span>findMaybeIndices :: (a -&gt; Maybe b) -&gt; [a] -&gt; [(Int, b)]
<span class="lineno"> 1064 </span><span class="decl"><span class="nottickedoff">findMaybeIndices f l = catMaybes $ zipWith (\i a -&gt; (i,) &lt;$&gt; f a) [0 ..] l</span></span>
<span class="lineno"> 1065 </span>
<span class="lineno"> 1066 </span>-- | Find the index of the first element of a list that returns the maximal
<span class="lineno"> 1067 </span>-- positive value from the supplied ranking function, or return 'Nothing' if all
<span class="lineno"> 1068 </span>-- elements have non-positive rank
<span class="lineno"> 1069 </span>findBestIndex :: (a -&gt; Int) -&gt; [a] -&gt; Maybe Int
<span class="lineno"> 1070 </span><span class="decl"><span class="nottickedoff">findBestIndex rank_f l =</span>
<span class="lineno"> 1071 </span><span class="spaces">  </span><span class="nottickedoff">fst $ foldl (\(best_ix,best_rank) (ix,rank) -&gt;</span>
<span class="lineno"> 1072 </span><span class="spaces">                </span><span class="nottickedoff">if rank &gt; best_rank then (Just ix, rank) else</span>
<span class="lineno"> 1073 </span><span class="spaces">                  </span><span class="nottickedoff">(best_ix,best_rank))</span>
<span class="lineno"> 1074 </span><span class="spaces">  </span><span class="nottickedoff">(Nothing, 0) (zipWith (\i a -&gt; (i,rank_f a)) [0 ..] l)</span></span>
<span class="lineno"> 1075 </span>
<span class="lineno"> 1076 </span>-- | Combine all elements of a list like 'foldr1' unless the list is empty, in
<span class="lineno"> 1077 </span>-- which case return the default case
<span class="lineno"> 1078 </span>foldr1WithDefault :: (a -&gt; a -&gt; a) -&gt; a -&gt; [a] -&gt; a
<span class="lineno"> 1079 </span><span class="decl"><span class="nottickedoff">foldr1WithDefault _ def [] = def</span>
<span class="lineno"> 1080 </span><span class="spaces"></span><span class="nottickedoff">foldr1WithDefault _ _ [a] = a</span>
<span class="lineno"> 1081 </span><span class="spaces"></span><span class="nottickedoff">foldr1WithDefault f def (a:as) = f a $ foldr1WithDefault f def as</span></span>
<span class="lineno"> 1082 </span>
<span class="lineno"> 1083 </span>-- | Map a function across a list and then call 'foldr1WithDefault'. This is a
<span class="lineno"> 1084 </span>-- form of map-reduce where the default is returned as a special case for the
<span class="lineno"> 1085 </span>-- empty list.
<span class="lineno"> 1086 </span>foldMapWithDefault :: (b -&gt; b -&gt; b) -&gt; b -&gt; (a -&gt; b) -&gt; [a] -&gt; b
<span class="lineno"> 1087 </span><span class="decl"><span class="nottickedoff">foldMapWithDefault comb def f l = foldr1WithDefault comb def $ map f l</span></span>
<span class="lineno"> 1088 </span>
<span class="lineno"> 1089 </span>-- | Build a 'NameSet' from a sequence of names and a list of 'Bool' flags
<span class="lineno"> 1090 </span>nameSetFromFlags :: RAssign Name (ctx :: RList k) -&gt; [Bool] -&gt; NameSet k
<span class="lineno"> 1091 </span><span class="decl"><span class="nottickedoff">nameSetFromFlags ns flags =</span>
<span class="lineno"> 1092 </span><span class="spaces">  </span><span class="nottickedoff">NameSet.fromList $</span>
<span class="lineno"> 1093 </span><span class="spaces">  </span><span class="nottickedoff">mapMaybe (\(n,flag) -&gt; if flag then Just n else Nothing) $</span>
<span class="lineno"> 1094 </span><span class="spaces">  </span><span class="nottickedoff">zip (RL.mapToList SomeName ns) flags</span></span>
<span class="lineno"> 1095 </span>
<span class="lineno"> 1096 </span>-- | A flag indicating whether an equality test has unfolded a
<span class="lineno"> 1097 </span>-- recursively-defined name on one side of the equation already
<span class="lineno"> 1098 </span>data RecurseFlag = RecLeft | RecRight | RecNone
<span class="lineno"> 1099 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Read</span></span></span></span></span></span></span></span>)
<span class="lineno"> 1100 </span>
<span class="lineno"> 1101 </span>
<span class="lineno"> 1102 </span>----------------------------------------------------------------------
<span class="lineno"> 1103 </span>-- * Pretty-printing
<span class="lineno"> 1104 </span>----------------------------------------------------------------------
<span class="lineno"> 1105 </span>
<span class="lineno"> 1106 </span>-- | A special-purpose type used to indicate debugging level
<span class="lineno"> 1107 </span>data DebugLevel = DebugLevel Int deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>,<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span></span></span></span></span>)
<span class="lineno"> 1108 </span>
<span class="lineno"> 1109 </span>-- | The debug level for no debugging
<span class="lineno"> 1110 </span>noDebugLevel :: DebugLevel
<span class="lineno"> 1111 </span><span class="decl"><span class="nottickedoff">noDebugLevel = DebugLevel 0</span></span>
<span class="lineno"> 1112 </span>
<span class="lineno"> 1113 </span>-- | The debug level to enable tracing
<span class="lineno"> 1114 </span>traceDebugLevel :: DebugLevel
<span class="lineno"> 1115 </span><span class="decl"><span class="nottickedoff">traceDebugLevel = DebugLevel 1</span></span>
<span class="lineno"> 1116 </span>
<span class="lineno"> 1117 </span>-- | The debug level to enable more verbose tracing
<span class="lineno"> 1118 </span>verboseDebugLevel :: DebugLevel
<span class="lineno"> 1119 </span><span class="decl"><span class="nottickedoff">verboseDebugLevel = DebugLevel 2</span></span>
<span class="lineno"> 1120 </span>
<span class="lineno"> 1121 </span>-- | Output a debug statement to @stderr@ using 'trace' if the second
<span class="lineno"> 1122 </span>-- 'DebugLevel' is at least the first, i.e., the first is the required level for
<span class="lineno"> 1123 </span>-- emitting this trace and the second is the current level
<span class="lineno"> 1124 </span>debugTrace :: DebugLevel -&gt; DebugLevel -&gt; String -&gt; a -&gt; a
<span class="lineno"> 1125 </span><span class="decl"><span class="nottickedoff">debugTrace req dlevel | dlevel &gt;= req = trace</span>
<span class="lineno"> 1126 </span><span class="spaces"></span><span class="nottickedoff">debugTrace _ _ = const id</span></span>
<span class="lineno"> 1127 </span>
<span class="lineno"> 1128 </span>-- | Call 'debugTrace' at 'traceDebugLevel'
<span class="lineno"> 1129 </span>debugTraceTraceLvl :: DebugLevel -&gt; String -&gt; a -&gt; a
<span class="lineno"> 1130 </span><span class="decl"><span class="nottickedoff">debugTraceTraceLvl = debugTrace traceDebugLevel</span></span>
<span class="lineno"> 1131 </span>
<span class="lineno"> 1132 </span>-- | Like 'debugTrace' but take in a 'Doc' instead of a 'String'
<span class="lineno"> 1133 </span>debugTracePretty :: DebugLevel -&gt; DebugLevel -&gt; Doc ann -&gt; a -&gt; a
<span class="lineno"> 1134 </span><span class="decl"><span class="nottickedoff">debugTracePretty req dlevel d a = debugTrace req dlevel (renderDoc d) a</span></span>
<span class="lineno"> 1135 </span>
<span class="lineno"> 1136 </span>-- | Convert a type to a base name for printing variables of that type
<span class="lineno"> 1137 </span>typeBaseName :: TypeRepr a -&gt; String
<span class="lineno"> 1138 </span><span class="decl"><span class="nottickedoff">typeBaseName UnitRepr = &quot;u&quot;</span>
<span class="lineno"> 1139 </span><span class="spaces"></span><span class="nottickedoff">typeBaseName BoolRepr = &quot;b&quot;</span>
<span class="lineno"> 1140 </span><span class="spaces"></span><span class="nottickedoff">typeBaseName NatRepr = &quot;n&quot;</span>
<span class="lineno"> 1141 </span><span class="spaces"></span><span class="nottickedoff">typeBaseName (BVRepr _) = &quot;bv&quot;</span>
<span class="lineno"> 1142 </span><span class="spaces"></span><span class="nottickedoff">typeBaseName (LLVMPointerRepr _) = &quot;ptr&quot;</span>
<span class="lineno"> 1143 </span><span class="spaces"></span><span class="nottickedoff">typeBaseName (LLVMBlockRepr _) = &quot;blk&quot;</span>
<span class="lineno"> 1144 </span><span class="spaces"></span><span class="nottickedoff">typeBaseName (LLVMFrameRepr _) = &quot;frm&quot;</span>
<span class="lineno"> 1145 </span><span class="spaces"></span><span class="nottickedoff">typeBaseName LifetimeRepr = &quot;l&quot;</span>
<span class="lineno"> 1146 </span><span class="spaces"></span><span class="nottickedoff">typeBaseName RWModalityRepr = &quot;rw&quot;</span>
<span class="lineno"> 1147 </span><span class="spaces"></span><span class="nottickedoff">typeBaseName (ValuePermRepr _) = &quot;perm&quot;</span>
<span class="lineno"> 1148 </span><span class="spaces"></span><span class="nottickedoff">typeBaseName (LLVMShapeRepr _) = &quot;shape&quot;</span>
<span class="lineno"> 1149 </span><span class="spaces"></span><span class="nottickedoff">typeBaseName (StringRepr _) = &quot;str&quot;</span>
<span class="lineno"> 1150 </span><span class="spaces"></span><span class="nottickedoff">typeBaseName (FunctionHandleRepr _ _) = &quot;fn&quot;</span>
<span class="lineno"> 1151 </span><span class="spaces"></span><span class="nottickedoff">typeBaseName (StructRepr _) = &quot;strct&quot;</span>
<span class="lineno"> 1152 </span><span class="spaces"></span><span class="nottickedoff">typeBaseName _ = &quot;x&quot;</span></span>
<span class="lineno"> 1153 </span>
<span class="lineno"> 1154 </span>
<span class="lineno"> 1155 </span>-- | A 'PPInfo' maps bound 'Name's to strings used for printing, with the
<span class="lineno"> 1156 </span>-- invariant that each 'Name' is mapped to a different string. This invariant is
<span class="lineno"> 1157 </span>-- maintained by always assigning each 'Name' to a \&quot;base string\&quot;, which is
<span class="lineno"> 1158 </span>-- often determined by the Crucible type of the 'Name', followed by a unique
<span class="lineno"> 1159 </span>-- integer. Note that this means no base name should end with an integer. To
<span class="lineno"> 1160 </span>-- ensure the uniqueness of these integers, the 'PPInfo' structure tracks the
<span class="lineno"> 1161 </span>-- next integer to be used for each base string.
<span class="lineno"> 1162 </span>data PPInfo =
<span class="lineno"> 1163 </span>  PPInfo { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">ppExprNames</span></span></span> :: NameMap (StringF :: CrucibleType -&gt; Type),
<span class="lineno"> 1164 </span>           <span class="nottickedoff"><span class="decl"><span class="nottickedoff">ppBaseNextInt</span></span></span> :: Map String Int }
<span class="lineno"> 1165 </span>
<span class="lineno"> 1166 </span>-- | Build an empty 'PPInfo' structure
<span class="lineno"> 1167 </span>emptyPPInfo :: PPInfo
<span class="lineno"> 1168 </span><span class="decl"><span class="nottickedoff">emptyPPInfo = PPInfo NameMap.empty Map.empty</span></span>
<span class="lineno"> 1169 </span>
<span class="lineno"> 1170 </span>-- | Add an expression variable to a 'PPInfo' with the given base name
<span class="lineno"> 1171 </span>ppInfoAddExprName :: String -&gt; ExprVar a -&gt; PPInfo -&gt; PPInfo
<span class="lineno"> 1172 </span><span class="decl"><span class="nottickedoff">ppInfoAddExprName base x ppi =</span>
<span class="lineno"> 1173 </span><span class="spaces">  </span><span class="nottickedoff">let (ppi', str) = ppInfoAllocateName base ppi in</span>
<span class="lineno"> 1174 </span><span class="spaces">  </span><span class="nottickedoff">ppInfoApplyName x str ppi'</span></span>
<span class="lineno"> 1175 </span>
<span class="lineno"> 1176 </span>ppInfoApplyName :: Name (x :: CrucibleType) -&gt; String -&gt; PPInfo -&gt; PPInfo
<span class="lineno"> 1177 </span><span class="decl"><span class="nottickedoff">ppInfoApplyName x str ppi =</span>
<span class="lineno"> 1178 </span><span class="spaces">  </span><span class="nottickedoff">ppi { ppExprNames = NameMap.insert x (StringF str) (ppExprNames ppi) }</span></span>
<span class="lineno"> 1179 </span>
<span class="lineno"> 1180 </span>ppInfoAllocateName :: String -&gt; PPInfo -&gt; (PPInfo, String)
<span class="lineno"> 1181 </span><span class="decl"><span class="nottickedoff">ppInfoAllocateName base _</span>
<span class="lineno"> 1182 </span><span class="spaces">  </span><span class="nottickedoff">| length base == 0 || isDigit (last base) =</span>
<span class="lineno"> 1183 </span><span class="spaces">    </span><span class="nottickedoff">error (&quot;ppInfoAddExprName: invalid base name: &quot; ++ base)</span>
<span class="lineno"> 1184 </span><span class="spaces"></span><span class="nottickedoff">ppInfoAllocateName base ppi =</span>
<span class="lineno"> 1185 </span><span class="spaces">  </span><span class="nottickedoff">let (i',str) =</span>
<span class="lineno"> 1186 </span><span class="spaces">        </span><span class="nottickedoff">case Map.lookup base (ppBaseNextInt ppi) of</span>
<span class="lineno"> 1187 </span><span class="spaces">          </span><span class="nottickedoff">Just i -&gt; (i+1, base ++ show i)</span>
<span class="lineno"> 1188 </span><span class="spaces">          </span><span class="nottickedoff">Nothing -&gt; (1, base) in</span>
<span class="lineno"> 1189 </span><span class="spaces">  </span><span class="nottickedoff">(ppi { ppBaseNextInt = Map.insert base i' (ppBaseNextInt ppi) }, str)</span></span>
<span class="lineno"> 1190 </span>
<span class="lineno"> 1191 </span>-- | Add a sequence of variables to a 'PPInfo' with the given base name
<span class="lineno"> 1192 </span>ppInfoAddExprNames :: String -&gt; RAssign Name (tps :: RList CrucibleType) -&gt;
<span class="lineno"> 1193 </span>                      PPInfo -&gt; PPInfo
<span class="lineno"> 1194 </span><span class="decl"><span class="nottickedoff">ppInfoAddExprNames _ MNil info = info</span>
<span class="lineno"> 1195 </span><span class="spaces"></span><span class="nottickedoff">ppInfoAddExprNames base (ns :&gt;: n) info =</span>
<span class="lineno"> 1196 </span><span class="spaces">  </span><span class="nottickedoff">ppInfoAddExprNames base ns $ ppInfoAddExprName base n info</span></span>
<span class="lineno"> 1197 </span>
<span class="lineno"> 1198 </span>-- |
<span class="lineno"> 1199 </span>ppInfoAllocateExprNames ::
<span class="lineno"> 1200 </span>  String {- ^ base name -} -&gt;
<span class="lineno"> 1201 </span>  RAssign pxy (tps :: RList CrucibleType) -&gt;
<span class="lineno"> 1202 </span>  PPInfo -&gt;
<span class="lineno"> 1203 </span>  (PPInfo, RAssign StringF tps)
<span class="lineno"> 1204 </span><span class="decl"><span class="nottickedoff">ppInfoAllocateExprNames _ MNil info = (info, MNil)</span>
<span class="lineno"> 1205 </span><span class="spaces"></span><span class="nottickedoff">ppInfoAllocateExprNames base (ns :&gt;: _) ppi =</span>
<span class="lineno"> 1206 </span><span class="spaces">  </span><span class="nottickedoff">case ppInfoAllocateName base ppi of</span>
<span class="lineno"> 1207 </span><span class="spaces">    </span><span class="nottickedoff">(ppi1, str) -&gt;</span>
<span class="lineno"> 1208 </span><span class="spaces">      </span><span class="nottickedoff">case ppInfoAllocateExprNames base ns ppi1 of</span>
<span class="lineno"> 1209 </span><span class="spaces">        </span><span class="nottickedoff">(ppi2, ns') -&gt; (ppi2, ns' :&gt;: StringF str)</span></span>
<span class="lineno"> 1210 </span>
<span class="lineno"> 1211 </span>-- | Add a sequence of variables to a 'PPInfo' using their 'typeBaseName's
<span class="lineno"> 1212 </span>ppInfoAddTypedExprNames :: CruCtx tps -&gt; RAssign Name tps -&gt; PPInfo -&gt; PPInfo
<span class="lineno"> 1213 </span><span class="decl"><span class="nottickedoff">ppInfoAddTypedExprNames _ MNil info = info</span>
<span class="lineno"> 1214 </span><span class="spaces"></span><span class="nottickedoff">ppInfoAddTypedExprNames (CruCtxCons tps tp) (ns :&gt;: n) info =</span>
<span class="lineno"> 1215 </span><span class="spaces">  </span><span class="nottickedoff">ppInfoAddTypedExprNames tps ns $ ppInfoAddExprName (typeBaseName tp) n info</span></span>
<span class="lineno"> 1216 </span>
<span class="lineno"> 1217 </span>ppInfoApplyAllocation ::
<span class="lineno"> 1218 </span>  RAssign Name (tps :: RList CrucibleType) -&gt;
<span class="lineno"> 1219 </span>  RAssign StringF tps -&gt;
<span class="lineno"> 1220 </span>  PPInfo -&gt;
<span class="lineno"> 1221 </span>  PPInfo
<span class="lineno"> 1222 </span><span class="decl"><span class="nottickedoff">ppInfoApplyAllocation MNil MNil ppi = ppi</span>
<span class="lineno"> 1223 </span><span class="spaces"></span><span class="nottickedoff">ppInfoApplyAllocation (ns :&gt;: n) (ss :&gt;: StringF s) ppi =</span>
<span class="lineno"> 1224 </span><span class="spaces">  </span><span class="nottickedoff">ppInfoApplyAllocation ns ss (ppInfoApplyName n s ppi)</span></span>
<span class="lineno"> 1225 </span>
<span class="lineno"> 1226 </span>type PermPPM = Reader PPInfo
<span class="lineno"> 1227 </span>
<span class="lineno"> 1228 </span>instance NuMatching (Doc ann) where
<span class="lineno"> 1229 </span>  <span class="decl"><span class="nottickedoff">nuMatchingProof = unsafeMbTypeRepr</span></span>
<span class="lineno"> 1230 </span>
<span class="lineno"> 1231 </span>instance Closable (Doc ann) where
<span class="lineno"> 1232 </span>  <span class="decl"><span class="nottickedoff">toClosed = unsafeClose</span></span>
<span class="lineno"> 1233 </span>
<span class="lineno"> 1234 </span>instance Liftable (Doc ann) where
<span class="lineno"> 1235 </span>  <span class="decl"><span class="nottickedoff">mbLift = unClosed . mbLift . fmap toClosed</span></span>
<span class="lineno"> 1236 </span>
<span class="lineno"> 1237 </span>
<span class="lineno"> 1238 </span>class PermPretty a where
<span class="lineno"> 1239 </span>  permPrettyM :: a -&gt; PermPPM (Doc ann)
<span class="lineno"> 1240 </span>
<span class="lineno"> 1241 </span>class PermPrettyF f where
<span class="lineno"> 1242 </span>  permPrettyMF :: f a -&gt; PermPPM (Doc ann)
<span class="lineno"> 1243 </span>
<span class="lineno"> 1244 </span>permPretty :: PermPretty a =&gt; PPInfo -&gt; a -&gt; Doc ann
<span class="lineno"> 1245 </span><span class="decl"><span class="nottickedoff">permPretty info a = runReader (permPrettyM a) info</span></span>
<span class="lineno"> 1246 </span>
<span class="lineno"> 1247 </span>renderDoc :: Doc ann -&gt; String
<span class="lineno"> 1248 </span><span class="decl"><span class="nottickedoff">renderDoc doc = renderString (layoutPretty opts doc)</span>
<span class="lineno"> 1249 </span><span class="spaces">  </span><span class="nottickedoff">where opts = LayoutOptions (AvailablePerLine 80 0.8)</span></span>
<span class="lineno"> 1250 </span>
<span class="lineno"> 1251 </span>permPrettyString :: PermPretty a =&gt; PPInfo -&gt; a -&gt; String
<span class="lineno"> 1252 </span><span class="decl"><span class="nottickedoff">permPrettyString info a = renderDoc $ permPretty info a</span></span>
<span class="lineno"> 1253 </span>
<span class="lineno"> 1254 </span>tracePretty :: Doc ann -&gt; a -&gt; a
<span class="lineno"> 1255 </span><span class="decl"><span class="nottickedoff">tracePretty doc = trace (renderDoc doc)</span></span>
<span class="lineno"> 1256 </span>
<span class="lineno"> 1257 </span>-- | Pretty-print a comma-separated list
<span class="lineno"> 1258 </span>ppCommaSep :: [Doc ann] -&gt; Doc ann
<span class="lineno"> 1259 </span><span class="decl"><span class="nottickedoff">ppCommaSep ds =</span>
<span class="lineno"> 1260 </span><span class="spaces">  </span><span class="nottickedoff">PP.group $ align $ fillSep $ map PP.group $ PP.punctuate comma ds</span></span>
<span class="lineno"> 1261 </span>
<span class="lineno"> 1262 </span>-- | Pretty-print a comma-separated list using 'fillSep' enclosed inside either
<span class="lineno"> 1263 </span>-- parentheses (if the supplied flag is 'True') or brackets (if it is 'False')
<span class="lineno"> 1264 </span>ppEncList :: Bool -&gt; [Doc ann] -&gt; Doc ann
<span class="lineno"> 1265 </span><span class="decl"><span class="nottickedoff">ppEncList flag ds =</span>
<span class="lineno"> 1266 </span><span class="spaces">  </span><span class="nottickedoff">(if flag then parens else brackets) $ ppCommaSep ds</span></span>
<span class="lineno"> 1267 </span>
<span class="lineno"> 1268 </span>instance (PermPretty a, PermPretty b) =&gt; PermPretty (a,b) where
<span class="lineno"> 1269 </span>  <span class="decl"><span class="nottickedoff">permPrettyM (a,b) = ppEncList True &lt;$&gt; sequence [permPrettyM a, permPrettyM b]</span></span>
<span class="lineno"> 1270 </span>
<span class="lineno"> 1271 </span>instance (PermPretty a, PermPretty b, PermPretty c) =&gt; PermPretty (a,b,c) where
<span class="lineno"> 1272 </span>  <span class="decl"><span class="nottickedoff">permPrettyM (a,b,c) =</span>
<span class="lineno"> 1273 </span><span class="spaces">    </span><span class="nottickedoff">ppEncList True &lt;$&gt; sequence [permPrettyM a, permPrettyM b, permPrettyM c]</span></span>
<span class="lineno"> 1274 </span>
<span class="lineno"> 1275 </span>instance PermPretty a =&gt; PermPretty [a] where
<span class="lineno"> 1276 </span>  <span class="decl"><span class="nottickedoff">permPrettyM as = ppEncList False &lt;$&gt; mapM permPrettyM as</span></span>
<span class="lineno"> 1277 </span>
<span class="lineno"> 1278 </span>instance PermPretty a =&gt; PermPretty (Maybe a) where
<span class="lineno"> 1279 </span>  <span class="decl"><span class="nottickedoff">permPrettyM Nothing = return $ pretty &quot;Nothing&quot;</span>
<span class="lineno"> 1280 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (Just a) = do</span>
<span class="lineno"> 1281 </span><span class="spaces">    </span><span class="nottickedoff">a_pp &lt;- permPrettyM a</span>
<span class="lineno"> 1282 </span><span class="spaces">    </span><span class="nottickedoff">return (pretty &quot;Just&quot; &lt;+&gt; a_pp)</span></span>
<span class="lineno"> 1283 </span>
<span class="lineno"> 1284 </span>instance PermPrettyF f =&gt; PermPretty (Some f) where
<span class="lineno"> 1285 </span>  <span class="decl"><span class="nottickedoff">permPrettyM (Some x) = permPrettyMF x</span></span>
<span class="lineno"> 1286 </span>
<span class="lineno"> 1287 </span>instance PermPretty (ExprVar a) where
<span class="lineno"> 1288 </span>  <span class="decl"><span class="nottickedoff">permPrettyM x =</span>
<span class="lineno"> 1289 </span><span class="spaces">    </span><span class="nottickedoff">do maybe_str &lt;- NameMap.lookup x &lt;$&gt; ppExprNames &lt;$&gt; ask</span>
<span class="lineno"> 1290 </span><span class="spaces">       </span><span class="nottickedoff">case maybe_str of</span>
<span class="lineno"> 1291 </span><span class="spaces">         </span><span class="nottickedoff">Just (StringF str) -&gt; return $ pretty str</span>
<span class="lineno"> 1292 </span><span class="spaces">         </span><span class="nottickedoff">Nothing -&gt; return $ pretty (show x)</span></span>
<span class="lineno"> 1293 </span>
<span class="lineno"> 1294 </span>instance PermPrettyF (Name :: CrucibleType -&gt; Type) where
<span class="lineno"> 1295 </span>  <span class="decl"><span class="nottickedoff">permPrettyMF = permPrettyM</span></span>
<span class="lineno"> 1296 </span>
<span class="lineno"> 1297 </span>instance PermPretty (SomeName CrucibleType) where
<span class="lineno"> 1298 </span>  <span class="decl"><span class="nottickedoff">permPrettyM (SomeName x) = permPrettyM x</span></span>
<span class="lineno"> 1299 </span>
<span class="lineno"> 1300 </span>instance PermPrettyF f =&gt; PermPretty (RAssign f ctx) where
<span class="lineno"> 1301 </span>  <span class="decl"><span class="nottickedoff">permPrettyM xs =</span>
<span class="lineno"> 1302 </span><span class="spaces">    </span><span class="nottickedoff">ppCommaSep &lt;$&gt; sequence (RL.mapToList permPrettyMF xs)</span></span>
<span class="lineno"> 1303 </span>
<span class="lineno"> 1304 </span>instance PermPrettyF f =&gt; PermPrettyF (RAssign f) where
<span class="lineno"> 1305 </span>  <span class="decl"><span class="nottickedoff">permPrettyMF xs = permPrettyM xs</span></span>
<span class="lineno"> 1306 </span>
<span class="lineno"> 1307 </span>
<span class="lineno"> 1308 </span>instance PermPretty (TypeRepr a) where
<span class="lineno"> 1309 </span>  <span class="decl"><span class="nottickedoff">permPrettyM UnitRepr = return $ pretty &quot;unit&quot;</span>
<span class="lineno"> 1310 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM BoolRepr = return $ pretty &quot;bool&quot;</span>
<span class="lineno"> 1311 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM NatRepr = return $ pretty &quot;nat&quot;</span>
<span class="lineno"> 1312 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (BVRepr w) = return (pretty &quot;bv&quot; &lt;+&gt; pretty (intValue w))</span>
<span class="lineno"> 1313 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (LLVMPointerRepr w) =</span>
<span class="lineno"> 1314 </span><span class="spaces">    </span><span class="nottickedoff">return (pretty &quot;llvmptr&quot; &lt;+&gt; pretty (intValue w))</span>
<span class="lineno"> 1315 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (LLVMFrameRepr w) =</span>
<span class="lineno"> 1316 </span><span class="spaces">    </span><span class="nottickedoff">return (pretty &quot;llvmframe&quot; &lt;+&gt; pretty (intValue w))</span>
<span class="lineno"> 1317 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM LifetimeRepr = return $ pretty &quot;lifetime&quot;</span>
<span class="lineno"> 1318 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM RWModalityRepr = return $ pretty &quot;rwmodality&quot;</span>
<span class="lineno"> 1319 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (LLVMShapeRepr w) =</span>
<span class="lineno"> 1320 </span><span class="spaces">    </span><span class="nottickedoff">return (pretty &quot;llvmshape&quot; &lt;+&gt; pretty (intValue w))</span>
<span class="lineno"> 1321 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (LLVMBlockRepr w) =</span>
<span class="lineno"> 1322 </span><span class="spaces">    </span><span class="nottickedoff">return (pretty &quot;llvmblock&quot; &lt;+&gt; pretty (intValue w))</span>
<span class="lineno"> 1323 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM PermListRepr = return $ pretty &quot;permlist&quot;</span>
<span class="lineno"> 1324 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (StructRepr flds) =</span>
<span class="lineno"> 1325 </span><span class="spaces">    </span><span class="nottickedoff">(pretty &quot;struct&quot; &lt;+&gt;) &lt;$&gt; parens &lt;$&gt; permPrettyM (assignToRList flds)</span>
<span class="lineno"> 1326 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (ValuePermRepr tp) = (pretty &quot;perm&quot; &lt;+&gt;) &lt;$&gt; permPrettyM tp</span>
<span class="lineno"> 1327 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM tp =</span>
<span class="lineno"> 1328 </span><span class="spaces">    </span><span class="nottickedoff">return (pretty &quot;not-yet-printable type&quot; &lt;+&gt; parens (pretty tp))</span></span>
<span class="lineno"> 1329 </span>
<span class="lineno"> 1330 </span>instance PermPrettyF TypeRepr where
<span class="lineno"> 1331 </span>  <span class="decl"><span class="nottickedoff">permPrettyMF = permPrettyM</span></span>
<span class="lineno"> 1332 </span>
<span class="lineno"> 1333 </span>instance PermPretty (CruCtx ctx) where
<span class="lineno"> 1334 </span>  <span class="decl"><span class="nottickedoff">permPrettyM = permPrettyM . cruCtxToTypes</span></span>
<span class="lineno"> 1335 </span>
<span class="lineno"> 1336 </span>-- | A pair of a variable and its 'CrucibleType', for pretty-printing
<span class="lineno"> 1337 </span>data VarAndType a = VarAndType (ExprVar a) (TypeRepr a)
<span class="lineno"> 1338 </span>
<span class="lineno"> 1339 </span>instance PermPretty (VarAndType a) where
<span class="lineno"> 1340 </span>  <span class="decl"><span class="nottickedoff">permPrettyM (VarAndType x tp) =</span>
<span class="lineno"> 1341 </span><span class="spaces">    </span><span class="nottickedoff">do x_pp &lt;- permPrettyM x</span>
<span class="lineno"> 1342 </span><span class="spaces">       </span><span class="nottickedoff">tp_pp &lt;- permPrettyM tp</span>
<span class="lineno"> 1343 </span><span class="spaces">       </span><span class="nottickedoff">return (x_pp &lt;&gt; colon &lt;&gt; tp_pp)</span></span>
<span class="lineno"> 1344 </span>
<span class="lineno"> 1345 </span>instance PermPrettyF VarAndType where
<span class="lineno"> 1346 </span>  <span class="decl"><span class="nottickedoff">permPrettyMF = permPrettyM</span></span>
<span class="lineno"> 1347 </span>
<span class="lineno"> 1348 </span>
<span class="lineno"> 1349 </span>-- | Pretty-print a name-binding using a function that takes the pretty-printed
<span class="lineno"> 1350 </span>-- names along with the body of the name-binding
<span class="lineno"> 1351 </span>permPrettyMb :: (RAssign (Constant (Doc ann)) ctx -&gt; a -&gt; PermPPM (Doc ann)) -&gt;
<span class="lineno"> 1352 </span>                Mb (ctx :: RList CrucibleType) a -&gt; PermPPM (Doc ann)
<span class="lineno"> 1353 </span><span class="decl"><span class="nottickedoff">permPrettyMb f mb =</span>
<span class="lineno"> 1354 </span><span class="spaces">  </span><span class="nottickedoff">fmap mbLift $ strongMbM $ flip nuMultiWithElim1 mb $ \ns a -&gt;</span>
<span class="lineno"> 1355 </span><span class="spaces">  </span><span class="nottickedoff">local (ppInfoAddExprNames &quot;z&quot; ns) $</span>
<span class="lineno"> 1356 </span><span class="spaces">  </span><span class="nottickedoff">do ns_pp &lt;- traverseRAssign (\n -&gt; Constant &lt;$&gt; permPrettyM n) ns</span>
<span class="lineno"> 1357 </span><span class="spaces">     </span><span class="nottickedoff">PP.group &lt;$&gt; hang 2 &lt;$&gt; f ns_pp a</span></span>
<span class="lineno"> 1358 </span>
<span class="lineno"> 1359 </span>-- | Pretty-print an expression-like construct in a name-binding using a
<span class="lineno"> 1360 </span>-- function that combines the pretty-printed names along with the pretty-printed
<span class="lineno"> 1361 </span>-- body of the name-binding
<span class="lineno"> 1362 </span>permPrettyExprMb :: PermPretty a =&gt;
<span class="lineno"> 1363 </span>                    (RAssign (Constant (Doc ann)) ctx -&gt; PermPPM (Doc ann) -&gt;
<span class="lineno"> 1364 </span>                     PermPPM (Doc ann)) -&gt;
<span class="lineno"> 1365 </span>                    Mb (ctx :: RList CrucibleType) a -&gt; PermPPM (Doc ann)
<span class="lineno"> 1366 </span><span class="decl"><span class="nottickedoff">permPrettyExprMb f = permPrettyMb (\ns_pp a -&gt; f ns_pp (permPrettyM a))</span></span>
<span class="lineno"> 1367 </span>
<span class="lineno"> 1368 </span>
<span class="lineno"> 1369 </span>-- | Pretty-print an expression-like construct in a name-binding using
<span class="lineno"> 1370 </span>-- a function that combines the pretty-printed names along with the
<span class="lineno"> 1371 </span>-- pretty-printed body of the name-binding, using the types of the
<span class="lineno"> 1372 </span>-- found names to generate their string names
<span class="lineno"> 1373 </span>permPrettyExprMbTyped :: PermPretty a =&gt;
<span class="lineno"> 1374 </span>  CruCtx ctx -&gt;
<span class="lineno"> 1375 </span>  (RAssign (Constant (Doc ann)) ctx -&gt; PermPPM (Doc ann) -&gt; PermPPM (Doc ann)) -&gt;
<span class="lineno"> 1376 </span>  Mb (ctx :: RList CrucibleType) a -&gt; PermPPM (Doc ann)
<span class="lineno"> 1377 </span><span class="decl"><span class="nottickedoff">permPrettyExprMbTyped ctx f mb =</span>
<span class="lineno"> 1378 </span><span class="spaces">  </span><span class="nottickedoff">fmap mbLift $ strongMbM $ flip nuMultiWithElim1 mb $ \ns a -&gt;</span>
<span class="lineno"> 1379 </span><span class="spaces">  </span><span class="nottickedoff">local (ppInfoAddTypedExprNames ctx ns) $</span>
<span class="lineno"> 1380 </span><span class="spaces">  </span><span class="nottickedoff">do docs &lt;- traverseRAssign (\n -&gt; Constant &lt;$&gt; permPrettyM n) ns</span>
<span class="lineno"> 1381 </span><span class="spaces">     </span><span class="nottickedoff">f docs $ permPrettyM a</span></span>
<span class="lineno"> 1382 </span>
<span class="lineno"> 1383 </span>instance (PermPretty a) =&gt; PermPretty (Mb (ctx :: RList CrucibleType) a) where
<span class="lineno"> 1384 </span>  <span class="decl"><span class="nottickedoff">permPrettyM =</span>
<span class="lineno"> 1385 </span><span class="spaces">    </span><span class="nottickedoff">permPrettyExprMb $ \docs ppm -&gt;</span>
<span class="lineno"> 1386 </span><span class="spaces">    </span><span class="nottickedoff">(\pp -&gt; ppEncList True (RL.toList docs) &lt;&gt; dot &lt;&gt; line &lt;&gt; pp) &lt;$&gt; ppm</span></span>
<span class="lineno"> 1387 </span>
<span class="lineno"> 1388 </span>instance PermPretty Integer where
<span class="lineno"> 1389 </span>  <span class="decl"><span class="nottickedoff">permPrettyM = return . pretty</span></span>
<span class="lineno"> 1390 </span>
<span class="lineno"> 1391 </span>
<span class="lineno"> 1392 </span>----------------------------------------------------------------------
<span class="lineno"> 1393 </span>-- * Expressions for Permissions
<span class="lineno"> 1394 </span>----------------------------------------------------------------------
<span class="lineno"> 1395 </span>
<span class="lineno"> 1396 </span>-- | The object-level representation of 'LifetimeType'
<span class="lineno"> 1397 </span>lifetimeTypeRepr :: TypeRepr LifetimeType
<span class="lineno"> 1398 </span><span class="decl"><span class="nottickedoff">lifetimeTypeRepr = knownRepr</span></span>
<span class="lineno"> 1399 </span>
<span class="lineno"> 1400 </span>-- | Pattern for building/destructing lifetime types
<span class="lineno"> 1401 </span>pattern LifetimeRepr :: () =&gt; (ty ~ LifetimeType) =&gt; TypeRepr ty
<span class="lineno"> 1402 </span>pattern LifetimeRepr &lt;-
<span class="lineno"> 1403 </span>  <span class="nottickedoff">IntrinsicRepr (testEquality (knownSymbol :: SymbolRepr &quot;Lifetime&quot;) -&gt;</span>
<span class="lineno"> 1404 </span><span class="spaces">                 </span><span class="nottickedoff">Just Refl)</span>
<span class="lineno"> 1405 </span><span class="spaces">  </span><span class="nottickedoff">Empty</span>
<span class="lineno"> 1406 </span>  where LifetimeRepr = <span class="nottickedoff">IntrinsicRepr knownSymbol Empty</span>
<span class="lineno"> 1407 </span>
<span class="lineno"> 1408 </span>-- | A lifetime is an expression of type 'LifetimeType'
<span class="lineno"> 1409 </span>--type Lifetime = PermExpr LifetimeType
<span class="lineno"> 1410 </span>
<span class="lineno"> 1411 </span>-- | The object-level representation of 'RWModalityType'
<span class="lineno"> 1412 </span>rwModalityTypeRepr :: TypeRepr RWModalityType
<span class="lineno"> 1413 </span><span class="decl"><span class="nottickedoff">rwModalityTypeRepr = knownRepr</span></span>
<span class="lineno"> 1414 </span>
<span class="lineno"> 1415 </span>-- | Pattern for building/destructing RWModality types
<span class="lineno"> 1416 </span>pattern RWModalityRepr :: () =&gt; (ty ~ RWModalityType) =&gt; TypeRepr ty
<span class="lineno"> 1417 </span>pattern RWModalityRepr &lt;-
<span class="lineno"> 1418 </span>  <span class="nottickedoff">IntrinsicRepr (testEquality (knownSymbol :: SymbolRepr &quot;RWModality&quot;) -&gt;</span>
<span class="lineno"> 1419 </span><span class="spaces">                 </span><span class="nottickedoff">Just Refl)</span>
<span class="lineno"> 1420 </span><span class="spaces">  </span><span class="nottickedoff">Empty</span>
<span class="lineno"> 1421 </span>  where RWModalityRepr = <span class="nottickedoff">IntrinsicRepr knownSymbol Empty</span>
<span class="lineno"> 1422 </span>
<span class="lineno"> 1423 </span>-- | Pattern for building/desctructing permission list types
<span class="lineno"> 1424 </span>pattern PermListRepr :: () =&gt; ty ~ PermListType =&gt; TypeRepr ty
<span class="lineno"> 1425 </span>pattern PermListRepr &lt;-
<span class="lineno"> 1426 </span>  <span class="nottickedoff">IntrinsicRepr (testEquality (knownSymbol :: SymbolRepr &quot;PermList&quot;) -&gt;</span>
<span class="lineno"> 1427 </span><span class="spaces">                 </span><span class="nottickedoff">Just Refl) Empty</span>
<span class="lineno"> 1428 </span>  where
<span class="lineno"> 1429 </span>    PermListRepr = <span class="nottickedoff">IntrinsicRepr knownSymbol Empty</span>
<span class="lineno"> 1430 </span>
<span class="lineno"> 1431 </span>-- | Pattern for building/desctructing LLVM frame types
<span class="lineno"> 1432 </span>pattern LLVMFrameRepr :: () =&gt; (1 &lt;= w, ty ~ LLVMFrameType w) =&gt;
<span class="lineno"> 1433 </span>                         NatRepr w -&gt; TypeRepr ty
<span class="lineno"> 1434 </span>pattern LLVMFrameRepr w &lt;-
<span class="lineno"> 1435 </span>  <span class="nottickedoff">IntrinsicRepr (testEquality (knownSymbol :: SymbolRepr &quot;LLVMFrame&quot;) -&gt;</span>
<span class="lineno"> 1436 </span><span class="spaces">                 </span><span class="nottickedoff">Just Refl)</span>
<span class="lineno"> 1437 </span><span class="spaces">  </span><span class="nottickedoff">(viewAssign -&gt; AssignExtend Empty (BVRepr w))</span>
<span class="lineno"> 1438 </span>  where
<span class="lineno"> 1439 </span>    LLVMFrameRepr w = <span class="nottickedoff">IntrinsicRepr knownSymbol (Ctx.extend Empty (BVRepr w))</span>
<span class="lineno"> 1440 </span>
<span class="lineno"> 1441 </span>-- | Pattern for building/desctructing permissions as expressions
<span class="lineno"> 1442 </span>pattern ValuePermRepr :: () =&gt; (ty ~ ValuePermType a) =&gt; TypeRepr a -&gt;
<span class="lineno"> 1443 </span>                         TypeRepr ty
<span class="lineno"> 1444 </span>pattern ValuePermRepr a &lt;-
<span class="lineno"> 1445 </span>  <span class="nottickedoff">IntrinsicRepr (testEquality (knownSymbol :: SymbolRepr &quot;Perm&quot;) -&gt;</span>
<span class="lineno"> 1446 </span><span class="spaces">                 </span><span class="nottickedoff">Just Refl)</span>
<span class="lineno"> 1447 </span><span class="spaces">  </span><span class="nottickedoff">(viewAssign -&gt; AssignExtend Empty a)</span>
<span class="lineno"> 1448 </span>  where
<span class="lineno"> 1449 </span>    ValuePermRepr a = <span class="nottickedoff">IntrinsicRepr knownSymbol (Ctx.extend Empty a)</span>
<span class="lineno"> 1450 </span>
<span class="lineno"> 1451 </span>-- | Pattern for building/desctructing LLVM frame types
<span class="lineno"> 1452 </span>pattern LLVMShapeRepr :: () =&gt; (1 &lt;= w, ty ~ LLVMShapeType w) =&gt;
<span class="lineno"> 1453 </span>                         NatRepr w -&gt; TypeRepr ty
<span class="lineno"> 1454 </span>pattern LLVMShapeRepr w &lt;-
<span class="lineno"> 1455 </span>  <span class="nottickedoff">IntrinsicRepr (testEquality (knownSymbol :: SymbolRepr &quot;LLVMShape&quot;) -&gt;</span>
<span class="lineno"> 1456 </span><span class="spaces">                 </span><span class="nottickedoff">Just Refl)</span>
<span class="lineno"> 1457 </span><span class="spaces">  </span><span class="nottickedoff">(viewAssign -&gt; AssignExtend Empty (BVRepr w))</span>
<span class="lineno"> 1458 </span>  where
<span class="lineno"> 1459 </span>    LLVMShapeRepr w = <span class="nottickedoff">IntrinsicRepr knownSymbol (Ctx.extend Empty (BVRepr w))</span>
<span class="lineno"> 1460 </span>
<span class="lineno"> 1461 </span>-- | Pattern for building/desctructing LLVM frame types
<span class="lineno"> 1462 </span>pattern LLVMBlockRepr :: () =&gt; (1 &lt;= w, ty ~ LLVMBlockType w) =&gt;
<span class="lineno"> 1463 </span>                         NatRepr w -&gt; TypeRepr ty
<span class="lineno"> 1464 </span>pattern LLVMBlockRepr w &lt;-
<span class="lineno"> 1465 </span>  <span class="nottickedoff">IntrinsicRepr (testEquality (knownSymbol :: SymbolRepr &quot;LLVMBlock&quot;) -&gt;</span>
<span class="lineno"> 1466 </span><span class="spaces">                 </span><span class="nottickedoff">Just Refl)</span>
<span class="lineno"> 1467 </span><span class="spaces">  </span><span class="nottickedoff">(viewAssign -&gt; AssignExtend Empty (BVRepr w))</span>
<span class="lineno"> 1468 </span>  where
<span class="lineno"> 1469 </span>    LLVMBlockRepr w = <span class="nottickedoff">IntrinsicRepr knownSymbol (Ctx.extend Empty (BVRepr w))</span>
<span class="lineno"> 1470 </span>
<span class="lineno"> 1471 </span>
<span class="lineno"> 1472 </span>-- | Pattern for an empty 'PermExprs' list
<span class="lineno"> 1473 </span>pattern PExprs_Nil :: () =&gt; (tps ~ RNil) =&gt; PermExprs tps
<span class="lineno"> 1474 </span>pattern PExprs_Nil = <span class="nottickedoff">MNil</span>
<span class="lineno"> 1475 </span>
<span class="lineno"> 1476 </span>-- | Pattern for a non-empty 'PermExprs' list
<span class="lineno"> 1477 </span>pattern PExprs_Cons :: () =&gt; (tps ~ (tps' :&gt; a)) =&gt;
<span class="lineno"> 1478 </span>                       PermExprs tps' -&gt; PermExpr a -&gt; PermExprs tps
<span class="lineno"> 1479 </span>pattern PExprs_Cons es e &lt;- <span class="nottickedoff">es :&gt;: e</span>
<span class="lineno"> 1480 </span>  where
<span class="lineno"> 1481 </span>    PExprs_Cons es e = <span class="nottickedoff">es :&gt;: e</span>
<span class="lineno"> 1482 </span>
<span class="lineno"> 1483 </span>{-# COMPLETE PExprs_Nil, PExprs_Cons #-}
<span class="lineno"> 1484 </span>
<span class="lineno"> 1485 </span>-- | Convert a 'PermExprs' to an 'RAssign'
<span class="lineno"> 1486 </span>exprsToRAssign :: PermExprs as -&gt; RAssign PermExpr as
<span class="lineno"> 1487 </span><span class="decl"><span class="nottickedoff">exprsToRAssign PExprs_Nil = MNil</span>
<span class="lineno"> 1488 </span><span class="spaces"></span><span class="nottickedoff">exprsToRAssign (PExprs_Cons es e) = exprsToRAssign es :&gt;: e</span></span>
<span class="lineno"> 1489 </span>
<span class="lineno"> 1490 </span>-- | Convert an 'RAssign' to a 'PermExprs'
<span class="lineno"> 1491 </span>rassignToExprs :: RAssign PermExpr as -&gt; PermExprs as
<span class="lineno"> 1492 </span><span class="decl"><span class="nottickedoff">rassignToExprs MNil = PExprs_Nil</span>
<span class="lineno"> 1493 </span><span class="spaces"></span><span class="nottickedoff">rassignToExprs (es :&gt;: e) = PExprs_Cons (rassignToExprs es) e</span></span>
<span class="lineno"> 1494 </span>
<span class="lineno"> 1495 </span>-- | Convert a list of names to a 'PermExprs' list
<span class="lineno"> 1496 </span>namesToExprs :: RAssign Name as -&gt; PermExprs as
<span class="lineno"> 1497 </span><span class="decl"><span class="nottickedoff">namesToExprs MNil = PExprs_Nil</span>
<span class="lineno"> 1498 </span><span class="spaces"></span><span class="nottickedoff">namesToExprs (ns :&gt;: n) = PExprs_Cons (namesToExprs ns) (PExpr_Var n)</span></span>
<span class="lineno"> 1499 </span>
<span class="lineno"> 1500 </span>-- | Create a list of phantom 'Proxy' arguments from a 'PermExprs' list
<span class="lineno"> 1501 </span>proxiesOfExprs :: PermExprs as -&gt; RAssign Proxy as
<span class="lineno"> 1502 </span><span class="decl"><span class="nottickedoff">proxiesOfExprs PExprs_Nil = MNil</span>
<span class="lineno"> 1503 </span><span class="spaces"></span><span class="nottickedoff">proxiesOfExprs (PExprs_Cons es _) = proxiesOfExprs es :&gt;: Proxy</span></span>
<span class="lineno"> 1504 </span>
<span class="lineno"> 1505 </span>-- | Append two 'PermExprs' lists
<span class="lineno"> 1506 </span>appendExprs :: PermExprs as -&gt; PermExprs bs -&gt; PermExprs (as :++: bs)
<span class="lineno"> 1507 </span><span class="decl"><span class="nottickedoff">appendExprs as PExprs_Nil = as</span>
<span class="lineno"> 1508 </span><span class="spaces"></span><span class="nottickedoff">appendExprs as (PExprs_Cons bs b) = PExprs_Cons (appendExprs as bs) b</span></span>
<span class="lineno"> 1509 </span>
<span class="lineno"> 1510 </span>-- | Convenience function to get the known type of an expression-like construct
<span class="lineno"> 1511 </span>exprType :: KnownRepr TypeRepr a =&gt; f a -&gt; TypeRepr a
<span class="lineno"> 1512 </span><span class="decl"><span class="nottickedoff">exprType _ = knownRepr</span></span>
<span class="lineno"> 1513 </span>
<span class="lineno"> 1514 </span>-- | Convenience function to get the known type of bound name
<span class="lineno"> 1515 </span>bindingType :: KnownRepr TypeRepr a =&gt; Binding a b -&gt; TypeRepr a
<span class="lineno"> 1516 </span><span class="decl"><span class="nottickedoff">bindingType _ = knownRepr</span></span>
<span class="lineno"> 1517 </span>
<span class="lineno"> 1518 </span>-- | Convenience function to get the bit width of an LLVM pointer type
<span class="lineno"> 1519 </span>exprLLVMTypeWidth :: KnownNat w =&gt; f (LLVMPointerType w) -&gt; NatRepr w
<span class="lineno"> 1520 </span><span class="decl"><span class="nottickedoff">exprLLVMTypeWidth _ = knownNat</span></span>
<span class="lineno"> 1521 </span>
<span class="lineno"> 1522 </span>-- | Convenience function to get the bit width of an LLVM pointer type
<span class="lineno"> 1523 </span>mbExprLLVMTypeWidth :: KnownNat w =&gt; Mb ctx (f (LLVMPointerType w)) -&gt;
<span class="lineno"> 1524 </span>                       NatRepr w
<span class="lineno"> 1525 </span><span class="decl"><span class="nottickedoff">mbExprLLVMTypeWidth _ = knownNat</span></span>
<span class="lineno"> 1526 </span>
<span class="lineno"> 1527 </span>-- | Convenience function to get the bit width of a bitvector type
<span class="lineno"> 1528 </span>exprBVTypeWidth :: KnownNat w =&gt; f (BVType w) -&gt; NatRepr w
<span class="lineno"> 1529 </span><span class="decl"><span class="nottickedoff">exprBVTypeWidth _ = knownNat</span></span>
<span class="lineno"> 1530 </span>
<span class="lineno"> 1531 </span>-- | Convenience function to get the bit width of an LLVM pointer type
<span class="lineno"> 1532 </span>mbExprBVTypeWidth :: KnownNat w =&gt; Mb ctx (f (BVType w)) -&gt; NatRepr w
<span class="lineno"> 1533 </span><span class="decl"><span class="nottickedoff">mbExprBVTypeWidth _ = knownNat</span></span>
<span class="lineno"> 1534 </span>
<span class="lineno"> 1535 </span>-- | Convenience function to get the bit width of an LLVM pointer type
<span class="lineno"> 1536 </span>shapeLLVMTypeWidth :: KnownNat w =&gt; f (LLVMShapeType w) -&gt; NatRepr w
<span class="lineno"> 1537 </span><span class="decl"><span class="nottickedoff">shapeLLVMTypeWidth _ = knownNat</span></span>
<span class="lineno"> 1538 </span>
<span class="lineno"> 1539 </span>-- | Convenience function to get the number of bytes = the bit width divided by
<span class="lineno"> 1540 </span>-- 8 of an LLVM pointer type rounded up
<span class="lineno"> 1541 </span>exprLLVMTypeBytes :: KnownNat w =&gt; f (LLVMPointerType w) -&gt; Integer
<span class="lineno"> 1542 </span><span class="decl"><span class="nottickedoff">exprLLVMTypeBytes e = intValue (exprLLVMTypeWidth e) `ceil_div` 8</span></span>
<span class="lineno"> 1543 </span>
<span class="lineno"> 1544 </span>-- | Convenience function to get the number of bytes = the bit width divided by
<span class="lineno"> 1545 </span>-- 8 of an LLVM pointer type as an expr. Note that this assumes the bit width is
<span class="lineno"> 1546 </span>-- a multiple of 8, so does not worry about rounding.
<span class="lineno"> 1547 </span>exprLLVMTypeBytesExpr :: (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno"> 1548 </span>                         f (LLVMPointerType sz) -&gt; PermExpr (BVType w)
<span class="lineno"> 1549 </span><span class="decl"><span class="nottickedoff">exprLLVMTypeBytesExpr e = bvInt (intValue (exprLLVMTypeWidth e) `ceil_div` 8)</span></span>
<span class="lineno"> 1550 </span>
<span class="lineno"> 1551 </span>-- | Convenience function to get the width of an LLVM pointer type of an
<span class="lineno"> 1552 </span>-- expression in a binding as an expression
<span class="lineno"> 1553 </span>mbExprLLVMTypeBytesExpr :: (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno"> 1554 </span>                           Mb ctx (f (LLVMPointerType sz)) -&gt;
<span class="lineno"> 1555 </span>                           PermExpr (BVType w)
<span class="lineno"> 1556 </span><span class="decl"><span class="nottickedoff">mbExprLLVMTypeBytesExpr mb_e =</span>
<span class="lineno"> 1557 </span><span class="spaces">  </span><span class="nottickedoff">bvInt $ ceil_div (intValue $ mbLift $ fmap exprLLVMTypeWidth mb_e) 8</span></span>
<span class="lineno"> 1558 </span>
<span class="lineno"> 1559 </span>-- | Pattern-match a permission list expression as a typed list of permissions
<span class="lineno"> 1560 </span>-- consed onto a terminator, which can either be the empty list (represented by
<span class="lineno"> 1561 </span>-- 'Nothing') or a variable expression
<span class="lineno"> 1562 </span>matchPermList :: PermExpr PermListType -&gt; (Some ExprPerms,
<span class="lineno"> 1563 </span>                                           Maybe (ExprVar PermListType))
<span class="lineno"> 1564 </span><span class="decl"><span class="nottickedoff">matchPermList PExpr_PermListNil = (Some MNil, Nothing)</span>
<span class="lineno"> 1565 </span><span class="spaces"></span><span class="nottickedoff">matchPermList (PExpr_Var ps) = (Some MNil, Just ps)</span>
<span class="lineno"> 1566 </span><span class="spaces"></span><span class="nottickedoff">matchPermList (PExpr_PermListCons _ e p l)</span>
<span class="lineno"> 1567 </span><span class="spaces">  </span><span class="nottickedoff">| (Some eperms, term) &lt;- matchPermList l</span>
<span class="lineno"> 1568 </span><span class="spaces">  </span><span class="nottickedoff">= (Some (RL.append (MNil :&gt;: ExprAndPerm e p) eperms), term)</span></span>
<span class="lineno"> 1569 </span>
<span class="lineno"> 1570 </span>-- | Pattern-match a permission list expression as a list of permissions on
<span class="lineno"> 1571 </span>-- variables with an empty list (not a variable) as a terminator
<span class="lineno"> 1572 </span>matchVarPermList :: PermExpr PermListType -&gt; Maybe (Some DistPerms)
<span class="lineno"> 1573 </span><span class="decl"><span class="nottickedoff">matchVarPermList PExpr_PermListNil = Just $ Some MNil</span>
<span class="lineno"> 1574 </span><span class="spaces"></span><span class="nottickedoff">matchVarPermList (PExpr_PermListCons _ (PExpr_Var x) p l)</span>
<span class="lineno"> 1575 </span><span class="spaces">  </span><span class="nottickedoff">| Just (Some perms) &lt;- matchVarPermList l =</span>
<span class="lineno"> 1576 </span><span class="spaces">    </span><span class="nottickedoff">Just $ Some $ RL.append (MNil :&gt;: VarAndPerm x p) perms</span>
<span class="lineno"> 1577 </span><span class="spaces"></span><span class="nottickedoff">matchVarPermList _ = Nothing</span></span>
<span class="lineno"> 1578 </span>
<span class="lineno"> 1579 </span>-- | Fold over all permissions associated with a specific variable in a
<span class="lineno"> 1580 </span>-- permission list
<span class="lineno"> 1581 </span>foldPermList :: ExprVar a -&gt; (ValuePerm a -&gt; r -&gt; r) -&gt; r -&gt;
<span class="lineno"> 1582 </span>                PermExpr PermListType -&gt; r
<span class="lineno"> 1583 </span><span class="decl"><span class="nottickedoff">foldPermList _ _ r PExpr_PermListNil = r</span>
<span class="lineno"> 1584 </span><span class="spaces"></span><span class="nottickedoff">foldPermList _ _ r (PExpr_Var _) = r</span>
<span class="lineno"> 1585 </span><span class="spaces"></span><span class="nottickedoff">foldPermList x f r (PExpr_PermListCons _ (PExpr_Var y) p plist)</span>
<span class="lineno"> 1586 </span><span class="spaces">  </span><span class="nottickedoff">| Just Refl &lt;- testEquality x y =</span>
<span class="lineno"> 1587 </span><span class="spaces">    </span><span class="nottickedoff">f p $ foldPermList x f r plist</span>
<span class="lineno"> 1588 </span><span class="spaces"></span><span class="nottickedoff">foldPermList x f r (PExpr_PermListCons _ _ _ plist) =</span>
<span class="lineno"> 1589 </span><span class="spaces">  </span><span class="nottickedoff">foldPermList x f r plist</span></span>
<span class="lineno"> 1590 </span>
<span class="lineno"> 1591 </span>-- | Fold over all atomic permissions associated with a specific variable in a
<span class="lineno"> 1592 </span>-- permission list
<span class="lineno"> 1593 </span>foldPermListAtomic :: ExprVar a -&gt; (AtomicPerm a -&gt; r -&gt; r) -&gt; r -&gt;
<span class="lineno"> 1594 </span>                      PermExpr PermListType -&gt; r
<span class="lineno"> 1595 </span><span class="decl"><span class="nottickedoff">foldPermListAtomic x f =</span>
<span class="lineno"> 1596 </span><span class="spaces">  </span><span class="nottickedoff">foldPermList x (\p rest -&gt;</span>
<span class="lineno"> 1597 </span><span class="spaces">                   </span><span class="nottickedoff">case p of</span>
<span class="lineno"> 1598 </span><span class="spaces">                     </span><span class="nottickedoff">ValPerm_Conj ps -&gt; foldr f rest ps</span>
<span class="lineno"> 1599 </span><span class="spaces">                     </span><span class="nottickedoff">_ -&gt; rest)</span></span>
<span class="lineno"> 1600 </span>
<span class="lineno"> 1601 </span>-- | Find a permission on a specific variable in a permission list
<span class="lineno"> 1602 </span>findPermInList :: ExprVar a -&gt; (ValuePerm a -&gt; Bool) -&gt; PermExpr PermListType -&gt;
<span class="lineno"> 1603 </span>                  Maybe (ValuePerm a)
<span class="lineno"> 1604 </span><span class="decl"><span class="nottickedoff">findPermInList x pred plist =</span>
<span class="lineno"> 1605 </span><span class="spaces">  </span><span class="nottickedoff">foldPermList x (\p rest -&gt; if pred p then Just p else rest) Nothing plist</span></span>
<span class="lineno"> 1606 </span>
<span class="lineno"> 1607 </span>-- | Find an atomic permission on a specific variable in a permission list
<span class="lineno"> 1608 </span>findAtomicPermInList :: ExprVar a -&gt; (AtomicPerm a -&gt; Bool) -&gt;
<span class="lineno"> 1609 </span>                        PermExpr PermListType -&gt; Maybe (AtomicPerm a)
<span class="lineno"> 1610 </span><span class="decl"><span class="nottickedoff">findAtomicPermInList x pred plist =</span>
<span class="lineno"> 1611 </span><span class="spaces">  </span><span class="nottickedoff">foldPermListAtomic x (\p rest -&gt;</span>
<span class="lineno"> 1612 </span><span class="spaces">                         </span><span class="nottickedoff">if pred p then Just p else rest) Nothing plist</span></span>
<span class="lineno"> 1613 </span>
<span class="lineno"> 1614 </span>instance <span class="decl"><span class="nottickedoff">Eq (PermExpr a)</span></span> where
<span class="lineno"> 1615 </span>  <span class="decl"><span class="nottickedoff">(PExpr_Var x1) == (PExpr_Var x2) = x1 == x2</span>
<span class="lineno"> 1616 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_Var _) == _ = False</span>
<span class="lineno"> 1617 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1618 </span><span class="spaces">  </span><span class="nottickedoff">PExpr_Unit == PExpr_Unit = True</span>
<span class="lineno"> 1619 </span><span class="spaces">  </span><span class="nottickedoff">PExpr_Unit == _ = False</span>
<span class="lineno"> 1620 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1621 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_Nat n1) == (PExpr_Nat n2) = n1 == n2</span>
<span class="lineno"> 1622 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_Nat _) == _ = False</span>
<span class="lineno"> 1623 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1624 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_String str1) == (PExpr_String str2) = str1 == str2</span>
<span class="lineno"> 1625 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_String _) == _ = False</span>
<span class="lineno"> 1626 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1627 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_Bool b1) == (PExpr_Bool b2) = b1 == b2</span>
<span class="lineno"> 1628 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_Bool _) == _ = False</span>
<span class="lineno"> 1629 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1630 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_BV factors1 const1) == (PExpr_BV factors2 const2) =</span>
<span class="lineno"> 1631 </span><span class="spaces">    </span><span class="nottickedoff">const1 == const2 &amp;&amp; eqFactors factors1 factors2</span>
<span class="lineno"> 1632 </span><span class="spaces">    </span><span class="nottickedoff">where</span>
<span class="lineno"> 1633 </span><span class="spaces">      </span><span class="nottickedoff">eqFactors :: [BVFactor w] -&gt; [BVFactor w] -&gt; Bool</span>
<span class="lineno"> 1634 </span><span class="spaces">      </span><span class="nottickedoff">eqFactors [] [] = True</span>
<span class="lineno"> 1635 </span><span class="spaces">      </span><span class="nottickedoff">eqFactors (f : fs1) fs2</span>
<span class="lineno"> 1636 </span><span class="spaces">        </span><span class="nottickedoff">| elem f fs2 = eqFactors fs1 (delete f fs2)</span>
<span class="lineno"> 1637 </span><span class="spaces">      </span><span class="nottickedoff">eqFactors _ _ = False</span>
<span class="lineno"> 1638 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_BV _ _) == _ = False</span>
<span class="lineno"> 1639 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1640 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_Struct args1) == (PExpr_Struct args2) = args1 == args2 where</span>
<span class="lineno"> 1641 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_Struct _) == _ = False</span>
<span class="lineno"> 1642 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1643 </span><span class="spaces">  </span><span class="nottickedoff">PExpr_Always == PExpr_Always = True</span>
<span class="lineno"> 1644 </span><span class="spaces">  </span><span class="nottickedoff">PExpr_Always == _ = False</span>
<span class="lineno"> 1645 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1646 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_LLVMWord e1) == (PExpr_LLVMWord e2) = e1 == e2</span>
<span class="lineno"> 1647 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_LLVMWord _) == _ = False</span>
<span class="lineno"> 1648 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1649 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_LLVMOffset x1 e1) == (PExpr_LLVMOffset x2 e2) =</span>
<span class="lineno"> 1650 </span><span class="spaces">    </span><span class="nottickedoff">x1 == x2 &amp;&amp; e1 == e2</span>
<span class="lineno"> 1651 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_LLVMOffset _ _) == _ = False</span>
<span class="lineno"> 1652 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1653 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_Fun fh1) == (PExpr_Fun fh2) = fh1 == fh2</span>
<span class="lineno"> 1654 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_Fun _) == _ = False</span>
<span class="lineno"> 1655 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1656 </span><span class="spaces">  </span><span class="nottickedoff">PExpr_PermListNil == PExpr_PermListNil = True</span>
<span class="lineno"> 1657 </span><span class="spaces">  </span><span class="nottickedoff">PExpr_PermListNil == _ = False</span>
<span class="lineno"> 1658 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1659 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_PermListCons tp1 e1 p1 l1) == (PExpr_PermListCons tp2 e2 p2 l2)</span>
<span class="lineno"> 1660 </span><span class="spaces">    </span><span class="nottickedoff">| Just Refl &lt;- testEquality tp1 tp2</span>
<span class="lineno"> 1661 </span><span class="spaces">    </span><span class="nottickedoff">= e1 == e2 &amp;&amp; p1 == p2 &amp;&amp; l1 == l2</span>
<span class="lineno"> 1662 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_PermListCons _ _ _ _) == _ = False</span>
<span class="lineno"> 1663 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1664 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_RWModality rw1) == (PExpr_RWModality rw2) = rw1 == rw2</span>
<span class="lineno"> 1665 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_RWModality _) == _ = False</span>
<span class="lineno"> 1666 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1667 </span><span class="spaces">  </span><span class="nottickedoff">PExpr_EmptyShape == PExpr_EmptyShape = True</span>
<span class="lineno"> 1668 </span><span class="spaces">  </span><span class="nottickedoff">PExpr_EmptyShape == _ = False</span>
<span class="lineno"> 1669 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1670 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_NamedShape maybe_rw1 maybe_l1 nmsh1 args1)</span>
<span class="lineno"> 1671 </span><span class="spaces">    </span><span class="nottickedoff">== (PExpr_NamedShape maybe_rw2 maybe_l2 nmsh2 args2)</span>
<span class="lineno"> 1672 </span><span class="spaces">    </span><span class="nottickedoff">| Just (Refl,Refl) &lt;- namedShapeEq nmsh1 nmsh2 =</span>
<span class="lineno"> 1673 </span><span class="spaces">      </span><span class="nottickedoff">maybe_rw1 == maybe_rw2 &amp;&amp; maybe_l1 == maybe_l2 &amp;&amp; args1 == args2</span>
<span class="lineno"> 1674 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_NamedShape _ _ _ _) == _ = False</span>
<span class="lineno"> 1675 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1676 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_EqShape len1 b1) == (PExpr_EqShape len2 b2) = len1 == len2 &amp;&amp; b1 == b2</span>
<span class="lineno"> 1677 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_EqShape _ _) == _ = False</span>
<span class="lineno"> 1678 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1679 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_PtrShape rw1 l1 sh1) == (PExpr_PtrShape rw2 l2 sh2) =</span>
<span class="lineno"> 1680 </span><span class="spaces">    </span><span class="nottickedoff">rw1 == rw2 &amp;&amp; l1 == l2 &amp;&amp; sh1 == sh2</span>
<span class="lineno"> 1681 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_PtrShape _ _ _) == _ = False</span>
<span class="lineno"> 1682 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1683 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_FieldShape p1) == (PExpr_FieldShape p2) = p1 == p2</span>
<span class="lineno"> 1684 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_FieldShape _) == _ = False</span>
<span class="lineno"> 1685 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1686 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_ArrayShape len1 s1 sh1) == (PExpr_ArrayShape len2 s2 sh2) =</span>
<span class="lineno"> 1687 </span><span class="spaces">    </span><span class="nottickedoff">len1 == len2 &amp;&amp; s1 == s2 &amp;&amp; sh1 == sh2</span>
<span class="lineno"> 1688 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_ArrayShape _ _ _) == _ = False</span>
<span class="lineno"> 1689 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1690 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_TupShape sh1) == (PExpr_TupShape sh2) = sh1 == sh2</span>
<span class="lineno"> 1691 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_TupShape _) == _ = False</span>
<span class="lineno"> 1692 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1693 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_SeqShape sh1 sh1') == (PExpr_SeqShape sh2 sh2') =</span>
<span class="lineno"> 1694 </span><span class="spaces">    </span><span class="nottickedoff">sh1 == sh2 &amp;&amp; sh1' == sh2'</span>
<span class="lineno"> 1695 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_SeqShape _ _) == _ = False</span>
<span class="lineno"> 1696 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1697 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_OrShape sh1 sh1') == (PExpr_OrShape sh2 sh2') =</span>
<span class="lineno"> 1698 </span><span class="spaces">    </span><span class="nottickedoff">sh1 == sh2 &amp;&amp; sh1' == sh2'</span>
<span class="lineno"> 1699 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_OrShape _ _) == _ = False</span>
<span class="lineno"> 1700 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1701 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_ExShape mb_sh1) == (PExpr_ExShape mb_sh2)</span>
<span class="lineno"> 1702 </span><span class="spaces">    </span><span class="nottickedoff">| Just Refl &lt;- testEquality (bindingType mb_sh1) (bindingType mb_sh2)</span>
<span class="lineno"> 1703 </span><span class="spaces">    </span><span class="nottickedoff">= mbLift $ mbMap2 (==) mb_sh1 mb_sh2</span>
<span class="lineno"> 1704 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_ExShape _) == _ = False</span>
<span class="lineno"> 1705 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1706 </span><span class="spaces">  </span><span class="nottickedoff">PExpr_FalseShape == PExpr_FalseShape = True</span>
<span class="lineno"> 1707 </span><span class="spaces">  </span><span class="nottickedoff">PExpr_FalseShape == _ = False</span>
<span class="lineno"> 1708 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1709 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_ValPerm p1) == (PExpr_ValPerm p2) = p1 == p2</span>
<span class="lineno"> 1710 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_ValPerm _) == _ = False</span></span>
<span class="lineno"> 1711 </span>
<span class="lineno"> 1712 </span>
<span class="lineno"> 1713 </span>instance Eq1 PermExpr where
<span class="lineno"> 1714 </span>  <span class="decl"><span class="nottickedoff">eq1 = (==)</span></span>
<span class="lineno"> 1715 </span>
<span class="lineno"> 1716 </span>instance <span class="decl"><span class="nottickedoff">Eq (BVFactor w)</span></span> where
<span class="lineno"> 1717 </span>  <span class="decl"><span class="nottickedoff">(BVFactor i1 x1) == (BVFactor i2 x2) = i1 == i2 &amp;&amp; x1 == x2</span></span>
<span class="lineno"> 1718 </span>
<span class="lineno"> 1719 </span>instance PermPretty (PermExpr a) where
<span class="lineno"> 1720 </span>  <span class="decl"><span class="nottickedoff">permPrettyM (PExpr_Var x) = permPrettyM x</span>
<span class="lineno"> 1721 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM PExpr_Unit = return $ pretty &quot;()&quot;</span>
<span class="lineno"> 1722 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (PExpr_Nat n) = return $ pretty $ show n</span>
<span class="lineno"> 1723 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (PExpr_String str) = return (pretty '&quot;' &lt;&gt; pretty str &lt;&gt; pretty '&quot;')</span>
<span class="lineno"> 1724 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (PExpr_Bool b) = return $ pretty b</span>
<span class="lineno"> 1725 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (PExpr_BV [] constant) =</span>
<span class="lineno"> 1726 </span><span class="spaces">    </span><span class="nottickedoff">return $ pretty $ BV.asSigned knownNat constant</span>
<span class="lineno"> 1727 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (PExpr_BV factors constant) =</span>
<span class="lineno"> 1728 </span><span class="spaces">    </span><span class="nottickedoff">do factors_pp &lt;-</span>
<span class="lineno"> 1729 </span><span class="spaces">         </span><span class="nottickedoff">encloseSep mempty mempty (pretty &quot;+&quot;) &lt;$&gt; mapM permPrettyM factors</span>
<span class="lineno"> 1730 </span><span class="spaces">       </span><span class="nottickedoff">case BV.asSigned knownNat constant of</span>
<span class="lineno"> 1731 </span><span class="spaces">         </span><span class="nottickedoff">0 -&gt; return factors_pp</span>
<span class="lineno"> 1732 </span><span class="spaces">         </span><span class="nottickedoff">c | c &gt; 0 -&gt; return (factors_pp &lt;&gt; pretty &quot;+&quot; &lt;&gt; pretty c)</span>
<span class="lineno"> 1733 </span><span class="spaces">         </span><span class="nottickedoff">c -&gt; return (factors_pp &lt;&gt; pretty c)</span>
<span class="lineno"> 1734 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (PExpr_Struct args) =</span>
<span class="lineno"> 1735 </span><span class="spaces">    </span><span class="nottickedoff">(\pp -&gt; pretty &quot;struct&quot; &lt;+&gt; parens pp) &lt;$&gt; permPrettyM args</span>
<span class="lineno"> 1736 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM PExpr_Always = return $ pretty &quot;always&quot;</span>
<span class="lineno"> 1737 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (PExpr_LLVMWord e) = (pretty &quot;LLVMword&quot; &lt;+&gt;) &lt;$&gt; permPrettyM e</span>
<span class="lineno"> 1738 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (PExpr_LLVMOffset x e) =</span>
<span class="lineno"> 1739 </span><span class="spaces">    </span><span class="nottickedoff">(\ppx ppe -&gt; ppx &lt;+&gt; pretty &quot;&amp;+&quot; &lt;+&gt; ppe)</span>
<span class="lineno"> 1740 </span><span class="spaces">    </span><span class="nottickedoff">&lt;$&gt; permPrettyM x &lt;*&gt; permPrettyM e</span>
<span class="lineno"> 1741 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (PExpr_Fun fh) = return $ angles $ pretty (&quot;fun&quot; ++ show fh)</span>
<span class="lineno"> 1742 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM e@PExpr_PermListNil = prettyPermListM e</span>
<span class="lineno"> 1743 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM e@(PExpr_PermListCons _ _ _ _) = prettyPermListM e</span>
<span class="lineno"> 1744 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (PExpr_RWModality rw) = permPrettyM rw</span>
<span class="lineno"> 1745 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM PExpr_EmptyShape = return $ pretty &quot;emptysh&quot;</span>
<span class="lineno"> 1746 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (PExpr_NamedShape maybe_rw maybe_l nmsh args) =</span>
<span class="lineno"> 1747 </span><span class="spaces">    </span><span class="nottickedoff">do l_pp &lt;- maybe (return mempty) permPrettyLifetimePrefix maybe_l</span>
<span class="lineno"> 1748 </span><span class="spaces">       </span><span class="nottickedoff">rw_pp &lt;- case maybe_rw of</span>
<span class="lineno"> 1749 </span><span class="spaces">         </span><span class="nottickedoff">Just rw -&gt; parens &lt;$&gt; permPrettyM rw</span>
<span class="lineno"> 1750 </span><span class="spaces">         </span><span class="nottickedoff">Nothing -&gt; return mempty</span>
<span class="lineno"> 1751 </span><span class="spaces">       </span><span class="nottickedoff">args_pp &lt;- permPrettyM args</span>
<span class="lineno"> 1752 </span><span class="spaces">       </span><span class="nottickedoff">return (l_pp &lt;&gt; rw_pp &lt;&gt; pretty (namedShapeName nmsh) &lt;&gt;</span>
<span class="lineno"> 1753 </span><span class="spaces">               </span><span class="nottickedoff">pretty '&lt;' &lt;&gt; align (args_pp &lt;&gt; pretty '&gt;'))</span>
<span class="lineno"> 1754 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (PExpr_EqShape len b) =</span>
<span class="lineno"> 1755 </span><span class="spaces">    </span><span class="nottickedoff">do len_pp &lt;- permPrettyM len</span>
<span class="lineno"> 1756 </span><span class="spaces">       </span><span class="nottickedoff">b_pp &lt;- permPrettyM b</span>
<span class="lineno"> 1757 </span><span class="spaces">       </span><span class="nottickedoff">return (pretty &quot;eqsh&quot; &lt;&gt; parens (len_pp &lt;&gt; comma &lt;&gt; b_pp))</span>
<span class="lineno"> 1758 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (PExpr_PtrShape maybe_rw maybe_l sh) =</span>
<span class="lineno"> 1759 </span><span class="spaces">    </span><span class="nottickedoff">do l_pp &lt;- maybe (return mempty) permPrettyLifetimePrefix maybe_l</span>
<span class="lineno"> 1760 </span><span class="spaces">       </span><span class="nottickedoff">rw_pp &lt;- case maybe_rw of</span>
<span class="lineno"> 1761 </span><span class="spaces">         </span><span class="nottickedoff">Just rw -&gt; (&lt;&gt; pretty &quot;,&quot;) &lt;$&gt; permPrettyM rw</span>
<span class="lineno"> 1762 </span><span class="spaces">         </span><span class="nottickedoff">Nothing -&gt; return mempty</span>
<span class="lineno"> 1763 </span><span class="spaces">       </span><span class="nottickedoff">sh_pp &lt;- permPrettyM sh</span>
<span class="lineno"> 1764 </span><span class="spaces">       </span><span class="nottickedoff">return (l_pp &lt;&gt; pretty &quot;ptrsh&quot; &lt;&gt; parens (rw_pp &lt;&gt; sh_pp))</span>
<span class="lineno"> 1765 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (PExpr_FieldShape fld) =</span>
<span class="lineno"> 1766 </span><span class="spaces">    </span><span class="nottickedoff">(pretty &quot;fieldsh&quot; &lt;&gt;) &lt;$&gt; permPrettyM fld</span>
<span class="lineno"> 1767 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (PExpr_ArrayShape len stride sh) =</span>
<span class="lineno"> 1768 </span><span class="spaces">    </span><span class="nottickedoff">do len_pp &lt;- permPrettyM len</span>
<span class="lineno"> 1769 </span><span class="spaces">       </span><span class="nottickedoff">sh_pp &lt;- permPrettyM sh</span>
<span class="lineno"> 1770 </span><span class="spaces">       </span><span class="nottickedoff">let stride_pp = pretty (toInteger stride)</span>
<span class="lineno"> 1771 </span><span class="spaces">       </span><span class="nottickedoff">return (pretty &quot;arraysh&quot; &lt;&gt;</span>
<span class="lineno"> 1772 </span><span class="spaces">               </span><span class="nottickedoff">ppEncList True [pretty &quot;&lt;&quot; &lt;&gt; len_pp,</span>
<span class="lineno"> 1773 </span><span class="spaces">                               </span><span class="nottickedoff">pretty &quot;*&quot; &lt;&gt; stride_pp, sh_pp])</span>
<span class="lineno"> 1774 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (PExpr_TupShape sh) =</span>
<span class="lineno"> 1775 </span><span class="spaces">    </span><span class="nottickedoff">do pp &lt;- permPrettyM sh</span>
<span class="lineno"> 1776 </span><span class="spaces">       </span><span class="nottickedoff">return $ nest 2 $ sep [pretty &quot;tuplesh&quot; &lt;+&gt; parens pp]</span>
<span class="lineno"> 1777 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (PExpr_SeqShape sh1 sh2) =</span>
<span class="lineno"> 1778 </span><span class="spaces">    </span><span class="nottickedoff">do pp1 &lt;- permPrettyM sh1</span>
<span class="lineno"> 1779 </span><span class="spaces">       </span><span class="nottickedoff">pp2 &lt;- permPrettyM sh2</span>
<span class="lineno"> 1780 </span><span class="spaces">       </span><span class="nottickedoff">return $ nest 2 $ sep [pp1 &lt;&gt; pretty ';', pp2]</span>
<span class="lineno"> 1781 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (PExpr_OrShape sh1 sh2) =</span>
<span class="lineno"> 1782 </span><span class="spaces">    </span><span class="nottickedoff">do pp1 &lt;- permPrettyM sh1</span>
<span class="lineno"> 1783 </span><span class="spaces">       </span><span class="nottickedoff">pp2 &lt;- permPrettyM sh2</span>
<span class="lineno"> 1784 </span><span class="spaces">       </span><span class="nottickedoff">return $ nest 2 $ sep [pp1 &lt;+&gt; pretty &quot;orsh&quot;, pp2]</span>
<span class="lineno"> 1785 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (PExpr_ExShape mb_sh) =</span>
<span class="lineno"> 1786 </span><span class="spaces">    </span><span class="nottickedoff">flip (permPrettyExprMbTyped (CruCtxNil `CruCtxCons` knownRepr)) mb_sh $ \(_ :&gt;: Constant pp_n) ppm -&gt;</span>
<span class="lineno"> 1787 </span><span class="spaces">    </span><span class="nottickedoff">do pp &lt;- ppm</span>
<span class="lineno"> 1788 </span><span class="spaces">       </span><span class="nottickedoff">return $ sep [pretty &quot;exsh&quot; &lt;+&gt; pp_n &lt;&gt; dot, pp]</span>
<span class="lineno"> 1789 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM PExpr_FalseShape = return $ pretty &quot;falsesh&quot;</span>
<span class="lineno"> 1790 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (PExpr_ValPerm p) = permPrettyM p</span></span>
<span class="lineno"> 1791 </span>
<span class="lineno"> 1792 </span>instance (1 &lt;= w, KnownNat w) =&gt; PermPretty (LLVMFieldShape w) where
<span class="lineno"> 1793 </span>  <span class="decl"><span class="nottickedoff">permPrettyM fsh@(LLVMFieldShape p)</span>
<span class="lineno"> 1794 </span><span class="spaces">    </span><span class="nottickedoff">| Just Refl &lt;- testEquality (natRepr fsh) (exprLLVMTypeWidth p) =</span>
<span class="lineno"> 1795 </span><span class="spaces">      </span><span class="nottickedoff">parens &lt;$&gt; permPrettyM p</span>
<span class="lineno"> 1796 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (LLVMFieldShape p) =</span>
<span class="lineno"> 1797 </span><span class="spaces">    </span><span class="nottickedoff">do p_pp &lt;- permPrettyM p</span>
<span class="lineno"> 1798 </span><span class="spaces">       </span><span class="nottickedoff">return $ ppEncList True [pretty (intValue $ exprLLVMTypeWidth p), p_pp]</span></span>
<span class="lineno"> 1799 </span>
<span class="lineno"> 1800 </span>prettyPermListM :: PermExpr PermListType -&gt; PermPPM (Doc ann)
<span class="lineno"> 1801 </span><span class="decl"><span class="nottickedoff">prettyPermListM PExpr_PermListNil =</span>
<span class="lineno"> 1802 </span><span class="spaces">  </span><span class="nottickedoff">-- Special case for an empty list of permissions</span>
<span class="lineno"> 1803 </span><span class="spaces">  </span><span class="nottickedoff">return $ pretty &quot;empty&quot;</span>
<span class="lineno"> 1804 </span><span class="spaces"></span><span class="nottickedoff">prettyPermListM e =</span>
<span class="lineno"> 1805 </span><span class="spaces">  </span><span class="nottickedoff">case matchPermList e of</span>
<span class="lineno"> 1806 </span><span class="spaces">    </span><span class="nottickedoff">(Some perms, Just term_var) -&gt;</span>
<span class="lineno"> 1807 </span><span class="spaces">      </span><span class="nottickedoff">do pps &lt;- sequence (RL.mapToList permPrettyMF perms)</span>
<span class="lineno"> 1808 </span><span class="spaces">         </span><span class="nottickedoff">pp_term &lt;- permPrettyM term_var</span>
<span class="lineno"> 1809 </span><span class="spaces">         </span><span class="nottickedoff">return $ align $ fillSep (map (&lt;&gt; comma) (take (length pps - 1) pps)</span>
<span class="lineno"> 1810 </span><span class="spaces">                                   </span><span class="nottickedoff">++ [last pps &lt;+&gt; pretty &quot;::&quot;, pp_term])</span>
<span class="lineno"> 1811 </span><span class="spaces">    </span><span class="nottickedoff">(Some perms, Nothing) -&gt; permPrettyM perms</span></span>
<span class="lineno"> 1812 </span>
<span class="lineno"> 1813 </span>instance PermPrettyF PermExpr where
<span class="lineno"> 1814 </span>  <span class="decl"><span class="nottickedoff">permPrettyMF = permPrettyM</span></span>
<span class="lineno"> 1815 </span>
<span class="lineno"> 1816 </span>instance PermPretty (BVFactor w) where
<span class="lineno"> 1817 </span>  <span class="decl"><span class="nottickedoff">permPrettyM (BVFactor i x) =</span>
<span class="lineno"> 1818 </span><span class="spaces">    </span><span class="nottickedoff">((pretty (BV.asSigned knownNat i) &lt;&gt; pretty &quot;*&quot;) &lt;&gt;) &lt;$&gt; permPrettyM x</span></span>
<span class="lineno"> 1819 </span>
<span class="lineno"> 1820 </span>instance PermPretty RWModality where
<span class="lineno"> 1821 </span>  <span class="decl"><span class="nottickedoff">permPrettyM Read = return $ pretty &quot;R&quot;</span>
<span class="lineno"> 1822 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM Write = return $ pretty &quot;W&quot;</span></span>
<span class="lineno"> 1823 </span>
<span class="lineno"> 1824 </span>-- | The 'Write' modality as an expression
<span class="lineno"> 1825 </span>pattern PExpr_Write :: PermExpr RWModalityType
<span class="lineno"> 1826 </span>pattern PExpr_Write = <span class="nottickedoff">PExpr_RWModality Write</span>
<span class="lineno"> 1827 </span>
<span class="lineno"> 1828 </span>-- | The 'Read' modality as an expression
<span class="lineno"> 1829 </span>pattern PExpr_Read :: PermExpr RWModalityType
<span class="lineno"> 1830 </span>pattern PExpr_Read = <span class="nottickedoff">PExpr_RWModality Read</span>
<span class="lineno"> 1831 </span>
<span class="lineno"> 1832 </span>-- | Build a \&quot;default\&quot; expression for a given type
<span class="lineno"> 1833 </span>zeroOfType :: TypeRepr tp -&gt; PermExpr tp
<span class="lineno"> 1834 </span><span class="decl"><span class="nottickedoff">zeroOfType (BVRepr w) = withKnownNat w $ PExpr_BV [] $ BV.mkBV w 0</span>
<span class="lineno"> 1835 </span><span class="spaces"></span><span class="nottickedoff">zeroOfType LifetimeRepr = PExpr_Always</span>
<span class="lineno"> 1836 </span><span class="spaces"></span><span class="nottickedoff">zeroOfType _ = error &quot;zeroOfType&quot;</span></span>
<span class="lineno"> 1837 </span>
<span class="lineno"> 1838 </span>
<span class="lineno"> 1839 </span>----------------------------------------------------------------------
<span class="lineno"> 1840 </span>-- * Operations on Bitvector and LLVM Pointer Expressions
<span class="lineno"> 1841 </span>----------------------------------------------------------------------
<span class="lineno"> 1842 </span>
<span class="lineno"> 1843 </span>-- | Build a 'BVFactor' for a variable
<span class="lineno"> 1844 </span>varFactor :: (1 &lt;= w, KnownNat w) =&gt; ExprVar (BVType w) -&gt; BVFactor w
<span class="lineno"> 1845 </span><span class="decl"><span class="nottickedoff">varFactor = BVFactor $ BV.one knownNat</span></span>
<span class="lineno"> 1846 </span>
<span class="lineno"> 1847 </span>-- | Merge two normalized / sorted lists of 'BVFactor's
<span class="lineno"> 1848 </span>bvMergeFactors :: [BVFactor w] -&gt; [BVFactor w] -&gt; [BVFactor w]
<span class="lineno"> 1849 </span><span class="decl"><span class="nottickedoff">bvMergeFactors fs1 fs2 =</span>
<span class="lineno"> 1850 </span><span class="spaces">  </span><span class="nottickedoff">filter (\(BVFactor i _) -&gt; i /= BV.zero knownNat) $</span>
<span class="lineno"> 1851 </span><span class="spaces">  </span><span class="nottickedoff">helper fs1 fs2</span>
<span class="lineno"> 1852 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno"> 1853 </span><span class="spaces">    </span><span class="nottickedoff">helper factors1 [] = factors1</span>
<span class="lineno"> 1854 </span><span class="spaces">    </span><span class="nottickedoff">helper [] factors2 = factors2</span>
<span class="lineno"> 1855 </span><span class="spaces">    </span><span class="nottickedoff">helper ((BVFactor i1 x1):factors1) ((BVFactor i2 x2):factors2)</span>
<span class="lineno"> 1856 </span><span class="spaces">      </span><span class="nottickedoff">| x1 == x2</span>
<span class="lineno"> 1857 </span><span class="spaces">      </span><span class="nottickedoff">= BVFactor (BV.add knownNat i1 i2) x1 : helper factors1 factors2</span>
<span class="lineno"> 1858 </span><span class="spaces">    </span><span class="nottickedoff">helper (f1@(BVFactor _ x1):factors1) (f2@(BVFactor _ x2):factors2)</span>
<span class="lineno"> 1859 </span><span class="spaces">      </span><span class="nottickedoff">| x1 &lt; x2 = f1 : helper factors1 (f2 : factors2)</span>
<span class="lineno"> 1860 </span><span class="spaces">    </span><span class="nottickedoff">helper (f1@(BVFactor _ _):factors1) (f2@(BVFactor _ _):factors2) =</span>
<span class="lineno"> 1861 </span><span class="spaces">      </span><span class="nottickedoff">f2 : helper (f1 : factors1) factors2</span></span>
<span class="lineno"> 1862 </span>
<span class="lineno"> 1863 </span>-- | Convert a bitvector expression to a sum of factors plus a constant
<span class="lineno"> 1864 </span>bvMatch :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 1865 </span>           ([BVFactor w], BV w)
<span class="lineno"> 1866 </span><span class="decl"><span class="nottickedoff">bvMatch (PExpr_Var x) = ([varFactor x], BV.zero knownNat)</span>
<span class="lineno"> 1867 </span><span class="spaces"></span><span class="nottickedoff">bvMatch (PExpr_BV factors constant) = (factors, constant)</span></span>
<span class="lineno"> 1868 </span>
<span class="lineno"> 1869 </span>-- | Test if a bitvector expression is a constant value
<span class="lineno"> 1870 </span>bvMatchConst :: PermExpr (BVType w) -&gt; Maybe (BV w)
<span class="lineno"> 1871 </span><span class="decl"><span class="nottickedoff">bvMatchConst (PExpr_BV [] constant) = Just constant</span>
<span class="lineno"> 1872 </span><span class="spaces"></span><span class="nottickedoff">bvMatchConst _ = Nothing</span></span>
<span class="lineno"> 1873 </span>
<span class="lineno"> 1874 </span>-- | Test if a bitvector expression is a constant unsigned 'Integer' value
<span class="lineno"> 1875 </span>bvMatchConstInt :: PermExpr (BVType w) -&gt; Maybe Integer
<span class="lineno"> 1876 </span><span class="decl"><span class="nottickedoff">bvMatchConstInt = fmap BV.asUnsigned . bvMatchConst</span></span>
<span class="lineno"> 1877 </span>
<span class="lineno"> 1878 </span>
<span class="lineno"> 1879 </span>-- | Normalize a bitvector expression to a canonical form. Currently this just
<span class="lineno"> 1880 </span>-- means converting @1*x+0@ to @x@.
<span class="lineno"> 1881 </span>normalizeBVExpr :: PermExpr (BVType w) -&gt; PermExpr (BVType w)
<span class="lineno"> 1882 </span><span class="decl"><span class="nottickedoff">normalizeBVExpr (PExpr_BV [BVFactor (BV.BV 1) x] (BV.BV 0)) = PExpr_Var x</span>
<span class="lineno"> 1883 </span><span class="spaces"></span><span class="nottickedoff">normalizeBVExpr e = e</span></span>
<span class="lineno"> 1884 </span>
<span class="lineno"> 1885 </span>-- | Test whether two bitvector expressions are semantically equal
<span class="lineno"> 1886 </span>bvEq :: PermExpr (BVType w) -&gt; PermExpr (BVType w) -&gt; Bool
<span class="lineno"> 1887 </span><span class="decl"><span class="nottickedoff">bvEq e1 e2 = normalizeBVExpr e1 == normalizeBVExpr e2</span></span>
<span class="lineno"> 1888 </span>
<span class="lineno"> 1889 </span>-- | Test whether a bitvector expression is less than another for all
<span class="lineno"> 1890 </span>-- substitutions to the free variables. The comparison is unsigned. This is an
<span class="lineno"> 1891 </span>-- underapproximation, meaning that it could return 'False' in cases where it is
<span class="lineno"> 1892 </span>-- actually 'True'. The current algorithm returns 'False' when the right-hand
<span class="lineno"> 1893 </span>-- side is 0, 'True' for constant expressions @k1 &lt; k2@, and 'False' otherwise.
<span class="lineno"> 1894 </span>bvLt :: PermExpr (BVType w) -&gt; PermExpr (BVType w) -&gt; Bool
<span class="lineno"> 1895 </span><span class="decl"><span class="nottickedoff">bvLt _ (PExpr_BV [] (BV.BV 0)) = False</span>
<span class="lineno"> 1896 </span><span class="spaces"></span><span class="nottickedoff">bvLt e1 e2 | bvEq e1 e2 = False</span>
<span class="lineno"> 1897 </span><span class="spaces"></span><span class="nottickedoff">bvLt (PExpr_BV [] k1) (PExpr_BV [] k2) = BV.ult k1 k2</span>
<span class="lineno"> 1898 </span><span class="spaces"></span><span class="nottickedoff">bvLt _ _ = False</span></span>
<span class="lineno"> 1899 </span>
<span class="lineno"> 1900 </span>-- | Test whether a bitvector expression is less than another for all
<span class="lineno"> 1901 </span>-- substitutions to the free variables. The comparison is signed. This is an
<span class="lineno"> 1902 </span>-- underapproximation, meaning that it could return 'False' in cases where it is
<span class="lineno"> 1903 </span>-- actually 'True'. The current algorithm only returns 'True' for constant
<span class="lineno"> 1904 </span>-- expressions @k1 &lt; k2@.
<span class="lineno"> 1905 </span>bvSLt :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 1906 </span>         PermExpr (BVType w) -&gt; PermExpr (BVType w) -&gt; Bool
<span class="lineno"> 1907 </span><span class="decl"><span class="nottickedoff">bvSLt (bvMatchConst -&gt; Just i1) (bvMatchConst -&gt; Just i2) =</span>
<span class="lineno"> 1908 </span><span class="spaces">  </span><span class="nottickedoff">BV.slt knownNat i1 i2</span>
<span class="lineno"> 1909 </span><span class="spaces"></span><span class="nottickedoff">bvSLt _ _ = False</span></span>
<span class="lineno"> 1910 </span>
<span class="lineno"> 1911 </span>-- | Test whether a bitvector expression @e@ is in a 'BVRange' for all
<span class="lineno"> 1912 </span>-- substitutions to the free variables. This is an underapproximation, meaning
<span class="lineno"> 1913 </span>-- that it could return 'False' in cases where it is actually 'True'. It is
<span class="lineno"> 1914 </span>-- implemented by testing whether @e - off &lt; len@ using the unsigned comparison
<span class="lineno"> 1915 </span>-- 'bvLt', where @off@ and @len@ are the offset and length of the 'BVRange'.
<span class="lineno"> 1916 </span>bvInRange :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (BVType w) -&gt; BVRange w -&gt; Bool
<span class="lineno"> 1917 </span><span class="decl"><span class="nottickedoff">bvInRange e (BVRange off len) = bvLt (bvSub e off) len</span></span>
<span class="lineno"> 1918 </span>
<span class="lineno"> 1919 </span>-- | Test whether a bitvector @e@ equals @0@
<span class="lineno"> 1920 </span>bvIsZero :: PermExpr (BVType w) -&gt; Bool
<span class="lineno"> 1921 </span><span class="decl"><span class="nottickedoff">bvIsZero (PExpr_Var _) = False</span>
<span class="lineno"> 1922 </span><span class="spaces"></span><span class="nottickedoff">bvIsZero (PExpr_BV [] (BV.BV 0)) = True</span>
<span class="lineno"> 1923 </span><span class="spaces"></span><span class="nottickedoff">bvIsZero (PExpr_BV _ _) = False</span></span>
<span class="lineno"> 1924 </span>
<span class="lineno"> 1925 </span>-- | Test whether a bitvector @e@ could equal @0@, i.e., whether the equation
<span class="lineno"> 1926 </span>-- @e=0@ has any solutions.
<span class="lineno"> 1927 </span>--
<span class="lineno"> 1928 </span>-- NOTE: this is an overapproximation, meaning that it may return 'True' for
<span class="lineno"> 1929 </span>-- complex expressions that technically cannot unify with @0@.
<span class="lineno"> 1930 </span>bvZeroable :: PermExpr (BVType w) -&gt; Bool
<span class="lineno"> 1931 </span><span class="decl"><span class="nottickedoff">bvZeroable (PExpr_Var _) = True</span>
<span class="lineno"> 1932 </span><span class="spaces"></span><span class="nottickedoff">bvZeroable (PExpr_BV _ (BV.BV 0)) = True</span>
<span class="lineno"> 1933 </span><span class="spaces"></span><span class="nottickedoff">bvZeroable (PExpr_BV [] _) = False</span>
<span class="lineno"> 1934 </span><span class="spaces"></span><span class="nottickedoff">bvZeroable (PExpr_BV _ _) =</span>
<span class="lineno"> 1935 </span><span class="spaces">  </span><span class="nottickedoff">-- NOTE: there are cases that match this pattern but are still not solvable,</span>
<span class="lineno"> 1936 </span><span class="spaces">  </span><span class="nottickedoff">-- like 8*x + 3 = 0.</span>
<span class="lineno"> 1937 </span><span class="spaces">  </span><span class="nottickedoff">True</span></span>
<span class="lineno"> 1938 </span>
<span class="lineno"> 1939 </span>-- | Test whether two bitvector expressions are potentially unifiable, i.e.,
<span class="lineno"> 1940 </span>-- whether some substitution to the variables could make them equal. This is an
<span class="lineno"> 1941 </span>-- overapproximation, meaning that some expressions are marked as \&quot;could\&quot;
<span class="lineno"> 1942 </span>-- equal when they actually cannot.
<span class="lineno"> 1943 </span>bvCouldEqual :: PermExpr (BVType w) -&gt; PermExpr (BVType w) -&gt; Bool
<span class="lineno"> 1944 </span><span class="decl"><span class="nottickedoff">bvCouldEqual e1@(PExpr_BV _ _) e2 =</span>
<span class="lineno"> 1945 </span><span class="spaces">  </span><span class="nottickedoff">-- NOTE: we can only call bvSub when at least one side matches PExpr_BV</span>
<span class="lineno"> 1946 </span><span class="spaces">  </span><span class="nottickedoff">bvZeroable (bvSub e1 e2)</span>
<span class="lineno"> 1947 </span><span class="spaces"></span><span class="nottickedoff">bvCouldEqual e1 e2@(PExpr_BV _ _) = bvZeroable (bvSub e1 e2)</span>
<span class="lineno"> 1948 </span><span class="spaces"></span><span class="nottickedoff">bvCouldEqual _ _ = True</span></span>
<span class="lineno"> 1949 </span>
<span class="lineno"> 1950 </span>-- | Test whether a bitvector expression could potentially be less than another,
<span class="lineno"> 1951 </span>-- for some substitution to the free variables. The comparison is unsigned. This
<span class="lineno"> 1952 </span>-- is an overapproximation, meaning that some expressions are marked as
<span class="lineno"> 1953 </span>-- \&quot;could\&quot; be less than when they actually cannot. The current algorithm
<span class="lineno"> 1954 </span>-- returns 'False' when the right-hand side is 0 and 'True' in all other cases
<span class="lineno"> 1955 </span>-- except constant expressions @k1 &gt;= k2@.
<span class="lineno"> 1956 </span>bvCouldBeLt :: PermExpr (BVType w) -&gt; PermExpr (BVType w) -&gt; Bool
<span class="lineno"> 1957 </span><span class="decl"><span class="nottickedoff">bvCouldBeLt _ (PExpr_BV [] (BV.BV 0)) = False</span>
<span class="lineno"> 1958 </span><span class="spaces"></span><span class="nottickedoff">bvCouldBeLt e1 e2 | bvEq e1 e2 = False</span>
<span class="lineno"> 1959 </span><span class="spaces"></span><span class="nottickedoff">bvCouldBeLt (PExpr_BV [] (BV.BV k1)) (PExpr_BV [] (BV.BV k2)) = k1 &lt; k2</span>
<span class="lineno"> 1960 </span><span class="spaces"></span><span class="nottickedoff">bvCouldBeLt _ _ = True</span></span>
<span class="lineno"> 1961 </span>
<span class="lineno"> 1962 </span>-- | Test whether a bitvector expression could potentially be less than another,
<span class="lineno"> 1963 </span>-- for some substitution to the free variables. The comparison is signed. This
<span class="lineno"> 1964 </span>-- is an overapproximation, meaning that some expressions are marked as
<span class="lineno"> 1965 </span>-- \&quot;could\&quot; be less than when they actually cannot. The current algorithm
<span class="lineno"> 1966 </span>-- returns 'True' in all cases except constant expressions @k1 &gt;= k2@.
<span class="lineno"> 1967 </span>bvCouldBeSLt :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 1968 </span>                PermExpr (BVType w) -&gt; PermExpr (BVType w) -&gt; Bool
<span class="lineno"> 1969 </span><span class="decl"><span class="nottickedoff">bvCouldBeSLt (bvMatchConst -&gt; Just i1) (bvMatchConst -&gt; Just i2) =</span>
<span class="lineno"> 1970 </span><span class="spaces">  </span><span class="nottickedoff">BV.slt knownNat i1 i2</span>
<span class="lineno"> 1971 </span><span class="spaces"></span><span class="nottickedoff">bvCouldBeSLt _ _ = True</span></span>
<span class="lineno"> 1972 </span>
<span class="lineno"> 1973 </span>-- | Test whether a bitvector expression is less than or equal to another for
<span class="lineno"> 1974 </span>-- all substitutions of the free variables. The comparison is unsigned. This is
<span class="lineno"> 1975 </span>-- an underapproximation, meaning that it could return 'False' in cases where it
<span class="lineno"> 1976 </span>-- is actually 'True'. The current algorithm simply tests if the second
<span class="lineno"> 1977 </span>-- epxression 'bvCouldBeLt' the first, and returns the negation of that result.
<span class="lineno"> 1978 </span>bvLeq :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 1979 </span>         PermExpr (BVType w) -&gt; PermExpr (BVType w) -&gt; Bool
<span class="lineno"> 1980 </span><span class="decl"><span class="nottickedoff">bvLeq e1 e2 = not (bvCouldBeLt e2 e1)</span></span>
<span class="lineno"> 1981 </span>
<span class="lineno"> 1982 </span>-- | Test whether a bitvector expression @e@ is in a 'BVRange' for all
<span class="lineno"> 1983 </span>-- substitutions to the free variables. This is an overapproximation, meaning
<span class="lineno"> 1984 </span>-- that some expressions are marked as \&quot;could\&quot; be in the range when they
<span class="lineno"> 1985 </span>-- actually cannot. The current algorithm tests if @e - off &lt; len@ using the
<span class="lineno"> 1986 </span>-- unsigned comparison 'bvCouldBeLt', where @off@ and @len@ are the offset and
<span class="lineno"> 1987 </span>-- length of the 'BVRange'.
<span class="lineno"> 1988 </span>bvCouldBeInRange :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (BVType w) -&gt; BVRange w -&gt; Bool
<span class="lineno"> 1989 </span><span class="decl"><span class="nottickedoff">bvCouldBeInRange e (BVRange off len) = bvCouldBeLt (bvSub e off) len</span></span>
<span class="lineno"> 1990 </span>
<span class="lineno"> 1991 </span>-- | Test whether a 'BVProp' holds for all substitutions of the free
<span class="lineno"> 1992 </span>-- variables. This is an underapproximation, meaning that some propositions are
<span class="lineno"> 1993 </span>-- marked as not holding when they actually do.
<span class="lineno"> 1994 </span>bvPropHolds :: (1 &lt;= w, KnownNat w) =&gt; BVProp w -&gt; Bool
<span class="lineno"> 1995 </span><span class="decl"><span class="nottickedoff">bvPropHolds (BVProp_Eq e1 e2) = bvEq e1 e2</span>
<span class="lineno"> 1996 </span><span class="spaces"></span><span class="nottickedoff">bvPropHolds (BVProp_Neq e1 e2) = not (bvCouldEqual e1 e2)</span>
<span class="lineno"> 1997 </span><span class="spaces"></span><span class="nottickedoff">bvPropHolds (BVProp_ULt e1 e2) = bvLt e1 e2</span>
<span class="lineno"> 1998 </span><span class="spaces"></span><span class="nottickedoff">bvPropHolds (BVProp_ULeq e1 e2) = bvLeq e1 e2</span>
<span class="lineno"> 1999 </span><span class="spaces"></span><span class="nottickedoff">bvPropHolds (BVProp_ULeq_Diff e1 e2 e3) =</span>
<span class="lineno"> 2000 </span><span class="spaces">  </span><span class="nottickedoff">not (bvCouldBeLt (bvSub e2 e3) e1)</span></span>
<span class="lineno"> 2001 </span>
<span class="lineno"> 2002 </span>-- | Test whether a 'BVProp' \&quot;could\&quot; hold for all substitutions of the free
<span class="lineno"> 2003 </span>-- variables. This is an overapproximation, meaning that some propositions are
<span class="lineno"> 2004 </span>-- marked as \&quot;could\&quot; hold when they actually cannot.
<span class="lineno"> 2005 </span>bvPropCouldHold :: (1 &lt;= w, KnownNat w) =&gt; BVProp w -&gt; Bool
<span class="lineno"> 2006 </span><span class="decl"><span class="nottickedoff">bvPropCouldHold (BVProp_Eq e1 e2) = bvCouldEqual e1 e2</span>
<span class="lineno"> 2007 </span><span class="spaces"></span><span class="nottickedoff">bvPropCouldHold (BVProp_Neq e1 e2) = not (bvEq e1 e2)</span>
<span class="lineno"> 2008 </span><span class="spaces"></span><span class="nottickedoff">bvPropCouldHold (BVProp_ULt e1 e2) = bvCouldBeLt e1 e2</span>
<span class="lineno"> 2009 </span><span class="spaces"></span><span class="nottickedoff">bvPropCouldHold (BVProp_ULeq e1 e2) = not (bvLt e2 e1)</span>
<span class="lineno"> 2010 </span><span class="spaces"></span><span class="nottickedoff">bvPropCouldHold (BVProp_ULeq_Diff e1 e2 e3) = not (bvLt (bvSub e2 e3) e1)</span></span>
<span class="lineno"> 2011 </span>
<span class="lineno"> 2012 </span>-- | Negate a 'BVProp'
<span class="lineno"> 2013 </span>bvPropNegate :: BVProp w -&gt; BVProp w
<span class="lineno"> 2014 </span><span class="decl"><span class="nottickedoff">bvPropNegate (BVProp_Eq e1 e2) = BVProp_Neq e1 e2</span>
<span class="lineno"> 2015 </span><span class="spaces"></span><span class="nottickedoff">bvPropNegate (BVProp_Neq e1 e2) = BVProp_Eq e1 e2</span>
<span class="lineno"> 2016 </span><span class="spaces"></span><span class="nottickedoff">bvPropNegate (BVProp_ULt e1 e2) = BVProp_ULeq e2 e1</span>
<span class="lineno"> 2017 </span><span class="spaces"></span><span class="nottickedoff">bvPropNegate (BVProp_ULeq e1 e2) = BVProp_ULt e2 e1</span>
<span class="lineno"> 2018 </span><span class="spaces"></span><span class="nottickedoff">bvPropNegate (BVProp_ULeq_Diff e1 e2 e3) =</span>
<span class="lineno"> 2019 </span><span class="spaces">  </span><span class="nottickedoff">BVProp_ULt (bvSub e2 e3) e1</span></span>
<span class="lineno"> 2020 </span>
<span class="lineno"> 2021 </span>-- | Build the proposition that @x@ is in the range @[off,off+len)@ as the
<span class="lineno"> 2022 </span>-- proposition
<span class="lineno"> 2023 </span>--
<span class="lineno"> 2024 </span>-- &gt; x-off &lt;u len
<span class="lineno"> 2025 </span>bvPropInRange :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 2026 </span>                 PermExpr (BVType w) -&gt; BVRange w -&gt; BVProp w
<span class="lineno"> 2027 </span><span class="decl"><span class="nottickedoff">bvPropInRange e (BVRange off len) = BVProp_ULt (bvSub e off) len</span></span>
<span class="lineno"> 2028 </span>
<span class="lineno"> 2029 </span>-- | Build the proposition that @x@ is /not/ in the range @[off,off+len)@ as the
<span class="lineno"> 2030 </span>-- negation of 'bvPropInRange'
<span class="lineno"> 2031 </span>bvPropNotInRange :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 2032 </span>                    PermExpr (BVType w) -&gt; BVRange w -&gt; BVProp w
<span class="lineno"> 2033 </span><span class="decl"><span class="nottickedoff">bvPropNotInRange e rng = bvPropNegate $ bvPropInRange e rng</span></span>
<span class="lineno"> 2034 </span>
<span class="lineno"> 2035 </span>-- | Build the proposition that @[off1,off1+len1)@ is a subset of
<span class="lineno"> 2036 </span>-- @[off2,off2+len2)@ as the following pair of propositions:
<span class="lineno"> 2037 </span>--
<span class="lineno"> 2038 </span>-- &gt; off1 - off2 &lt;=u len2
<span class="lineno"> 2039 </span>-- &gt; len1 &lt;=u len2 - (off1 - off2)
<span class="lineno"> 2040 </span>--
<span class="lineno"> 2041 </span>-- The first one states that the first @off1 - off2@ elements of the range
<span class="lineno"> 2042 </span>-- @[off2,off2+len2)@ can be removed to get the range
<span class="lineno"> 2043 </span>-- @[off1,off1+(len2-(off1-off2)))@. This also ensures that @len2-(off1- off2)@
<span class="lineno"> 2044 </span>-- does not underflow. The second then ensures that removing @off1-off2@
<span class="lineno"> 2045 </span>-- elements from the front of the second interval still yields a length that is
<span class="lineno"> 2046 </span>-- at least as long as @len1@.
<span class="lineno"> 2047 </span>--
<span class="lineno"> 2048 </span>-- NOTE: this is technically not complete, because the subset relation should
<span class="lineno"> 2049 </span>-- always hold when @len1=0@ while the first proposition above does not always
<span class="lineno"> 2050 </span>-- hold in this case, but we are ok with this. Equivalently, this approach views
<span class="lineno"> 2051 </span>-- @[off1,off1+len1)@ as always containing @off1@ even when @len1=0@.
<span class="lineno"> 2052 </span>--
<span class="lineno"> 2053 </span>-- NOTE: we cannot simplify the subtraction @len2 - (off1 - off2)@ because when
<span class="lineno"> 2054 </span>-- we translate to SAW core both @len2@ and @(off1 - off2)@ become different
<span class="lineno"> 2055 </span>-- arguments to @sliceBVVec@ and @updSliceBVVec@, and SAW core does not simplify
<span class="lineno"> 2056 </span>-- the subtraction of these two arguments.
<span class="lineno"> 2057 </span>bvPropRangeSubset :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 2058 </span>                     BVRange w -&gt; BVRange w -&gt; [BVProp w]
<span class="lineno"> 2059 </span><span class="decl"><span class="nottickedoff">bvPropRangeSubset (BVRange off1 len1) (BVRange off2 len2) =</span>
<span class="lineno"> 2060 </span><span class="spaces">  </span><span class="nottickedoff">[BVProp_ULeq (bvSub off1 off2) len2,</span>
<span class="lineno"> 2061 </span><span class="spaces">   </span><span class="nottickedoff">BVProp_ULeq_Diff len1 len2 (bvSub off1 off2)]</span></span>
<span class="lineno"> 2062 </span>
<span class="lineno"> 2063 </span>-- | Test that one range is a subset of another, by testing that the
<span class="lineno"> 2064 </span>-- propositions returned by 'bvPropRangeSubset' all hold (in the sense of
<span class="lineno"> 2065 </span>-- 'bvPropHolds')
<span class="lineno"> 2066 </span>bvRangeSubset :: (1 &lt;= w, KnownNat w) =&gt; BVRange w -&gt; BVRange w -&gt; Bool
<span class="lineno"> 2067 </span><span class="decl"><span class="nottickedoff">bvRangeSubset rng1 rng2 = all bvPropHolds $ bvPropRangeSubset rng1 rng2</span></span>
<span class="lineno"> 2068 </span>
<span class="lineno"> 2069 </span>-- | Build the proposition that @[off1,off1+len1)@ and @[off2,off2+len2)@ are
<span class="lineno"> 2070 </span>-- disjoint as following pair of propositions:
<span class="lineno"> 2071 </span>--
<span class="lineno"> 2072 </span>-- &gt; len2 &lt;=u off1 - off2
<span class="lineno"> 2073 </span>-- &gt; len1 &lt;=u off2 - off1
<span class="lineno"> 2074 </span>--
<span class="lineno"> 2075 </span>-- These say that each @off@ is not in the other range.
<span class="lineno"> 2076 </span>bvPropRangesDisjoint :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 2077 </span>                        BVRange w -&gt; BVRange w -&gt; [BVProp w]
<span class="lineno"> 2078 </span><span class="decl"><span class="nottickedoff">bvPropRangesDisjoint (BVRange off1 len1) (BVRange off2 len2) =</span>
<span class="lineno"> 2079 </span><span class="spaces">  </span><span class="nottickedoff">[BVProp_ULeq len2 (bvSub off1 off2), BVProp_ULeq len1 (bvSub off2 off1)]</span></span>
<span class="lineno"> 2080 </span>
<span class="lineno"> 2081 </span>-- | Test if @[off1,off1+len1)@ and @[off2,off2+len2)@ overlap, i.e., share at
<span class="lineno"> 2082 </span>-- least one element, by testing that they could not satisfy (in the sense of
<span class="lineno"> 2083 </span>-- 'bvPropCouldHold') the results of 'bvPropRangesDisjoint'
<span class="lineno"> 2084 </span>bvRangesOverlap :: (1 &lt;= w, KnownNat w) =&gt; BVRange w -&gt; BVRange w -&gt; Bool
<span class="lineno"> 2085 </span><span class="decl"><span class="nottickedoff">bvRangesOverlap rng1 rng2 =</span>
<span class="lineno"> 2086 </span><span class="spaces">  </span><span class="nottickedoff">not $ all bvPropCouldHold $ bvPropRangesDisjoint rng1 rng2</span></span>
<span class="lineno"> 2087 </span>
<span class="lineno"> 2088 </span>-- | Test if @[off1,off1+len1)@ and @[off2,off2+len2)@ could overlap, i.e.,
<span class="lineno"> 2089 </span>-- share at least one element, by testing that they do not definitely satisfy
<span class="lineno"> 2090 </span>-- (in the sense of 'bvPropHolds') the results of 'bvPropRangesDisjoint'
<span class="lineno"> 2091 </span>bvRangesCouldOverlap :: (1 &lt;= w, KnownNat w) =&gt; BVRange w -&gt; BVRange w -&gt; Bool
<span class="lineno"> 2092 </span><span class="decl"><span class="nottickedoff">bvRangesCouldOverlap rng1 rng2 =</span>
<span class="lineno"> 2093 </span><span class="spaces">  </span><span class="nottickedoff">not $ all bvPropHolds $ bvPropRangesDisjoint rng1 rng2</span></span>
<span class="lineno"> 2094 </span>
<span class="lineno"> 2095 </span>-- | Get the ending offset of a range
<span class="lineno"> 2096 </span>bvRangeEnd :: (1 &lt;= w, KnownNat w) =&gt; BVRange w -&gt; PermExpr (BVType w)
<span class="lineno"> 2097 </span><span class="decl"><span class="nottickedoff">bvRangeEnd (BVRange off len) = bvAdd off len</span></span>
<span class="lineno"> 2098 </span>
<span class="lineno"> 2099 </span>-- | Take the suffix of a range starting at a given offset, assuming that offset
<span class="lineno"> 2100 </span>-- is in the range
<span class="lineno"> 2101 </span>bvRangeSuffix :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (BVType w) -&gt; BVRange w -&gt;
<span class="lineno"> 2102 </span>                 BVRange w
<span class="lineno"> 2103 </span><span class="decl"><span class="nottickedoff">bvRangeSuffix off' (BVRange off len) =</span>
<span class="lineno"> 2104 </span><span class="spaces">  </span><span class="nottickedoff">BVRange off' (bvSub len (bvSub off' off))</span></span>
<span class="lineno"> 2105 </span>
<span class="lineno"> 2106 </span>-- | Build the range of offsets not in a 'BVRange'
<span class="lineno"> 2107 </span>bvRangeInvert :: (1 &lt;= w, KnownNat w) =&gt; BVRange w -&gt; BVRange w
<span class="lineno"> 2108 </span><span class="decl"><span class="nottickedoff">bvRangeInvert (BVRange off len) =</span>
<span class="lineno"> 2109 </span><span class="spaces">  </span><span class="nottickedoff">BVRange (bvAdd off len) (bvSub (bvInt 0) len)</span></span>
<span class="lineno"> 2110 </span>
<span class="lineno"> 2111 </span>-- | Subtract a bitvector word from the offset of a 'BVRange'
<span class="lineno"> 2112 </span>bvRangeSub :: (1 &lt;= w, KnownNat w) =&gt; BVRange w -&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 2113 </span>              BVRange w
<span class="lineno"> 2114 </span><span class="decl"><span class="nottickedoff">bvRangeSub (BVRange off len) x = BVRange (bvSub off x) len</span></span>
<span class="lineno"> 2115 </span>
<span class="lineno"> 2116 </span>-- | Delete all offsets from the first 'BVRange' that are definitely (in the
<span class="lineno"> 2117 </span>-- sense of 'bvPropHolds') in the second, returning a list of 'BVRange's that
<span class="lineno"> 2118 </span>-- together describe the remaining offsets
<span class="lineno"> 2119 </span>bvRangeDelete :: (1 &lt;= w, KnownNat w) =&gt; BVRange w -&gt; BVRange w -&gt; [BVRange w]
<span class="lineno"> 2120 </span><span class="decl"><span class="nottickedoff">bvRangeDelete rng1 rng2</span>
<span class="lineno"> 2121 </span><span class="spaces">  </span><span class="nottickedoff">-- If rng1 is a subset of rng2, return the empty set</span>
<span class="lineno"> 2122 </span><span class="spaces">  </span><span class="nottickedoff">| bvRangeSubset rng1 rng2 = []</span>
<span class="lineno"> 2123 </span><span class="spaces"></span><span class="nottickedoff">bvRangeDelete rng1 rng2</span>
<span class="lineno"> 2124 </span><span class="spaces">  </span><span class="nottickedoff">-- If both endpoints of rng1 are in rng2 but it is not a subset of rng2, then</span>
<span class="lineno"> 2125 </span><span class="spaces">  </span><span class="nottickedoff">-- one of the ranges wrapped, and we return the range from the end of rng2 to</span>
<span class="lineno"> 2126 </span><span class="spaces">  </span><span class="nottickedoff">-- its beginning again</span>
<span class="lineno"> 2127 </span><span class="spaces">  </span><span class="nottickedoff">| bvInRange (bvRangeOffset rng1) rng2 &amp;&amp;</span>
<span class="lineno"> 2128 </span><span class="spaces">    </span><span class="nottickedoff">bvInRange (bvRangeEnd rng1) rng2 =</span>
<span class="lineno"> 2129 </span><span class="spaces">    </span><span class="nottickedoff">[BVRange (bvRangeEnd rng2) (bvSub (bvInt 0) (bvRangeLength rng2))]</span>
<span class="lineno"> 2130 </span><span class="spaces"></span><span class="nottickedoff">bvRangeDelete rng1 rng2</span>
<span class="lineno"> 2131 </span><span class="spaces">  </span><span class="nottickedoff">-- If the beginning of rng1 is in rng2 but the above cases don't hold, then</span>
<span class="lineno"> 2132 </span><span class="spaces">  </span><span class="nottickedoff">-- rng2 removes some prefix of rng1, so return the range from the end of rng2</span>
<span class="lineno"> 2133 </span><span class="spaces">  </span><span class="nottickedoff">-- to the end of rng1</span>
<span class="lineno"> 2134 </span><span class="spaces">  </span><span class="nottickedoff">| bvInRange (bvRangeOffset rng1) rng2 =</span>
<span class="lineno"> 2135 </span><span class="spaces">    </span><span class="nottickedoff">[bvRangeSuffix (bvRangeEnd rng2) rng1]</span>
<span class="lineno"> 2136 </span><span class="spaces"></span><span class="nottickedoff">bvRangeDelete rng1 rng2</span>
<span class="lineno"> 2137 </span><span class="spaces">  </span><span class="nottickedoff">-- If the end of rng1 is in rng2 but the above cases don't hold, then rng2</span>
<span class="lineno"> 2138 </span><span class="spaces">  </span><span class="nottickedoff">-- removes some suffix of rng1, so return the range from the beginnning of</span>
<span class="lineno"> 2139 </span><span class="spaces">  </span><span class="nottickedoff">-- rng1 to the beginning of rng2</span>
<span class="lineno"> 2140 </span><span class="spaces">  </span><span class="nottickedoff">| bvInRange (bvRangeEnd rng1) rng2 =</span>
<span class="lineno"> 2141 </span><span class="spaces">    </span><span class="nottickedoff">[BVRange (bvRangeOffset rng1)</span>
<span class="lineno"> 2142 </span><span class="spaces">     </span><span class="nottickedoff">(bvSub (bvRangeOffset rng2) (bvRangeOffset rng1))]</span>
<span class="lineno"> 2143 </span><span class="spaces"></span><span class="nottickedoff">bvRangeDelete rng1 rng2</span>
<span class="lineno"> 2144 </span><span class="spaces">  </span><span class="nottickedoff">-- If we get here then both endpoints of rng1 are not in rng2, but rng2 sits</span>
<span class="lineno"> 2145 </span><span class="spaces">  </span><span class="nottickedoff">-- inside of rng1, so return the prefix of rng1 before rng2 and the suffix of</span>
<span class="lineno"> 2146 </span><span class="spaces">  </span><span class="nottickedoff">-- rng1 after rng2</span>
<span class="lineno"> 2147 </span><span class="spaces">  </span><span class="nottickedoff">| off1 &lt;- bvRangeOffset rng1</span>
<span class="lineno"> 2148 </span><span class="spaces">  </span><span class="nottickedoff">, off2 &lt;- bvRangeOffset rng2</span>
<span class="lineno"> 2149 </span><span class="spaces">  </span><span class="nottickedoff">, end1 &lt;- bvRangeEnd rng1</span>
<span class="lineno"> 2150 </span><span class="spaces">  </span><span class="nottickedoff">, end2 &lt;- bvRangeEnd rng2</span>
<span class="lineno"> 2151 </span><span class="spaces">  </span><span class="nottickedoff">, bvInRange off2 rng1 =</span>
<span class="lineno"> 2152 </span><span class="spaces">    </span><span class="nottickedoff">[BVRange off1 (bvSub off2 off1), BVRange end2 (bvSub end1 end2)]</span>
<span class="lineno"> 2153 </span><span class="spaces"></span><span class="nottickedoff">bvRangeDelete rng1 _ =</span>
<span class="lineno"> 2154 </span><span class="spaces">  </span><span class="nottickedoff">-- If we get here, then rng2 is completely disjoint from rng1, so return rng1</span>
<span class="lineno"> 2155 </span><span class="spaces">  </span><span class="nottickedoff">[rng1]</span></span>
<span class="lineno"> 2156 </span>
<span class="lineno"> 2157 </span>-- | Delete all offsets in any of a list of ranges from a range, yielding a list
<span class="lineno"> 2158 </span>-- of ranges of the remaining offsets
<span class="lineno"> 2159 </span>bvRangesDelete :: (1 &lt;= w, KnownNat w) =&gt; BVRange w -&gt; [BVRange w] -&gt;
<span class="lineno"> 2160 </span>                  [BVRange w]
<span class="lineno"> 2161 </span><span class="decl"><span class="nottickedoff">bvRangesDelete rng_top =</span>
<span class="lineno"> 2162 </span><span class="spaces">  </span><span class="nottickedoff">foldr (\rng_del rngs -&gt; concatMap (flip bvRangeDelete rng_del) rngs) [rng_top]</span></span>
<span class="lineno"> 2163 </span>
<span class="lineno"> 2164 </span>-- | Find all offsets in the first range that could (in the sense of
<span class="lineno"> 2165 </span>-- 'bvPropCouldHold') be in the second. This is an asymmetric form of
<span class="lineno"> 2166 </span>-- intersection, and is equivalent to 'bvRangeDelete' of the complement of the
<span class="lineno"> 2167 </span>-- second range
<span class="lineno"> 2168 </span>bvRangeSubsetTo :: (1 &lt;= w, KnownNat w) =&gt; BVRange w -&gt; BVRange w -&gt;
<span class="lineno"> 2169 </span>                   [BVRange w]
<span class="lineno"> 2170 </span><span class="decl"><span class="nottickedoff">bvRangeSubsetTo rng1 rng2 = bvRangeDelete rng1 $ bvRangeInvert rng2</span></span>
<span class="lineno"> 2171 </span>
<span class="lineno"> 2172 </span>-- | Find all offsets in any of the first list of ranges that could (in the
<span class="lineno"> 2173 </span>-- sense of 'bvPropCouldHold') be in one of those in the second list
<span class="lineno"> 2174 </span>bvRangesSubsetTo :: (1 &lt;= w, KnownNat w) =&gt; [BVRange w] -&gt; [BVRange w] -&gt;
<span class="lineno"> 2175 </span>                    [BVRange w]
<span class="lineno"> 2176 </span><span class="decl"><span class="nottickedoff">bvRangesSubsetTo rngs1 rngs2 =</span>
<span class="lineno"> 2177 </span><span class="spaces">  </span><span class="nottickedoff">flip concatMap rngs1 $ \rng1 -&gt; flip concatMap rngs2 $ \rng2 -&gt;</span>
<span class="lineno"> 2178 </span><span class="spaces">  </span><span class="nottickedoff">bvRangeSubsetTo rng1 rng2</span></span>
<span class="lineno"> 2179 </span>
<span class="lineno"> 2180 </span>-- | Convert an 'MbRangeForType' in a binding to an 'MbRangeForType'
<span class="lineno"> 2181 </span>mbMbRangeForType :: CruCtx ctx -&gt; Mb ctx (MbRangeForType a) -&gt;
<span class="lineno"> 2182 </span>                    MbRangeForType a
<span class="lineno"> 2183 </span>-- If the range can be lifted out of the binding, do so
<span class="lineno"> 2184 </span><span class="decl"><span class="nottickedoff">mbMbRangeForType ctx mb_rngft</span>
<span class="lineno"> 2185 </span><span class="spaces">  </span><span class="nottickedoff">| Just rngft &lt;- partialSubst (emptyPSubst $ cruCtxProxies ctx) mb_rngft</span>
<span class="lineno"> 2186 </span><span class="spaces">  </span><span class="nottickedoff">= rngft</span>
<span class="lineno"> 2187 </span><span class="spaces"></span><span class="nottickedoff">-- Otherwise, add the new variables to the existing bound variables</span>
<span class="lineno"> 2188 </span><span class="spaces"></span><span class="nottickedoff">mbMbRangeForType ctx mb_rngft = case mbMatch mb_rngft of</span>
<span class="lineno"> 2189 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| MbRangeForLLVMType vars rw l rng |] -&gt;</span>
<span class="lineno"> 2190 </span><span class="spaces">    </span><span class="nottickedoff">MbRangeForLLVMType (appendCruCtx ctx $ mbLift vars)</span>
<span class="lineno"> 2191 </span><span class="spaces">    </span><span class="nottickedoff">(mbCombine (cruCtxProxies $ mbLift vars) rw)</span>
<span class="lineno"> 2192 </span><span class="spaces">    </span><span class="nottickedoff">(mbCombine (cruCtxProxies $ mbLift vars) l)</span>
<span class="lineno"> 2193 </span><span class="spaces">    </span><span class="nottickedoff">(mbCombine (cruCtxProxies $ mbLift vars) rng)</span></span>
<span class="lineno"> 2194 </span>
<span class="lineno"> 2195 </span>-- | Add a 'PermOffset' to an 'MbRangeForType
<span class="lineno"> 2196 </span>offsetMbRangeForType :: PermOffset a -&gt; MbRangeForType a -&gt; MbRangeForType a
<span class="lineno"> 2197 </span><span class="decl"><span class="nottickedoff">offsetMbRangeForType NoPermOffset rng = rng</span>
<span class="lineno"> 2198 </span><span class="spaces"></span><span class="nottickedoff">offsetMbRangeForType (LLVMPermOffset off) (MbRangeForLLVMType</span>
<span class="lineno"> 2199 </span><span class="spaces">                                           </span><span class="nottickedoff">vars mb_rw mb_l mb_rng) =</span>
<span class="lineno"> 2200 </span><span class="spaces">  </span><span class="nottickedoff">MbRangeForLLVMType vars mb_rw mb_l $ fmap (offsetBVRange off) mb_rng</span></span>
<span class="lineno"> 2201 </span>
<span class="lineno"> 2202 </span>-- | Test if the first read/write modality in a binding \&quot;covers\&quot; the second,
<span class="lineno"> 2203 </span>-- meaning a permission relative to the first implies or can be coerced to a
<span class="lineno"> 2204 </span>-- similar permission relative to the second, possibly by instantiating evars on
<span class="lineno"> 2205 </span>-- the right
<span class="lineno"> 2206 </span>mbRWModCovers ::
<span class="lineno"> 2207 </span>  Mb (ctx1 :: RList CrucibleType) (PermExpr RWModalityType) -&gt;
<span class="lineno"> 2208 </span>  Mb (ctx2 :: RList CrucibleType) (PermExpr RWModalityType) -&gt; Bool
<span class="lineno"> 2209 </span><span class="decl"><span class="nottickedoff">mbRWModCovers [nuP| PExpr_Write |] _ = True</span>
<span class="lineno"> 2210 </span><span class="spaces"></span><span class="nottickedoff">mbRWModCovers _ [nuP| PExpr_Read |] = True</span>
<span class="lineno"> 2211 </span><span class="spaces"></span><span class="nottickedoff">mbRWModCovers _ [nuP| PExpr_Var mb_x |]</span>
<span class="lineno"> 2212 </span><span class="spaces">  </span><span class="nottickedoff">| Left _ &lt;- mbNameBoundP mb_x = True</span>
<span class="lineno"> 2213 </span><span class="spaces"></span><span class="nottickedoff">mbRWModCovers mb_rw2 mb_rw1 =</span>
<span class="lineno"> 2214 </span><span class="spaces">  </span><span class="nottickedoff">fromMaybe False ((==) &lt;$&gt; tryLift mb_rw1 &lt;*&gt; tryLift mb_rw2)</span></span>
<span class="lineno"> 2215 </span>
<span class="lineno"> 2216 </span>-- | Test if the first lifetime in a binding \&quot;covers\&quot; the second, meaning a
<span class="lineno"> 2217 </span>-- permission relative to the second implies or can be coerced to a similar
<span class="lineno"> 2218 </span>-- permission relative to the first, possibly by instantiating evars on the
<span class="lineno"> 2219 </span>-- right
<span class="lineno"> 2220 </span>mbLifetimeCovers ::
<span class="lineno"> 2221 </span>  Mb (ctx1 :: RList CrucibleType) (PermExpr LifetimeType) -&gt;
<span class="lineno"> 2222 </span>  Mb (ctx2 :: RList CrucibleType) (PermExpr LifetimeType) -&gt; Bool
<span class="lineno"> 2223 </span><span class="decl"><span class="nottickedoff">mbLifetimeCovers _ [nuP| PExpr_Always |] = True</span>
<span class="lineno"> 2224 </span><span class="spaces"></span><span class="nottickedoff">mbLifetimeCovers _ [nuP| PExpr_Var mb_x |]</span>
<span class="lineno"> 2225 </span><span class="spaces">  </span><span class="nottickedoff">| Left _ &lt;- mbNameBoundP mb_x = True</span>
<span class="lineno"> 2226 </span><span class="spaces"></span><span class="nottickedoff">mbLifetimeCovers mb_l1 mb_l2 =</span>
<span class="lineno"> 2227 </span><span class="spaces">  </span><span class="nottickedoff">fromMaybe False ((==) &lt;$&gt; tryLift mb_l1 &lt;*&gt; tryLift mb_l2)</span></span>
<span class="lineno"> 2228 </span>
<span class="lineno"> 2229 </span>-- | Delete one range from another, where the deletion only happens if the
<span class="lineno"> 2230 </span>-- modalities of the RHS cover those of the LHS
<span class="lineno"> 2231 </span>mbRangeFTDelete :: MbRangeForType a -&gt; MbRangeForType a -&gt;
<span class="lineno"> 2232 </span>                   [MbRangeForType a]
<span class="lineno"> 2233 </span><span class="decl"><span class="nottickedoff">mbRangeFTDelete</span>
<span class="lineno"> 2234 </span><span class="spaces">  </span><span class="nottickedoff">(MbRangeForLLVMType vars1 mb_rw1 mb_l1 mb_rng1)</span>
<span class="lineno"> 2235 </span><span class="spaces">  </span><span class="nottickedoff">(MbRangeForLLVMType vars2 mb_rw2 mb_l2 mb_rng2)</span>
<span class="lineno"> 2236 </span><span class="spaces">  </span><span class="nottickedoff">| mbRWModCovers mb_rw2 mb_rw1</span>
<span class="lineno"> 2237 </span><span class="spaces">  </span><span class="nottickedoff">, mbLifetimeCovers mb_l2 mb_l1</span>
<span class="lineno"> 2238 </span><span class="spaces">  </span><span class="nottickedoff">, mb_rw2' &lt;- extMbMultiL (cruCtxProxies vars1) mb_rw2</span>
<span class="lineno"> 2239 </span><span class="spaces">  </span><span class="nottickedoff">, mb_l2' &lt;- extMbMultiL (cruCtxProxies vars1) mb_l2 =</span>
<span class="lineno"> 2240 </span><span class="spaces">    </span><span class="nottickedoff">map (MbRangeForLLVMType (appendCruCtx vars1 vars2) mb_rw2' mb_l2') $</span>
<span class="lineno"> 2241 </span><span class="spaces">    </span><span class="nottickedoff">mbList $ mbCombine (cruCtxProxies vars2) $</span>
<span class="lineno"> 2242 </span><span class="spaces">    </span><span class="nottickedoff">flip fmap mb_rng1 $ \rng1 -&gt; flip fmap mb_rng2 $ \rng2 -&gt;</span>
<span class="lineno"> 2243 </span><span class="spaces">    </span><span class="nottickedoff">bvRangeDelete rng1 rng2</span>
<span class="lineno"> 2244 </span><span class="spaces"></span><span class="nottickedoff">mbRangeFTDelete mb_rng _ = [mb_rng]</span></span>
<span class="lineno"> 2245 </span>
<span class="lineno"> 2246 </span>-- | Delete all ranges in any of a list of ranges from
<span class="lineno"> 2247 </span>mbRangeFTsDelete :: [MbRangeForType a] -&gt; [MbRangeForType a] -&gt;
<span class="lineno"> 2248 </span>                    [MbRangeForType a]
<span class="lineno"> 2249 </span><span class="decl"><span class="nottickedoff">mbRangeFTsDelete rngs_l rngs_r =</span>
<span class="lineno"> 2250 </span><span class="spaces">  </span><span class="nottickedoff">foldr (\rng_r rngs -&gt; concatMap (flip mbRangeFTDelete rng_r) rngs) rngs_l rngs_r</span></span>
<span class="lineno"> 2251 </span>
<span class="lineno"> 2252 </span>-- | Find all the offsets in the first 'MbRangeForType' that could be in the
<span class="lineno"> 2253 </span>-- second, in a manner similar to 'bvRangeSubsetTo', preserving the modalities
<span class="lineno"> 2254 </span>-- of the first
<span class="lineno"> 2255 </span>mbRangeFTSubsetTo :: MbRangeForType a -&gt; MbRangeForType a -&gt;
<span class="lineno"> 2256 </span>                     [MbRangeForType a]
<span class="lineno"> 2257 </span><span class="decl"><span class="nottickedoff">mbRangeFTSubsetTo</span>
<span class="lineno"> 2258 </span><span class="spaces">  </span><span class="nottickedoff">(MbRangeForLLVMType vars1 mb_rw1 mb_l1 mb_rng1)</span>
<span class="lineno"> 2259 </span><span class="spaces">  </span><span class="nottickedoff">(MbRangeForLLVMType vars2 _ _ mb_rng2)</span>
<span class="lineno"> 2260 </span><span class="spaces">  </span><span class="nottickedoff">| mb_rw1' &lt;- extMbMulti (cruCtxProxies vars2) mb_rw1</span>
<span class="lineno"> 2261 </span><span class="spaces">  </span><span class="nottickedoff">, mb_l1' &lt;- extMbMulti (cruCtxProxies vars2) mb_l1 =</span>
<span class="lineno"> 2262 </span><span class="spaces">    </span><span class="nottickedoff">map (MbRangeForLLVMType (appendCruCtx vars1 vars2) mb_rw1' mb_l1') $ mbList $</span>
<span class="lineno"> 2263 </span><span class="spaces">    </span><span class="nottickedoff">mbCombine (cruCtxProxies vars2) $</span>
<span class="lineno"> 2264 </span><span class="spaces">    </span><span class="nottickedoff">flip fmap mb_rng1 $ \rng1 -&gt; flip fmap mb_rng2 $ \rng2 -&gt;</span>
<span class="lineno"> 2265 </span><span class="spaces">    </span><span class="nottickedoff">bvRangeSubsetTo rng1 rng2</span></span>
<span class="lineno"> 2266 </span>
<span class="lineno"> 2267 </span>-- | Find all the offsets in an 'MbRangeForType' in the first list that could be
<span class="lineno"> 2268 </span>-- in one in the second, in a manner similar to 'bvRangesSubsetTo'
<span class="lineno"> 2269 </span>mbRangeFTsSubsetTo :: [MbRangeForType a] -&gt; [MbRangeForType a] -&gt;
<span class="lineno"> 2270 </span>                      [MbRangeForType a]
<span class="lineno"> 2271 </span><span class="decl"><span class="nottickedoff">mbRangeFTsSubsetTo rngs1 rngs2 =</span>
<span class="lineno"> 2272 </span><span class="spaces">  </span><span class="nottickedoff">flip concatMap rngs1 $ \rng1 -&gt; flip concatMap rngs2 $ \rng2 -&gt;</span>
<span class="lineno"> 2273 </span><span class="spaces">  </span><span class="nottickedoff">mbRangeFTSubsetTo rng1 rng2</span></span>
<span class="lineno"> 2274 </span>
<span class="lineno"> 2275 </span>-- | Test if one 'MbRangeForType' could cover part of another, using
<span class="lineno"> 2276 </span>-- 'mbRWModCovers' and 'mbLifetimeCovers' for the modalities
<span class="lineno"> 2277 </span>mbRangeFTCouldCoverPart :: MbRangeForType a -&gt; MbRangeForType a -&gt; Bool
<span class="lineno"> 2278 </span><span class="decl"><span class="nottickedoff">mbRangeFTCouldCoverPart</span>
<span class="lineno"> 2279 </span><span class="spaces">  </span><span class="nottickedoff">(MbRangeForLLVMType _ mb_rw1 mb_l1 mb_rng1)</span>
<span class="lineno"> 2280 </span><span class="spaces">  </span><span class="nottickedoff">(MbRangeForLLVMType _ mb_rw2 mb_l2 mb_rng2) =</span>
<span class="lineno"> 2281 </span><span class="spaces">  </span><span class="nottickedoff">mbRWModCovers mb_rw1 mb_rw2 &amp;&amp;</span>
<span class="lineno"> 2282 </span><span class="spaces">  </span><span class="nottickedoff">mbLifetimeCovers mb_l1 mb_l2 &amp;&amp;</span>
<span class="lineno"> 2283 </span><span class="spaces">  </span><span class="nottickedoff">(mbLift $ flip fmap mb_rng1 $ \rng1 -&gt;</span>
<span class="lineno"> 2284 </span><span class="spaces">    </span><span class="nottickedoff">mbLift $ flip fmap mb_rng2 $ \rng2 -&gt;</span>
<span class="lineno"> 2285 </span><span class="spaces">    </span><span class="nottickedoff">bvRangesCouldOverlap rng1 rng2)</span></span>
<span class="lineno"> 2286 </span>
<span class="lineno"> 2287 </span>-- | Test if any offsets in one list of 'MbRangeForType's could (as in
<span class="lineno"> 2288 </span>-- 'bvPropCouldHold') covert some offsets in another
<span class="lineno"> 2289 </span>mbRangeFTsCouldCoverPart :: [MbRangeForType a] -&gt; [MbRangeForType a] -&gt; Bool
<span class="lineno"> 2290 </span><span class="decl"><span class="nottickedoff">mbRangeFTsCouldCoverPart rngs1 rngs2 =</span>
<span class="lineno"> 2291 </span><span class="spaces">  </span><span class="nottickedoff">or $ flip concatMap rngs1 $ \rng1 -&gt;</span>
<span class="lineno"> 2292 </span><span class="spaces">  </span><span class="nottickedoff">map (mbRangeFTCouldCoverPart rng1) rngs2</span></span>
<span class="lineno"> 2293 </span>
<span class="lineno"> 2294 </span>-- | Build a bitvector expression from an integer
<span class="lineno"> 2295 </span>bvInt :: (1 &lt;= w, KnownNat w) =&gt; Integer -&gt; PermExpr (BVType w)
<span class="lineno"> 2296 </span><span class="decl"><span class="nottickedoff">bvInt i = PExpr_BV [] $ BV.mkBV knownNat i</span></span>
<span class="lineno"> 2297 </span>
<span class="lineno"> 2298 </span>-- | Build a bitvector expression of a given size from an integer
<span class="lineno"> 2299 </span>bvIntOfSize :: (1 &lt;= sz, KnownNat sz) =&gt; prx sz -&gt; Integer -&gt; PermExpr (BVType sz)
<span class="lineno"> 2300 </span><span class="decl"><span class="nottickedoff">bvIntOfSize _ = bvInt</span></span>
<span class="lineno"> 2301 </span>
<span class="lineno"> 2302 </span>-- | Build a bitvector expression from a Haskell bitvector
<span class="lineno"> 2303 </span>bvBV :: (1 &lt;= w, KnownNat w) =&gt; BV w -&gt; PermExpr (BVType w)
<span class="lineno"> 2304 </span><span class="decl"><span class="nottickedoff">bvBV i = PExpr_BV [] i</span></span>
<span class="lineno"> 2305 </span>
<span class="lineno"> 2306 </span>-- | Helper datatype for 'bvFromBytes'
<span class="lineno"> 2307 </span>data BVExpr w = (1 &lt;= w, KnownNat w) =&gt; BVExpr (PermExpr (BVType w))
<span class="lineno"> 2308 </span>
<span class="lineno"> 2309 </span>-- | Build a bitvector expression from a list of bytes, depending on the
<span class="lineno"> 2310 </span>-- endianness
<span class="lineno"> 2311 </span>bvFromBytes :: EndianForm -&gt; [Word8] -&gt; Some BVExpr
<span class="lineno"> 2312 </span><span class="decl"><span class="nottickedoff">bvFromBytes endianness bytes =</span>
<span class="lineno"> 2313 </span><span class="spaces">  </span><span class="nottickedoff">let bv_fun =</span>
<span class="lineno"> 2314 </span><span class="spaces">        </span><span class="nottickedoff">case endianness of</span>
<span class="lineno"> 2315 </span><span class="spaces">          </span><span class="nottickedoff">BigEndian -&gt; BV.bytesBE</span>
<span class="lineno"> 2316 </span><span class="spaces">          </span><span class="nottickedoff">LittleEndian -&gt; BV.bytesLE in</span>
<span class="lineno"> 2317 </span><span class="spaces">  </span><span class="nottickedoff">case bv_fun bytes of</span>
<span class="lineno"> 2318 </span><span class="spaces">    </span><span class="nottickedoff">Pair sz bv</span>
<span class="lineno"> 2319 </span><span class="spaces">      </span><span class="nottickedoff">| Left leq_proof &lt;- decideLeq (knownNat @1) sz -&gt;</span>
<span class="lineno"> 2320 </span><span class="spaces">        </span><span class="nottickedoff">withKnownNat sz $ withLeqProof leq_proof $ Some $ BVExpr $ bvBV bv</span>
<span class="lineno"> 2321 </span><span class="spaces">    </span><span class="nottickedoff">Pair _ _ -&gt; error &quot;bvFromBytes: zero-sized bitvector&quot;</span></span>
<span class="lineno"> 2322 </span>
<span class="lineno"> 2323 </span>-- | Concatenate two bitvectors, using the current endianness to determine how
<span class="lineno"> 2324 </span>-- they combine
<span class="lineno"> 2325 </span>bvConcat :: KnownNat sz1 =&gt; KnownNat sz2 =&gt; EndianForm -&gt;
<span class="lineno"> 2326 </span>            BV.BV sz1 -&gt; BV.BV sz2 -&gt; BV.BV (sz1+sz2)
<span class="lineno"> 2327 </span><span class="decl"><span class="nottickedoff">bvConcat BigEndian bv1 bv2 = BV.concat knownRepr knownRepr bv1 bv2</span>
<span class="lineno"> 2328 </span><span class="spaces"></span><span class="nottickedoff">bvConcat LittleEndian bv1 bv2</span>
<span class="lineno"> 2329 </span><span class="spaces">  </span><span class="nottickedoff">| Refl &lt;- plusComm bv1 bv2 =</span>
<span class="lineno"> 2330 </span><span class="spaces">    </span><span class="nottickedoff">BV.concat knownRepr knownRepr bv2 bv1</span></span>
<span class="lineno"> 2331 </span>
<span class="lineno"> 2332 </span>-- | Split a bitvector in two, if this is possible, using the current endianness
<span class="lineno"> 2333 </span>-- to determine which is the first versus second part of the split
<span class="lineno"> 2334 </span>bvSplit :: KnownNat sz1 =&gt; KnownNat sz2 =&gt; EndianForm -&gt;
<span class="lineno"> 2335 </span>           NatRepr sz1 -&gt; BV.BV sz2 -&gt; Maybe (BV.BV sz1, BV.BV (sz2 - sz1))
<span class="lineno"> 2336 </span><span class="decl"><span class="nottickedoff">bvSplit LittleEndian sz1 bv2</span>
<span class="lineno"> 2337 </span><span class="spaces">  </span><span class="nottickedoff">| n0 &lt;- knownNat @0</span>
<span class="lineno"> 2338 </span><span class="spaces">  </span><span class="nottickedoff">, sz2 &lt;- natRepr bv2</span>
<span class="lineno"> 2339 </span><span class="spaces">  </span><span class="nottickedoff">, Left LeqProof &lt;- decideLeq (addNat n0 sz1) sz2</span>
<span class="lineno"> 2340 </span><span class="spaces">  </span><span class="nottickedoff">, Left LeqProof &lt;- decideLeq (addNat sz1 (subNat sz2 sz1)) sz2 =</span>
<span class="lineno"> 2341 </span><span class="spaces">    </span><span class="nottickedoff">Just (BV.select n0 sz1 bv2, BV.select sz1 (subNat sz2 sz1) bv2)</span>
<span class="lineno"> 2342 </span><span class="spaces"></span><span class="nottickedoff">bvSplit BigEndian sz1 bv2</span>
<span class="lineno"> 2343 </span><span class="spaces">  </span><span class="nottickedoff">| n0 &lt;- knownNat @0</span>
<span class="lineno"> 2344 </span><span class="spaces">  </span><span class="nottickedoff">, sz2 &lt;- natRepr bv2</span>
<span class="lineno"> 2345 </span><span class="spaces">  </span><span class="nottickedoff">, Left LeqProof &lt;- decideLeq sz1 sz2</span>
<span class="lineno"> 2346 </span><span class="spaces">  </span><span class="nottickedoff">, Left LeqProof &lt;- decideLeq (addNat (subNat sz2 sz1) sz1) sz2</span>
<span class="lineno"> 2347 </span><span class="spaces">  </span><span class="nottickedoff">, Left LeqProof &lt;- decideLeq (addNat n0 (subNat sz2 sz1)) sz2 =</span>
<span class="lineno"> 2348 </span><span class="spaces">    </span><span class="nottickedoff">Just (BV.select (subNat sz2 sz1) sz1 bv2,</span>
<span class="lineno"> 2349 </span><span class="spaces">          </span><span class="nottickedoff">BV.select n0 (subNat sz2 sz1) bv2)</span>
<span class="lineno"> 2350 </span><span class="spaces"></span><span class="nottickedoff">bvSplit _ _ _ = Nothing</span></span>
<span class="lineno"> 2351 </span>
<span class="lineno"> 2352 </span>-- | Build a bitvector expression consisting of a single single 'BVFactor',
<span class="lineno"> 2353 </span>-- i.e. a variable multiplied by some constant
<span class="lineno"> 2354 </span>bvFactorExpr :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 2355 </span>                BV w -&gt; ExprVar (BVType w) -&gt; PermExpr (BVType w)
<span class="lineno"> 2356 </span><span class="decl"><span class="nottickedoff">bvFactorExpr (BV.BV 1) x = PExpr_Var x</span>
<span class="lineno"> 2357 </span><span class="spaces"></span><span class="nottickedoff">bvFactorExpr i         x = PExpr_BV [BVFactor i x] (BV.zero knownNat)</span></span>
<span class="lineno"> 2358 </span>
<span class="lineno"> 2359 </span>-- | Add two bitvector expressions
<span class="lineno"> 2360 </span>bvAdd :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (BVType w) -&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 2361 </span>         PermExpr (BVType w)
<span class="lineno"> 2362 </span><span class="decl"><span class="nottickedoff">bvAdd (bvMatch -&gt; (factors1, const1)) (bvMatch -&gt; (factors2, const2)) =</span>
<span class="lineno"> 2363 </span><span class="spaces">  </span><span class="nottickedoff">normalizeBVExpr $</span>
<span class="lineno"> 2364 </span><span class="spaces">  </span><span class="nottickedoff">PExpr_BV (bvMergeFactors factors1 factors2) (BV.add knownNat const1 const2)</span></span>
<span class="lineno"> 2365 </span>
<span class="lineno"> 2366 </span>-- | Multiply a bitvector expression by a bitvector
<span class="lineno"> 2367 </span>bvMultBV :: (1 &lt;= w, KnownNat w) =&gt; BV.BV w -&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 2368 </span>            PermExpr (BVType w)
<span class="lineno"> 2369 </span><span class="decl"><span class="nottickedoff">bvMultBV i_bv (bvMatch -&gt; (factors, off)) =</span>
<span class="lineno"> 2370 </span><span class="spaces">  </span><span class="nottickedoff">normalizeBVExpr $</span>
<span class="lineno"> 2371 </span><span class="spaces">  </span><span class="nottickedoff">PExpr_BV (map (\(BVFactor j x) -&gt;</span>
<span class="lineno"> 2372 </span><span class="spaces">                  </span><span class="nottickedoff">BVFactor (BV.mul knownNat i_bv j) x) factors)</span>
<span class="lineno"> 2373 </span><span class="spaces">  </span><span class="nottickedoff">(BV.mul knownNat i_bv off)</span></span>
<span class="lineno"> 2374 </span>
<span class="lineno"> 2375 </span>-- | Multiply a bitvector expression by a constant
<span class="lineno"> 2376 </span>bvMult :: (1 &lt;= w, KnownNat w, Integral a) =&gt; a -&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 2377 </span>          PermExpr (BVType w)
<span class="lineno"> 2378 </span><span class="decl"><span class="nottickedoff">bvMult i = bvMultBV (BV.mkBV knownNat $ toInteger i)</span></span>
<span class="lineno"> 2379 </span>
<span class="lineno"> 2380 </span>-- | Negate a bitvector expression
<span class="lineno"> 2381 </span>bvNegate :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (BVType w) -&gt; PermExpr (BVType w)
<span class="lineno"> 2382 </span><span class="decl"><span class="nottickedoff">bvNegate = bvMult (-1 :: Integer)</span></span>
<span class="lineno"> 2383 </span>
<span class="lineno"> 2384 </span>-- | Subtract one bitvector expression from another
<span class="lineno"> 2385 </span>--
<span class="lineno"> 2386 </span>-- FIXME: this would be more efficient if we did not use 'bvNegate', which could
<span class="lineno"> 2387 </span>-- make very large 'Integer's for negative numbers wrapped around to be positive
<span class="lineno"> 2388 </span>bvSub :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (BVType w) -&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 2389 </span>         PermExpr (BVType w)
<span class="lineno"> 2390 </span><span class="decl"><span class="nottickedoff">bvSub e1 e2 = bvAdd e1 (bvNegate e2)</span></span>
<span class="lineno"> 2391 </span>
<span class="lineno"> 2392 </span>-- | Integer division on bitvector expressions, truncating any factors @i*x@
<span class="lineno"> 2393 </span>-- where @i@ is not a multiple of the divisor to zero
<span class="lineno"> 2394 </span>bvDiv :: (1 &lt;= w, KnownNat w, Integral a) =&gt; PermExpr (BVType w) -&gt; a -&gt;
<span class="lineno"> 2395 </span>         PermExpr (BVType w)
<span class="lineno"> 2396 </span><span class="decl"><span class="nottickedoff">bvDiv (bvMatch -&gt; (factors, off)) n =</span>
<span class="lineno"> 2397 </span><span class="spaces">  </span><span class="nottickedoff">let n_bv = BV.mkBV knownNat (toInteger n) in</span>
<span class="lineno"> 2398 </span><span class="spaces">  </span><span class="nottickedoff">normalizeBVExpr $</span>
<span class="lineno"> 2399 </span><span class="spaces">  </span><span class="nottickedoff">PExpr_BV (mapMaybe (\(BVFactor i x) -&gt;</span>
<span class="lineno"> 2400 </span><span class="spaces">                       </span><span class="nottickedoff">if BV.urem i n_bv == BV.zero knownNat then</span>
<span class="lineno"> 2401 </span><span class="spaces">                         </span><span class="nottickedoff">Just (BVFactor (BV.uquot i n_bv) x)</span>
<span class="lineno"> 2402 </span><span class="spaces">                       </span><span class="nottickedoff">else Nothing) factors)</span>
<span class="lineno"> 2403 </span><span class="spaces">  </span><span class="nottickedoff">(BV.uquot off n_bv)</span></span>
<span class="lineno"> 2404 </span>
<span class="lineno"> 2405 </span>-- | Integer Modulus on bitvector expressions, where any factors @i*x@ with @i@
<span class="lineno"> 2406 </span>-- not a multiple of the divisor are included in the modulus
<span class="lineno"> 2407 </span>bvMod :: (1 &lt;= w, KnownNat w, Integral a) =&gt; PermExpr (BVType w) -&gt; a -&gt;
<span class="lineno"> 2408 </span>         PermExpr (BVType w)
<span class="lineno"> 2409 </span><span class="decl"><span class="nottickedoff">bvMod (bvMatch -&gt; (factors, off)) n =</span>
<span class="lineno"> 2410 </span><span class="spaces">  </span><span class="nottickedoff">let n_bv = BV.mkBV knownNat $ toInteger n in</span>
<span class="lineno"> 2411 </span><span class="spaces">  </span><span class="nottickedoff">normalizeBVExpr $</span>
<span class="lineno"> 2412 </span><span class="spaces">  </span><span class="nottickedoff">PExpr_BV (mapMaybe (\f@(BVFactor i _) -&gt;</span>
<span class="lineno"> 2413 </span><span class="spaces">                       </span><span class="nottickedoff">if BV.urem i n_bv /= BV.zero knownNat</span>
<span class="lineno"> 2414 </span><span class="spaces">                       </span><span class="nottickedoff">then Just f else Nothing) factors)</span>
<span class="lineno"> 2415 </span><span class="spaces">  </span><span class="nottickedoff">(BV.urem off n_bv)</span></span>
<span class="lineno"> 2416 </span>
<span class="lineno"> 2417 </span>-- | Given a constant factor @a@, test if a bitvector expression can be written
<span class="lineno"> 2418 </span>-- as @a*x+y@ for some constant @y@
<span class="lineno"> 2419 </span>bvMatchFactorPlusConst :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 2420 </span>                          Integer -&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 2421 </span>                          Maybe (PermExpr (BVType w), BV w)
<span class="lineno"> 2422 </span><span class="decl"><span class="nottickedoff">bvMatchFactorPlusConst a e =</span>
<span class="lineno"> 2423 </span><span class="spaces">  </span><span class="nottickedoff">bvMatchConst (bvMod e a) &gt;&gt;= \y -&gt; Just (bvDiv e a, y)</span></span>
<span class="lineno"> 2424 </span>
<span class="lineno"> 2425 </span>-- | Returns the greatest common divisor of all the coefficients (i.e. offsets
<span class="lineno"> 2426 </span>-- and factor coefficients) of the given bitvectors, returning a negative
<span class="lineno"> 2427 </span>-- number iff all coefficients are &lt;= 0
<span class="lineno"> 2428 </span>bvGCD :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 2429 </span>         PermExpr (BVType w) -&gt; PermExpr (BVType w) -&gt; BV w
<span class="lineno"> 2430 </span><span class="decl"><span class="nottickedoff">bvGCD (bvMatch -&gt; (fs1, off1)) (bvMatch -&gt; (fs2, off2)) =</span>
<span class="lineno"> 2431 </span><span class="spaces">  </span><span class="nottickedoff">fromMaybe (error &quot;bvGCD: overflow&quot;) . BV.mkBVSigned knownNat $</span>
<span class="lineno"> 2432 </span><span class="spaces">  </span><span class="nottickedoff">foldl' (\d (BVFactor i _) -&gt; d `gcdS` BV.asSigned knownNat i)</span>
<span class="lineno"> 2433 </span><span class="spaces">         </span><span class="nottickedoff">(foldl' (\d (BVFactor i _) -&gt; d `gcdS` BV.asSigned knownNat i)</span>
<span class="lineno"> 2434 </span><span class="spaces">                 </span><span class="nottickedoff">(BV.asSigned knownNat off1 `gcdS` BV.asSigned knownNat off2)</span>
<span class="lineno"> 2435 </span><span class="spaces">                 </span><span class="nottickedoff">fs1)</span>
<span class="lineno"> 2436 </span><span class="spaces">         </span><span class="nottickedoff">fs2</span>
<span class="lineno"> 2437 </span><span class="spaces">  </span><span class="nottickedoff">where -- A version of 'gcd' whose return value is negative iff both of</span>
<span class="lineno"> 2438 </span><span class="spaces">        </span><span class="nottickedoff">-- its arguments are &lt;= 0</span>
<span class="lineno"> 2439 </span><span class="spaces">        </span><span class="nottickedoff">gcdS :: Integer -&gt; Integer -&gt; Integer</span>
<span class="lineno"> 2440 </span><span class="spaces">        </span><span class="nottickedoff">gcdS x y | x &lt;= 0 &amp;&amp; y &lt;= 0 = - gcd x y</span>
<span class="lineno"> 2441 </span><span class="spaces">                 </span><span class="nottickedoff">| otherwise        =   gcd x y</span></span>
<span class="lineno"> 2442 </span>
<span class="lineno"> 2443 </span>-- | Convert an LLVM pointer expression to a variable + optional offset, if this
<span class="lineno"> 2444 </span>-- is possible
<span class="lineno"> 2445 </span>asLLVMOffset :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (LLVMPointerType w) -&gt;
<span class="lineno"> 2446 </span>                Maybe (ExprVar (LLVMPointerType w), PermExpr (BVType w))
<span class="lineno"> 2447 </span><span class="decl"><span class="nottickedoff">asLLVMOffset (PExpr_Var x) = Just (x, bvInt 0)</span>
<span class="lineno"> 2448 </span><span class="spaces"></span><span class="nottickedoff">asLLVMOffset (PExpr_LLVMOffset x off) = Just (x, off)</span>
<span class="lineno"> 2449 </span><span class="spaces"></span><span class="nottickedoff">asLLVMOffset _ = Nothing</span></span>
<span class="lineno"> 2450 </span>
<span class="lineno"> 2451 </span>-- | Add a word expression to an LLVM pointer expression
<span class="lineno"> 2452 </span>addLLVMOffset :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 2453 </span>                 PermExpr (LLVMPointerType w) -&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 2454 </span>                 PermExpr (LLVMPointerType w)
<span class="lineno"> 2455 </span><span class="decl"><span class="nottickedoff">addLLVMOffset (PExpr_Var x) off = PExpr_LLVMOffset x off</span>
<span class="lineno"> 2456 </span><span class="spaces"></span><span class="nottickedoff">addLLVMOffset (PExpr_LLVMWord e) off = PExpr_LLVMWord $ bvAdd e off</span>
<span class="lineno"> 2457 </span><span class="spaces"></span><span class="nottickedoff">addLLVMOffset (PExpr_LLVMOffset x e) off =</span>
<span class="lineno"> 2458 </span><span class="spaces">  </span><span class="nottickedoff">PExpr_LLVMOffset x $ bvAdd e off</span></span>
<span class="lineno"> 2459 </span>
<span class="lineno"> 2460 </span>-- | Build a range that contains exactly one index
<span class="lineno"> 2461 </span>bvRangeOfIndex :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (BVType w) -&gt; BVRange w
<span class="lineno"> 2462 </span><span class="decl"><span class="nottickedoff">bvRangeOfIndex e = BVRange e (bvInt 1)</span></span>
<span class="lineno"> 2463 </span>
<span class="lineno"> 2464 </span>-- | Add an offset to a 'BVRange'
<span class="lineno"> 2465 </span>offsetBVRange :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (BVType w) -&gt; BVRange w -&gt;
<span class="lineno"> 2466 </span>                 BVRange w
<span class="lineno"> 2467 </span><span class="decl"><span class="nottickedoff">offsetBVRange off (BVRange off' len) = (BVRange (bvAdd off' off) len)</span></span>
<span class="lineno"> 2468 </span>
<span class="lineno"> 2469 </span>
<span class="lineno"> 2470 </span>----------------------------------------------------------------------
<span class="lineno"> 2471 </span>-- * Permissions
<span class="lineno"> 2472 </span>----------------------------------------------------------------------
<span class="lineno"> 2473 </span>
<span class="lineno"> 2474 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving instance Eq (BVRange w)</span></span></span></span>
<span class="lineno"> 2475 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving instance Eq (BVProp w)</span></span></span></span>
<span class="lineno"> 2476 </span>
<span class="lineno"> 2477 </span>-- | Build an equality permission in a binding
<span class="lineno"> 2478 </span>mbValPerm_Eq :: Mb ctx (PermExpr a) -&gt; Mb ctx (ValuePerm a)
<span class="lineno"> 2479 </span><span class="decl"><span class="nottickedoff">mbValPerm_Eq = mbMapCl $(mkClosed [| ValPerm_Eq |])</span></span>
<span class="lineno"> 2480 </span>
<span class="lineno"> 2481 </span>-- | The conjunction of a list of atomic permissions in a binding
<span class="lineno"> 2482 </span>mbValPerm_Conj :: Mb ctx [AtomicPerm a] -&gt; Mb ctx (ValuePerm a)
<span class="lineno"> 2483 </span><span class="decl"><span class="nottickedoff">mbValPerm_Conj = mbMapCl $(mkClosed [| ValPerm_Conj |])</span></span>
<span class="lineno"> 2484 </span>
<span class="lineno"> 2485 </span>-- | The vacuously true permission is the conjunction of 0 atomic permissions
<span class="lineno"> 2486 </span>pattern ValPerm_True :: ValuePerm a
<span class="lineno"> 2487 </span>pattern ValPerm_True = <span class="nottickedoff">ValPerm_Conj []</span>
<span class="lineno"> 2488 </span>
<span class="lineno"> 2489 </span>-- | The conjunction of exactly 1 atomic permission
<span class="lineno"> 2490 </span>pattern ValPerm_Conj1 :: AtomicPerm a -&gt; ValuePerm a
<span class="lineno"> 2491 </span>pattern ValPerm_Conj1 p = <span class="nottickedoff">ValPerm_Conj [p]</span>
<span class="lineno"> 2492 </span>
<span class="lineno"> 2493 </span>-- | The conjunction of exactly 1 atomic permission in a binding
<span class="lineno"> 2494 </span>mbValPerm_Conj1 :: Mb ctx (AtomicPerm a) -&gt; Mb ctx (ValuePerm a)
<span class="lineno"> 2495 </span><span class="decl"><span class="nottickedoff">mbValPerm_Conj1 = mbMapCl $(mkClosed [| ValPerm_Conj1 |])</span></span>
<span class="lineno"> 2496 </span>
<span class="lineno"> 2497 </span>-- | The conjunction of exactly 1 field permission
<span class="lineno"> 2498 </span>pattern ValPerm_LLVMField :: () =&gt; (a ~ LLVMPointerType w, 1 &lt;= w, KnownNat w,
<span class="lineno"> 2499 </span>                                    1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno"> 2500 </span>                             LLVMFieldPerm w sz -&gt; ValuePerm a
<span class="lineno"> 2501 </span>pattern ValPerm_LLVMField fp &lt;- <span class="nottickedoff">ValPerm_Conj [Perm_LLVMField fp]</span>
<span class="lineno"> 2502 </span>  where
<span class="lineno"> 2503 </span>    ValPerm_LLVMField fp = <span class="nottickedoff">ValPerm_Conj [Perm_LLVMField fp]</span>
<span class="lineno"> 2504 </span>
<span class="lineno"> 2505 </span>{- FIXME: why doesn't this work?
<span class="lineno"> 2506 </span>-- | The conjunction of exactly 1 field permission in a binding
<span class="lineno"> 2507 </span>pattern MbValPerm_LLVMField :: () =&gt; (a ~ LLVMPointerType w, 1 &lt;= w, KnownNat w,
<span class="lineno"> 2508 </span>                                      1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno"> 2509 </span>                               Mb ctx (LLVMFieldPerm w sz) -&gt;
<span class="lineno"> 2510 </span>                               Mb ctx (ValuePerm a)
<span class="lineno"> 2511 </span>pattern MbValPerm_LLVMField mb_fp &lt;- [nuP| ValPerm_LLVMField mb_fp |]
<span class="lineno"> 2512 </span>  where
<span class="lineno"> 2513 </span>    MbValPerm_LLVMField mb_fp =
<span class="lineno"> 2514 </span>      mbMapCl $(mkClosed [| ValPerm_LLVMField |]) mb_fp
<span class="lineno"> 2515 </span>-}
<span class="lineno"> 2516 </span>
<span class="lineno"> 2517 </span>-- | Build a 'ValPerm_LLVMField' in a binding
<span class="lineno"> 2518 </span>mbValPerm_LLVMField :: (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno"> 2519 </span>                       Mb ctx (LLVMFieldPerm w sz) -&gt;
<span class="lineno"> 2520 </span>                       Mb ctx (ValuePerm (LLVMPointerType w))
<span class="lineno"> 2521 </span><span class="decl"><span class="nottickedoff">mbValPerm_LLVMField = mbMapCl $(mkClosed [| ValPerm_LLVMField |])</span></span>
<span class="lineno"> 2522 </span>
<span class="lineno"> 2523 </span>-- | The conjunction of exactly 1 array permission
<span class="lineno"> 2524 </span>pattern ValPerm_LLVMArray :: () =&gt; (a ~ LLVMPointerType w, 1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 2525 </span>                             LLVMArrayPerm w -&gt; ValuePerm a
<span class="lineno"> 2526 </span>pattern ValPerm_LLVMArray ap &lt;- <span class="nottickedoff">ValPerm_Conj [Perm_LLVMArray ap]</span>
<span class="lineno"> 2527 </span>  where
<span class="lineno"> 2528 </span>    ValPerm_LLVMArray ap = <span class="nottickedoff">ValPerm_Conj [Perm_LLVMArray ap]</span>
<span class="lineno"> 2529 </span>
<span class="lineno"> 2530 </span>{- FIXME: why doesn't this work?
<span class="lineno"> 2531 </span>-- | The conjunction of exactly 1 array permission
<span class="lineno"> 2532 </span>pattern MbValPerm_LLVMArray :: () =&gt; (a ~ LLVMPointerType w, 1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 2533 </span>                               Mb ctx (LLVMArrayPerm w) -&gt; Mb ctx (ValuePerm a)
<span class="lineno"> 2534 </span>pattern MbValPerm_LLVMArray mb_ap &lt;- [nuP| ValPerm_LLVMArray mb_ap |]
<span class="lineno"> 2535 </span>  where
<span class="lineno"> 2536 </span>    MbValPerm_LLVMArray mb_ap =
<span class="lineno"> 2537 </span>      mbMapCl $(mkClosed [| ValPerm_LLVMArray |]) mb_ap
<span class="lineno"> 2538 </span>-}
<span class="lineno"> 2539 </span>
<span class="lineno"> 2540 </span>-- | Build a 'ValPerm_LLVMArray' in a binding
<span class="lineno"> 2541 </span>mbValPerm_LLVMArray :: (1 &lt;= w, KnownNat w) =&gt; Mb ctx (LLVMArrayPerm w) -&gt;
<span class="lineno"> 2542 </span>                       Mb ctx (ValuePerm (LLVMPointerType w))
<span class="lineno"> 2543 </span><span class="decl"><span class="nottickedoff">mbValPerm_LLVMArray = mbMapCl $(mkClosed [| ValPerm_LLVMArray |])</span></span>
<span class="lineno"> 2544 </span>
<span class="lineno"> 2545 </span>-- | The conjunction of exactly 1 block permission
<span class="lineno"> 2546 </span>pattern ValPerm_LLVMBlock :: () =&gt; (a ~ LLVMPointerType w, 1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 2547 </span>                             LLVMBlockPerm w -&gt; ValuePerm a
<span class="lineno"> 2548 </span>pattern ValPerm_LLVMBlock bp &lt;- <span class="nottickedoff">ValPerm_Conj [Perm_LLVMBlock bp]</span>
<span class="lineno"> 2549 </span>  where
<span class="lineno"> 2550 </span>    ValPerm_LLVMBlock bp = <span class="nottickedoff">ValPerm_Conj [Perm_LLVMBlock bp]</span>
<span class="lineno"> 2551 </span>
<span class="lineno"> 2552 </span>-- | Build a 'ValPerm_LLVMBlock' in a binding
<span class="lineno"> 2553 </span>mbValPerm_LLVMBlock :: (1 &lt;= w, KnownNat w) =&gt; Mb ctx (LLVMBlockPerm w) -&gt;
<span class="lineno"> 2554 </span>                       Mb ctx (ValuePerm (LLVMPointerType w))
<span class="lineno"> 2555 </span><span class="decl"><span class="nottickedoff">mbValPerm_LLVMBlock = mbMapCl $(mkClosed [| ValPerm_LLVMBlock |])</span></span>
<span class="lineno"> 2556 </span>
<span class="lineno"> 2557 </span>-- | The conjunction of exactly 1 block shape permission
<span class="lineno"> 2558 </span>pattern ValPerm_LLVMBlockShape :: () =&gt; (a ~ LLVMBlockType w, b ~ LLVMShapeType w,
<span class="lineno"> 2559 </span>                                         1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 2560 </span>                                  PermExpr b -&gt; ValuePerm a
<span class="lineno"> 2561 </span>pattern ValPerm_LLVMBlockShape sh &lt;- <span class="nottickedoff">ValPerm_Conj [Perm_LLVMBlockShape sh]</span>
<span class="lineno"> 2562 </span>  where
<span class="lineno"> 2563 </span>    ValPerm_LLVMBlockShape sh = <span class="nottickedoff">ValPerm_Conj [Perm_LLVMBlockShape sh]</span>
<span class="lineno"> 2564 </span>
<span class="lineno"> 2565 </span>-- | The conjunction of exactly 1 @llvmfunptr@ permission
<span class="lineno"> 2566 </span>pattern ValPerm_LLVMFunPtr :: () =&gt;
<span class="lineno"> 2567 </span>                              (a ~ LLVMPointerType w, 1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 2568 </span>                              TypeRepr (FunctionHandleType cargs ret) -&gt;
<span class="lineno"> 2569 </span>                              ValuePerm (FunctionHandleType cargs ret) -&gt;
<span class="lineno"> 2570 </span>                              ValuePerm a
<span class="lineno"> 2571 </span>pattern ValPerm_LLVMFunPtr tp p &lt;- <span class="nottickedoff">ValPerm_Conj [Perm_LLVMFunPtr tp p]</span>
<span class="lineno"> 2572 </span>  where
<span class="lineno"> 2573 </span>    ValPerm_LLVMFunPtr tp p = <span class="nottickedoff">ValPerm_Conj [Perm_LLVMFunPtr tp p]</span>
<span class="lineno"> 2574 </span>
<span class="lineno"> 2575 </span>-- | A single @lowned@ permission
<span class="lineno"> 2576 </span>pattern ValPerm_LOwned :: () =&gt; (a ~ LifetimeType) =&gt; [PermExpr LifetimeType] -&gt;
<span class="lineno"> 2577 </span>                          CruCtx ps_in -&gt; CruCtx ps_out -&gt;
<span class="lineno"> 2578 </span>                          ExprPerms ps_in -&gt; ExprPerms ps_out -&gt; ValuePerm a
<span class="lineno"> 2579 </span>pattern ValPerm_LOwned ls tps_in tps_out ps_in ps_out &lt;-
<span class="lineno"> 2580 </span>  <span class="nottickedoff">ValPerm_Conj [Perm_LOwned ls tps_in tps_out ps_in ps_out]</span>
<span class="lineno"> 2581 </span>  where
<span class="lineno"> 2582 </span>    ValPerm_LOwned ls tps_in tps_out ps_in ps_out =
<span class="lineno"> 2583 </span>      <span class="nottickedoff">ValPerm_Conj [Perm_LOwned ls tps_in tps_out ps_in ps_out]</span>
<span class="lineno"> 2584 </span>
<span class="lineno"> 2585 </span>-- | A single simple @lowned@ permission
<span class="lineno"> 2586 </span>pattern ValPerm_LOwnedSimple :: () =&gt; (a ~ LifetimeType) =&gt;
<span class="lineno"> 2587 </span>                                CruCtx ps -&gt; ExprPerms ps -&gt; ValuePerm a
<span class="lineno"> 2588 </span>pattern ValPerm_LOwnedSimple tps ps &lt;- <span class="nottickedoff">ValPerm_Conj [Perm_LOwnedSimple tps ps]</span>
<span class="lineno"> 2589 </span>  where
<span class="lineno"> 2590 </span>    ValPerm_LOwnedSimple tps ps = <span class="nottickedoff">ValPerm_Conj [Perm_LOwnedSimple tps ps]</span>
<span class="lineno"> 2591 </span>
<span class="lineno"> 2592 </span>-- | A single @lcurrent@ permission
<span class="lineno"> 2593 </span>pattern ValPerm_LCurrent :: () =&gt; (a ~ LifetimeType) =&gt;
<span class="lineno"> 2594 </span>                            PermExpr LifetimeType -&gt; ValuePerm a
<span class="lineno"> 2595 </span>pattern ValPerm_LCurrent l &lt;- <span class="nottickedoff">ValPerm_Conj [Perm_LCurrent l]</span>
<span class="lineno"> 2596 </span>  where
<span class="lineno"> 2597 </span>    ValPerm_LCurrent l = <span class="nottickedoff">ValPerm_Conj [Perm_LCurrent l]</span>
<span class="lineno"> 2598 </span>
<span class="lineno"> 2599 </span>-- | A single @lfinished@ permission
<span class="lineno"> 2600 </span>pattern ValPerm_LFinished :: () =&gt; (a ~ LifetimeType) =&gt; ValuePerm a
<span class="lineno"> 2601 </span>pattern ValPerm_LFinished &lt;- <span class="nottickedoff">ValPerm_Conj [Perm_LFinished]</span>
<span class="lineno"> 2602 </span>  where
<span class="lineno"> 2603 </span>    ValPerm_LFinished = <span class="nottickedoff">ValPerm_Conj [Perm_LFinished]</span>
<span class="lineno"> 2604 </span>
<span class="lineno"> 2605 </span>-- | A single @struct@ permission
<span class="lineno"> 2606 </span>pattern ValPerm_Struct :: () =&gt; (a ~ StructType ctx) =&gt;
<span class="lineno"> 2607 </span>                          RAssign ValuePerm (CtxToRList ctx) -&gt;
<span class="lineno"> 2608 </span>                          ValuePerm a
<span class="lineno"> 2609 </span>pattern ValPerm_Struct ps &lt;- <span class="nottickedoff">ValPerm_Conj [Perm_Struct ps]</span>
<span class="lineno"> 2610 </span>  where
<span class="lineno"> 2611 </span>    ValPerm_Struct ps = <span class="nottickedoff">ValPerm_Conj [Perm_Struct ps]</span>
<span class="lineno"> 2612 </span>
<span class="lineno"> 2613 </span>-- | A single @any@ permission
<span class="lineno"> 2614 </span>pattern ValPerm_Any :: ValuePerm a
<span class="lineno"> 2615 </span>pattern ValPerm_Any = <span class="nottickedoff">ValPerm_Conj [Perm_Any]</span>
<span class="lineno"> 2616 </span>
<span class="lineno"> 2617 </span>-- | A single function permission
<span class="lineno"> 2618 </span>pattern ValPerm_Fun :: () =&gt; (a ~ FunctionHandleType cargs ret) =&gt;
<span class="lineno"> 2619 </span>                       FunPerm ghosts (CtxToRList cargs) gouts ret -&gt;
<span class="lineno"> 2620 </span>                       ValuePerm a
<span class="lineno"> 2621 </span>pattern ValPerm_Fun fun_perm &lt;- <span class="nottickedoff">ValPerm_Conj [Perm_Fun fun_perm]</span>
<span class="lineno"> 2622 </span>  where
<span class="lineno"> 2623 </span>    ValPerm_Fun fun_perm = <span class="nottickedoff">ValPerm_Conj [Perm_Fun fun_perm]</span>
<span class="lineno"> 2624 </span>
<span class="lineno"> 2625 </span>pattern ValPerms_Nil :: () =&gt; (tps ~ RNil) =&gt; ValuePerms tps
<span class="lineno"> 2626 </span>pattern ValPerms_Nil = <span class="nottickedoff">MNil</span>
<span class="lineno"> 2627 </span>
<span class="lineno"> 2628 </span>pattern ValPerms_Cons :: () =&gt; (tps ~ (tps' :&gt; a)) =&gt;
<span class="lineno"> 2629 </span>                         ValuePerms tps' -&gt; ValuePerm a -&gt; ValuePerms tps
<span class="lineno"> 2630 </span>pattern ValPerms_Cons ps p = <span class="nottickedoff">ps :&gt;: p</span>
<span class="lineno"> 2631 </span>
<span class="lineno"> 2632 </span>{-# COMPLETE ValPerms_Nil, ValPerms_Cons #-}
<span class="lineno"> 2633 </span>
<span class="lineno"> 2634 </span>
<span class="lineno"> 2635 </span>-- | Fold a function over a 'ValuePerms' list, where
<span class="lineno"> 2636 </span>--
<span class="lineno"> 2637 </span>-- &gt; foldValuePerms f b ('ValuePermsCons'
<span class="lineno"> 2638 </span>-- &gt;                     ('ValuePermsCons' (... 'ValuePermsNil' ...) p2) p1) =
<span class="lineno"> 2639 </span>-- &gt; f (f (... b ...) p2) p1
<span class="lineno"> 2640 </span>--
<span class="lineno"> 2641 </span>-- FIXME: implement more functions on ValuePerms in terms of this
<span class="lineno"> 2642 </span>foldValuePerms :: (forall a. b -&gt; ValuePerm a -&gt; b) -&gt; b -&gt; ValuePerms as -&gt; b
<span class="lineno"> 2643 </span><span class="decl"><span class="nottickedoff">foldValuePerms _ b ValPerms_Nil = b</span>
<span class="lineno"> 2644 </span><span class="spaces"></span><span class="nottickedoff">foldValuePerms f b (ValPerms_Cons ps p) = f (foldValuePerms f b ps) p</span></span>
<span class="lineno"> 2645 </span>
<span class="lineno"> 2646 </span>-- | Build a one-element 'ValuePerms' list from a single permission
<span class="lineno"> 2647 </span>singletonValuePerms :: ValuePerm a -&gt; ValuePerms (RNil :&gt; a)
<span class="lineno"> 2648 </span><span class="decl"><span class="nottickedoff">singletonValuePerms = ValPerms_Cons ValPerms_Nil</span></span>
<span class="lineno"> 2649 </span>
<span class="lineno"> 2650 </span>-- | Build a 'ValuePerms' from an 'RAssign' of permissions
<span class="lineno"> 2651 </span>assignToPerms :: RAssign ValuePerm ps -&gt; ValuePerms ps
<span class="lineno"> 2652 </span><span class="decl"><span class="nottickedoff">assignToPerms MNil = ValPerms_Nil</span>
<span class="lineno"> 2653 </span><span class="spaces"></span><span class="nottickedoff">assignToPerms (ps :&gt;: p) = ValPerms_Cons (assignToPerms ps) p</span></span>
<span class="lineno"> 2654 </span>
<span class="lineno"> 2655 </span>-- | An LLVM pointer permission is an 'AtomicPerm' of type 'LLVMPointerType'
<span class="lineno"> 2656 </span>type LLVMPtrPerm w = AtomicPerm (LLVMPointerType w)
<span class="lineno"> 2657 </span>
<span class="lineno"> 2658 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving instance Eq (LLVMFieldPerm w sz)</span></span></span></span>
<span class="lineno"> 2659 </span>
<span class="lineno"> 2660 </span>-- | Helper to get a 'NatRepr' for the size of an 'LLVMFieldPerm'
<span class="lineno"> 2661 </span>llvmFieldSize :: KnownNat sz =&gt; LLVMFieldPerm w sz -&gt; NatRepr sz
<span class="lineno"> 2662 </span><span class="decl"><span class="nottickedoff">llvmFieldSize _ = knownNat</span></span>
<span class="lineno"> 2663 </span>
<span class="lineno"> 2664 </span>-- | Get the size of an 'LLVMFieldPerm' in bytes
<span class="lineno"> 2665 </span>llvmFieldSizeBytes :: KnownNat sz =&gt; LLVMFieldPerm w sz -&gt; Integer
<span class="lineno"> 2666 </span><span class="decl"><span class="nottickedoff">llvmFieldSizeBytes fp = intValue (llvmFieldSize fp) `ceil_div` 8</span></span>
<span class="lineno"> 2667 </span>
<span class="lineno"> 2668 </span>-- | Get the size of an 'LLVMFieldPerm' as an expression
<span class="lineno"> 2669 </span>llvmFieldLen :: (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno"> 2670 </span>                LLVMFieldPerm w sz -&gt; PermExpr (BVType w)
<span class="lineno"> 2671 </span><span class="decl"><span class="nottickedoff">llvmFieldLen fp = exprLLVMTypeBytesExpr $ llvmFieldContents fp</span></span>
<span class="lineno"> 2672 </span>
<span class="lineno"> 2673 </span>-- | Get the ending offset of an 'LLVMFieldPerm'
<span class="lineno"> 2674 </span>llvmFieldEndOffset :: (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno"> 2675 </span>                      LLVMFieldPerm w sz -&gt; PermExpr (BVType w)
<span class="lineno"> 2676 </span><span class="decl"><span class="nottickedoff">llvmFieldEndOffset fp = bvAdd (llvmFieldOffset fp) (llvmFieldLen fp)</span></span>
<span class="lineno"> 2677 </span>
<span class="lineno"> 2678 </span>-- | Helper to get a 'NatRepr' for the size of an 'LLVMFieldPerm' in a binding
<span class="lineno"> 2679 </span>mbLLVMFieldSize :: KnownNat sz =&gt; Mb ctx (LLVMFieldPerm w sz) -&gt; NatRepr sz
<span class="lineno"> 2680 </span><span class="decl"><span class="nottickedoff">mbLLVMFieldSize _ = knownNat</span></span>
<span class="lineno"> 2681 </span>
<span class="lineno"> 2682 </span>-- | Get the rw-modality-in-binding of a field permission in binding
<span class="lineno"> 2683 </span>mbLLVMFieldRW :: Mb ctx (LLVMFieldPerm w sz) -&gt; Mb ctx (PermExpr RWModalityType)
<span class="lineno"> 2684 </span><span class="decl"><span class="nottickedoff">mbLLVMFieldRW = mbMapCl $(mkClosed [| llvmFieldRW |])</span></span>
<span class="lineno"> 2685 </span>
<span class="lineno"> 2686 </span>-- | Get the lifetime-in-binding of a field permission in binding
<span class="lineno"> 2687 </span>mbLLVMFieldLifetime :: Mb ctx (LLVMFieldPerm w sz) -&gt;
<span class="lineno"> 2688 </span>                       Mb ctx (PermExpr LifetimeType)
<span class="lineno"> 2689 </span><span class="decl"><span class="nottickedoff">mbLLVMFieldLifetime = mbMapCl $(mkClosed [| llvmFieldLifetime |])</span></span>
<span class="lineno"> 2690 </span>
<span class="lineno"> 2691 </span>-- | Get the offset-in-binding of a field permission in binding
<span class="lineno"> 2692 </span>mbLLVMFieldOffset :: Mb ctx (LLVMFieldPerm w sz) -&gt; Mb ctx (PermExpr (BVType w))
<span class="lineno"> 2693 </span><span class="decl"><span class="nottickedoff">mbLLVMFieldOffset = mbMapCl $(mkClosed [| llvmFieldOffset |])</span></span>
<span class="lineno"> 2694 </span>
<span class="lineno"> 2695 </span>-- | Get the contents-in-binding of a field permission in binding
<span class="lineno"> 2696 </span>mbLLVMFieldContents :: Mb ctx (LLVMFieldPerm w sz) -&gt;
<span class="lineno"> 2697 </span>                       Mb ctx (ValuePerm (LLVMPointerType sz))
<span class="lineno"> 2698 </span><span class="decl"><span class="nottickedoff">mbLLVMFieldContents = mbMapCl $(mkClosed [| llvmFieldContents |])</span></span>
<span class="lineno"> 2699 </span>
<span class="lineno"> 2700 </span>-- | Get the range of bytes contained in a field permisison
<span class="lineno"> 2701 </span>llvmFieldRange :: (1 &lt;= w, KnownNat w, KnownNat sz) =&gt; LLVMFieldPerm w sz -&gt;
<span class="lineno"> 2702 </span>                  BVRange w
<span class="lineno"> 2703 </span><span class="decl"><span class="nottickedoff">llvmFieldRange fp =</span>
<span class="lineno"> 2704 </span><span class="spaces">  </span><span class="nottickedoff">BVRange (llvmFieldOffset fp) (bvInt $ llvmFieldSizeBytes fp)</span></span>
<span class="lineno"> 2705 </span>
<span class="lineno"> 2706 </span>
<span class="lineno"> 2707 </span>-- NOTE: we need a custom instance of Eq so we can use bvEq on the cell
<span class="lineno"> 2708 </span>instance <span class="decl"><span class="nottickedoff">Eq (LLVMArrayIndex w)</span></span> where
<span class="lineno"> 2709 </span>  <span class="decl"><span class="nottickedoff">LLVMArrayIndex e1 i1 == LLVMArrayIndex e2 i2 =</span>
<span class="lineno"> 2710 </span><span class="spaces">    </span><span class="nottickedoff">bvEq e1 e2 &amp;&amp; i1 == i2</span></span>
<span class="lineno"> 2711 </span>
<span class="lineno"> 2712 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving instance Eq (LLVMArrayPerm w)</span></span></span></span>
<span class="lineno"> 2713 </span>
<span class="lineno"> 2714 </span>-- | Get the stride of an array in bits
<span class="lineno"> 2715 </span>llvmArrayStrideBits :: LLVMArrayPerm w -&gt; Integer
<span class="lineno"> 2716 </span><span class="decl"><span class="nottickedoff">llvmArrayStrideBits = toInteger . bytesToBits . llvmArrayStride</span></span>
<span class="lineno"> 2717 </span>
<span class="lineno"> 2718 </span>-- | Get the rw-modality-in-binding of an array permission in binding
<span class="lineno"> 2719 </span>mbLLVMArrayRW :: Mb ctx (LLVMArrayPerm w) -&gt; Mb ctx (PermExpr RWModalityType)
<span class="lineno"> 2720 </span><span class="decl"><span class="nottickedoff">mbLLVMArrayRW = mbMapCl $(mkClosed [| llvmArrayRW |])</span></span>
<span class="lineno"> 2721 </span>
<span class="lineno"> 2722 </span>-- | Get the lifetime-in-binding of an array permission in binding
<span class="lineno"> 2723 </span>mbLLVMArrayLifetime :: Mb ctx (LLVMArrayPerm w) -&gt;
<span class="lineno"> 2724 </span>                       Mb ctx (PermExpr LifetimeType)
<span class="lineno"> 2725 </span><span class="decl"><span class="nottickedoff">mbLLVMArrayLifetime = mbMapCl $(mkClosed [| llvmArrayLifetime |])</span></span>
<span class="lineno"> 2726 </span>
<span class="lineno"> 2727 </span>-- | Get the offset-in-binding of an array permission in binding
<span class="lineno"> 2728 </span>mbLLVMArrayOffset :: Mb ctx (LLVMArrayPerm w) -&gt; Mb ctx (PermExpr (BVType w))
<span class="lineno"> 2729 </span><span class="decl"><span class="nottickedoff">mbLLVMArrayOffset = mbMapCl $(mkClosed [| llvmArrayOffset |])</span></span>
<span class="lineno"> 2730 </span>
<span class="lineno"> 2731 </span>-- | Get the offset-in-binding of an array permission in binding
<span class="lineno"> 2732 </span>mbLLVMArrayOffsetBytes :: Mb ctx (LLVMArrayPerm w) -&gt; Mb ctx (PermExpr (BVType w))
<span class="lineno"> 2733 </span><span class="decl"><span class="nottickedoff">mbLLVMArrayOffsetBytes = mbMapCl $(mkClosed [| llvmArrayOffset |])</span></span>
<span class="lineno"> 2734 </span>
<span class="lineno"> 2735 </span>-- | Get the length-in-binding of an array permission in binding
<span class="lineno"> 2736 </span>mbLLVMArrayLen :: Mb ctx (LLVMArrayPerm w) -&gt; Mb ctx (PermExpr (BVType w))
<span class="lineno"> 2737 </span><span class="decl"><span class="nottickedoff">mbLLVMArrayLen = mbMapCl $(mkClosed [| llvmArrayLen |])</span></span>
<span class="lineno"> 2738 </span>
<span class="lineno"> 2739 </span>-- | Get the length-in-binding of an array permission in binding
<span class="lineno"> 2740 </span>mbLLVMArrayLenBytes :: (1 &lt;= w, KnownNat w) =&gt; Mb ctx (LLVMArrayPerm w) -&gt;
<span class="lineno"> 2741 </span>                       Mb ctx (PermExpr (BVType w))
<span class="lineno"> 2742 </span><span class="decl"><span class="nottickedoff">mbLLVMArrayLenBytes = mbMapCl $(mkClosed [| llvmArrayLengthBytes |])</span></span>
<span class="lineno"> 2743 </span>
<span class="lineno"> 2744 </span>-- | Get the range of offsets of an array permission in binding
<span class="lineno"> 2745 </span>mbLLVMArrayRange :: (1 &lt;= w, KnownNat w) =&gt; Mb ctx (LLVMArrayPerm w) -&gt;
<span class="lineno"> 2746 </span>                    Mb ctx (BVRange w)
<span class="lineno"> 2747 </span><span class="decl"><span class="nottickedoff">mbLLVMArrayRange = mbMapCl $(mkClosed [| llvmArrayRange |])</span></span>
<span class="lineno"> 2748 </span>
<span class="lineno"> 2749 </span>-- | Get the stride of an array permission in binding
<span class="lineno"> 2750 </span>mbLLVMArrayStride :: Mb ctx (LLVMArrayPerm w) -&gt; Bytes
<span class="lineno"> 2751 </span><span class="decl"><span class="nottickedoff">mbLLVMArrayStride = mbLift . mbMapCl $(mkClosed [| llvmArrayStride |])</span></span>
<span class="lineno"> 2752 </span>
<span class="lineno"> 2753 </span>-- | Get the cell-shape-in-binding of an array permission in binding
<span class="lineno"> 2754 </span>mbLLVMArrayCellShape :: Mb ctx (LLVMArrayPerm w) -&gt;
<span class="lineno"> 2755 </span>                        Mb ctx (PermExpr (LLVMShapeType w))
<span class="lineno"> 2756 </span><span class="decl"><span class="nottickedoff">mbLLVMArrayCellShape = mbMapCl $(mkClosed [| llvmArrayCellShape |])</span></span>
<span class="lineno"> 2757 </span>
<span class="lineno"> 2758 </span>-- | Get the borrows in a binding for an array permission in binding
<span class="lineno"> 2759 </span>mbLLVMArrayBorrows :: Mb ctx (LLVMArrayPerm w) -&gt; Mb ctx [LLVMArrayBorrow w]
<span class="lineno"> 2760 </span><span class="decl"><span class="nottickedoff">mbLLVMArrayBorrows = mbMapCl $(mkClosed [| llvmArrayBorrows |])</span></span>
<span class="lineno"> 2761 </span>
<span class="lineno"> 2762 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving instance Eq (LLVMArrayBorrow w)</span></span></span></span>
<span class="lineno"> 2763 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving instance Eq (LLVMBlockPerm w)</span></span></span></span>
<span class="lineno"> 2764 </span>
<span class="lineno"> 2765 </span>-- | Get the rw-modality-in-binding of a block permission in binding
<span class="lineno"> 2766 </span>mbLLVMBlockRW :: Mb ctx (LLVMBlockPerm w) -&gt; Mb ctx (PermExpr RWModalityType)
<span class="lineno"> 2767 </span><span class="decl"><span class="nottickedoff">mbLLVMBlockRW = mbMapCl $(mkClosed [| llvmBlockRW |])</span></span>
<span class="lineno"> 2768 </span>
<span class="lineno"> 2769 </span>-- | Get the lifetime-in-binding of a block permission in binding
<span class="lineno"> 2770 </span>mbLLVMBlockLifetime :: Mb ctx (LLVMBlockPerm w) -&gt;
<span class="lineno"> 2771 </span>                       Mb ctx (PermExpr LifetimeType)
<span class="lineno"> 2772 </span><span class="decl"><span class="nottickedoff">mbLLVMBlockLifetime = mbMapCl $(mkClosed [| llvmBlockLifetime |])</span></span>
<span class="lineno"> 2773 </span>
<span class="lineno"> 2774 </span>-- | Get the offset-in-binding of a block permission in binding
<span class="lineno"> 2775 </span>mbLLVMBlockOffset :: Mb ctx (LLVMBlockPerm w) -&gt; Mb ctx (PermExpr (BVType w))
<span class="lineno"> 2776 </span><span class="decl"><span class="nottickedoff">mbLLVMBlockOffset = mbMapCl $(mkClosed [| llvmBlockOffset |])</span></span>
<span class="lineno"> 2777 </span>
<span class="lineno"> 2778 </span>-- | Get the length-in-binding of a block permission in binding
<span class="lineno"> 2779 </span>mbLLVMBlockLen :: Mb ctx (LLVMBlockPerm w) -&gt; Mb ctx (PermExpr (BVType w))
<span class="lineno"> 2780 </span><span class="decl"><span class="nottickedoff">mbLLVMBlockLen = mbMapCl $(mkClosed [| llvmBlockLen |])</span></span>
<span class="lineno"> 2781 </span>
<span class="lineno"> 2782 </span>-- | Get the shape-in-binding of a block permission in binding
<span class="lineno"> 2783 </span>mbLLVMBlockShape :: Mb ctx (LLVMBlockPerm w) -&gt;
<span class="lineno"> 2784 </span>                    Mb ctx (PermExpr (LLVMShapeType w))
<span class="lineno"> 2785 </span><span class="decl"><span class="nottickedoff">mbLLVMBlockShape = mbMapCl $(mkClosed [| llvmBlockShape |])</span></span>
<span class="lineno"> 2786 </span>
<span class="lineno"> 2787 </span>-- | Get the range of offsets represented by an 'LLVMBlockPerm'
<span class="lineno"> 2788 </span>llvmBlockRange :: LLVMBlockPerm w -&gt; BVRange w
<span class="lineno"> 2789 </span><span class="decl"><span class="nottickedoff">llvmBlockRange bp = BVRange (llvmBlockOffset bp) (llvmBlockLen bp)</span></span>
<span class="lineno"> 2790 </span>
<span class="lineno"> 2791 </span>-- | Get the range-in-binding of a block permission in binding
<span class="lineno"> 2792 </span>mbLLVMBlockRange :: Mb ctx (LLVMBlockPerm w) -&gt; Mb ctx (BVRange w)
<span class="lineno"> 2793 </span><span class="decl"><span class="nottickedoff">mbLLVMBlockRange = mbMapCl $(mkClosed [| llvmBlockRange |])</span></span>
<span class="lineno"> 2794 </span>
<span class="lineno"> 2795 </span>instance <span class="decl"><span class="nottickedoff">Eq (LLVMFieldShape w)</span></span> where
<span class="lineno"> 2796 </span>  <span class="decl"><span class="nottickedoff">(LLVMFieldShape p1) == (LLVMFieldShape p2)</span>
<span class="lineno"> 2797 </span><span class="spaces">    </span><span class="nottickedoff">| Just Refl &lt;- testEquality (exprType p1) (exprType p2) = p1 == p2</span>
<span class="lineno"> 2798 </span><span class="spaces">  </span><span class="nottickedoff">_ == _ = False</span></span>
<span class="lineno"> 2799 </span>
<span class="lineno"> 2800 </span>
<span class="lineno"> 2801 </span>-- | Convert an 'ExprAndPerm' to a variable plus permission, if possible
<span class="lineno"> 2802 </span>exprPermVarAndPerm :: ExprAndPerm a -&gt; Maybe (VarAndPerm a)
<span class="lineno"> 2803 </span><span class="decl"><span class="nottickedoff">exprPermVarAndPerm (ExprAndPerm e p)</span>
<span class="lineno"> 2804 </span><span class="spaces">  </span><span class="nottickedoff">| Just (x, off) &lt;- asVarOffset e =</span>
<span class="lineno"> 2805 </span><span class="spaces">    </span><span class="nottickedoff">Just $ VarAndPerm x (offsetPerm off p)</span>
<span class="lineno"> 2806 </span><span class="spaces"></span><span class="nottickedoff">exprPermVarAndPerm _ = Nothing</span></span>
<span class="lineno"> 2807 </span>
<span class="lineno"> 2808 </span>-- | Convert an 'ExprPerms' to a 'DistPerms', if possible
<span class="lineno"> 2809 </span>exprPermsToDistPerms :: ExprPerms ctx -&gt; Maybe (DistPerms ctx)
<span class="lineno"> 2810 </span><span class="decl"><span class="nottickedoff">exprPermsToDistPerms = traverseRAssign exprPermVarAndPerm</span></span>
<span class="lineno"> 2811 </span>
<span class="lineno"> 2812 </span>-- | Convert an 'ExprPerms' in bindings to a 'DistPerms' in bindings
<span class="lineno"> 2813 </span>mbExprPermsToDistPerms :: Mb ctx (ExprPerms ps) -&gt;
<span class="lineno"> 2814 </span>                          Maybe (Mb ctx (DistPerms ps))
<span class="lineno"> 2815 </span><span class="decl"><span class="nottickedoff">mbExprPermsToDistPerms =</span>
<span class="lineno"> 2816 </span><span class="spaces">  </span><span class="nottickedoff">mbMaybe . mbMapCl $(mkClosed [| exprPermsToDistPerms |])</span></span>
<span class="lineno"> 2817 </span>
<span class="lineno"> 2818 </span>-- | Find all permissions in an 'ExprPerms' list for a variable
<span class="lineno"> 2819 </span>exprPermsForVar :: ExprVar a -&gt; ExprPerms ps -&gt; [ValuePerm a]
<span class="lineno"> 2820 </span><span class="decl"><span class="nottickedoff">exprPermsForVar _ MNil = []</span>
<span class="lineno"> 2821 </span><span class="spaces"></span><span class="nottickedoff">exprPermsForVar x (ps :&gt;: e_and_p)</span>
<span class="lineno"> 2822 </span><span class="spaces">  </span><span class="nottickedoff">| Just (VarAndPerm y p) &lt;- exprPermVarAndPerm e_and_p</span>
<span class="lineno"> 2823 </span><span class="spaces">  </span><span class="nottickedoff">, Just Refl &lt;- testEquality x y</span>
<span class="lineno"> 2824 </span><span class="spaces">  </span><span class="nottickedoff">= p : exprPermsForVar x ps</span>
<span class="lineno"> 2825 </span><span class="spaces"></span><span class="nottickedoff">exprPermsForVar x (ps :&gt;: _) = exprPermsForVar x ps</span></span>
<span class="lineno"> 2826 </span>
<span class="lineno"> 2827 </span>-- | Get the permissions resulting from converting an 'ExprPerms' to a
<span class="lineno"> 2828 </span>-- 'DistPerms', if possible. Note taht this can be different from just getting
<span class="lineno"> 2829 </span>-- the permissions in the 'ExprPerms', because they may be offset by offsets on
<span class="lineno"> 2830 </span>-- variables in the expressions.
<span class="lineno"> 2831 </span>exprPermsToValuePerms :: ExprPerms ctx -&gt; Maybe (ValuePerms ctx)
<span class="lineno"> 2832 </span><span class="decl"><span class="nottickedoff">exprPermsToValuePerms = fmap distPermsToValuePerms . exprPermsToDistPerms</span></span>
<span class="lineno"> 2833 </span>
<span class="lineno"> 2834 </span>-- | Get the permisisons in an 'ExprPerms' in bindings
<span class="lineno"> 2835 </span>mbExprPermsToValuePerms :: Mb ctx (ExprPerms ps) -&gt;
<span class="lineno"> 2836 </span>                           Maybe (Mb ctx (ValuePerms ps))
<span class="lineno"> 2837 </span><span class="decl"><span class="nottickedoff">mbExprPermsToValuePerms =</span>
<span class="lineno"> 2838 </span><span class="spaces">  </span><span class="nottickedoff">mbMaybe . mbMapCl $(mkClosed [| exprPermsToValuePerms |])</span></span>
<span class="lineno"> 2839 </span>
<span class="lineno"> 2840 </span>-- | Convert an expression plus permission to an 'ExprAndPerm'
<span class="lineno"> 2841 </span>varAndPermExprPerm :: VarAndPerm a -&gt; ExprAndPerm a
<span class="lineno"> 2842 </span><span class="decl"><span class="nottickedoff">varAndPermExprPerm (VarAndPerm x p) = ExprAndPerm (PExpr_Var x) p</span></span>
<span class="lineno"> 2843 </span>
<span class="lineno"> 2844 </span>-- | Convert a 'DistPerms' to an 'ExprPerms'
<span class="lineno"> 2845 </span>distPermsToExprPerms :: DistPerms ps -&gt; ExprPerms ps
<span class="lineno"> 2846 </span><span class="decl"><span class="nottickedoff">distPermsToExprPerms = RL.map varAndPermExprPerm</span></span>
<span class="lineno"> 2847 </span>
<span class="lineno"> 2848 </span>-- | Convert a 'DistPerms' in a binding to an 'ExprPerms' in a binding
<span class="lineno"> 2849 </span>mbDistPermsToExprPerms :: Mb ctx (DistPerms ps) -&gt; Mb ctx (ExprPerms ps)
<span class="lineno"> 2850 </span><span class="decl"><span class="nottickedoff">mbDistPermsToExprPerms = mbMapCl $(mkClosed [| distPermsToExprPerms |])</span></span>
<span class="lineno"> 2851 </span>
<span class="lineno"> 2852 </span>-- | Convert the expressions in an 'ExprPerms' to variables, if possible
<span class="lineno"> 2853 </span>exprPermsVars :: ExprPerms ps -&gt; Maybe (RAssign Name ps)
<span class="lineno"> 2854 </span><span class="decl"><span class="nottickedoff">exprPermsVars = fmap distPermsVars . exprPermsToDistPerms</span></span>
<span class="lineno"> 2855 </span>
<span class="lineno"> 2856 </span>-- | Convert the variables in a 'DistPerms' in a binding to variables bound
<span class="lineno"> 2857 </span>-- in that binding, if possible
<span class="lineno"> 2858 </span>mbDistPermsMembers :: Mb ctx (DistPerms ps) -&gt; Maybe (RAssign (Member ctx) ps)
<span class="lineno"> 2859 </span><span class="decl"><span class="nottickedoff">mbDistPermsMembers [nuP| mb_ps' :&gt;: VarAndPerm mb_n _ |]</span>
<span class="lineno"> 2860 </span><span class="spaces">  </span><span class="nottickedoff">| Left memb &lt;- mbNameBoundP mb_n = (:&gt;: memb) &lt;$&gt; mbDistPermsMembers mb_ps'</span>
<span class="lineno"> 2861 </span><span class="spaces"></span><span class="nottickedoff">mbDistPermsMembers [nuP| MNil |] = Just MNil</span>
<span class="lineno"> 2862 </span><span class="spaces"></span><span class="nottickedoff">mbDistPermsMembers _ = Nothing</span></span>
<span class="lineno"> 2863 </span>
<span class="lineno"> 2864 </span>-- | Convert the expressions in an 'ExprPerms' in a binding to variables bound
<span class="lineno"> 2865 </span>-- in that binding, if possible
<span class="lineno"> 2866 </span>mbExprPermsMembers :: Mb ctx (ExprPerms ps) -&gt; Maybe (RAssign (Member ctx) ps)
<span class="lineno"> 2867 </span><span class="decl"><span class="nottickedoff">mbExprPermsMembers = mbExprPermsToDistPerms &gt;=&gt; mbDistPermsMembers</span></span>
<span class="lineno"> 2868 </span>
<span class="lineno"> 2869 </span>-- | Convert the expressions in an 'ExprPerms' to variables, if possible, and
<span class="lineno"> 2870 </span>-- collect them into a list
<span class="lineno"> 2871 </span>exprPermsVarsList :: ExprPerms ps -&gt; [SomeName CrucibleType]
<span class="lineno"> 2872 </span><span class="decl"><span class="nottickedoff">exprPermsVarsList ps =</span>
<span class="lineno"> 2873 </span><span class="spaces">  </span><span class="nottickedoff">case exprPermsVars ps of</span>
<span class="lineno"> 2874 </span><span class="spaces">    </span><span class="nottickedoff">Just ns -&gt; RL.mapToList SomeName ns</span>
<span class="lineno"> 2875 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; []</span></span>
<span class="lineno"> 2876 </span>
<span class="lineno"> 2877 </span>-- | Convert the expressions in an 'ExprPerms'-in-binding to variables, if
<span class="lineno"> 2878 </span>-- possible, and collect them into a list
<span class="lineno"> 2879 </span>mbExprPermsVarsList :: Mb ctx (ExprPerms ps) -&gt; [SomeName CrucibleType]
<span class="lineno"> 2880 </span><span class="decl"><span class="nottickedoff">mbExprPermsVarsList =</span>
<span class="lineno"> 2881 </span><span class="spaces">  </span><span class="nottickedoff">concatMap (\case</span>
<span class="lineno"> 2882 </span><span class="spaces">                </span><span class="nottickedoff">[nuP| SomeName mb_n |]</span>
<span class="lineno"> 2883 </span><span class="spaces">                  </span><span class="nottickedoff">| Right n &lt;- mbNameBoundP mb_n -&gt; [SomeName n]</span>
<span class="lineno"> 2884 </span><span class="spaces">                </span><span class="nottickedoff">_ -&gt; []) .</span>
<span class="lineno"> 2885 </span><span class="spaces">  </span><span class="nottickedoff">mbList . mbMapCl $(mkClosed [| exprPermsVarsList |])</span></span>
<span class="lineno"> 2886 </span>
<span class="lineno"> 2887 </span>-- | Convert the expressions in an 'ExprPerms' to variables, if possible, and
<span class="lineno"> 2888 </span>-- collect them into a set
<span class="lineno"> 2889 </span>exprPermsVarsSet :: ExprPerms ps -&gt; NameSet CrucibleType
<span class="lineno"> 2890 </span><span class="decl"><span class="nottickedoff">exprPermsVarsSet = NameSet.fromList . exprPermsVarsList</span></span>
<span class="lineno"> 2891 </span>
<span class="lineno"> 2892 </span>-- | Convert the expressions in an 'ExprPerms'-in-binding to variables, if
<span class="lineno"> 2893 </span>-- possible, and collect them in a 'NameSet'
<span class="lineno"> 2894 </span>mbExprPermsVarsSet :: Mb ctx (ExprPerms ps) -&gt; NameSet CrucibleType
<span class="lineno"> 2895 </span><span class="decl"><span class="nottickedoff">mbExprPermsVarsSet = NameSet.liftNameSet . fmap exprPermsVarsSet</span></span>
<span class="lineno"> 2896 </span>
<span class="lineno"> 2897 </span>-- | Extract the @args@ context from a function permission
<span class="lineno"> 2898 </span>funPermArgs :: FunPerm ghosts args gouts ret -&gt; CruCtx args
<span class="lineno"> 2899 </span><span class="decl"><span class="nottickedoff">funPermArgs (FunPerm _ args _ _ _ _) = args</span></span>
<span class="lineno"> 2900 </span>
<span class="lineno"> 2901 </span>-- | Extract the @ghosts@ context from a function permission
<span class="lineno"> 2902 </span>funPermGhosts :: FunPerm ghosts args gouts ret -&gt; CruCtx ghosts
<span class="lineno"> 2903 </span><span class="decl"><span class="nottickedoff">funPermGhosts (FunPerm ghosts _ _ _ _ _) = ghosts</span></span>
<span class="lineno"> 2904 </span>
<span class="lineno"> 2905 </span>-- | Extract the @ghosts@ and @args@ contexts from a function permission
<span class="lineno"> 2906 </span>funPermTops :: FunPerm ghosts args gouts ret -&gt; CruCtx (ghosts :++: args)
<span class="lineno"> 2907 </span><span class="decl"><span class="nottickedoff">funPermTops fun_perm =</span>
<span class="lineno"> 2908 </span><span class="spaces">  </span><span class="nottickedoff">appendCruCtx (funPermGhosts fun_perm) (funPermArgs fun_perm)</span></span>
<span class="lineno"> 2909 </span>
<span class="lineno"> 2910 </span>-- | Extract the return type from a function permission
<span class="lineno"> 2911 </span>funPermRet :: FunPerm ghosts args gouts ret -&gt; TypeRepr ret
<span class="lineno"> 2912 </span><span class="decl"><span class="nottickedoff">funPermRet (FunPerm _ _ _ ret _ _) = ret</span></span>
<span class="lineno"> 2913 </span>
<span class="lineno"> 2914 </span>-- | Extract the return types including ghosts from a function permission
<span class="lineno"> 2915 </span>funPermRets :: FunPerm ghosts args gouts ret -&gt; CruCtx (gouts :&gt; ret)
<span class="lineno"> 2916 </span><span class="decl"><span class="nottickedoff">funPermRets fun_perm = CruCtxCons (funPermGouts fun_perm) (funPermRet fun_perm)</span></span>
<span class="lineno"> 2917 </span>
<span class="lineno"> 2918 </span>-- | Extract the @gouts@ context from a function permission
<span class="lineno"> 2919 </span>funPermGouts :: FunPerm ghosts args gouts ret -&gt; CruCtx gouts
<span class="lineno"> 2920 </span><span class="decl"><span class="nottickedoff">funPermGouts (FunPerm _ _ gouts _ _ _) = gouts</span></span>
<span class="lineno"> 2921 </span>
<span class="lineno"> 2922 </span>-- | Extract the input permissions of a function permission
<span class="lineno"> 2923 </span>funPermIns :: FunPerm ghosts args gouts ret -&gt; MbValuePerms (ghosts :++: args)
<span class="lineno"> 2924 </span><span class="decl"><span class="nottickedoff">funPermIns (FunPerm _ _ _ _ perms_in _) = perms_in</span></span>
<span class="lineno"> 2925 </span>
<span class="lineno"> 2926 </span>-- | Extract the output permissions of a function permission
<span class="lineno"> 2927 </span>funPermOuts :: FunPerm ghosts args gouts ret -&gt;
<span class="lineno"> 2928 </span>               MbValuePerms ((ghosts :++: args) :++: gouts :&gt; ret)
<span class="lineno"> 2929 </span><span class="decl"><span class="nottickedoff">funPermOuts (FunPerm _ _ _ _ _ perms_out) = perms_out</span></span>
<span class="lineno"> 2930 </span>
<span class="lineno"> 2931 </span>-- | Build the context of types for the output permissions of a function
<span class="lineno"> 2932 </span>funPermOutCtx :: FunPerm ghosts args gouts ret -&gt;
<span class="lineno"> 2933 </span>                 CruCtx ((ghosts :++: args) :++: gouts :&gt; ret)
<span class="lineno"> 2934 </span><span class="decl"><span class="nottickedoff">funPermOutCtx fun_perm =</span>
<span class="lineno"> 2935 </span><span class="spaces">  </span><span class="nottickedoff">appendCruCtx (funPermTops fun_perm) (funPermRets fun_perm)</span></span>
<span class="lineno"> 2936 </span>
<span class="lineno"> 2937 </span>
<span class="lineno"> 2938 </span>-- | Test whether a name of a given 'NameSort' can be folded / unfolded
<span class="lineno"> 2939 </span>type family NameSortCanFold (ns::NameSort) :: Bool where
<span class="lineno"> 2940 </span>  NameSortCanFold (DefinedSort _) = 'True
<span class="lineno"> 2941 </span>  NameSortCanFold (OpaqueSort _) = 'False
<span class="lineno"> 2942 </span>  NameSortCanFold (RecursiveSort b _) = 'True
<span class="lineno"> 2943 </span>
<span class="lineno"> 2944 </span>-- | Get a 'BoolRepr' for whether a name sort is conjunctive
<span class="lineno"> 2945 </span>nameSortIsConjRepr :: NameSortRepr ns -&gt; BoolRepr (NameSortIsConj ns)
<span class="lineno"> 2946 </span><span class="decl"><span class="nottickedoff">nameSortIsConjRepr (DefinedSortRepr b) = b</span>
<span class="lineno"> 2947 </span><span class="spaces"></span><span class="nottickedoff">nameSortIsConjRepr (OpaqueSortRepr b) = b</span>
<span class="lineno"> 2948 </span><span class="spaces"></span><span class="nottickedoff">nameSortIsConjRepr (RecursiveSortRepr b _) = b</span></span>
<span class="lineno"> 2949 </span>
<span class="lineno"> 2950 </span>-- | Get a 'BoolRepr' for whether a 'NamedPermName' is conjunctive
<span class="lineno"> 2951 </span>nameIsConjRepr :: NamedPermName ns args a -&gt; BoolRepr (NameSortIsConj ns)
<span class="lineno"> 2952 </span><span class="decl"><span class="nottickedoff">nameIsConjRepr = nameSortIsConjRepr . namedPermNameSort</span></span>
<span class="lineno"> 2953 </span>
<span class="lineno"> 2954 </span>-- | Get a 'BoolRepr' for whether a name sort allows folds / unfolds
<span class="lineno"> 2955 </span>nameSortCanFoldRepr :: NameSortRepr ns -&gt; BoolRepr (NameSortCanFold ns)
<span class="lineno"> 2956 </span><span class="decl"><span class="nottickedoff">nameSortCanFoldRepr (DefinedSortRepr _) = TrueRepr</span>
<span class="lineno"> 2957 </span><span class="spaces"></span><span class="nottickedoff">nameSortCanFoldRepr (OpaqueSortRepr _) = FalseRepr</span>
<span class="lineno"> 2958 </span><span class="spaces"></span><span class="nottickedoff">nameSortCanFoldRepr (RecursiveSortRepr _ _) = TrueRepr</span></span>
<span class="lineno"> 2959 </span>
<span class="lineno"> 2960 </span>-- | Get a 'BoolRepr' for whether a 'NamedPermName' allows folds / unfolds
<span class="lineno"> 2961 </span>nameCanFoldRepr :: NamedPermName ns args a -&gt; BoolRepr (NameSortCanFold ns)
<span class="lineno"> 2962 </span><span class="decl"><span class="nottickedoff">nameCanFoldRepr = nameSortCanFoldRepr . namedPermNameSort</span></span>
<span class="lineno"> 2963 </span>
<span class="lineno"> 2964 </span>-- | Extract to Boolean value out of a 'BoolRepr'
<span class="lineno"> 2965 </span>--
<span class="lineno"> 2966 </span>-- FIXME: this should probably go in @BoolRepr.hs@
<span class="lineno"> 2967 </span>boolVal :: BoolRepr b -&gt; Bool
<span class="lineno"> 2968 </span><span class="decl"><span class="nottickedoff">boolVal TrueRepr = True</span>
<span class="lineno"> 2969 </span><span class="spaces"></span><span class="nottickedoff">boolVal FalseRepr = False</span></span>
<span class="lineno"> 2970 </span>
<span class="lineno"> 2971 </span>-- | Test whether a name of a given sort can be used as an atomic permission
<span class="lineno"> 2972 </span>nameSortIsConj :: NameSortRepr ns -&gt; Bool
<span class="lineno"> 2973 </span><span class="decl"><span class="nottickedoff">nameSortIsConj = boolVal . nameSortIsConjRepr</span></span>
<span class="lineno"> 2974 </span>
<span class="lineno"> 2975 </span>-- | Get a 'Bool' for whether a 'NamedPermName' allows folds / unfolds
<span class="lineno"> 2976 </span>nameCanFold :: NamedPermName ns args a -&gt; Bool
<span class="lineno"> 2977 </span><span class="decl"><span class="nottickedoff">nameCanFold = boolVal . nameCanFoldRepr</span></span>
<span class="lineno"> 2978 </span>
<span class="lineno"> 2979 </span>instance TestEquality NameSortRepr where
<span class="lineno"> 2980 </span>  <span class="decl"><span class="nottickedoff">testEquality (DefinedSortRepr b1) (DefinedSortRepr b2)</span>
<span class="lineno"> 2981 </span><span class="spaces">    </span><span class="nottickedoff">| Just Refl &lt;- testEquality b1 b2 = Just Refl</span>
<span class="lineno"> 2982 </span><span class="spaces">  </span><span class="nottickedoff">testEquality (DefinedSortRepr _) _ = Nothing</span>
<span class="lineno"> 2983 </span><span class="spaces">  </span><span class="nottickedoff">testEquality (OpaqueSortRepr b1) (OpaqueSortRepr b2)</span>
<span class="lineno"> 2984 </span><span class="spaces">    </span><span class="nottickedoff">| Just Refl &lt;- testEquality b1 b2 = Just Refl</span>
<span class="lineno"> 2985 </span><span class="spaces">  </span><span class="nottickedoff">testEquality (OpaqueSortRepr _) _ = Nothing</span>
<span class="lineno"> 2986 </span><span class="spaces">  </span><span class="nottickedoff">testEquality (RecursiveSortRepr b1 reach1) (RecursiveSortRepr b2 reach2)</span>
<span class="lineno"> 2987 </span><span class="spaces">    </span><span class="nottickedoff">| Just Refl &lt;- testEquality b1 b2</span>
<span class="lineno"> 2988 </span><span class="spaces">    </span><span class="nottickedoff">, Just Refl &lt;- testEquality reach1 reach2</span>
<span class="lineno"> 2989 </span><span class="spaces">    </span><span class="nottickedoff">= Just Refl</span>
<span class="lineno"> 2990 </span><span class="spaces">  </span><span class="nottickedoff">testEquality (RecursiveSortRepr _ _) _ = Nothing</span></span>
<span class="lineno"> 2991 </span>
<span class="lineno"> 2992 </span>-- | Extract a 'BoolRepr' from a 'NameReachConstr' for whether the name it
<span class="lineno"> 2993 </span>-- constrains is a reachability name
<span class="lineno"> 2994 </span>nameReachConstrBool :: NameReachConstr ns args a -&gt;
<span class="lineno"> 2995 </span>                       BoolRepr (IsReachabilityName ns)
<span class="lineno"> 2996 </span><span class="decl"><span class="nottickedoff">nameReachConstrBool NameReachConstr = TrueRepr</span>
<span class="lineno"> 2997 </span><span class="spaces"></span><span class="nottickedoff">nameReachConstrBool NameNonReachConstr = FalseRepr</span></span>
<span class="lineno"> 2998 </span>
<span class="lineno"> 2999 </span>-- FIXME: NamedPermNames should maybe say something about which arguments are
<span class="lineno"> 3000 </span>-- covariant? Right now we assume lifetime and rwmodalities are covariant
<span class="lineno"> 3001 </span>-- w.r.t. their respective orders, and everything else is invariant, but that
<span class="lineno"> 3002 </span>-- could potentially change
<span class="lineno"> 3003 </span>
<span class="lineno"> 3004 </span>-- | Test if two 'NamedPermName's of possibly different types are equal
<span class="lineno"> 3005 </span>testNamedPermNameEq :: NamedPermName ns1 args1 a1 -&gt;
<span class="lineno"> 3006 </span>                       NamedPermName ns2 args2 a2 -&gt;
<span class="lineno"> 3007 </span>                       Maybe (ns1 :~: ns2, args1 :~: args2, a1 :~: a2)
<span class="lineno"> 3008 </span><span class="decl"><span class="nottickedoff">testNamedPermNameEq (NamedPermName str1 tp1 ctx1 ns1 _r1)</span>
<span class="lineno"> 3009 </span><span class="spaces">                    </span><span class="nottickedoff">(NamedPermName str2 tp2 ctx2 ns2 _r2)</span>
<span class="lineno"> 3010 </span><span class="spaces">  </span><span class="nottickedoff">| Just Refl &lt;- testEquality tp1 tp2</span>
<span class="lineno"> 3011 </span><span class="spaces">  </span><span class="nottickedoff">, Just Refl &lt;- testEquality ctx1 ctx2</span>
<span class="lineno"> 3012 </span><span class="spaces">  </span><span class="nottickedoff">, Just Refl &lt;- testEquality ns1 ns2</span>
<span class="lineno"> 3013 </span><span class="spaces">  </span><span class="nottickedoff">, str1 == str2 = Just (Refl, Refl, Refl)</span>
<span class="lineno"> 3014 </span><span class="spaces"></span><span class="nottickedoff">testNamedPermNameEq _ _ = Nothing</span></span>
<span class="lineno"> 3015 </span>
<span class="lineno"> 3016 </span>instance <span class="decl"><span class="nottickedoff">Eq (NamedPermName ns args a)</span></span> where
<span class="lineno"> 3017 </span>  <span class="decl"><span class="nottickedoff">n1 == n2 | Just (Refl, Refl, Refl) &lt;- testNamedPermNameEq n1 n2 = True</span>
<span class="lineno"> 3018 </span><span class="spaces">  </span><span class="nottickedoff">_ == _ = False</span></span>
<span class="lineno"> 3019 </span>
<span class="lineno"> 3020 </span>instance <span class="decl"><span class="nottickedoff">Eq SomeNamedPermName</span></span> where
<span class="lineno"> 3021 </span>  <span class="decl"><span class="nottickedoff">(SomeNamedPermName n1) == (SomeNamedPermName n2)</span>
<span class="lineno"> 3022 </span><span class="spaces">    </span><span class="nottickedoff">| Just (Refl, Refl, Refl) &lt;- testNamedPermNameEq n1 n2 = True</span>
<span class="lineno"> 3023 </span><span class="spaces">  </span><span class="nottickedoff">_ == _ = False</span></span>
<span class="lineno"> 3024 </span>
<span class="lineno"> 3025 </span>-- | An existentially quantified conjunctive 'NamedPermName'
<span class="lineno"> 3026 </span>data SomeNamedConjPermName where
<span class="lineno"> 3027 </span>  SomeNamedConjPermName ::
<span class="lineno"> 3028 </span>    NameSortIsConj ns ~ 'True =&gt; NamedPermName ns args a -&gt;
<span class="lineno"> 3029 </span>    SomeNamedConjPermName
<span class="lineno"> 3030 </span>
<span class="lineno"> 3031 </span>-- | Test if two 'NamedShapes' of possibly different @b@ and @args@ arguments
<span class="lineno"> 3032 </span>-- are equal
<span class="lineno"> 3033 </span>namedShapeEq :: NamedShape b1 args1 w -&gt; NamedShape b2 args2 w -&gt;
<span class="lineno"> 3034 </span>                Maybe (b1 :~: b2, args1 :~: args2)
<span class="lineno"> 3035 </span><span class="decl"><span class="nottickedoff">namedShapeEq nmsh1 nmsh2</span>
<span class="lineno"> 3036 </span><span class="spaces">  </span><span class="nottickedoff">| Just Refl &lt;- testEquality (namedShapeArgs nmsh1) (namedShapeArgs nmsh2)</span>
<span class="lineno"> 3037 </span><span class="spaces">  </span><span class="nottickedoff">, b1 &lt;- namedShapeCanUnfoldRepr nmsh1</span>
<span class="lineno"> 3038 </span><span class="spaces">  </span><span class="nottickedoff">, b2 &lt;- namedShapeCanUnfoldRepr nmsh2</span>
<span class="lineno"> 3039 </span><span class="spaces">  </span><span class="nottickedoff">, Just Refl &lt;- testEquality b1 b2</span>
<span class="lineno"> 3040 </span><span class="spaces">  </span><span class="nottickedoff">, namedShapeName nmsh1 == namedShapeName nmsh2</span>
<span class="lineno"> 3041 </span><span class="spaces">  </span><span class="nottickedoff">, namedShapeBody nmsh1 == namedShapeBody nmsh2 =</span>
<span class="lineno"> 3042 </span><span class="spaces">    </span><span class="nottickedoff">Just (Refl,Refl)</span>
<span class="lineno"> 3043 </span><span class="spaces"></span><span class="nottickedoff">namedShapeEq _ _ = Nothing</span></span>
<span class="lineno"> 3044 </span>
<span class="lineno"> 3045 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving instance Eq (NamedShapeBody b args w)</span></span></span></span>
<span class="lineno"> 3046 </span>
<span class="lineno"> 3047 </span>-- | Test if a 'NamedShape' is recursive
<span class="lineno"> 3048 </span>namedShapeIsRecursive :: NamedShape b args w -&gt; Bool
<span class="lineno"> 3049 </span><span class="decl"><span class="nottickedoff">namedShapeIsRecursive (NamedShape _ _ (RecShapeBody _ _ _)) = True</span>
<span class="lineno"> 3050 </span><span class="spaces"></span><span class="nottickedoff">namedShapeIsRecursive _ = False</span></span>
<span class="lineno"> 3051 </span>
<span class="lineno"> 3052 </span>-- | Test if a 'NamedShape' in a binding is recursive
<span class="lineno"> 3053 </span>mbNamedShapeIsRecursive :: Mb ctx (NamedShape b args w) -&gt; Bool
<span class="lineno"> 3054 </span><span class="decl"><span class="nottickedoff">mbNamedShapeIsRecursive =</span>
<span class="lineno"> 3055 </span><span class="spaces">  </span><span class="nottickedoff">mbLift . mbMapCl $(mkClosed [| namedShapeIsRecursive |])</span></span>
<span class="lineno"> 3056 </span>
<span class="lineno"> 3057 </span>-- | Get a 'BoolRepr' for the Boolean flag for whether a named shape can be
<span class="lineno"> 3058 </span>-- unfolded
<span class="lineno"> 3059 </span>namedShapeCanUnfoldRepr :: NamedShape b args w -&gt; BoolRepr b
<span class="lineno"> 3060 </span><span class="decl"><span class="nottickedoff">namedShapeCanUnfoldRepr (NamedShape _ _ (DefinedShapeBody _)) = TrueRepr</span>
<span class="lineno"> 3061 </span><span class="spaces"></span><span class="nottickedoff">namedShapeCanUnfoldRepr (NamedShape _ _ (OpaqueShapeBody _ _ _)) = FalseRepr</span>
<span class="lineno"> 3062 </span><span class="spaces"></span><span class="nottickedoff">namedShapeCanUnfoldRepr (NamedShape _ _ (RecShapeBody _ _ _)) = TrueRepr</span></span>
<span class="lineno"> 3063 </span>
<span class="lineno"> 3064 </span>-- | Get a 'BoolRepr' for the Boolean flag for whether a named shape in a
<span class="lineno"> 3065 </span>-- binding can be unfolded
<span class="lineno"> 3066 </span>mbNamedShapeCanUnfoldRepr :: Mb ctx (NamedShape b args w) -&gt; BoolRepr b
<span class="lineno"> 3067 </span><span class="decl"><span class="nottickedoff">mbNamedShapeCanUnfoldRepr =</span>
<span class="lineno"> 3068 </span><span class="spaces">  </span><span class="nottickedoff">mbLift . mbMapCl $(mkClosed [| namedShapeCanUnfoldRepr |])</span></span>
<span class="lineno"> 3069 </span>
<span class="lineno"> 3070 </span>-- | Whether a 'NamedShape' can be unfolded
<span class="lineno"> 3071 </span>namedShapeCanUnfold :: NamedShape b args w -&gt; Bool
<span class="lineno"> 3072 </span><span class="decl"><span class="nottickedoff">namedShapeCanUnfold = boolVal . namedShapeCanUnfoldRepr</span></span>
<span class="lineno"> 3073 </span>
<span class="lineno"> 3074 </span>instance <span class="decl"><span class="nottickedoff">Eq (PermOffset a)</span></span> where
<span class="lineno"> 3075 </span>  <span class="decl"><span class="nottickedoff">NoPermOffset == NoPermOffset = True</span>
<span class="lineno"> 3076 </span><span class="spaces">  </span><span class="nottickedoff">(LLVMPermOffset e1) == (LLVMPermOffset e2) = e1 == e2</span>
<span class="lineno"> 3077 </span><span class="spaces">  </span><span class="nottickedoff">_ == _ = False</span></span>
<span class="lineno"> 3078 </span>
<span class="lineno"> 3079 </span>-- | Smart constructor for 'LLVMPermOffset', that maps a 0 to 'NoPermOffset'
<span class="lineno"> 3080 </span>mkLLVMPermOffset :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 3081 </span>                    PermOffset (LLVMPointerType w)
<span class="lineno"> 3082 </span><span class="decl"><span class="nottickedoff">mkLLVMPermOffset off | bvIsZero off = NoPermOffset</span>
<span class="lineno"> 3083 </span><span class="spaces"></span><span class="nottickedoff">mkLLVMPermOffset off = LLVMPermOffset off</span></span>
<span class="lineno"> 3084 </span>
<span class="lineno"> 3085 </span>-- | Extract a bitvector offset expression from a 'PermOffset' of pointer type
<span class="lineno"> 3086 </span>llvmPermOffsetExpr :: (1 &lt;= w, KnownNat w) =&gt; PermOffset (LLVMPointerType w) -&gt;
<span class="lineno"> 3087 </span>                      PermExpr (BVType w)
<span class="lineno"> 3088 </span><span class="decl"><span class="nottickedoff">llvmPermOffsetExpr NoPermOffset = bvInt 0</span>
<span class="lineno"> 3089 </span><span class="spaces"></span><span class="nottickedoff">llvmPermOffsetExpr (LLVMPermOffset e) = e</span></span>
<span class="lineno"> 3090 </span>
<span class="lineno"> 3091 </span>-- | Test two 'PermOffset's for semantic, not just syntactic, equality
<span class="lineno"> 3092 </span>offsetsEq :: PermOffset a -&gt; PermOffset a -&gt; Bool
<span class="lineno"> 3093 </span><span class="decl"><span class="nottickedoff">offsetsEq NoPermOffset NoPermOffset = True</span>
<span class="lineno"> 3094 </span><span class="spaces"></span><span class="nottickedoff">offsetsEq (LLVMPermOffset off) NoPermOffset = bvIsZero off</span>
<span class="lineno"> 3095 </span><span class="spaces"></span><span class="nottickedoff">offsetsEq NoPermOffset (LLVMPermOffset off) = bvIsZero off</span>
<span class="lineno"> 3096 </span><span class="spaces"></span><span class="nottickedoff">offsetsEq (LLVMPermOffset off1) (LLVMPermOffset off2) = bvEq off1 off2</span></span>
<span class="lineno"> 3097 </span>
<span class="lineno"> 3098 </span>-- | Add a 'PermOffset' to an expression
<span class="lineno"> 3099 </span>offsetExpr :: PermOffset a -&gt; PermExpr a -&gt; PermExpr a
<span class="lineno"> 3100 </span><span class="decl"><span class="nottickedoff">offsetExpr NoPermOffset e = e</span>
<span class="lineno"> 3101 </span><span class="spaces"></span><span class="nottickedoff">offsetExpr (LLVMPermOffset off) e = addLLVMOffset e off</span></span>
<span class="lineno"> 3102 </span>
<span class="lineno"> 3103 </span>-- | Convert an expression to a variable + optional offset, if this is possible
<span class="lineno"> 3104 </span>asVarOffset :: PermExpr a -&gt; Maybe (ExprVar a, PermOffset a)
<span class="lineno"> 3105 </span><span class="decl"><span class="nottickedoff">asVarOffset (PExpr_Var x) = Just (x, NoPermOffset)</span>
<span class="lineno"> 3106 </span><span class="spaces"></span><span class="nottickedoff">asVarOffset (PExpr_LLVMOffset x off) = Just (x, LLVMPermOffset off)</span>
<span class="lineno"> 3107 </span><span class="spaces"></span><span class="nottickedoff">asVarOffset _ = Nothing</span></span>
<span class="lineno"> 3108 </span>
<span class="lineno"> 3109 </span>-- | Convert an expression to a variable if possible
<span class="lineno"> 3110 </span>asVar :: PermExpr a -&gt; Maybe (ExprVar a)
<span class="lineno"> 3111 </span><span class="decl"><span class="nottickedoff">asVar e</span>
<span class="lineno"> 3112 </span><span class="spaces">  </span><span class="nottickedoff">| Just (x,off) &lt;- asVarOffset e</span>
<span class="lineno"> 3113 </span><span class="spaces">  </span><span class="nottickedoff">, offsetsEq off NoPermOffset =</span>
<span class="lineno"> 3114 </span><span class="spaces">    </span><span class="nottickedoff">Just x</span>
<span class="lineno"> 3115 </span><span class="spaces"></span><span class="nottickedoff">asVar _ = Nothing</span></span>
<span class="lineno"> 3116 </span>
<span class="lineno"> 3117 </span>-- | Negate a 'PermOffset'
<span class="lineno"> 3118 </span>negatePermOffset :: PermOffset a -&gt; PermOffset a
<span class="lineno"> 3119 </span><span class="decl"><span class="nottickedoff">negatePermOffset NoPermOffset = NoPermOffset</span>
<span class="lineno"> 3120 </span><span class="spaces"></span><span class="nottickedoff">negatePermOffset (LLVMPermOffset off) = LLVMPermOffset $ bvNegate off</span></span>
<span class="lineno"> 3121 </span>
<span class="lineno"> 3122 </span>-- | Add two 'PermOffset's
<span class="lineno"> 3123 </span>addPermOffsets :: PermOffset a -&gt; PermOffset a -&gt; PermOffset a
<span class="lineno"> 3124 </span><span class="decl"><span class="nottickedoff">addPermOffsets NoPermOffset off = off</span>
<span class="lineno"> 3125 </span><span class="spaces"></span><span class="nottickedoff">addPermOffsets off NoPermOffset = off</span>
<span class="lineno"> 3126 </span><span class="spaces"></span><span class="nottickedoff">addPermOffsets (LLVMPermOffset off1) (LLVMPermOffset off2) =</span>
<span class="lineno"> 3127 </span><span class="spaces">  </span><span class="nottickedoff">mkLLVMPermOffset (bvAdd off1 off2)</span></span>
<span class="lineno"> 3128 </span>
<span class="lineno"> 3129 </span>-- | Get the @n@th expression in a 'PermExprs' list
<span class="lineno"> 3130 </span>nthPermExpr :: PermExprs args -&gt; Member args a -&gt; PermExpr a
<span class="lineno"> 3131 </span><span class="decl"><span class="nottickedoff">nthPermExpr PExprs_Nil m = case m of {}</span>
<span class="lineno"> 3132 </span><span class="spaces"></span><span class="nottickedoff">nthPermExpr (PExprs_Cons _ arg) Member_Base = arg</span>
<span class="lineno"> 3133 </span><span class="spaces"></span><span class="nottickedoff">nthPermExpr (PExprs_Cons args _) (Member_Step memb) =</span>
<span class="lineno"> 3134 </span><span class="spaces">  </span><span class="nottickedoff">nthPermExpr args memb</span></span>
<span class="lineno"> 3135 </span>
<span class="lineno"> 3136 </span>-- | Set the @n@th expression in a 'PermExprs' list
<span class="lineno"> 3137 </span>setNthPermExpr :: PermExprs args -&gt; Member args a -&gt; PermExpr a -&gt;
<span class="lineno"> 3138 </span>                  PermExprs args
<span class="lineno"> 3139 </span><span class="decl"><span class="nottickedoff">setNthPermExpr PExprs_Nil m _ =</span>
<span class="lineno"> 3140 </span><span class="spaces">  </span><span class="nottickedoff">case m of {}</span>
<span class="lineno"> 3141 </span><span class="spaces"></span><span class="nottickedoff">setNthPermExpr (PExprs_Cons args _) Member_Base a =</span>
<span class="lineno"> 3142 </span><span class="spaces">  </span><span class="nottickedoff">PExprs_Cons args a</span>
<span class="lineno"> 3143 </span><span class="spaces"></span><span class="nottickedoff">setNthPermExpr (PExprs_Cons args arg) (Member_Step memb) a =</span>
<span class="lineno"> 3144 </span><span class="spaces">  </span><span class="nottickedoff">PExprs_Cons (setNthPermExpr args memb a) arg</span></span>
<span class="lineno"> 3145 </span>
<span class="lineno"> 3146 </span>-- | Get a list of 'Member' proofs for each expression in a 'PermExprs' list
<span class="lineno"> 3147 </span>getPermExprsMembers :: PermExprs args -&gt;
<span class="lineno"> 3148 </span>                       [Some (Member args :: CrucibleType -&gt; Type)]
<span class="lineno"> 3149 </span><span class="decl"><span class="nottickedoff">getPermExprsMembers PExprs_Nil = []</span>
<span class="lineno"> 3150 </span><span class="spaces"></span><span class="nottickedoff">getPermExprsMembers (PExprs_Cons args _) =</span>
<span class="lineno"> 3151 </span><span class="spaces">  </span><span class="nottickedoff">map (\case Some memb -&gt; Some (Member_Step memb)) (getPermExprsMembers args)</span>
<span class="lineno"> 3152 </span><span class="spaces">  </span><span class="nottickedoff">++ [Some Member_Base]</span></span>
<span class="lineno"> 3153 </span>
<span class="lineno"> 3154 </span>-- | Extract the name back out of the interpretation of a 'NamedPerm'
<span class="lineno"> 3155 </span>namedPermName :: NamedPerm ns args a -&gt; NamedPermName ns args a
<span class="lineno"> 3156 </span><span class="decl"><span class="nottickedoff">namedPermName (NamedPerm_Opaque op) = opaquePermName op</span>
<span class="lineno"> 3157 </span><span class="spaces"></span><span class="nottickedoff">namedPermName (NamedPerm_Rec rp) = recPermName rp</span>
<span class="lineno"> 3158 </span><span class="spaces"></span><span class="nottickedoff">namedPermName (NamedPerm_Defined dp) = definedPermName dp</span></span>
<span class="lineno"> 3159 </span>
<span class="lineno"> 3160 </span>-- | Extract out the argument context of the name of a 'NamedPerm'
<span class="lineno"> 3161 </span>namedPermArgs :: NamedPerm ns args a -&gt; CruCtx args
<span class="lineno"> 3162 </span><span class="decl"><span class="nottickedoff">namedPermArgs = namedPermNameArgs . namedPermName</span></span>
<span class="lineno"> 3163 </span>
<span class="lineno"> 3164 </span>-- | Get the @trans@ method from a 'RecPerm' for a reachability permission
<span class="lineno"> 3165 </span>recPermTransMethod :: RecPerm b 'True args a -&gt; Ident
<span class="lineno"> 3166 </span><span class="decl"><span class="nottickedoff">recPermTransMethod (RecPerm { recPermReachMethods = ReachMethods { .. }}) =</span>
<span class="lineno"> 3167 </span><span class="spaces">  </span><span class="nottickedoff">reachMethodTrans</span></span>
<span class="lineno"> 3168 </span>
<span class="lineno"> 3169 </span>-- | Extract the permissions from a 'VarAndPerm'
<span class="lineno"> 3170 </span>varAndPermPerm :: VarAndPerm a -&gt; ValuePerm a
<span class="lineno"> 3171 </span><span class="decl"><span class="nottickedoff">varAndPermPerm (VarAndPerm _ p) = p</span></span>
<span class="lineno"> 3172 </span>
<span class="lineno"> 3173 </span>-- | A pair that is specifically pretty-printing with a colon
<span class="lineno"> 3174 </span>data ColonPair a b = ColonPair a b
<span class="lineno"> 3175 </span>
<span class="lineno"> 3176 </span>-- | Pattern for an empty 'DistPerms'
<span class="lineno"> 3177 </span>pattern DistPermsNil :: () =&gt; (ps ~ RNil) =&gt; DistPerms ps
<span class="lineno"> 3178 </span>pattern DistPermsNil = <span class="nottickedoff">MNil</span>
<span class="lineno"> 3179 </span>
<span class="lineno"> 3180 </span>-- | Pattern for a non-empty 'DistPerms'
<span class="lineno"> 3181 </span>pattern DistPermsCons :: () =&gt; (ps ~ (ps' :&gt; a)) =&gt;
<span class="lineno"> 3182 </span>                         DistPerms ps' -&gt; ExprVar a -&gt; ValuePerm a -&gt;
<span class="lineno"> 3183 </span>                         DistPerms ps
<span class="lineno"> 3184 </span>pattern DistPermsCons ps x p &lt;- <span class="nottickedoff">ps :&gt;: (VarAndPerm x p)</span>
<span class="lineno"> 3185 </span>  where
<span class="lineno"> 3186 </span>    DistPermsCons ps x p = <span class="nottickedoff">ps :&gt;: VarAndPerm x p</span>
<span class="lineno"> 3187 </span>
<span class="lineno"> 3188 </span>{-# COMPLETE DistPermsNil, DistPermsCons #-}
<span class="lineno"> 3189 </span>
<span class="lineno"> 3190 </span>{-
<span class="lineno"> 3191 </span>data DistPerms ps where
<span class="lineno"> 3192 </span>  DistPermsNil :: DistPerms RNil
<span class="lineno"> 3193 </span>  DistPermsCons :: DistPerms ps -&gt; ExprVar a -&gt; ValuePerm a -&gt;
<span class="lineno"> 3194 </span>                   DistPerms (ps :&gt; a)
<span class="lineno"> 3195 </span>-}
<span class="lineno"> 3196 </span>
<span class="lineno"> 3197 </span>type MbDistPerms ps = Mb ps (DistPerms ps)
<span class="lineno"> 3198 </span>
<span class="lineno"> 3199 </span>-- FIXME: change all of the following functions on DistPerms to use the RAssign
<span class="lineno"> 3200 </span>-- combinators
<span class="lineno"> 3201 </span>
<span class="lineno"> 3202 </span>-- | Fold a function over a 'DistPerms' list, where
<span class="lineno"> 3203 </span>--
<span class="lineno"> 3204 </span>-- &gt; foldDistPerms f b ('DistPermsCons'
<span class="lineno"> 3205 </span>-- &gt;                    ('DistPermsCons' (... 'DistPermsNil' ...) x2 p2) x1 p1) =
<span class="lineno"> 3206 </span>-- &gt; f (f (... b ...) x2 p2) x1 p1
<span class="lineno"> 3207 </span>--
<span class="lineno"> 3208 </span>-- FIXME: implement more functions on DistPerms in terms of this
<span class="lineno"> 3209 </span>foldDistPerms :: (forall a. b -&gt; ExprVar a -&gt; ValuePerm a -&gt; b) -&gt;
<span class="lineno"> 3210 </span>                 b -&gt; DistPerms as -&gt; b
<span class="lineno"> 3211 </span><span class="decl"><span class="nottickedoff">foldDistPerms _ b DistPermsNil = b</span>
<span class="lineno"> 3212 </span><span class="spaces"></span><span class="nottickedoff">foldDistPerms f b (DistPermsCons ps x p) = f (foldDistPerms f b ps) x p</span></span>
<span class="lineno"> 3213 </span>
<span class="lineno"> 3214 </span>-- | Find all permissions in a 'DistPerms' on a specific variable
<span class="lineno"> 3215 </span>varPermsInDistPerms :: ExprVar a -&gt; DistPerms ps -&gt; [ValuePerm a]
<span class="lineno"> 3216 </span><span class="decl"><span class="nottickedoff">varPermsInDistPerms x =</span>
<span class="lineno"> 3217 </span><span class="spaces">  </span><span class="nottickedoff">RL.foldr (\case (VarAndPerm y p) | Just Refl &lt;- testEquality x y -&gt; (p:)</span>
<span class="lineno"> 3218 </span><span class="spaces">                  </span><span class="nottickedoff">_ -&gt; id)</span>
<span class="lineno"> 3219 </span><span class="spaces">  </span><span class="nottickedoff">[]</span></span>
<span class="lineno"> 3220 </span>
<span class="lineno"> 3221 </span>-- | Find all atomic permissions in a 'DistPerms' on a specific variable
<span class="lineno"> 3222 </span>varAtomicPermsInDistPerms :: ExprVar a -&gt; DistPerms ps -&gt; [AtomicPerm a]
<span class="lineno"> 3223 </span><span class="decl"><span class="nottickedoff">varAtomicPermsInDistPerms x =</span>
<span class="lineno"> 3224 </span><span class="spaces">  </span><span class="nottickedoff">RL.foldr (\case (VarAndPerm y (ValPerm_Conj ps))</span>
<span class="lineno"> 3225 </span><span class="spaces">                    </span><span class="nottickedoff">| Just Refl &lt;- testEquality x y -&gt; (ps ++)</span>
<span class="lineno"> 3226 </span><span class="spaces">                  </span><span class="nottickedoff">_ -&gt; id)</span>
<span class="lineno"> 3227 </span><span class="spaces">  </span><span class="nottickedoff">[]</span></span>
<span class="lineno"> 3228 </span>
<span class="lineno"> 3229 </span>-- | Combine a list of variable names and a list of permissions into a list of
<span class="lineno"> 3230 </span>-- distinguished permissions
<span class="lineno"> 3231 </span>valuePermsToDistPerms :: RAssign Name ps -&gt; ValuePerms ps -&gt; DistPerms ps
<span class="lineno"> 3232 </span><span class="decl"><span class="nottickedoff">valuePermsToDistPerms MNil _ = DistPermsNil</span>
<span class="lineno"> 3233 </span><span class="spaces"></span><span class="nottickedoff">valuePermsToDistPerms (ns :&gt;: n) (ps :&gt;: p) =</span>
<span class="lineno"> 3234 </span><span class="spaces">  </span><span class="nottickedoff">DistPermsCons (valuePermsToDistPerms ns ps) n p</span></span>
<span class="lineno"> 3235 </span>
<span class="lineno"> 3236 </span>-- | Convert a list of permissions inside bindings for variables into a list of
<span class="lineno"> 3237 </span>-- distinguished permissions for those variables
<span class="lineno"> 3238 </span>mbValuePermsToDistPerms :: MbValuePerms ps -&gt; MbDistPerms ps
<span class="lineno"> 3239 </span><span class="decl"><span class="nottickedoff">mbValuePermsToDistPerms = nuMultiWithElim1 valuePermsToDistPerms</span></span>
<span class="lineno"> 3240 </span>
<span class="lineno"> 3241 </span>-- | Extract the permissions for a particular variable in a 'DistPerms' list
<span class="lineno"> 3242 </span>distPermsForVar :: ExprVar a -&gt; DistPerms ps -&gt; [ValuePerm a]
<span class="lineno"> 3243 </span><span class="decl"><span class="nottickedoff">distPermsForVar _ MNil = []</span>
<span class="lineno"> 3244 </span><span class="spaces"></span><span class="nottickedoff">distPermsForVar x (ps :&gt;: VarAndPerm y p)</span>
<span class="lineno"> 3245 </span><span class="spaces">  </span><span class="nottickedoff">| Just Refl &lt;- testEquality x y = p : distPermsForVar x ps</span>
<span class="lineno"> 3246 </span><span class="spaces"></span><span class="nottickedoff">distPermsForVar x (ps :&gt;: _) = distPermsForVar x ps</span></span>
<span class="lineno"> 3247 </span>
<span class="lineno"> 3248 </span>-- | Extract the permissions from a 'DistPerms'
<span class="lineno"> 3249 </span>distPermsToValuePerms :: DistPerms ps -&gt; ValuePerms ps
<span class="lineno"> 3250 </span><span class="decl"><span class="nottickedoff">distPermsToValuePerms DistPermsNil = ValPerms_Nil</span>
<span class="lineno"> 3251 </span><span class="spaces"></span><span class="nottickedoff">distPermsToValuePerms (DistPermsCons dperms _ p) =</span>
<span class="lineno"> 3252 </span><span class="spaces">  </span><span class="nottickedoff">ValPerms_Cons (distPermsToValuePerms dperms) p</span></span>
<span class="lineno"> 3253 </span>
<span class="lineno"> 3254 </span>-- | Extract the permissions-in-binding from a 'DistPerms' in a binding
<span class="lineno"> 3255 </span>mbDistPermsToValuePerms :: Mb ctx (DistPerms ps) -&gt; Mb ctx (ValuePerms ps)
<span class="lineno"> 3256 </span><span class="decl"><span class="nottickedoff">mbDistPermsToValuePerms = fmap distPermsToValuePerms</span></span>
<span class="lineno"> 3257 </span>
<span class="lineno"> 3258 </span>-- | Create a sequence @x1:eq(e1), ..., xn:eq(en)@ of equality permissions
<span class="lineno"> 3259 </span>eqDistPerms :: RAssign Name ps -&gt; PermExprs ps -&gt; DistPerms ps
<span class="lineno"> 3260 </span><span class="decl"><span class="nottickedoff">eqDistPerms ns exprs =</span>
<span class="lineno"> 3261 </span><span class="spaces">  </span><span class="nottickedoff">valuePermsToDistPerms ns $ RL.map ValPerm_Eq $ exprsToRAssign exprs</span></span>
<span class="lineno"> 3262 </span>
<span class="lineno"> 3263 </span>-- | Create a sequence @x1:true, ..., xn:true@ of vacuous permissions
<span class="lineno"> 3264 </span>trueDistPerms :: RAssign Name ps -&gt; DistPerms ps
<span class="lineno"> 3265 </span><span class="decl"><span class="nottickedoff">trueDistPerms MNil = DistPermsNil</span>
<span class="lineno"> 3266 </span><span class="spaces"></span><span class="nottickedoff">trueDistPerms (ns :&gt;: n) = DistPermsCons (trueDistPerms ns) n ValPerm_True</span></span>
<span class="lineno"> 3267 </span>
<span class="lineno"> 3268 </span>-- | A list of \&quot;distinguished\&quot; permissions with types
<span class="lineno"> 3269 </span>type TypedDistPerms = RAssign (Typed VarAndPerm)
<span class="lineno"> 3270 </span>
<span class="lineno"> 3271 </span>-- | Get the 'CruCtx' for a 'TypedDistPerms'
<span class="lineno"> 3272 </span>typedDistPermsCtx :: TypedDistPerms ctx -&gt; CruCtx ctx
<span class="lineno"> 3273 </span><span class="decl"><span class="nottickedoff">typedDistPermsCtx = cruCtxOfTypes . RL.map typedType</span></span>
<span class="lineno"> 3274 </span>
<span class="lineno"> 3275 </span>-- | Convert a permission list expression to a 'TypedDistPerms', if possible
<span class="lineno"> 3276 </span>permListToTypedPerms :: PermExpr PermListType -&gt; Maybe (Some TypedDistPerms)
<span class="lineno"> 3277 </span><span class="decl"><span class="nottickedoff">permListToTypedPerms PExpr_PermListNil = Just $ Some MNil</span>
<span class="lineno"> 3278 </span><span class="spaces"></span><span class="nottickedoff">permListToTypedPerms (PExpr_PermListCons tp (PExpr_Var x) p l)</span>
<span class="lineno"> 3279 </span><span class="spaces">  </span><span class="nottickedoff">| Just (Some perms) &lt;- permListToTypedPerms l =</span>
<span class="lineno"> 3280 </span><span class="spaces">    </span><span class="nottickedoff">Just $ Some $ RL.append (MNil :&gt;: Typed tp (VarAndPerm x p)) perms</span>
<span class="lineno"> 3281 </span><span class="spaces"></span><span class="nottickedoff">permListToTypedPerms _ = Nothing</span></span>
<span class="lineno"> 3282 </span>
<span class="lineno"> 3283 </span>-- | Convert a 'TypedDistPerms' to a permission list
<span class="lineno"> 3284 </span>typedPermsToPermList :: TypedDistPerms ps -&gt; PermExpr PermListType
<span class="lineno"> 3285 </span><span class="decl"><span class="nottickedoff">typedPermsToPermList = flip helper PExpr_PermListNil where</span>
<span class="lineno"> 3286 </span><span class="spaces">  </span><span class="nottickedoff">-- We use an accumulator to reverse as we go, because DistPerms cons to the</span>
<span class="lineno"> 3287 </span><span class="spaces">  </span><span class="nottickedoff">-- right while PermLists cons to the left</span>
<span class="lineno"> 3288 </span><span class="spaces">  </span><span class="nottickedoff">helper :: TypedDistPerms ps' -&gt; PermExpr PermListType -&gt; PermExpr PermListType</span>
<span class="lineno"> 3289 </span><span class="spaces">  </span><span class="nottickedoff">helper MNil accum = accum</span>
<span class="lineno"> 3290 </span><span class="spaces">  </span><span class="nottickedoff">helper (ps :&gt;: Typed tp (VarAndPerm x p)) accum =</span>
<span class="lineno"> 3291 </span><span class="spaces">    </span><span class="nottickedoff">helper ps $ PExpr_PermListCons tp (PExpr_Var x) p accum</span></span>
<span class="lineno"> 3292 </span>
<span class="lineno"> 3293 </span>-- | Convert a 'TypedDistPerms' to a normal 'DistPerms'
<span class="lineno"> 3294 </span>unTypeDistPerms :: TypedDistPerms ps -&gt; DistPerms ps
<span class="lineno"> 3295 </span><span class="decl"><span class="nottickedoff">unTypeDistPerms = RL.map (\(Typed _ v_and_p) -&gt; v_and_p)</span></span>
<span class="lineno"> 3296 </span>
<span class="lineno"> 3297 </span>
<span class="lineno"> 3298 </span>instance TestEquality VarAndPerm where
<span class="lineno"> 3299 </span>  <span class="decl"><span class="nottickedoff">testEquality (VarAndPerm x1 p1) (VarAndPerm x2 p2)</span>
<span class="lineno"> 3300 </span><span class="spaces">    </span><span class="nottickedoff">| Just Refl &lt;- testEquality x1 x2</span>
<span class="lineno"> 3301 </span><span class="spaces">    </span><span class="nottickedoff">, p1 == p2</span>
<span class="lineno"> 3302 </span><span class="spaces">    </span><span class="nottickedoff">= Just Refl</span>
<span class="lineno"> 3303 </span><span class="spaces">  </span><span class="nottickedoff">testEquality _ _ = Nothing</span></span>
<span class="lineno"> 3304 </span>
<span class="lineno"> 3305 </span>instance <span class="decl"><span class="nottickedoff">Eq (VarAndPerm a)</span></span> where
<span class="lineno"> 3306 </span>  <span class="decl"><span class="nottickedoff">vp1 == vp2 | Just _ &lt;- testEquality vp1 vp2 = True</span>
<span class="lineno"> 3307 </span><span class="spaces">  </span><span class="nottickedoff">_ == _ = False</span></span>
<span class="lineno"> 3308 </span>
<span class="lineno"> 3309 </span>instance Eq1 VarAndPerm where
<span class="lineno"> 3310 </span>  <span class="decl"><span class="nottickedoff">eq1 = (==)</span></span>
<span class="lineno"> 3311 </span>
<span class="lineno"> 3312 </span>instance <span class="decl"><span class="nottickedoff">Eq (ExprAndPerm a)</span></span> where
<span class="lineno"> 3313 </span>  <span class="decl"><span class="nottickedoff">ExprAndPerm e1 p1 == ExprAndPerm e2 p2 = e1 == e2 &amp;&amp; p1 == p2</span></span>
<span class="lineno"> 3314 </span>
<span class="lineno"> 3315 </span>instance Eq1 ExprAndPerm where
<span class="lineno"> 3316 </span>  <span class="decl"><span class="nottickedoff">eq1 = (==)</span></span>
<span class="lineno"> 3317 </span>
<span class="lineno"> 3318 </span>{-
<span class="lineno"> 3319 </span>instance TestEquality DistPerms where
<span class="lineno"> 3320 </span>  testEquality DistPermsNil DistPermsNil = Just Refl
<span class="lineno"> 3321 </span>  testEquality (DistPermsCons ps1 x1 p1) (DistPermsCons ps2 x2 p2)
<span class="lineno"> 3322 </span>    | Just Refl &lt;- testEquality ps1 ps2
<span class="lineno"> 3323 </span>    , Just Refl &lt;- testEquality x1 x2
<span class="lineno"> 3324 </span>    , p1 == p2
<span class="lineno"> 3325 </span>    = Just Refl
<span class="lineno"> 3326 </span>  testEquality _ _ = Nothing
<span class="lineno"> 3327 </span>
<span class="lineno"> 3328 </span>instance Eq (DistPerms ps) where
<span class="lineno"> 3329 </span>  perms1 == perms2 =
<span class="lineno"> 3330 </span>    case testEquality perms1 perms2 of
<span class="lineno"> 3331 </span>      Just _ -&gt; True
<span class="lineno"> 3332 </span>      Nothing -&gt; False
<span class="lineno"> 3333 </span>-}
<span class="lineno"> 3334 </span>
<span class="lineno"> 3335 </span>
<span class="lineno"> 3336 </span>-- | Build the permission and the variable it applies to that is needed to prove
<span class="lineno"> 3337 </span>-- that @l@ is current during @l2@. If @l@ is @always@, this holds vacuously, so
<span class="lineno"> 3338 </span>-- return the permission @l2:true@, and otherwise, if @l@ is a variable, return
<span class="lineno"> 3339 </span>-- @l:[l2]lcurrent@.
<span class="lineno"> 3340 </span>lcurrentPerm :: PermExpr LifetimeType -&gt; ExprVar LifetimeType -&gt;
<span class="lineno"> 3341 </span>                (ExprVar LifetimeType, ValuePerm LifetimeType)
<span class="lineno"> 3342 </span><span class="decl"><span class="nottickedoff">lcurrentPerm PExpr_Always l2 = (l2, ValPerm_True)</span>
<span class="lineno"> 3343 </span><span class="spaces"></span><span class="nottickedoff">lcurrentPerm (PExpr_Var l) l2 = (l, ValPerm_LCurrent $ PExpr_Var l2)</span></span>
<span class="lineno"> 3344 </span>
<span class="lineno"> 3345 </span>-- | Get the lifetime that a 'LifetimeCurrentPerms' is about
<span class="lineno"> 3346 </span>lifetimeCurrentPermsLifetime :: LifetimeCurrentPerms ps_l -&gt;
<span class="lineno"> 3347 </span>                                PermExpr LifetimeType
<span class="lineno"> 3348 </span><span class="decl"><span class="nottickedoff">lifetimeCurrentPermsLifetime AlwaysCurrentPerms = PExpr_Always</span>
<span class="lineno"> 3349 </span><span class="spaces"></span><span class="nottickedoff">lifetimeCurrentPermsLifetime (LOwnedCurrentPerms l _ _ _ _ _) = PExpr_Var l</span>
<span class="lineno"> 3350 </span><span class="spaces"></span><span class="nottickedoff">lifetimeCurrentPermsLifetime (LOwnedSimpleCurrentPerms l _ _) = PExpr_Var l</span>
<span class="lineno"> 3351 </span><span class="spaces"></span><span class="nottickedoff">lifetimeCurrentPermsLifetime (CurrentTransPerms _ l) = PExpr_Var l</span></span>
<span class="lineno"> 3352 </span>
<span class="lineno"> 3353 </span>-- | Convert a 'LifetimeCurrentPerms' to the 'DistPerms' it represent
<span class="lineno"> 3354 </span>lifetimeCurrentPermsPerms :: LifetimeCurrentPerms ps_l -&gt; DistPerms ps_l
<span class="lineno"> 3355 </span><span class="decl"><span class="nottickedoff">lifetimeCurrentPermsPerms AlwaysCurrentPerms = DistPermsNil</span>
<span class="lineno"> 3356 </span><span class="spaces"></span><span class="nottickedoff">lifetimeCurrentPermsPerms (LOwnedCurrentPerms l ls tps_in tps_out ps_in ps_out) =</span>
<span class="lineno"> 3357 </span><span class="spaces">  </span><span class="nottickedoff">DistPermsCons DistPermsNil l $ ValPerm_LOwned ls tps_in tps_out ps_in ps_out</span>
<span class="lineno"> 3358 </span><span class="spaces"></span><span class="nottickedoff">lifetimeCurrentPermsPerms (LOwnedSimpleCurrentPerms l tps lops) =</span>
<span class="lineno"> 3359 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 l $ ValPerm_LOwnedSimple tps lops</span>
<span class="lineno"> 3360 </span><span class="spaces"></span><span class="nottickedoff">lifetimeCurrentPermsPerms (CurrentTransPerms cur_ps l) =</span>
<span class="lineno"> 3361 </span><span class="spaces">  </span><span class="nottickedoff">DistPermsCons (lifetimeCurrentPermsPerms cur_ps) l $</span>
<span class="lineno"> 3362 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_Conj1 $ Perm_LCurrent $ lifetimeCurrentPermsLifetime cur_ps</span></span>
<span class="lineno"> 3363 </span>
<span class="lineno"> 3364 </span>-- | Build a lift of proxies for a 'LifetimeCurrentPerms'
<span class="lineno"> 3365 </span>mbLifetimeCurrentPermsProxies :: Mb ctx (LifetimeCurrentPerms ps_l) -&gt;
<span class="lineno"> 3366 </span>                                 RAssign Proxy ps_l
<span class="lineno"> 3367 </span><span class="decl"><span class="nottickedoff">mbLifetimeCurrentPermsProxies mb_l = case mbMatch mb_l of</span>
<span class="lineno"> 3368 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| AlwaysCurrentPerms |] -&gt; MNil</span>
<span class="lineno"> 3369 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| LOwnedCurrentPerms _ _ _ _ _ _ |] -&gt; MNil :&gt;: Proxy</span>
<span class="lineno"> 3370 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| LOwnedSimpleCurrentPerms _ _ _ |] -&gt; MNil :&gt;: Proxy</span>
<span class="lineno"> 3371 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| CurrentTransPerms cur_ps _ |] -&gt;</span>
<span class="lineno"> 3372 </span><span class="spaces">    </span><span class="nottickedoff">mbLifetimeCurrentPermsProxies cur_ps :&gt;: Proxy</span></span>
<span class="lineno"> 3373 </span>
<span class="lineno"> 3374 </span>-- | Apply a functor to its arguments to get out a permission
<span class="lineno"> 3375 </span>ltFuncApply :: LifetimeFunctor args a -&gt; PermExprs args -&gt;
<span class="lineno"> 3376 </span>               PermExpr LifetimeType -&gt; ValuePerm a
<span class="lineno"> 3377 </span><span class="decl"><span class="nottickedoff">ltFuncApply (LTFunctorField off p) (MNil :&gt;: rw) l =</span>
<span class="lineno"> 3378 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_LLVMField $ LLVMFieldPerm rw l off p</span>
<span class="lineno"> 3379 </span><span class="spaces"></span><span class="nottickedoff">ltFuncApply (LTFunctorArray off len stride sh bs) (MNil :&gt;: rw) l =</span>
<span class="lineno"> 3380 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_LLVMArray $ LLVMArrayPerm rw l off len stride sh bs</span>
<span class="lineno"> 3381 </span><span class="spaces"></span><span class="nottickedoff">ltFuncApply (LTFunctorBlock off len sh) (MNil :&gt;: rw) l =</span>
<span class="lineno"> 3382 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_LLVMBlock $ LLVMBlockPerm rw l off len sh</span></span>
<span class="lineno"> 3383 </span>
<span class="lineno"> 3384 </span>-- | Apply a functor to a lifetime and the \&quot;minimal\&quot; rwmodalities, i.e., with
<span class="lineno"> 3385 </span>-- all read permissions
<span class="lineno"> 3386 </span>ltFuncMinApply :: LifetimeFunctor args a -&gt; PermExpr LifetimeType -&gt; ValuePerm a
<span class="lineno"> 3387 </span><span class="decl"><span class="nottickedoff">ltFuncMinApply (LTFunctorField off p) l =</span>
<span class="lineno"> 3388 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_LLVMField $ LLVMFieldPerm PExpr_Read l off p</span>
<span class="lineno"> 3389 </span><span class="spaces"></span><span class="nottickedoff">ltFuncMinApply (LTFunctorArray off len stride sh bs) l =</span>
<span class="lineno"> 3390 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_LLVMArray $ LLVMArrayPerm PExpr_Read l off len stride sh bs</span>
<span class="lineno"> 3391 </span><span class="spaces"></span><span class="nottickedoff">ltFuncMinApply (LTFunctorBlock off len sh) l =</span>
<span class="lineno"> 3392 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_LLVMBlock $ LLVMBlockPerm PExpr_Read l off len sh</span></span>
<span class="lineno"> 3393 </span>
<span class="lineno"> 3394 </span>-- | Convert a field permission to a lifetime functor and its arguments
<span class="lineno"> 3395 </span>fieldToLTFunc :: (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno"> 3396 </span>                 LLVMFieldPerm w sz -&gt;
<span class="lineno"> 3397 </span>                 (LifetimeFunctor (RNil :&gt; RWModalityType) (LLVMPointerType w),
<span class="lineno"> 3398 </span>                  PermExprs (RNil :&gt; RWModalityType))
<span class="lineno"> 3399 </span><span class="decl"><span class="nottickedoff">fieldToLTFunc fp = (LTFunctorField (llvmFieldOffset fp) (llvmFieldContents fp),</span>
<span class="lineno"> 3400 </span><span class="spaces">                    </span><span class="nottickedoff">MNil :&gt;: llvmFieldRW fp)</span></span>
<span class="lineno"> 3401 </span>
<span class="lineno"> 3402 </span>-- | Convert an array permission to a lifetime functor and its arguments
<span class="lineno"> 3403 </span>arrayToLTFunc :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 3404 </span>                 (LifetimeFunctor (RNil :&gt; RWModalityType) (LLVMPointerType w),
<span class="lineno"> 3405 </span>                  PermExprs (RNil :&gt; RWModalityType))
<span class="lineno"> 3406 </span><span class="decl"><span class="nottickedoff">arrayToLTFunc (LLVMArrayPerm rw _ off len stride sh bs) =</span>
<span class="lineno"> 3407 </span><span class="spaces">  </span><span class="nottickedoff">(LTFunctorArray off len stride sh bs, MNil :&gt;: rw)</span></span>
<span class="lineno"> 3408 </span>
<span class="lineno"> 3409 </span>-- | Convert a block permission to a lifetime functor and its arguments
<span class="lineno"> 3410 </span>blockToLTFunc :: (1 &lt;= w, KnownNat w) =&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 3411 </span>                 (LifetimeFunctor (RNil :&gt; RWModalityType) (LLVMPointerType w),
<span class="lineno"> 3412 </span>                  PermExprs (RNil :&gt; RWModalityType))
<span class="lineno"> 3413 </span><span class="decl"><span class="nottickedoff">blockToLTFunc bp =</span>
<span class="lineno"> 3414 </span><span class="spaces">  </span><span class="nottickedoff">(LTFunctorBlock (llvmBlockOffset bp) (llvmBlockLen bp) (llvmBlockShape bp),</span>
<span class="lineno"> 3415 </span><span class="spaces">   </span><span class="nottickedoff">MNil :&gt;: llvmBlockRW bp)</span></span>
<span class="lineno"> 3416 </span>
<span class="lineno"> 3417 </span>instance <span class="decl"><span class="nottickedoff">Eq (ValuePerm a)</span></span> where
<span class="lineno"> 3418 </span>  <span class="decl"><span class="nottickedoff">(ValPerm_Eq e1) == (ValPerm_Eq e2) = e1 == e2</span>
<span class="lineno"> 3419 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Eq _) == _ = False</span>
<span class="lineno"> 3420 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Or p1 p1') == (ValPerm_Or p2 p2') = p1 == p2 &amp;&amp; p1' == p2'</span>
<span class="lineno"> 3421 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Or _ _) == _ = False</span>
<span class="lineno"> 3422 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Exists (p1 :: Binding a1 (ValuePerm a))) ==</span>
<span class="lineno"> 3423 </span><span class="spaces">   </span><span class="nottickedoff">(ValPerm_Exists (p2 :: Binding a2 (ValuePerm a)))</span>
<span class="lineno"> 3424 </span><span class="spaces">    </span><span class="nottickedoff">| Just Refl &lt;-</span>
<span class="lineno"> 3425 </span><span class="spaces">        </span><span class="nottickedoff">testEquality (knownRepr :: TypeRepr a1) (knownRepr :: TypeRepr a2)</span>
<span class="lineno"> 3426 </span><span class="spaces">    </span><span class="nottickedoff">= p1 == p2</span>
<span class="lineno"> 3427 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Exists _) == _ = False</span>
<span class="lineno"> 3428 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Named n1 args1 off1) == (ValPerm_Named n2 args2 off2)</span>
<span class="lineno"> 3429 </span><span class="spaces">    </span><span class="nottickedoff">| Just (Refl, Refl, Refl) &lt;- testNamedPermNameEq n1 n2 =</span>
<span class="lineno"> 3430 </span><span class="spaces">        </span><span class="nottickedoff">args1 == args2 &amp;&amp; off1 == off2</span>
<span class="lineno"> 3431 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Named _ _ _) == _ = False</span>
<span class="lineno"> 3432 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Var x1 off1) == (ValPerm_Var x2 off2) = x1 == x2 &amp;&amp; off1 == off2</span>
<span class="lineno"> 3433 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Var _ _) == _ = False</span>
<span class="lineno"> 3434 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Conj aps1) == (ValPerm_Conj aps2) = aps1 == aps2</span>
<span class="lineno"> 3435 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Conj _) == _ = False</span>
<span class="lineno"> 3436 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_False == ValPerm_False = True</span>
<span class="lineno"> 3437 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_False == _ = False</span></span>
<span class="lineno"> 3438 </span>
<span class="lineno"> 3439 </span>instance <span class="decl"><span class="nottickedoff">Eq (AtomicPerm a)</span></span> where
<span class="lineno"> 3440 </span>  <span class="decl"><span class="nottickedoff">(Perm_LLVMField fp1) == (Perm_LLVMField fp2)</span>
<span class="lineno"> 3441 </span><span class="spaces">    </span><span class="nottickedoff">| Just Refl &lt;- testEquality (llvmFieldSize fp1) (llvmFieldSize fp2)</span>
<span class="lineno"> 3442 </span><span class="spaces">    </span><span class="nottickedoff">= fp1 == fp2</span>
<span class="lineno"> 3443 </span><span class="spaces">  </span><span class="nottickedoff">(Perm_LLVMField _) == _ = False</span>
<span class="lineno"> 3444 </span><span class="spaces">  </span><span class="nottickedoff">(Perm_LLVMArray ap1) == (Perm_LLVMArray ap2) = ap1 == ap2</span>
<span class="lineno"> 3445 </span><span class="spaces">  </span><span class="nottickedoff">(Perm_LLVMArray _) == _ = False</span>
<span class="lineno"> 3446 </span><span class="spaces">  </span><span class="nottickedoff">(Perm_LLVMBlock bp1) == (Perm_LLVMBlock bp2) = bp1 == bp2</span>
<span class="lineno"> 3447 </span><span class="spaces">  </span><span class="nottickedoff">(Perm_LLVMBlock _) == _ = False</span>
<span class="lineno"> 3448 </span><span class="spaces">  </span><span class="nottickedoff">(Perm_LLVMFree e1) == (Perm_LLVMFree e2) = e1 == e2</span>
<span class="lineno"> 3449 </span><span class="spaces">  </span><span class="nottickedoff">(Perm_LLVMFree _) == _ = False</span>
<span class="lineno"> 3450 </span><span class="spaces">  </span><span class="nottickedoff">(Perm_LLVMFunPtr tp1 p1) == (Perm_LLVMFunPtr tp2 p2)</span>
<span class="lineno"> 3451 </span><span class="spaces">    </span><span class="nottickedoff">| Just Refl &lt;- testEquality tp1 tp2 = p1 == p2</span>
<span class="lineno"> 3452 </span><span class="spaces">  </span><span class="nottickedoff">(Perm_LLVMFunPtr _ _) == _ = False</span>
<span class="lineno"> 3453 </span><span class="spaces">  </span><span class="nottickedoff">Perm_IsLLVMPtr == Perm_IsLLVMPtr = True</span>
<span class="lineno"> 3454 </span><span class="spaces">  </span><span class="nottickedoff">Perm_IsLLVMPtr == _ = False</span>
<span class="lineno"> 3455 </span><span class="spaces">  </span><span class="nottickedoff">(Perm_LLVMBlockShape sh1) == (Perm_LLVMBlockShape sh2) = sh1 == sh2</span>
<span class="lineno"> 3456 </span><span class="spaces">  </span><span class="nottickedoff">(Perm_LLVMBlockShape _) == _ = False</span>
<span class="lineno"> 3457 </span><span class="spaces">  </span><span class="nottickedoff">(Perm_LLVMFrame frame1) == (Perm_LLVMFrame frame2) = frame1 == frame2</span>
<span class="lineno"> 3458 </span><span class="spaces">  </span><span class="nottickedoff">(Perm_LLVMFrame _) == _ = False</span>
<span class="lineno"> 3459 </span><span class="spaces">  </span><span class="nottickedoff">(Perm_LOwned</span>
<span class="lineno"> 3460 </span><span class="spaces">   </span><span class="nottickedoff">ls1 tps_in1 tps_out1 ps_in1 ps_out1) == (Perm_LOwned</span>
<span class="lineno"> 3461 </span><span class="spaces">                                            </span><span class="nottickedoff">ls2 tps_in2 tps_out2 ps_in2 ps_out2)</span>
<span class="lineno"> 3462 </span><span class="spaces">    </span><span class="nottickedoff">| Just Refl &lt;- testEquality tps_in1 tps_in2</span>
<span class="lineno"> 3463 </span><span class="spaces">    </span><span class="nottickedoff">, Just Refl &lt;- testEquality tps_out1 tps_out2</span>
<span class="lineno"> 3464 </span><span class="spaces">    </span><span class="nottickedoff">= ls1 == ls2 &amp;&amp; ps_in1 == ps_in2 &amp;&amp; ps_out1 == ps_out2</span>
<span class="lineno"> 3465 </span><span class="spaces">  </span><span class="nottickedoff">(Perm_LOwned _ _ _ _ _) == _ = False</span>
<span class="lineno"> 3466 </span><span class="spaces">  </span><span class="nottickedoff">(Perm_LOwnedSimple tps1 lops1) == (Perm_LOwnedSimple tps2 lops2)</span>
<span class="lineno"> 3467 </span><span class="spaces">    </span><span class="nottickedoff">| Just Refl &lt;- testEquality tps1 tps2 = lops1 == lops2</span>
<span class="lineno"> 3468 </span><span class="spaces">  </span><span class="nottickedoff">(Perm_LOwnedSimple _ _) == _ = False</span>
<span class="lineno"> 3469 </span><span class="spaces">  </span><span class="nottickedoff">(Perm_LCurrent e1) == (Perm_LCurrent e2) = e1 == e2</span>
<span class="lineno"> 3470 </span><span class="spaces">  </span><span class="nottickedoff">(Perm_LCurrent _) == _ = False</span>
<span class="lineno"> 3471 </span><span class="spaces">  </span><span class="nottickedoff">Perm_LFinished == Perm_LFinished = True</span>
<span class="lineno"> 3472 </span><span class="spaces">  </span><span class="nottickedoff">Perm_LFinished == _ = False</span>
<span class="lineno"> 3473 </span><span class="spaces">  </span><span class="nottickedoff">(Perm_Struct ps1) == (Perm_Struct ps2) = ps1 == ps2</span>
<span class="lineno"> 3474 </span><span class="spaces">  </span><span class="nottickedoff">(Perm_Struct _) == _ = False</span>
<span class="lineno"> 3475 </span><span class="spaces">  </span><span class="nottickedoff">(Perm_Fun fperm1) == (Perm_Fun fperm2)</span>
<span class="lineno"> 3476 </span><span class="spaces">    </span><span class="nottickedoff">| Just (Refl, Refl) &lt;- funPermEq fperm1 fperm2 = True</span>
<span class="lineno"> 3477 </span><span class="spaces">  </span><span class="nottickedoff">(Perm_Fun _) == _ = False</span>
<span class="lineno"> 3478 </span><span class="spaces">  </span><span class="nottickedoff">(Perm_NamedConj n1 args1 off1) == (Perm_NamedConj n2 args2 off2)</span>
<span class="lineno"> 3479 </span><span class="spaces">    </span><span class="nottickedoff">| Just (Refl, Refl, Refl) &lt;- testNamedPermNameEq n1 n2 =</span>
<span class="lineno"> 3480 </span><span class="spaces">      </span><span class="nottickedoff">args1 == args2 &amp;&amp; off1 == off2</span>
<span class="lineno"> 3481 </span><span class="spaces">  </span><span class="nottickedoff">(Perm_NamedConj _ _ _) == _ = False</span>
<span class="lineno"> 3482 </span><span class="spaces">  </span><span class="nottickedoff">(Perm_BVProp p1) == (Perm_BVProp p2) = p1 == p2</span>
<span class="lineno"> 3483 </span><span class="spaces">  </span><span class="nottickedoff">(Perm_BVProp _) == _ = False</span>
<span class="lineno"> 3484 </span><span class="spaces">  </span><span class="nottickedoff">Perm_Any == Perm_Any = True</span>
<span class="lineno"> 3485 </span><span class="spaces">  </span><span class="nottickedoff">Perm_Any == _ = False</span></span>
<span class="lineno"> 3486 </span>
<span class="lineno"> 3487 </span>instance Eq1 ValuePerm where
<span class="lineno"> 3488 </span>  <span class="decl"><span class="nottickedoff">eq1 = (==)</span></span>
<span class="lineno"> 3489 </span>
<span class="lineno"> 3490 </span>{-
<span class="lineno"> 3491 </span>instance Eq (ValuePerms as) where
<span class="lineno"> 3492 </span>  ValPerms_Nil == ValPerms_Nil = True
<span class="lineno"> 3493 </span>  (ValPerms_Cons ps1 p1) == (ValPerms_Cons ps2 p2) =
<span class="lineno"> 3494 </span>    ps1 == ps2 &amp;&amp; p1 == p2
<span class="lineno"> 3495 </span>-}
<span class="lineno"> 3496 </span>
<span class="lineno"> 3497 </span>-- | Test if function permissions with different ghost argument lists are equal
<span class="lineno"> 3498 </span>funPermEq :: FunPerm ghosts1 args gouts1 ret -&gt;
<span class="lineno"> 3499 </span>             FunPerm ghosts2 args gouts2 ret -&gt;
<span class="lineno"> 3500 </span>             Maybe (ghosts1 :~: ghosts2, gouts1 :~: gouts2)
<span class="lineno"> 3501 </span><span class="decl"><span class="nottickedoff">funPermEq (FunPerm ghosts1 _ gouts1 _ perms_in1 perms_out1)</span>
<span class="lineno"> 3502 </span><span class="spaces">  </span><span class="nottickedoff">(FunPerm ghosts2 _ gouts2 _ perms_in2 perms_out2)</span>
<span class="lineno"> 3503 </span><span class="spaces">  </span><span class="nottickedoff">| Just Refl &lt;- testEquality ghosts1 ghosts2</span>
<span class="lineno"> 3504 </span><span class="spaces">  </span><span class="nottickedoff">, Just Refl &lt;- testEquality gouts1 gouts2</span>
<span class="lineno"> 3505 </span><span class="spaces">  </span><span class="nottickedoff">, perms_in1 == perms_in2 &amp;&amp; perms_out1 == perms_out2</span>
<span class="lineno"> 3506 </span><span class="spaces">  </span><span class="nottickedoff">= Just (Refl, Refl)</span>
<span class="lineno"> 3507 </span><span class="spaces"></span><span class="nottickedoff">funPermEq _ _ = Nothing</span></span>
<span class="lineno"> 3508 </span>
<span class="lineno"> 3509 </span>-- | Test if function permissions with all 4 type args different are equal
<span class="lineno"> 3510 </span>funPermEq4 :: FunPerm ghosts1 args1 gouts1 ret1 -&gt;
<span class="lineno"> 3511 </span>              FunPerm ghosts2 args2 gouts2 ret2 -&gt;
<span class="lineno"> 3512 </span>              Maybe (ghosts1 :~: ghosts2, args1 :~: args2,
<span class="lineno"> 3513 </span>                     gouts1 :~: gouts2, ret1 :~: ret2)
<span class="lineno"> 3514 </span><span class="decl"><span class="nottickedoff">funPermEq4 (FunPerm ghosts1 args1 ret1 gouts1 perms_in1 perms_out1)</span>
<span class="lineno"> 3515 </span><span class="spaces">  </span><span class="nottickedoff">(FunPerm ghosts2 args2 ret2 gouts2 perms_in2 perms_out2)</span>
<span class="lineno"> 3516 </span><span class="spaces">  </span><span class="nottickedoff">| Just Refl &lt;- testEquality ghosts1 ghosts2</span>
<span class="lineno"> 3517 </span><span class="spaces">  </span><span class="nottickedoff">, Just Refl &lt;- testEquality args1 args2</span>
<span class="lineno"> 3518 </span><span class="spaces">  </span><span class="nottickedoff">, Just Refl &lt;- testEquality gouts1 gouts2</span>
<span class="lineno"> 3519 </span><span class="spaces">  </span><span class="nottickedoff">, Just Refl &lt;- testEquality ret1 ret2</span>
<span class="lineno"> 3520 </span><span class="spaces">  </span><span class="nottickedoff">, perms_in1 == perms_in2 &amp;&amp; perms_out1 == perms_out2</span>
<span class="lineno"> 3521 </span><span class="spaces">  </span><span class="nottickedoff">= Just (Refl, Refl, Refl, Refl)</span>
<span class="lineno"> 3522 </span><span class="spaces"></span><span class="nottickedoff">funPermEq4 _ _ = Nothing</span></span>
<span class="lineno"> 3523 </span>
<span class="lineno"> 3524 </span>instance <span class="decl"><span class="nottickedoff">Eq (FunPerm ghosts args gouts ret)</span></span> where
<span class="lineno"> 3525 </span>  <span class="decl"><span class="nottickedoff">fperm1 == fperm2 = isJust (funPermEq fperm1 fperm2)</span></span>
<span class="lineno"> 3526 </span>
<span class="lineno"> 3527 </span>instance PermPretty (NamedPermName ns args a) where
<span class="lineno"> 3528 </span>  <span class="decl"><span class="nottickedoff">permPrettyM (NamedPermName str _ _ _ _) = return $ pretty str</span></span>
<span class="lineno"> 3529 </span>
<span class="lineno"> 3530 </span>instance PermPretty (ValuePerm a) where
<span class="lineno"> 3531 </span>  <span class="decl"><span class="nottickedoff">permPrettyM (ValPerm_Eq e) = ((pretty &quot;eq&quot; &lt;&gt;) . parens) &lt;$&gt; permPrettyM e</span>
<span class="lineno"> 3532 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (ValPerm_Or p1 p2) =</span>
<span class="lineno"> 3533 </span><span class="spaces">    </span><span class="nottickedoff">-- FIXME: If we ever fix the SAW lexer to handle &quot;\/&quot;...</span>
<span class="lineno"> 3534 </span><span class="spaces">    </span><span class="nottickedoff">-- (\pp1 pp2 -&gt; hang 2 (pp1 &lt;/&gt; string &quot;\\/&quot; &lt;&gt; pp2))</span>
<span class="lineno"> 3535 </span><span class="spaces">    </span><span class="nottickedoff">(\pp1 pp2 -&gt; hang 2 (pp1 &lt;&gt; softline &lt;&gt; pretty &quot;or&quot; &lt;+&gt; pp2))</span>
<span class="lineno"> 3536 </span><span class="spaces">    </span><span class="nottickedoff">&lt;$&gt; permPrettyM p1 &lt;*&gt; permPrettyM p2</span>
<span class="lineno"> 3537 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (ValPerm_Exists mb_p) =</span>
<span class="lineno"> 3538 </span><span class="spaces">    </span><span class="nottickedoff">flip (permPrettyExprMbTyped (CruCtxNil `CruCtxCons` knownRepr)) mb_p $ \(_ :&gt;: Constant pp_n) ppm -&gt;</span>
<span class="lineno"> 3539 </span><span class="spaces">    </span><span class="nottickedoff">(\pp -&gt; hang 2 (pretty &quot;exists&quot; &lt;+&gt; pp_n &lt;&gt; dot &lt;+&gt; pp)) &lt;$&gt; ppm</span>
<span class="lineno"> 3540 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (ValPerm_Named n args off) =</span>
<span class="lineno"> 3541 </span><span class="spaces">    </span><span class="nottickedoff">do n_pp &lt;- permPrettyM n</span>
<span class="lineno"> 3542 </span><span class="spaces">       </span><span class="nottickedoff">args_pp &lt;- permPrettyM args</span>
<span class="lineno"> 3543 </span><span class="spaces">       </span><span class="nottickedoff">off_pp &lt;- permPrettyM off</span>
<span class="lineno"> 3544 </span><span class="spaces">       </span><span class="nottickedoff">return (n_pp &lt;&gt; pretty '&lt;' &lt;&gt;</span>
<span class="lineno"> 3545 </span><span class="spaces">               </span><span class="nottickedoff">align (args_pp &lt;&gt; pretty '&gt;') &lt;&gt; off_pp)</span>
<span class="lineno"> 3546 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (ValPerm_Var n off) =</span>
<span class="lineno"> 3547 </span><span class="spaces">    </span><span class="nottickedoff">do n_pp &lt;- permPrettyM n</span>
<span class="lineno"> 3548 </span><span class="spaces">       </span><span class="nottickedoff">off_pp &lt;- permPrettyM off</span>
<span class="lineno"> 3549 </span><span class="spaces">       </span><span class="nottickedoff">return (n_pp &lt;&gt; off_pp)</span>
<span class="lineno"> 3550 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM ValPerm_True = return $ pretty &quot;true&quot;</span>
<span class="lineno"> 3551 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (ValPerm_Conj ps) =</span>
<span class="lineno"> 3552 </span><span class="spaces">    </span><span class="nottickedoff">(hang 2 . encloseSep mempty mempty (pretty &quot;*&quot;)) &lt;$&gt; mapM permPrettyM ps</span>
<span class="lineno"> 3553 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (ValPerm_False) = return $ pretty &quot;false&quot;</span></span>
<span class="lineno"> 3554 </span>
<span class="lineno"> 3555 </span>instance PermPrettyF ValuePerm where
<span class="lineno"> 3556 </span>  <span class="decl"><span class="nottickedoff">permPrettyMF = permPrettyM</span></span>
<span class="lineno"> 3557 </span>
<span class="lineno"> 3558 </span>-- | Pretty-print a lifetime @l@ as either the string @[l]@, or as the empty
<span class="lineno"> 3559 </span>-- string if @l==always@
<span class="lineno"> 3560 </span>permPrettyLifetimePrefix :: PermExpr LifetimeType -&gt; PermPPM (Doc ann)
<span class="lineno"> 3561 </span><span class="decl"><span class="nottickedoff">permPrettyLifetimePrefix PExpr_Always = return emptyDoc</span>
<span class="lineno"> 3562 </span><span class="spaces"></span><span class="nottickedoff">permPrettyLifetimePrefix l = brackets &lt;$&gt; permPrettyM l</span></span>
<span class="lineno"> 3563 </span>
<span class="lineno"> 3564 </span>-- | Pretty-print an 'LLVMFieldPerm', either by itself as the form
<span class="lineno"> 3565 </span>-- @[l]ptr((rw,off) |-&gt; p)@ if the 'Bool' flag is 'False' or as part of an array
<span class="lineno"> 3566 </span>-- permission as the form @[l](rw,off) |-&gt; p@ if the 'Bool' flag is 'True'
<span class="lineno"> 3567 </span>permPrettyLLVMField :: (KnownNat w, KnownNat sz) =&gt;
<span class="lineno"> 3568 </span>                       Bool -&gt; LLVMFieldPerm w sz -&gt; PermPPM (Doc ann)
<span class="lineno"> 3569 </span><span class="decl"><span class="nottickedoff">permPrettyLLVMField in_array (LLVMFieldPerm {..} :: LLVMFieldPerm w sz) =</span>
<span class="lineno"> 3570 </span><span class="spaces">  </span><span class="nottickedoff">do let w = knownNat @w</span>
<span class="lineno"> 3571 </span><span class="spaces">     </span><span class="nottickedoff">let sz = knownNat @sz</span>
<span class="lineno"> 3572 </span><span class="spaces">     </span><span class="nottickedoff">pp_l &lt;- permPrettyLifetimePrefix llvmFieldLifetime</span>
<span class="lineno"> 3573 </span><span class="spaces">     </span><span class="nottickedoff">pp_off &lt;- permPrettyM llvmFieldOffset</span>
<span class="lineno"> 3574 </span><span class="spaces">     </span><span class="nottickedoff">pp_rw &lt;- permPrettyM llvmFieldRW</span>
<span class="lineno"> 3575 </span><span class="spaces">     </span><span class="nottickedoff">let pp_parens =</span>
<span class="lineno"> 3576 </span><span class="spaces">           </span><span class="nottickedoff">parens $</span>
<span class="lineno"> 3577 </span><span class="spaces">           </span><span class="nottickedoff">if intValue sz == intValue w then</span>
<span class="lineno"> 3578 </span><span class="spaces">             </span><span class="nottickedoff">pp_rw &lt;&gt; comma &lt;&gt; pp_off</span>
<span class="lineno"> 3579 </span><span class="spaces">           </span><span class="nottickedoff">else</span>
<span class="lineno"> 3580 </span><span class="spaces">             </span><span class="nottickedoff">pp_rw &lt;&gt; comma &lt;&gt; pp_off &lt;&gt; comma &lt;&gt; pretty (intValue sz)</span>
<span class="lineno"> 3581 </span><span class="spaces">     </span><span class="nottickedoff">pp_contents &lt;- permPrettyM llvmFieldContents</span>
<span class="lineno"> 3582 </span><span class="spaces">     </span><span class="nottickedoff">return (pp_l &lt;&gt;</span>
<span class="lineno"> 3583 </span><span class="spaces">             </span><span class="nottickedoff">(if in_array then id else (pretty &quot;ptr&quot; &lt;&gt;) . parens)</span>
<span class="lineno"> 3584 </span><span class="spaces">             </span><span class="nottickedoff">(hang 2</span>
<span class="lineno"> 3585 </span><span class="spaces">              </span><span class="nottickedoff">(pp_parens &lt;+&gt; pretty &quot;|-&gt;&quot; &lt;&gt; softline &lt;&gt; pp_contents)))</span></span>
<span class="lineno"> 3586 </span>
<span class="lineno"> 3587 </span>instance (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno"> 3588 </span>         PermPretty (LLVMFieldPerm w sz) where
<span class="lineno"> 3589 </span>  <span class="decl"><span class="nottickedoff">permPrettyM = permPrettyLLVMField False</span></span>
<span class="lineno"> 3590 </span>
<span class="lineno"> 3591 </span>instance (1 &lt;= w, KnownNat w) =&gt; PermPretty (LLVMArrayPerm w) where
<span class="lineno"> 3592 </span>  <span class="decl"><span class="nottickedoff">permPrettyM (LLVMArrayPerm {..}) =</span>
<span class="lineno"> 3593 </span><span class="spaces">    </span><span class="nottickedoff">do pp_l &lt;- permPrettyLifetimePrefix llvmArrayLifetime</span>
<span class="lineno"> 3594 </span><span class="spaces">       </span><span class="nottickedoff">pp_rw &lt;- permPrettyM llvmArrayRW</span>
<span class="lineno"> 3595 </span><span class="spaces">       </span><span class="nottickedoff">pp_off &lt;- permPrettyM llvmArrayOffset</span>
<span class="lineno"> 3596 </span><span class="spaces">       </span><span class="nottickedoff">pp_len &lt;- permPrettyM llvmArrayLen</span>
<span class="lineno"> 3597 </span><span class="spaces">       </span><span class="nottickedoff">let pp_stride = pretty (show llvmArrayStride)</span>
<span class="lineno"> 3598 </span><span class="spaces">       </span><span class="nottickedoff">pp_sh &lt;- permPrettyM llvmArrayCellShape</span>
<span class="lineno"> 3599 </span><span class="spaces">       </span><span class="nottickedoff">pp_bs &lt;- mapM permPrettyM llvmArrayBorrows</span>
<span class="lineno"> 3600 </span><span class="spaces">       </span><span class="nottickedoff">return $ PP.group (pp_l &lt;&gt; pretty &quot;array&quot; &lt;&gt;</span>
<span class="lineno"> 3601 </span><span class="spaces">                          </span><span class="nottickedoff">ppEncList True [pp_rw, pp_off, pretty &quot;&lt;&quot; &lt;&gt; pp_len,</span>
<span class="lineno"> 3602 </span><span class="spaces">                                          </span><span class="nottickedoff">pretty &quot;*&quot; &lt;&gt; pp_stride,</span>
<span class="lineno"> 3603 </span><span class="spaces">                                          </span><span class="nottickedoff">pp_sh,</span>
<span class="lineno"> 3604 </span><span class="spaces">                                          </span><span class="nottickedoff">ppEncList False pp_bs])</span></span>
<span class="lineno"> 3605 </span>
<span class="lineno"> 3606 </span>instance (1 &lt;= w, KnownNat w) =&gt; PermPretty (LLVMBlockPerm w) where
<span class="lineno"> 3607 </span>  <span class="decl"><span class="nottickedoff">permPrettyM (LLVMBlockPerm {..}) =</span>
<span class="lineno"> 3608 </span><span class="spaces">    </span><span class="nottickedoff">do pp_rw &lt;- permPrettyM llvmBlockRW</span>
<span class="lineno"> 3609 </span><span class="spaces">       </span><span class="nottickedoff">pp_l &lt;- permPrettyLifetimePrefix llvmBlockLifetime</span>
<span class="lineno"> 3610 </span><span class="spaces">       </span><span class="nottickedoff">pp_off &lt;- permPrettyM llvmBlockOffset</span>
<span class="lineno"> 3611 </span><span class="spaces">       </span><span class="nottickedoff">pp_len &lt;- permPrettyM llvmBlockLen</span>
<span class="lineno"> 3612 </span><span class="spaces">       </span><span class="nottickedoff">pp_sh &lt;- permPrettyM llvmBlockShape</span>
<span class="lineno"> 3613 </span><span class="spaces">       </span><span class="nottickedoff">return $ PP.group (pp_l &lt;&gt; pretty &quot;memblock&quot; &lt;&gt;</span>
<span class="lineno"> 3614 </span><span class="spaces">                          </span><span class="nottickedoff">ppEncList True [pp_rw, pp_off, pp_len, pp_sh])</span></span>
<span class="lineno"> 3615 </span>
<span class="lineno"> 3616 </span>instance PermPretty (AtomicPerm a) where
<span class="lineno"> 3617 </span>  <span class="decl"><span class="nottickedoff">permPrettyM (Perm_LLVMField fp) = permPrettyLLVMField False fp</span>
<span class="lineno"> 3618 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (Perm_LLVMArray ap) = permPrettyM ap</span>
<span class="lineno"> 3619 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (Perm_LLVMBlock bp) = permPrettyM bp</span>
<span class="lineno"> 3620 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (Perm_LLVMBlockShape sh) =</span>
<span class="lineno"> 3621 </span><span class="spaces">    </span><span class="nottickedoff">((pretty &quot;shape&quot; &lt;&gt;) . parens) &lt;$&gt; permPrettyM sh</span>
<span class="lineno"> 3622 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (Perm_LLVMFree e) = (pretty &quot;free&quot; &lt;+&gt;) &lt;$&gt; permPrettyM e</span>
<span class="lineno"> 3623 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (Perm_LLVMFunPtr _tp fp) =</span>
<span class="lineno"> 3624 </span><span class="spaces">    </span><span class="nottickedoff">(\pp -&gt; pretty &quot;llvmfunptr&quot; &lt;+&gt; parens pp) &lt;$&gt; permPrettyM fp</span>
<span class="lineno"> 3625 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM Perm_IsLLVMPtr = return (pretty &quot;is_llvmptr&quot;)</span>
<span class="lineno"> 3626 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (Perm_LLVMFrame fperm) =</span>
<span class="lineno"> 3627 </span><span class="spaces">    </span><span class="nottickedoff">do pps &lt;- mapM (\(e,i) -&gt; (&lt;&gt; (colon &lt;&gt; pretty i)) &lt;$&gt; permPrettyM e) fperm</span>
<span class="lineno"> 3628 </span><span class="spaces">       </span><span class="nottickedoff">return (pretty &quot;llvmframe&quot; &lt;+&gt; ppEncList False pps)</span>
<span class="lineno"> 3629 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (Perm_LOwned ls _ _ ps_in ps_out) =</span>
<span class="lineno"> 3630 </span><span class="spaces">    </span><span class="nottickedoff">do pp_in &lt;- permPrettyM ps_in</span>
<span class="lineno"> 3631 </span><span class="spaces">       </span><span class="nottickedoff">pp_out &lt;- permPrettyM ps_out</span>
<span class="lineno"> 3632 </span><span class="spaces">       </span><span class="nottickedoff">ls_pp &lt;- case ls of</span>
<span class="lineno"> 3633 </span><span class="spaces">         </span><span class="nottickedoff">[] -&gt; return emptyDoc</span>
<span class="lineno"> 3634 </span><span class="spaces">         </span><span class="nottickedoff">_ -&gt; ppEncList False &lt;$&gt; mapM permPrettyM ls</span>
<span class="lineno"> 3635 </span><span class="spaces">       </span><span class="nottickedoff">return (pretty &quot;lowned&quot; &lt;&gt; ls_pp &lt;+&gt;</span>
<span class="lineno"> 3636 </span><span class="spaces">               </span><span class="nottickedoff">parens (align $ sep [pp_in, pretty &quot;-o&quot;, pp_out]))</span>
<span class="lineno"> 3637 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (Perm_LOwnedSimple _ lops) =</span>
<span class="lineno"> 3638 </span><span class="spaces">    </span><span class="nottickedoff">(pretty &quot;lowned&quot; &lt;&gt;) &lt;$&gt; parens &lt;$&gt; permPrettyM lops</span>
<span class="lineno"> 3639 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (Perm_LCurrent l) = (pretty &quot;lcurrent&quot; &lt;+&gt;) &lt;$&gt; permPrettyM l</span>
<span class="lineno"> 3640 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM Perm_LFinished = return (pretty &quot;lfinished&quot;)</span>
<span class="lineno"> 3641 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (Perm_Struct ps) =</span>
<span class="lineno"> 3642 </span><span class="spaces">    </span><span class="nottickedoff">((pretty &quot;struct&quot; &lt;+&gt;) . parens) &lt;$&gt; permPrettyM ps</span>
<span class="lineno"> 3643 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (Perm_Fun fun_perm) = permPrettyM fun_perm</span>
<span class="lineno"> 3644 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (Perm_BVProp prop) = permPrettyM prop</span>
<span class="lineno"> 3645 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM Perm_Any = return $ pretty &quot;any&quot;</span>
<span class="lineno"> 3646 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (Perm_NamedConj n args off) =</span>
<span class="lineno"> 3647 </span><span class="spaces">    </span><span class="nottickedoff">do n_pp &lt;- permPrettyM n</span>
<span class="lineno"> 3648 </span><span class="spaces">       </span><span class="nottickedoff">args_pp &lt;- permPrettyM args</span>
<span class="lineno"> 3649 </span><span class="spaces">       </span><span class="nottickedoff">off_pp &lt;- permPrettyM off</span>
<span class="lineno"> 3650 </span><span class="spaces">       </span><span class="nottickedoff">return (n_pp &lt;&gt; pretty '&lt;' &lt;&gt; args_pp &lt;&gt; pretty '&gt;' &lt;&gt; off_pp)</span></span>
<span class="lineno"> 3651 </span>
<span class="lineno"> 3652 </span>instance PermPretty (PermOffset a) where
<span class="lineno"> 3653 </span>  <span class="decl"><span class="nottickedoff">permPrettyM NoPermOffset = return mempty</span>
<span class="lineno"> 3654 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (LLVMPermOffset e) =</span>
<span class="lineno"> 3655 </span><span class="spaces">    </span><span class="nottickedoff">do e_pp &lt;- permPrettyM e</span>
<span class="lineno"> 3656 </span><span class="spaces">       </span><span class="nottickedoff">return (pretty '@' &lt;&gt; parens e_pp)</span></span>
<span class="lineno"> 3657 </span>
<span class="lineno"> 3658 </span>instance PermPretty (FunPerm ghosts args gouts ret) where
<span class="lineno"> 3659 </span>  <span class="decl"><span class="nottickedoff">permPrettyM (FunPerm ghosts args gouts _ mb_ps_in mb_ps_out) =</span>
<span class="lineno"> 3660 </span><span class="spaces">    </span><span class="nottickedoff">fmap mbLift $ strongMbM $</span>
<span class="lineno"> 3661 </span><span class="spaces">    </span><span class="nottickedoff">flip nuMultiWithElim1 (mbValuePermsToDistPerms mb_ps_out) $</span>
<span class="lineno"> 3662 </span><span class="spaces">    </span><span class="nottickedoff">\(ghosts_args_gouts_ns :&gt;: ret_n) ps_out -&gt;</span>
<span class="lineno"> 3663 </span><span class="spaces">    </span><span class="nottickedoff">let (ghosts_ns, args_ns, gouts_ns) =</span>
<span class="lineno"> 3664 </span><span class="spaces">          </span><span class="nottickedoff">rlSplit3 (cruCtxProxies ghosts) (cruCtxProxies args)</span>
<span class="lineno"> 3665 </span><span class="spaces">          </span><span class="nottickedoff">(cruCtxProxies gouts) ghosts_args_gouts_ns in</span>
<span class="lineno"> 3666 </span><span class="spaces">    </span><span class="nottickedoff">let ps_in =</span>
<span class="lineno"> 3667 </span><span class="spaces">          </span><span class="nottickedoff">varSubst (permVarSubstOfNames $ RL.append ghosts_ns args_ns)</span>
<span class="lineno"> 3668 </span><span class="spaces">          </span><span class="nottickedoff">(mbValuePermsToDistPerms mb_ps_in) in</span>
<span class="lineno"> 3669 </span><span class="spaces">    </span><span class="nottickedoff">local (ppInfoAddExprName &quot;ret&quot; ret_n) $</span>
<span class="lineno"> 3670 </span><span class="spaces">    </span><span class="nottickedoff">local (ppInfoAddExprNames &quot;arg&quot; args_ns) $</span>
<span class="lineno"> 3671 </span><span class="spaces">    </span><span class="nottickedoff">local (ppInfoAddTypedExprNames ghosts ghosts_ns) $</span>
<span class="lineno"> 3672 </span><span class="spaces">    </span><span class="nottickedoff">local (ppInfoAddTypedExprNames gouts gouts_ns) $</span>
<span class="lineno"> 3673 </span><span class="spaces">    </span><span class="nottickedoff">do pp_ps_in  &lt;- permPrettyM ps_in</span>
<span class="lineno"> 3674 </span><span class="spaces">       </span><span class="nottickedoff">pp_ps_out &lt;- permPrettyM ps_out</span>
<span class="lineno"> 3675 </span><span class="spaces">       </span><span class="nottickedoff">pp_ghosts &lt;- permPrettyM (RL.map2 VarAndType ghosts_ns $</span>
<span class="lineno"> 3676 </span><span class="spaces">                                 </span><span class="nottickedoff">cruCtxToTypes ghosts)</span>
<span class="lineno"> 3677 </span><span class="spaces">       </span><span class="nottickedoff">pp_gouts &lt;- case gouts of</span>
<span class="lineno"> 3678 </span><span class="spaces">         </span><span class="nottickedoff">CruCtxNil -&gt; return mempty</span>
<span class="lineno"> 3679 </span><span class="spaces">         </span><span class="nottickedoff">_ -&gt; parens &lt;$&gt; permPrettyM (RL.map2 VarAndType gouts_ns $</span>
<span class="lineno"> 3680 </span><span class="spaces">                                      </span><span class="nottickedoff">cruCtxToTypes gouts)</span>
<span class="lineno"> 3681 </span><span class="spaces">       </span><span class="nottickedoff">return $ align $</span>
<span class="lineno"> 3682 </span><span class="spaces">         </span><span class="nottickedoff">sep [parens pp_ghosts &lt;&gt; dot, pp_ps_in, pretty &quot;-o&quot;,</span>
<span class="lineno"> 3683 </span><span class="spaces">              </span><span class="nottickedoff">pp_gouts &lt;&gt; pp_ps_out]</span></span>
<span class="lineno"> 3684 </span>
<span class="lineno"> 3685 </span>instance PermPretty (BVRange w) where
<span class="lineno"> 3686 </span>  <span class="decl"><span class="nottickedoff">permPrettyM (BVRange e1 e2) =</span>
<span class="lineno"> 3687 </span><span class="spaces">    </span><span class="nottickedoff">(\pp1 pp2 -&gt; braces (pp1 &lt;&gt; comma &lt;+&gt; pp2))</span>
<span class="lineno"> 3688 </span><span class="spaces">    </span><span class="nottickedoff">&lt;$&gt; permPrettyM e1 &lt;*&gt; permPrettyM e2</span></span>
<span class="lineno"> 3689 </span>
<span class="lineno"> 3690 </span>instance PermPretty (MbRangeForType a) where
<span class="lineno"> 3691 </span>  <span class="decl"><span class="nottickedoff">permPrettyM (MbRangeForLLVMType _ mb_rw mb_l mb_rng) =</span>
<span class="lineno"> 3692 </span><span class="spaces">    </span><span class="nottickedoff">permPrettyMb</span>
<span class="lineno"> 3693 </span><span class="spaces">    </span><span class="nottickedoff">(\ns_pp (rw,l,rng) -&gt;</span>
<span class="lineno"> 3694 </span><span class="spaces">      </span><span class="nottickedoff">do pp_rw &lt;- permPrettyM rw</span>
<span class="lineno"> 3695 </span><span class="spaces">         </span><span class="nottickedoff">pp_l_prefix &lt;- permPrettyLifetimePrefix l</span>
<span class="lineno"> 3696 </span><span class="spaces">         </span><span class="nottickedoff">pp_rng &lt;- permPrettyM rng</span>
<span class="lineno"> 3697 </span><span class="spaces">         </span><span class="nottickedoff">return (ppEncList True (RL.toList ns_pp) &lt;&gt; dot &lt;&gt; line &lt;&gt;</span>
<span class="lineno"> 3698 </span><span class="spaces">                 </span><span class="nottickedoff">pp_l_prefix &lt;&gt; parens pp_rw &lt;&gt; pp_rng)) $</span>
<span class="lineno"> 3699 </span><span class="spaces">    </span><span class="nottickedoff">mbMap3 (,,) mb_rw mb_l mb_rng</span></span>
<span class="lineno"> 3700 </span>
<span class="lineno"> 3701 </span>instance PermPretty (BVProp w) where
<span class="lineno"> 3702 </span>  <span class="decl"><span class="nottickedoff">permPrettyM (BVProp_Eq e1 e2) =</span>
<span class="lineno"> 3703 </span><span class="spaces">    </span><span class="nottickedoff">(\pp1 pp2 -&gt; pp1 &lt;+&gt; equals &lt;+&gt; pp2) &lt;$&gt; permPrettyM e1 &lt;*&gt; permPrettyM e2</span>
<span class="lineno"> 3704 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (BVProp_Neq e1 e2) =</span>
<span class="lineno"> 3705 </span><span class="spaces">    </span><span class="nottickedoff">(\pp1 pp2 -&gt; pp1 &lt;+&gt; pretty &quot;/=&quot; &lt;+&gt; pp2) &lt;$&gt; permPrettyM e1 &lt;*&gt; permPrettyM e2</span>
<span class="lineno"> 3706 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (BVProp_ULt e1 e2) =</span>
<span class="lineno"> 3707 </span><span class="spaces">    </span><span class="nottickedoff">(\pp1 pp2 -&gt; pp1 &lt;+&gt; pretty &quot;&lt;u&quot; &lt;+&gt; pp2) &lt;$&gt; permPrettyM e1 &lt;*&gt; permPrettyM e2</span>
<span class="lineno"> 3708 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (BVProp_ULeq e1 e2) =</span>
<span class="lineno"> 3709 </span><span class="spaces">    </span><span class="nottickedoff">(\pp1 pp2 -&gt; pp1 &lt;+&gt; pretty &quot;&lt;=u&quot; &lt;+&gt; pp2) &lt;$&gt; permPrettyM e1 &lt;*&gt; permPrettyM e2</span>
<span class="lineno"> 3710 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (BVProp_ULeq_Diff e1 e2 e3) =</span>
<span class="lineno"> 3711 </span><span class="spaces">    </span><span class="nottickedoff">(\pp1 pp2 pp3 -&gt; pp1 &lt;+&gt; pretty &quot;&lt;=u&quot; &lt;+&gt; pp2 &lt;+&gt; pretty '-' &lt;+&gt; pp3)</span>
<span class="lineno"> 3712 </span><span class="spaces">    </span><span class="nottickedoff">&lt;$&gt; permPrettyM e1 &lt;*&gt; permPrettyM e2 &lt;*&gt; permPrettyM e3</span></span>
<span class="lineno"> 3713 </span>
<span class="lineno"> 3714 </span>instance PermPretty (LLVMArrayBorrow w) where
<span class="lineno"> 3715 </span>  <span class="decl"><span class="nottickedoff">permPrettyM (FieldBorrow ix) = permPrettyM ix</span>
<span class="lineno"> 3716 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (RangeBorrow rng) = permPrettyM rng</span></span>
<span class="lineno"> 3717 </span>
<span class="lineno"> 3718 </span>instance PermPretty (VarAndPerm a) where
<span class="lineno"> 3719 </span>  <span class="decl"><span class="nottickedoff">permPrettyM (VarAndPerm x p) =</span>
<span class="lineno"> 3720 </span><span class="spaces">    </span><span class="nottickedoff">(\pp1 pp2 -&gt; pp1 &lt;&gt; colon &lt;&gt; pp2) &lt;$&gt; permPrettyM x &lt;*&gt; permPrettyM p</span></span>
<span class="lineno"> 3721 </span>
<span class="lineno"> 3722 </span>instance PermPrettyF VarAndPerm where
<span class="lineno"> 3723 </span>  <span class="decl"><span class="nottickedoff">permPrettyMF = permPrettyM</span></span>
<span class="lineno"> 3724 </span>
<span class="lineno"> 3725 </span>instance (PermPretty a, PermPretty b) =&gt; PermPretty (ColonPair a b) where
<span class="lineno"> 3726 </span>  <span class="decl"><span class="nottickedoff">permPrettyM (ColonPair a b) =</span>
<span class="lineno"> 3727 </span><span class="spaces">    </span><span class="nottickedoff">(\pp1 pp2 -&gt; pp1 &lt;&gt; colon &lt;&gt; pp2) &lt;$&gt; permPrettyM a &lt;*&gt; permPrettyM b</span></span>
<span class="lineno"> 3728 </span>
<span class="lineno"> 3729 </span>
<span class="lineno"> 3730 </span>{-
<span class="lineno"> 3731 </span>instance PermPretty (DistPerms ps) where
<span class="lineno"> 3732 </span>  permPrettyM ps = ppCommaSep &lt;$&gt; helper ps where
<span class="lineno"> 3733 </span>    helper :: DistPerms ps' -&gt; PermPPM [Doc ann]
<span class="lineno"> 3734 </span>    helper DistPermsNil = return []
<span class="lineno"> 3735 </span>    helper (DistPermsCons ps x p) =
<span class="lineno"> 3736 </span>      do x_pp &lt;- permPrettyM x
<span class="lineno"> 3737 </span>         p_pp &lt;- permPrettyM p
<span class="lineno"> 3738 </span>         (++ [x_pp &lt;&gt; colon &lt;&gt; p_pp]) &lt;$&gt; helper ps
<span class="lineno"> 3739 </span>-}
<span class="lineno"> 3740 </span>
<span class="lineno"> 3741 </span>instance PermPretty (ExprAndPerm a) where
<span class="lineno"> 3742 </span>  <span class="decl"><span class="nottickedoff">permPrettyM (ExprAndPerm x p) =</span>
<span class="lineno"> 3743 </span><span class="spaces">    </span><span class="nottickedoff">(\pp1 pp2 -&gt; pp1 &lt;&gt; colon &lt;&gt; pp2) &lt;$&gt; permPrettyM x &lt;*&gt; permPrettyM p</span></span>
<span class="lineno"> 3744 </span>
<span class="lineno"> 3745 </span>instance PermPrettyF ExprAndPerm where
<span class="lineno"> 3746 </span>  <span class="decl"><span class="nottickedoff">permPrettyMF = permPrettyM</span></span>
<span class="lineno"> 3747 </span>
<span class="lineno"> 3748 </span>-- | Embed a 'ValuePerm' in a 'PermExpr' - like 'PExpr_ValPerm' but maps
<span class="lineno"> 3749 </span>-- 'ValPerm_Var's to 'PExpr_Var's
<span class="lineno"> 3750 </span>permToExpr :: ValuePerm a -&gt; PermExpr (ValuePermType a)
<span class="lineno"> 3751 </span><span class="decl"><span class="nottickedoff">permToExpr (ValPerm_Var n NoPermOffset) = PExpr_Var n</span>
<span class="lineno"> 3752 </span><span class="spaces"></span><span class="nottickedoff">permToExpr a = PExpr_ValPerm a</span></span>
<span class="lineno"> 3753 </span>
<span class="lineno"> 3754 </span>-- | Extract @p1@ from a permission of the form @p1 \/ p2@
<span class="lineno"> 3755 </span>orPermLeft :: ValuePerm a -&gt; ValuePerm a
<span class="lineno"> 3756 </span><span class="decl"><span class="nottickedoff">orPermLeft (ValPerm_Or p _) = p</span>
<span class="lineno"> 3757 </span><span class="spaces"></span><span class="nottickedoff">orPermLeft _ = error &quot;orPermLeft&quot;</span></span>
<span class="lineno"> 3758 </span>
<span class="lineno"> 3759 </span>-- | Extract @p2@ from a permission of the form @p1 \/ p2@
<span class="lineno"> 3760 </span>orPermRight :: ValuePerm a -&gt; ValuePerm a
<span class="lineno"> 3761 </span><span class="decl"><span class="nottickedoff">orPermRight (ValPerm_Or _ p) = p</span>
<span class="lineno"> 3762 </span><span class="spaces"></span><span class="nottickedoff">orPermRight _ = error &quot;orPermRight&quot;</span></span>
<span class="lineno"> 3763 </span>
<span class="lineno"> 3764 </span>-- | Extract the body @p@ from a permission of the form @exists (x:tp).p@
<span class="lineno"> 3765 </span>exPermBody :: TypeRepr tp -&gt; ValuePerm a -&gt; Binding tp (ValuePerm a)
<span class="lineno"> 3766 </span><span class="decl"><span class="nottickedoff">exPermBody tp (ValPerm_Exists (p :: Binding tp' (ValuePerm a)))</span>
<span class="lineno"> 3767 </span><span class="spaces">  </span><span class="nottickedoff">| Just Refl &lt;- testEquality tp (knownRepr :: TypeRepr tp') = p</span>
<span class="lineno"> 3768 </span><span class="spaces"></span><span class="nottickedoff">exPermBody _ _ = error &quot;exPermBody&quot;</span></span>
<span class="lineno"> 3769 </span>
<span class="lineno"> 3770 </span>-- | Construct 0 or more nested existential permissions
<span class="lineno"> 3771 </span>valPermExistsMulti :: KnownCruCtx ctx -&gt; Mb ctx (ValuePerm a) -&gt; ValuePerm a
<span class="lineno"> 3772 </span><span class="decl"><span class="nottickedoff">valPermExistsMulti MNil mb_p = elimEmptyMb mb_p</span>
<span class="lineno"> 3773 </span><span class="spaces"></span><span class="nottickedoff">valPermExistsMulti (ctx :&gt;: KnownReprObj) mb_p =</span>
<span class="lineno"> 3774 </span><span class="spaces">  </span><span class="nottickedoff">valPermExistsMulti ctx (fmap ValPerm_Exists $</span>
<span class="lineno"> 3775 </span><span class="spaces">                          </span><span class="nottickedoff">mbSeparate (MNil :&gt;: Proxy) mb_p)</span></span>
<span class="lineno"> 3776 </span>
<span class="lineno"> 3777 </span>-- | Test if an 'AtomicPerm' is a field permission
<span class="lineno"> 3778 </span>isLLVMFieldPerm :: AtomicPerm a -&gt; Bool
<span class="lineno"> 3779 </span><span class="decl"><span class="nottickedoff">isLLVMFieldPerm (Perm_LLVMField _) = True</span>
<span class="lineno"> 3780 </span><span class="spaces"></span><span class="nottickedoff">isLLVMFieldPerm _ = False</span></span>
<span class="lineno"> 3781 </span>
<span class="lineno"> 3782 </span>-- | Test if an 'AtomicPerm' is a field permission with the given offset
<span class="lineno"> 3783 </span>isLLVMFieldPermWithOffset :: PermExpr (BVType w) -&gt;
<span class="lineno"> 3784 </span>                             AtomicPerm (LLVMPointerType w) -&gt; Bool
<span class="lineno"> 3785 </span><span class="decl"><span class="nottickedoff">isLLVMFieldPermWithOffset off (Perm_LLVMField fp) =</span>
<span class="lineno"> 3786 </span><span class="spaces">  </span><span class="nottickedoff">bvEq off (llvmFieldOffset fp)</span>
<span class="lineno"> 3787 </span><span class="spaces"></span><span class="nottickedoff">isLLVMFieldPermWithOffset _ _ = False</span></span>
<span class="lineno"> 3788 </span>
<span class="lineno"> 3789 </span>-- | Test if an 'AtomicPerm' starts with the given offset
<span class="lineno"> 3790 </span>isLLVMAtomicPermWithOffset :: PermExpr (BVType w) -&gt;
<span class="lineno"> 3791 </span>                              AtomicPerm (LLVMPointerType w) -&gt; Bool
<span class="lineno"> 3792 </span><span class="decl"><span class="nottickedoff">isLLVMAtomicPermWithOffset off p</span>
<span class="lineno"> 3793 </span><span class="spaces">  </span><span class="nottickedoff">| Just off' &lt;- llvmAtomicPermOffset p = bvEq off off'</span>
<span class="lineno"> 3794 </span><span class="spaces"></span><span class="nottickedoff">isLLVMAtomicPermWithOffset _ _ = False</span></span>
<span class="lineno"> 3795 </span>
<span class="lineno"> 3796 </span>-- | Test if an 'AtomicPerm' is an array permission
<span class="lineno"> 3797 </span>isLLVMArrayPerm :: AtomicPerm a -&gt; Bool
<span class="lineno"> 3798 </span><span class="decl"><span class="nottickedoff">isLLVMArrayPerm (Perm_LLVMArray _) = True</span>
<span class="lineno"> 3799 </span><span class="spaces"></span><span class="nottickedoff">isLLVMArrayPerm _ = False</span></span>
<span class="lineno"> 3800 </span>
<span class="lineno"> 3801 </span>-- | Test if an 'AtomicPerm' is an llvmblock permission
<span class="lineno"> 3802 </span>isLLVMBlockPerm :: AtomicPerm a -&gt; Bool
<span class="lineno"> 3803 </span><span class="decl"><span class="nottickedoff">isLLVMBlockPerm (Perm_LLVMBlock _) = True</span>
<span class="lineno"> 3804 </span><span class="spaces"></span><span class="nottickedoff">isLLVMBlockPerm _ = False</span></span>
<span class="lineno"> 3805 </span>
<span class="lineno"> 3806 </span>-- | Test if an 'AtomicPerm' is any form of pointer permission
<span class="lineno"> 3807 </span>isLLVMPointerPerm :: AtomicPerm a -&gt; Bool
<span class="lineno"> 3808 </span><span class="decl"><span class="nottickedoff">isLLVMPointerPerm (Perm_LLVMField _) = True</span>
<span class="lineno"> 3809 </span><span class="spaces"></span><span class="nottickedoff">isLLVMPointerPerm (Perm_LLVMArray _) = True</span>
<span class="lineno"> 3810 </span><span class="spaces"></span><span class="nottickedoff">isLLVMPointerPerm (Perm_LLVMBlock _) = True</span>
<span class="lineno"> 3811 </span><span class="spaces"></span><span class="nottickedoff">isLLVMPointerPerm (Perm_LLVMFunPtr _ _) = True</span>
<span class="lineno"> 3812 </span><span class="spaces"></span><span class="nottickedoff">isLLVMPointerPerm _ = False</span></span>
<span class="lineno"> 3813 </span>
<span class="lineno"> 3814 </span>-- | Test if an 'AtomicPerm' is a lifetime permission
<span class="lineno"> 3815 </span>isLifetimePerm :: AtomicPerm a -&gt; Maybe (a :~: LifetimeType)
<span class="lineno"> 3816 </span><span class="decl"><span class="nottickedoff">isLifetimePerm (Perm_LOwned _ _ _ _ _) = Just Refl</span>
<span class="lineno"> 3817 </span><span class="spaces"></span><span class="nottickedoff">isLifetimePerm (Perm_LOwnedSimple _ _) = Just Refl</span>
<span class="lineno"> 3818 </span><span class="spaces"></span><span class="nottickedoff">isLifetimePerm (Perm_LCurrent _) = Just Refl</span>
<span class="lineno"> 3819 </span><span class="spaces"></span><span class="nottickedoff">isLifetimePerm Perm_LFinished = Just Refl</span>
<span class="lineno"> 3820 </span><span class="spaces"></span><span class="nottickedoff">isLifetimePerm _ = Nothing</span></span>
<span class="lineno"> 3821 </span>
<span class="lineno"> 3822 </span>-- | Test if an 'AtomicPerm' is a lifetime permission that gives ownership
<span class="lineno"> 3823 </span>isLifetimeOwnershipPerm :: AtomicPerm a -&gt; Maybe (a :~: LifetimeType)
<span class="lineno"> 3824 </span><span class="decl"><span class="nottickedoff">isLifetimeOwnershipPerm (Perm_LOwned _ _ _ _ _) = Just Refl</span>
<span class="lineno"> 3825 </span><span class="spaces"></span><span class="nottickedoff">isLifetimeOwnershipPerm (Perm_LOwnedSimple _ _) = Just Refl</span>
<span class="lineno"> 3826 </span><span class="spaces"></span><span class="nottickedoff">isLifetimeOwnershipPerm _ = Nothing</span></span>
<span class="lineno"> 3827 </span>
<span class="lineno"> 3828 </span>-- | Test if an 'AtomicPerm' is a struct permission
<span class="lineno"> 3829 </span>isStructPerm :: AtomicPerm a -&gt; Bool
<span class="lineno"> 3830 </span><span class="decl"><span class="nottickedoff">isStructPerm (Perm_Struct _) = True</span>
<span class="lineno"> 3831 </span><span class="spaces"></span><span class="nottickedoff">isStructPerm _ = False</span></span>
<span class="lineno"> 3832 </span>
<span class="lineno"> 3833 </span>-- | Test if an 'AtomicPerm' is a function permission
<span class="lineno"> 3834 </span>isFunPerm :: AtomicPerm a -&gt; Bool
<span class="lineno"> 3835 </span><span class="decl"><span class="nottickedoff">isFunPerm (Perm_Fun _) = True</span>
<span class="lineno"> 3836 </span><span class="spaces"></span><span class="nottickedoff">isFunPerm _ = False</span></span>
<span class="lineno"> 3837 </span>
<span class="lineno"> 3838 </span>-- | Test if an 'AtomicPerm' is a named conjunctive permission
<span class="lineno"> 3839 </span>isNamedConjPerm :: AtomicPerm a -&gt; Bool
<span class="lineno"> 3840 </span><span class="decl"><span class="nottickedoff">isNamedConjPerm (Perm_NamedConj _ _ _) = True</span>
<span class="lineno"> 3841 </span><span class="spaces"></span><span class="nottickedoff">isNamedConjPerm _ = False</span></span>
<span class="lineno"> 3842 </span>
<span class="lineno"> 3843 </span>-- | Test if an 'AtomicPerm' is a foldable named conjunctive permission
<span class="lineno"> 3844 </span>isFoldableConjPerm :: AtomicPerm a -&gt; Bool
<span class="lineno"> 3845 </span><span class="decl"><span class="nottickedoff">isFoldableConjPerm (Perm_NamedConj npn _ _) = nameCanFold npn</span>
<span class="lineno"> 3846 </span><span class="spaces"></span><span class="nottickedoff">isFoldableConjPerm _ = False</span></span>
<span class="lineno"> 3847 </span>
<span class="lineno"> 3848 </span>-- | Test if an 'AtomicPerm' is a defined conjunctive permission
<span class="lineno"> 3849 </span>isDefinedConjPerm :: AtomicPerm a -&gt; Bool
<span class="lineno"> 3850 </span><span class="decl"><span class="nottickedoff">isDefinedConjPerm (Perm_NamedConj</span>
<span class="lineno"> 3851 </span><span class="spaces">                   </span><span class="nottickedoff">(namedPermNameSort -&gt; DefinedSortRepr _) _ _) = True</span>
<span class="lineno"> 3852 </span><span class="spaces"></span><span class="nottickedoff">isDefinedConjPerm _ = False</span></span>
<span class="lineno"> 3853 </span>
<span class="lineno"> 3854 </span>-- | Test if an 'AtomicPerm' is a recursive conjunctive permission
<span class="lineno"> 3855 </span>isRecursiveConjPerm :: AtomicPerm a -&gt; Bool
<span class="lineno"> 3856 </span><span class="decl"><span class="nottickedoff">isRecursiveConjPerm (Perm_NamedConj</span>
<span class="lineno"> 3857 </span><span class="spaces">                     </span><span class="nottickedoff">(namedPermNameSort -&gt; RecursiveSortRepr _ _) _ _) = True</span>
<span class="lineno"> 3858 </span><span class="spaces"></span><span class="nottickedoff">isRecursiveConjPerm _ = False</span></span>
<span class="lineno"> 3859 </span>
<span class="lineno"> 3860 </span>-- | Test that a permission is a conjunctive permission, meaning that it is
<span class="lineno"> 3861 </span>-- built inductively using only existentials, disjunctions, conjunctive named
<span class="lineno"> 3862 </span>-- permissions, and conjunctions of atomic permissions. Note that an atomic
<span class="lineno"> 3863 </span>-- permissions in such a conjunction can itself contain equality permissions;
<span class="lineno"> 3864 </span>-- e.g., in LLVM field permissions.
<span class="lineno"> 3865 </span>isConjPerm :: ValuePerm a -&gt; Bool
<span class="lineno"> 3866 </span><span class="decl"><span class="nottickedoff">isConjPerm (ValPerm_Eq _) = False</span>
<span class="lineno"> 3867 </span><span class="spaces"></span><span class="nottickedoff">isConjPerm (ValPerm_Or p1 p2) = isConjPerm p1 &amp;&amp; isConjPerm p2</span>
<span class="lineno"> 3868 </span><span class="spaces"></span><span class="nottickedoff">isConjPerm (ValPerm_Exists mb_p) = mbLift $ fmap isConjPerm mb_p</span>
<span class="lineno"> 3869 </span><span class="spaces"></span><span class="nottickedoff">isConjPerm (ValPerm_Named n _ _) = nameSortIsConj (namedPermNameSort n)</span>
<span class="lineno"> 3870 </span><span class="spaces"></span><span class="nottickedoff">isConjPerm (ValPerm_Var _ _) = False</span>
<span class="lineno"> 3871 </span><span class="spaces"></span><span class="nottickedoff">isConjPerm (ValPerm_Conj _) = True</span>
<span class="lineno"> 3872 </span><span class="spaces"></span><span class="nottickedoff">isConjPerm (ValPerm_False) = False</span></span>
<span class="lineno"> 3873 </span>
<span class="lineno"> 3874 </span>-- | Return a struct permission where all fields have @true@ permissions
<span class="lineno"> 3875 </span>trueStructAtomicPerm :: Assignment prx ctx -&gt; AtomicPerm (StructType ctx)
<span class="lineno"> 3876 </span><span class="decl"><span class="nottickedoff">trueStructAtomicPerm =</span>
<span class="lineno"> 3877 </span><span class="spaces">  </span><span class="nottickedoff">Perm_Struct . RL.map (const ValPerm_True). assignToRList</span></span>
<span class="lineno"> 3878 </span>
<span class="lineno"> 3879 </span>-- | Take two list of atomic struct permissions, one for structs with fields
<span class="lineno"> 3880 </span>-- given by @ctx1@ and one with those given by @ctx2@, and append them pointwise
<span class="lineno"> 3881 </span>-- to get a list of atomic struct permissions whose fields are given by the
<span class="lineno"> 3882 </span>-- append @ctx1 &lt;+&gt; ctx2@. If one list is shorter than the other, fill it out
<span class="lineno"> 3883 </span>-- with struct permissions @struct (true, ..., true)@ of all @true@ permissions.
<span class="lineno"> 3884 </span>-- This only works if both lists have only 'Perm_Struct' permissions, and
<span class="lineno"> 3885 </span>-- otherwise return 'Nothing'.
<span class="lineno"> 3886 </span>tryAppendStructAPerms :: Assignment prx1 ctx1 -&gt; Assignment prx2 ctx2 -&gt;
<span class="lineno"> 3887 </span>                         [AtomicPerm (StructType ctx1)] -&gt;
<span class="lineno"> 3888 </span>                         [AtomicPerm (StructType ctx2)] -&gt;
<span class="lineno"> 3889 </span>                         Maybe [AtomicPerm (StructType (ctx1 &lt;+&gt; ctx2))]
<span class="lineno"> 3890 </span><span class="decl"><span class="nottickedoff">tryAppendStructAPerms _ _ [] [] = return []</span>
<span class="lineno"> 3891 </span><span class="spaces"></span><span class="nottickedoff">tryAppendStructAPerms ctx1 ctx2 (Perm_Struct fs_ps:ps) (Perm_Struct fs_qs:qs) =</span>
<span class="lineno"> 3892 </span><span class="spaces">  </span><span class="nottickedoff">(Perm_Struct (assignToRListAppend ctx1 ctx2 fs_ps fs_qs) :) &lt;$&gt;</span>
<span class="lineno"> 3893 </span><span class="spaces">  </span><span class="nottickedoff">tryAppendStructAPerms ctx1 ctx2 ps qs</span>
<span class="lineno"> 3894 </span><span class="spaces"></span><span class="nottickedoff">tryAppendStructAPerms ctx1 ctx2 [] qs =</span>
<span class="lineno"> 3895 </span><span class="spaces">  </span><span class="nottickedoff">tryAppendStructAPerms ctx1 ctx2 [trueStructAtomicPerm ctx1] qs</span>
<span class="lineno"> 3896 </span><span class="spaces"></span><span class="nottickedoff">tryAppendStructAPerms ctx1 ctx2 ps [] =</span>
<span class="lineno"> 3897 </span><span class="spaces">  </span><span class="nottickedoff">tryAppendStructAPerms ctx1 ctx2 ps [trueStructAtomicPerm ctx2]</span>
<span class="lineno"> 3898 </span><span class="spaces"></span><span class="nottickedoff">tryAppendStructAPerms _ _ _ _ = mzero</span></span>
<span class="lineno"> 3899 </span>
<span class="lineno"> 3900 </span>-- | Try to append struct permissions for structs with fields given by @ctx1@
<span class="lineno"> 3901 </span>-- and @ctx2@ to get a permission for structs with fields given by the append
<span class="lineno"> 3902 </span>-- @ctx1 &lt;+&gt; ctx2@ of these two contexts. Return 'Nothing' if this is not
<span class="lineno"> 3903 </span>-- possible.
<span class="lineno"> 3904 </span>tryAppendStructPerms :: Assignment prx1 ctx1 -&gt; Assignment prx2 ctx2 -&gt;
<span class="lineno"> 3905 </span>                        ValuePerm (StructType ctx1) -&gt;
<span class="lineno"> 3906 </span>                        ValuePerm (StructType ctx2) -&gt;
<span class="lineno"> 3907 </span>                        Maybe (ValuePerm (StructType (ctx1 &lt;+&gt; ctx2)))
<span class="lineno"> 3908 </span><span class="decl"><span class="nottickedoff">tryAppendStructPerms ctx1 ctx2 (ValPerm_Or p1 p2) q =</span>
<span class="lineno"> 3909 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_Or &lt;$&gt; tryAppendStructPerms ctx1 ctx2 p1 q &lt;*&gt;</span>
<span class="lineno"> 3910 </span><span class="spaces">  </span><span class="nottickedoff">tryAppendStructPerms ctx1 ctx2 p2 q</span>
<span class="lineno"> 3911 </span><span class="spaces"></span><span class="nottickedoff">tryAppendStructPerms ctx1 ctx2 p (ValPerm_Or q1 q2) =</span>
<span class="lineno"> 3912 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_Or &lt;$&gt; tryAppendStructPerms ctx1 ctx2 p q1 &lt;*&gt;</span>
<span class="lineno"> 3913 </span><span class="spaces">  </span><span class="nottickedoff">tryAppendStructPerms ctx1 ctx2 p q2</span>
<span class="lineno"> 3914 </span><span class="spaces"></span><span class="nottickedoff">tryAppendStructPerms ctx1 ctx2 (ValPerm_Exists mb_p) q =</span>
<span class="lineno"> 3915 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_Exists &lt;$&gt; mbMaybe (flip fmap mb_p $ \p -&gt;</span>
<span class="lineno"> 3916 </span><span class="spaces">                               </span><span class="nottickedoff">tryAppendStructPerms ctx1 ctx2 p q)</span>
<span class="lineno"> 3917 </span><span class="spaces"></span><span class="nottickedoff">tryAppendStructPerms ctx1 ctx2 p (ValPerm_Exists mb_q) =</span>
<span class="lineno"> 3918 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_Exists &lt;$&gt; mbMaybe (flip fmap mb_q $ \q -&gt;</span>
<span class="lineno"> 3919 </span><span class="spaces">                               </span><span class="nottickedoff">tryAppendStructPerms ctx1 ctx2 p q)</span>
<span class="lineno"> 3920 </span><span class="spaces"></span><span class="nottickedoff">tryAppendStructPerms ctx1 ctx2 (ValPerm_Conj ps) (ValPerm_Conj qs) =</span>
<span class="lineno"> 3921 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_Conj &lt;$&gt; tryAppendStructAPerms ctx1 ctx2 ps qs</span>
<span class="lineno"> 3922 </span><span class="spaces"></span><span class="nottickedoff">tryAppendStructPerms _ _ _ _ = mzero</span></span>
<span class="lineno"> 3923 </span>
<span class="lineno"> 3924 </span>
<span class="lineno"> 3925 </span>-- | Helper function to build a 'Perm_LLVMFunPtr' from a 'FunPerm'
<span class="lineno"> 3926 </span>mkPermLLVMFunPtr :: (1 &lt;= w, KnownNat w) =&gt; f w -&gt;
<span class="lineno"> 3927 </span>                    FunPerm ghosts args gouts ret -&gt;
<span class="lineno"> 3928 </span>                    AtomicPerm (LLVMPointerType w)
<span class="lineno"> 3929 </span><span class="decl"><span class="nottickedoff">mkPermLLVMFunPtr (_w :: f w) fun_perm =</span>
<span class="lineno"> 3930 </span><span class="spaces">  </span><span class="nottickedoff">case cruCtxToReprEq (funPermArgs fun_perm) of</span>
<span class="lineno"> 3931 </span><span class="spaces">    </span><span class="nottickedoff">Refl -&gt;</span>
<span class="lineno"> 3932 </span><span class="spaces">      </span><span class="nottickedoff">Perm_LLVMFunPtr (FunctionHandleRepr</span>
<span class="lineno"> 3933 </span><span class="spaces">                       </span><span class="nottickedoff">(cruCtxToRepr $ funPermArgs fun_perm)</span>
<span class="lineno"> 3934 </span><span class="spaces">                       </span><span class="nottickedoff">(funPermRet fun_perm))</span>
<span class="lineno"> 3935 </span><span class="spaces">      </span><span class="nottickedoff">(ValPerm_Conj1 $ Perm_Fun fun_perm)</span></span>
<span class="lineno"> 3936 </span>
<span class="lineno"> 3937 </span>-- | Helper function to build a 'Perm_LLVMFunPtr' from a list of 'FunPerm's. The
<span class="lineno"> 3938 </span>-- list must be non-empty.
<span class="lineno"> 3939 </span>mkPermLLVMFunPtrs :: (1 &lt;= w, KnownNat w) =&gt; f w -&gt; [SomeFunPerm args ret] -&gt;
<span class="lineno"> 3940 </span>                     AtomicPerm (LLVMPointerType w)
<span class="lineno"> 3941 </span><span class="decl"><span class="nottickedoff">mkPermLLVMFunPtrs (_w :: f w) [] = error &quot;mkPermLLVMFunPtrs: empty list&quot;</span>
<span class="lineno"> 3942 </span><span class="spaces"></span><span class="nottickedoff">mkPermLLVMFunPtrs (_w :: f w) fun_perms@(SomeFunPerm fun_perm:_) =</span>
<span class="lineno"> 3943 </span><span class="spaces">  </span><span class="nottickedoff">case cruCtxToReprEq (funPermArgs fun_perm) of</span>
<span class="lineno"> 3944 </span><span class="spaces">    </span><span class="nottickedoff">Refl -&gt;</span>
<span class="lineno"> 3945 </span><span class="spaces">      </span><span class="nottickedoff">Perm_LLVMFunPtr (FunctionHandleRepr</span>
<span class="lineno"> 3946 </span><span class="spaces">                       </span><span class="nottickedoff">(cruCtxToRepr $ funPermArgs fun_perm)</span>
<span class="lineno"> 3947 </span><span class="spaces">                       </span><span class="nottickedoff">(funPermRet fun_perm))</span>
<span class="lineno"> 3948 </span><span class="spaces">      </span><span class="nottickedoff">(ValPerm_Conj $ map (\(SomeFunPerm fp) -&gt; Perm_Fun fp) fun_perms)</span></span>
<span class="lineno"> 3949 </span>
<span class="lineno"> 3950 </span>-- | The shape for an @eq(llvmword(w))@ permission
<span class="lineno"> 3951 </span>llvmEqWordShape :: (1 &lt;= w, KnownNat w) =&gt; prx w -&gt; Integer -&gt;
<span class="lineno"> 3952 </span>                   PermExpr (LLVMShapeType w)
<span class="lineno"> 3953 </span><span class="decl"><span class="nottickedoff">llvmEqWordShape w i =</span>
<span class="lineno"> 3954 </span><span class="spaces">  </span><span class="nottickedoff">PExpr_FieldShape $ LLVMFieldShape $ ValPerm_Eq $</span>
<span class="lineno"> 3955 </span><span class="spaces">  </span><span class="nottickedoff">PExpr_LLVMWord $ bvIntOfSize w i</span></span>
<span class="lineno"> 3956 </span>
<span class="lineno"> 3957 </span>-- | Existential permission @x:eq(word(e))@ for some @e@
<span class="lineno"> 3958 </span>llvmExEqWord :: (1 &lt;= w, KnownNat w) =&gt; prx w -&gt;
<span class="lineno"> 3959 </span>                Binding (BVType w) (ValuePerm (LLVMPointerType w))
<span class="lineno"> 3960 </span><span class="decl"><span class="nottickedoff">llvmExEqWord _ = nu $ \e -&gt; ValPerm_Eq (PExpr_LLVMWord $ PExpr_Var e)</span></span>
<span class="lineno"> 3961 </span>
<span class="lineno"> 3962 </span>{-
<span class="lineno"> 3963 </span>-- | Create a field pointer permission with offset 0 and @eq(e)@ permissions
<span class="lineno"> 3964 </span>-- with the given read-write modality
<span class="lineno"> 3965 </span>llvmFieldContents0Eq :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 3966 </span>                    RWModality -&gt; PermExpr (LLVMPointerType w) -&gt;
<span class="lineno"> 3967 </span>                    LLVMPtrPerm w
<span class="lineno"> 3968 </span>llvmFieldContents0Eq rw e =
<span class="lineno"> 3969 </span>  Perm_LLVMField $ LLVMFieldPerm { llvmFieldRW = rw,
<span class="lineno"> 3970 </span>                                   llvmFieldOffset = bvInt 0,
<span class="lineno"> 3971 </span>                                   llvmFieldContents = ValPerm_Eq e }
<span class="lineno"> 3972 </span>-}
<span class="lineno"> 3973 </span>
<span class="lineno"> 3974 </span>-- | Create a field permission to read a known value from offset 0 of an LLVM
<span class="lineno"> 3975 </span>-- pointer using an existential modality, lifetime, and value
<span class="lineno"> 3976 </span>llvmPtr0EqEx :: (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt; prx sz -&gt;
<span class="lineno"> 3977 </span>                Mb (RNil :&gt; RWModalityType :&gt; LifetimeType :&gt; LLVMPointerType sz)
<span class="lineno"> 3978 </span>                (LLVMFieldPerm w sz)
<span class="lineno"> 3979 </span><span class="decl"><span class="nottickedoff">llvmPtr0EqEx _ =</span>
<span class="lineno"> 3980 </span><span class="spaces">  </span><span class="nottickedoff">nuMulti (MNil :&gt;: Proxy :&gt;: Proxy :&gt;: Proxy) $ \(_ :&gt;: rw :&gt;: l :&gt;: x) -&gt;</span>
<span class="lineno"> 3981 </span><span class="spaces">  </span><span class="nottickedoff">LLVMFieldPerm { llvmFieldRW = PExpr_Var rw,</span>
<span class="lineno"> 3982 </span><span class="spaces">                  </span><span class="nottickedoff">llvmFieldLifetime = PExpr_Var l,</span>
<span class="lineno"> 3983 </span><span class="spaces">                  </span><span class="nottickedoff">llvmFieldOffset = bvInt 0,</span>
<span class="lineno"> 3984 </span><span class="spaces">                  </span><span class="nottickedoff">llvmFieldContents = ValPerm_Eq (PExpr_Var x) }</span></span>
<span class="lineno"> 3985 </span>
<span class="lineno"> 3986 </span>-- | Create a permission to read a known value from offset 0 of an LLVM pointer
<span class="lineno"> 3987 </span>-- using an existential modality, lifetime, and value, i.e., return the
<span class="lineno"> 3988 </span>-- permission @exists rw,l,y.[l]ptr ((0,rw) |-&gt; eq(y))@
<span class="lineno"> 3989 </span>llvmPtr0EqExPerm :: (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt; prx sz -&gt;
<span class="lineno"> 3990 </span>                    Mb (RNil :&gt; RWModalityType :&gt; LifetimeType :&gt; LLVMPointerType sz)
<span class="lineno"> 3991 </span>                    (ValuePerm (LLVMPointerType w))
<span class="lineno"> 3992 </span><span class="decl"><span class="nottickedoff">llvmPtr0EqExPerm = fmap (ValPerm_Conj1 . Perm_LLVMField) . llvmPtr0EqEx</span></span>
<span class="lineno"> 3993 </span>
<span class="lineno"> 3994 </span>-- | Create a permission to read a known value from offset 0 of an LLVM pointer
<span class="lineno"> 3995 </span>-- in the given lifetime, i.e., return @exists y.[l]ptr ((0,R) |-&gt; eq(e))@
<span class="lineno"> 3996 </span>llvmRead0EqPerm :: (1 &lt;= w, KnownNat w) =&gt; PermExpr LifetimeType -&gt;
<span class="lineno"> 3997 </span>                    PermExpr (LLVMPointerType w) -&gt;
<span class="lineno"> 3998 </span>                    ValuePerm (LLVMPointerType w)
<span class="lineno"> 3999 </span><span class="decl"><span class="nottickedoff">llvmRead0EqPerm l e =</span>
<span class="lineno"> 4000 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_Conj [Perm_LLVMField $</span>
<span class="lineno"> 4001 </span><span class="spaces">                </span><span class="nottickedoff">LLVMFieldPerm { llvmFieldRW = PExpr_Read,</span>
<span class="lineno"> 4002 </span><span class="spaces">                                </span><span class="nottickedoff">llvmFieldLifetime = l,</span>
<span class="lineno"> 4003 </span><span class="spaces">                                </span><span class="nottickedoff">llvmFieldOffset = bvInt 0,</span>
<span class="lineno"> 4004 </span><span class="spaces">                                </span><span class="nottickedoff">llvmFieldContents = ValPerm_Eq e }]</span></span>
<span class="lineno"> 4005 </span>
<span class="lineno"> 4006 </span>-- | Create a field write permission with offset 0 and @true@ permissions of a
<span class="lineno"> 4007 </span>-- given size
<span class="lineno"> 4008 </span>llvmSizedFieldWrite0True :: (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno"> 4009 </span>                            f1 w -&gt; f2 sz -&gt; LLVMFieldPerm w sz
<span class="lineno"> 4010 </span><span class="decl"><span class="nottickedoff">llvmSizedFieldWrite0True _ _ =</span>
<span class="lineno"> 4011 </span><span class="spaces">  </span><span class="nottickedoff">LLVMFieldPerm { llvmFieldRW = PExpr_Write,</span>
<span class="lineno"> 4012 </span><span class="spaces">                  </span><span class="nottickedoff">llvmFieldLifetime = PExpr_Always,</span>
<span class="lineno"> 4013 </span><span class="spaces">                  </span><span class="nottickedoff">llvmFieldOffset = bvInt 0,</span>
<span class="lineno"> 4014 </span><span class="spaces">                  </span><span class="nottickedoff">llvmFieldContents = ValPerm_True }</span></span>
<span class="lineno"> 4015 </span>
<span class="lineno"> 4016 </span>-- | Create a field write permission with offset 0 and @true@ permissions
<span class="lineno"> 4017 </span>llvmFieldWrite0True :: (1 &lt;= w, KnownNat w) =&gt; LLVMFieldPerm w w
<span class="lineno"> 4018 </span><span class="decl"><span class="nottickedoff">llvmFieldWrite0True = llvmSizedFieldWrite0True Proxy Proxy</span></span>
<span class="lineno"> 4019 </span>
<span class="lineno"> 4020 </span>-- | Create a field write permission with offset 0 and @true@ permissions
<span class="lineno"> 4021 </span>llvmWrite0TruePerm :: (1 &lt;= w, KnownNat w) =&gt; ValuePerm (LLVMPointerType w)
<span class="lineno"> 4022 </span><span class="decl"><span class="nottickedoff">llvmWrite0TruePerm = ValPerm_Conj [Perm_LLVMField llvmFieldWrite0True]</span></span>
<span class="lineno"> 4023 </span>
<span class="lineno"> 4024 </span>-- | Create a field write permission with offset 0 and an @eq(e)@ permission
<span class="lineno"> 4025 </span>llvmFieldWrite0Eq :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (LLVMPointerType w) -&gt;
<span class="lineno"> 4026 </span>                     LLVMFieldPerm w w
<span class="lineno"> 4027 </span><span class="decl"><span class="nottickedoff">llvmFieldWrite0Eq e =</span>
<span class="lineno"> 4028 </span><span class="spaces">  </span><span class="nottickedoff">LLVMFieldPerm { llvmFieldRW = PExpr_Write,</span>
<span class="lineno"> 4029 </span><span class="spaces">                  </span><span class="nottickedoff">llvmFieldLifetime = PExpr_Always,</span>
<span class="lineno"> 4030 </span><span class="spaces">                  </span><span class="nottickedoff">llvmFieldOffset = bvInt 0,</span>
<span class="lineno"> 4031 </span><span class="spaces">                  </span><span class="nottickedoff">llvmFieldContents = ValPerm_Eq e }</span></span>
<span class="lineno"> 4032 </span>
<span class="lineno"> 4033 </span>-- | Create a field write permission with offset 0 and an @eq(e)@ permission
<span class="lineno"> 4034 </span>llvmWrite0EqPerm :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (LLVMPointerType w) -&gt;
<span class="lineno"> 4035 </span>                    ValuePerm (LLVMPointerType w)
<span class="lineno"> 4036 </span><span class="decl"><span class="nottickedoff">llvmWrite0EqPerm e = ValPerm_Conj [Perm_LLVMField $ llvmFieldWrite0Eq e]</span></span>
<span class="lineno"> 4037 </span>
<span class="lineno"> 4038 </span>-- | Create a field write permission with offset @e@ and lifetime @l@
<span class="lineno"> 4039 </span>llvmFieldWriteTrueL :: (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno"> 4040 </span>                       prx sz -&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 4041 </span>                       PermExpr LifetimeType -&gt; LLVMFieldPerm w sz
<span class="lineno"> 4042 </span><span class="decl"><span class="nottickedoff">llvmFieldWriteTrueL _ off l =</span>
<span class="lineno"> 4043 </span><span class="spaces">  </span><span class="nottickedoff">LLVMFieldPerm { llvmFieldRW = PExpr_Write,</span>
<span class="lineno"> 4044 </span><span class="spaces">                  </span><span class="nottickedoff">llvmFieldLifetime = l,</span>
<span class="lineno"> 4045 </span><span class="spaces">                  </span><span class="nottickedoff">llvmFieldOffset = off,</span>
<span class="lineno"> 4046 </span><span class="spaces">                  </span><span class="nottickedoff">llvmFieldContents = ValPerm_True }</span></span>
<span class="lineno"> 4047 </span>
<span class="lineno"> 4048 </span>-- | Create a field write permission with offset @e@ and an existential lifetime
<span class="lineno"> 4049 </span>llvmWriteTrueExLPerm :: (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno"> 4050 </span>                        prx sz -&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 4051 </span>                        Binding LifetimeType (ValuePerm (LLVMPointerType w))
<span class="lineno"> 4052 </span><span class="decl"><span class="nottickedoff">llvmWriteTrueExLPerm sz off =</span>
<span class="lineno"> 4053 </span><span class="spaces">  </span><span class="nottickedoff">nu $ \l -&gt;</span>
<span class="lineno"> 4054 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_Conj1 $ Perm_LLVMField $ llvmFieldWriteTrueL sz off (PExpr_Var l)</span></span>
<span class="lineno"> 4055 </span>
<span class="lineno"> 4056 </span>-- | Create a field permission with offset @e@ and existential lifetime and rw
<span class="lineno"> 4057 </span>llvmReadExRWExLPerm :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 4058 </span>                       Mb (RNil :&gt; RWModalityType :&gt; LifetimeType)
<span class="lineno"> 4059 </span>                       (ValuePerm (LLVMPointerType w))
<span class="lineno"> 4060 </span><span class="decl"><span class="nottickedoff">llvmReadExRWExLPerm (off :: PermExpr (BVType w)) =</span>
<span class="lineno"> 4061 </span><span class="spaces">  </span><span class="nottickedoff">nuMulti (MNil :&gt;: Proxy :&gt;: Proxy) $ \(_ :&gt;: rw :&gt;: l) -&gt;</span>
<span class="lineno"> 4062 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_Conj1 $ Perm_LLVMField @w @w $</span>
<span class="lineno"> 4063 </span><span class="spaces">  </span><span class="nottickedoff">LLVMFieldPerm { llvmFieldRW = PExpr_Var rw,</span>
<span class="lineno"> 4064 </span><span class="spaces">                  </span><span class="nottickedoff">llvmFieldLifetime = PExpr_Var l,</span>
<span class="lineno"> 4065 </span><span class="spaces">                  </span><span class="nottickedoff">llvmFieldOffset = off,</span>
<span class="lineno"> 4066 </span><span class="spaces">                  </span><span class="nottickedoff">llvmFieldContents = ValPerm_True }</span></span>
<span class="lineno"> 4067 </span>
<span class="lineno"> 4068 </span>-- | Add a bitvector expression to the offset of a field permission
<span class="lineno"> 4069 </span>llvmFieldAddOffset :: (1 &lt;= w, KnownNat w) =&gt; LLVMFieldPerm w sz -&gt;
<span class="lineno"> 4070 </span>                      PermExpr (BVType w) -&gt; LLVMFieldPerm w sz
<span class="lineno"> 4071 </span><span class="decl"><span class="nottickedoff">llvmFieldAddOffset fp off =</span>
<span class="lineno"> 4072 </span><span class="spaces">  </span><span class="nottickedoff">fp { llvmFieldOffset = bvAdd (llvmFieldOffset fp) off }</span></span>
<span class="lineno"> 4073 </span>
<span class="lineno"> 4074 </span>-- | Add an integer to the offset of a field permission
<span class="lineno"> 4075 </span>llvmFieldAddOffsetInt :: (1 &lt;= w, KnownNat w) =&gt; LLVMFieldPerm w sz -&gt;
<span class="lineno"> 4076 </span>                         Integer -&gt; LLVMFieldPerm w sz
<span class="lineno"> 4077 </span><span class="decl"><span class="nottickedoff">llvmFieldAddOffsetInt fp off = llvmFieldAddOffset fp (bvInt off)</span></span>
<span class="lineno"> 4078 </span>
<span class="lineno"> 4079 </span>-- | Set the contents of a field permission, possibly changing its size
<span class="lineno"> 4080 </span>llvmFieldSetContents :: LLVMFieldPerm w sz1 -&gt;
<span class="lineno"> 4081 </span>                        ValuePerm (LLVMPointerType sz2) -&gt; LLVMFieldPerm w sz2
<span class="lineno"> 4082 </span><span class="decl"><span class="nottickedoff">llvmFieldSetContents (LLVMFieldPerm {..}) p =</span>
<span class="lineno"> 4083 </span><span class="spaces">  </span><span class="nottickedoff">LLVMFieldPerm { llvmFieldContents = p, .. }</span></span>
<span class="lineno"> 4084 </span>
<span class="lineno"> 4085 </span>-- | Set the contents of a field permission to an @eq(llvmword(e))@ permission
<span class="lineno"> 4086 </span>llvmFieldSetEqWord :: (1 &lt;= sz2, KnownNat sz2) =&gt; LLVMFieldPerm w sz1 -&gt;
<span class="lineno"> 4087 </span>                      PermExpr (BVType sz2) -&gt; LLVMFieldPerm w sz2
<span class="lineno"> 4088 </span><span class="decl"><span class="nottickedoff">llvmFieldSetEqWord fp e =</span>
<span class="lineno"> 4089 </span><span class="spaces">  </span><span class="nottickedoff">llvmFieldSetContents fp (ValPerm_Eq $ PExpr_LLVMWord e)</span></span>
<span class="lineno"> 4090 </span>
<span class="lineno"> 4091 </span>-- | Set the contents of a field permission to an @eq(y)@ permission
<span class="lineno"> 4092 </span>llvmFieldSetEqVar :: (1 &lt;= sz2, KnownNat sz2) =&gt; LLVMFieldPerm w sz1 -&gt;
<span class="lineno"> 4093 </span>                     ExprVar (LLVMPointerType sz2) -&gt; LLVMFieldPerm w sz2
<span class="lineno"> 4094 </span><span class="decl"><span class="nottickedoff">llvmFieldSetEqVar fp y =</span>
<span class="lineno"> 4095 </span><span class="spaces">  </span><span class="nottickedoff">llvmFieldSetContents fp (ValPerm_Eq $ PExpr_Var y)</span></span>
<span class="lineno"> 4096 </span>
<span class="lineno"> 4097 </span>-- | Set the contents of a field permission to an @eq(llvmword(y))@ permission
<span class="lineno"> 4098 </span>llvmFieldSetEqWordVar :: (1 &lt;= sz2, KnownNat sz2) =&gt; LLVMFieldPerm w sz1 -&gt;
<span class="lineno"> 4099 </span>                         ExprVar (BVType sz2) -&gt; LLVMFieldPerm w sz2
<span class="lineno"> 4100 </span><span class="decl"><span class="nottickedoff">llvmFieldSetEqWordVar fp y =</span>
<span class="lineno"> 4101 </span><span class="spaces">  </span><span class="nottickedoff">llvmFieldSetContents fp (ValPerm_Eq $ PExpr_LLVMWord $ PExpr_Var y)</span></span>
<span class="lineno"> 4102 </span>
<span class="lineno"> 4103 </span>-- | Set the contents of a field permission to an @true@ permission of a
<span class="lineno"> 4104 </span>-- specific size
<span class="lineno"> 4105 </span>llvmFieldSetTrue :: (1 &lt;= sz2, KnownNat sz2) =&gt; LLVMFieldPerm w sz1 -&gt;
<span class="lineno"> 4106 </span>                    f sz2 -&gt; LLVMFieldPerm w sz2
<span class="lineno"> 4107 </span><span class="decl"><span class="nottickedoff">llvmFieldSetTrue fp _ = llvmFieldSetContents fp ValPerm_True</span></span>
<span class="lineno"> 4108 </span>
<span class="lineno"> 4109 </span>-- | Convert a field permission to a block permission
<span class="lineno"> 4110 </span>llvmFieldPermToBlock :: (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno"> 4111 </span>                        LLVMFieldPerm w sz -&gt; LLVMBlockPerm w
<span class="lineno"> 4112 </span><span class="decl"><span class="nottickedoff">llvmFieldPermToBlock fp =</span>
<span class="lineno"> 4113 </span><span class="spaces">  </span><span class="nottickedoff">LLVMBlockPerm</span>
<span class="lineno"> 4114 </span><span class="spaces">  </span><span class="nottickedoff">{ llvmBlockRW = llvmFieldRW fp,</span>
<span class="lineno"> 4115 </span><span class="spaces">    </span><span class="nottickedoff">llvmBlockLifetime = llvmFieldLifetime fp,</span>
<span class="lineno"> 4116 </span><span class="spaces">    </span><span class="nottickedoff">llvmBlockOffset = llvmFieldOffset fp,</span>
<span class="lineno"> 4117 </span><span class="spaces">    </span><span class="nottickedoff">llvmBlockLen = llvmFieldLen fp,</span>
<span class="lineno"> 4118 </span><span class="spaces">    </span><span class="nottickedoff">llvmBlockShape = PExpr_FieldShape (LLVMFieldShape $ llvmFieldContents fp) }</span></span>
<span class="lineno"> 4119 </span>
<span class="lineno"> 4120 </span>-- | Convert a block permission with field shape to a field permission
<span class="lineno"> 4121 </span>--
<span class="lineno"> 4122 </span>-- NOTE: do not check that the length of the block equals that of the resulting
<span class="lineno"> 4123 </span>-- field permission, in case the length of the block has a free variable that
<span class="lineno"> 4124 </span>-- might be provably but not syntacitcally equal to the length
<span class="lineno"> 4125 </span>llvmBlockPermToField :: (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno"> 4126 </span>                        NatRepr sz -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 4127 </span>                        Maybe (LLVMFieldPerm w sz)
<span class="lineno"> 4128 </span><span class="decl"><span class="nottickedoff">llvmBlockPermToField sz bp</span>
<span class="lineno"> 4129 </span><span class="spaces">  </span><span class="nottickedoff">| PExpr_FieldShape (LLVMFieldShape p) &lt;- llvmBlockShape bp</span>
<span class="lineno"> 4130 </span><span class="spaces">  </span><span class="nottickedoff">, Just Refl &lt;- testEquality sz (exprLLVMTypeWidth p)</span>
<span class="lineno"> 4131 </span><span class="spaces">  </span><span class="nottickedoff">= Just $ LLVMFieldPerm { llvmFieldRW = llvmBlockRW bp,</span>
<span class="lineno"> 4132 </span><span class="spaces">                           </span><span class="nottickedoff">llvmFieldLifetime = llvmBlockLifetime bp,</span>
<span class="lineno"> 4133 </span><span class="spaces">                           </span><span class="nottickedoff">llvmFieldOffset = llvmBlockOffset bp,</span>
<span class="lineno"> 4134 </span><span class="spaces">                           </span><span class="nottickedoff">llvmFieldContents = p }</span>
<span class="lineno"> 4135 </span><span class="spaces"></span><span class="nottickedoff">llvmBlockPermToField _ _ = Nothing</span></span>
<span class="lineno"> 4136 </span>
<span class="lineno"> 4137 </span>-- | Get the range of bytes described by an array permisison. Note that these
<span class="lineno"> 4138 </span>-- bytes may not currently be *in* the array permission, if it has any borrows.
<span class="lineno"> 4139 </span>llvmArrayRange :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt; BVRange w
<span class="lineno"> 4140 </span><span class="decl"><span class="nottickedoff">llvmArrayRange fp =</span>
<span class="lineno"> 4141 </span><span class="spaces">  </span><span class="nottickedoff">BVRange (llvmArrayOffset fp) (llvmArrayLengthBytes fp)</span></span>
<span class="lineno"> 4142 </span>
<span class="lineno"> 4143 </span>-- | Convert an array permission with total size @sz@ bits to a field permission
<span class="lineno"> 4144 </span>-- of size @sz@ bits, assuming it has no borrows
<span class="lineno"> 4145 </span>llvmArrayToField :: (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno"> 4146 </span>                    NatRepr sz -&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 4147 </span>                    Maybe (LLVMFieldPerm w sz)
<span class="lineno"> 4148 </span><span class="decl"><span class="nottickedoff">llvmArrayToField sz ap</span>
<span class="lineno"> 4149 </span><span class="spaces">  </span><span class="nottickedoff">| bvEq (bvMult (llvmArrayStrideBits ap) (llvmArrayLen ap)) (bvInt $</span>
<span class="lineno"> 4150 </span><span class="spaces">                                                              </span><span class="nottickedoff">intValue sz)</span>
<span class="lineno"> 4151 </span><span class="spaces">  </span><span class="nottickedoff">, [] &lt;- llvmArrayBorrows ap =</span>
<span class="lineno"> 4152 </span><span class="spaces">    </span><span class="nottickedoff">Just $ LLVMFieldPerm { llvmFieldRW = llvmArrayRW ap,</span>
<span class="lineno"> 4153 </span><span class="spaces">                           </span><span class="nottickedoff">llvmFieldLifetime = llvmArrayLifetime ap,</span>
<span class="lineno"> 4154 </span><span class="spaces">                           </span><span class="nottickedoff">llvmFieldOffset = llvmArrayOffset ap,</span>
<span class="lineno"> 4155 </span><span class="spaces">                           </span><span class="nottickedoff">llvmFieldContents = ValPerm_True }</span>
<span class="lineno"> 4156 </span><span class="spaces"></span><span class="nottickedoff">llvmArrayToField _ _ = Nothing</span></span>
<span class="lineno"> 4157 </span>
<span class="lineno"> 4158 </span>-- | Convert an array permission with no borrows to a block permission
<span class="lineno"> 4159 </span>llvmArrayPermToBlock :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 4160 </span>                        LLVMArrayPerm w -&gt; Maybe (LLVMBlockPerm w)
<span class="lineno"> 4161 </span><span class="decl"><span class="nottickedoff">llvmArrayPermToBlock ap</span>
<span class="lineno"> 4162 </span><span class="spaces">  </span><span class="nottickedoff">| [] &lt;- llvmArrayBorrows ap =</span>
<span class="lineno"> 4163 </span><span class="spaces">    </span><span class="nottickedoff">Just $ LLVMBlockPerm</span>
<span class="lineno"> 4164 </span><span class="spaces">    </span><span class="nottickedoff">{ llvmBlockRW = llvmArrayRW ap,</span>
<span class="lineno"> 4165 </span><span class="spaces">      </span><span class="nottickedoff">llvmBlockLifetime = llvmArrayLifetime ap,</span>
<span class="lineno"> 4166 </span><span class="spaces">      </span><span class="nottickedoff">llvmBlockOffset = llvmArrayOffset ap,</span>
<span class="lineno"> 4167 </span><span class="spaces">      </span><span class="nottickedoff">llvmBlockLen = bvMult (llvmArrayStride ap) (llvmArrayLen ap),</span>
<span class="lineno"> 4168 </span><span class="spaces">      </span><span class="nottickedoff">llvmBlockShape =</span>
<span class="lineno"> 4169 </span><span class="spaces">        </span><span class="nottickedoff">PExpr_ArrayShape (llvmArrayLen ap) (llvmArrayStride ap)</span>
<span class="lineno"> 4170 </span><span class="spaces">        </span><span class="nottickedoff">(llvmArrayCellShape ap) }</span>
<span class="lineno"> 4171 </span><span class="spaces"></span><span class="nottickedoff">llvmArrayPermToBlock _ = Nothing</span></span>
<span class="lineno"> 4172 </span>
<span class="lineno"> 4173 </span>-- | Convert a block permission with array shape to an array permission,
<span class="lineno"> 4174 </span>-- assuming the length of the block permission equals the size of the array
<span class="lineno"> 4175 </span>--
<span class="lineno"> 4176 </span>-- NOTE: do not check that the length of the block equals that of the resulting
<span class="lineno"> 4177 </span>-- array permission, in case the length of the block has a free variable that
<span class="lineno"> 4178 </span>-- might be provably but not syntacitcally equal to the length
<span class="lineno"> 4179 </span>llvmBlockPermToArray :: (1 &lt;= w, KnownNat w) =&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 4180 </span>                        Maybe (LLVMArrayPerm w)
<span class="lineno"> 4181 </span><span class="decl"><span class="nottickedoff">llvmBlockPermToArray bp</span>
<span class="lineno"> 4182 </span><span class="spaces">  </span><span class="nottickedoff">| PExpr_ArrayShape len stride sh &lt;- llvmBlockShape bp =</span>
<span class="lineno"> 4183 </span><span class="spaces">    </span><span class="nottickedoff">Just $ LLVMArrayPerm</span>
<span class="lineno"> 4184 </span><span class="spaces">    </span><span class="nottickedoff">{ llvmArrayRW = llvmBlockRW bp,</span>
<span class="lineno"> 4185 </span><span class="spaces">      </span><span class="nottickedoff">llvmArrayLifetime = llvmBlockLifetime bp,</span>
<span class="lineno"> 4186 </span><span class="spaces">      </span><span class="nottickedoff">llvmArrayOffset = llvmBlockOffset bp,</span>
<span class="lineno"> 4187 </span><span class="spaces">      </span><span class="nottickedoff">llvmArrayLen = len,</span>
<span class="lineno"> 4188 </span><span class="spaces">      </span><span class="nottickedoff">llvmArrayStride = stride,</span>
<span class="lineno"> 4189 </span><span class="spaces">      </span><span class="nottickedoff">llvmArrayCellShape = sh,</span>
<span class="lineno"> 4190 </span><span class="spaces">      </span><span class="nottickedoff">llvmArrayBorrows = [] }</span>
<span class="lineno"> 4191 </span><span class="spaces"></span><span class="nottickedoff">llvmBlockPermToArray _ = Nothing</span></span>
<span class="lineno"> 4192 </span>
<span class="lineno"> 4193 </span>-- | Convert a block permission with statically-known length @len@ to an
<span class="lineno"> 4194 </span>-- equivalent array of length 1 with stride @len@
<span class="lineno"> 4195 </span>llvmBlockPermToArray1 :: (1 &lt;= w, KnownNat w) =&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 4196 </span>                         Maybe (LLVMArrayPerm w)
<span class="lineno"> 4197 </span><span class="decl"><span class="nottickedoff">llvmBlockPermToArray1 bp</span>
<span class="lineno"> 4198 </span><span class="spaces">  </span><span class="nottickedoff">| Just stride &lt;- bvMatchConstInt $ llvmBlockLen bp =</span>
<span class="lineno"> 4199 </span><span class="spaces">    </span><span class="nottickedoff">Just $ LLVMArrayPerm</span>
<span class="lineno"> 4200 </span><span class="spaces">    </span><span class="nottickedoff">{ llvmArrayRW = llvmBlockRW bp,</span>
<span class="lineno"> 4201 </span><span class="spaces">      </span><span class="nottickedoff">llvmArrayLifetime = llvmBlockLifetime bp,</span>
<span class="lineno"> 4202 </span><span class="spaces">      </span><span class="nottickedoff">llvmArrayOffset = llvmBlockOffset bp,</span>
<span class="lineno"> 4203 </span><span class="spaces">      </span><span class="nottickedoff">llvmArrayLen = bvInt 1,</span>
<span class="lineno"> 4204 </span><span class="spaces">      </span><span class="nottickedoff">llvmArrayStride = fromInteger stride,</span>
<span class="lineno"> 4205 </span><span class="spaces">      </span><span class="nottickedoff">llvmArrayCellShape = llvmBlockShape bp,</span>
<span class="lineno"> 4206 </span><span class="spaces">      </span><span class="nottickedoff">llvmArrayBorrows = [] }</span>
<span class="lineno"> 4207 </span><span class="spaces"></span><span class="nottickedoff">llvmBlockPermToArray1 _ = Nothing</span></span>
<span class="lineno"> 4208 </span>
<span class="lineno"> 4209 </span>-- | Get the permission for a single cell of an array permission
<span class="lineno"> 4210 </span>llvmArrayCellPerm :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 4211 </span>                     PermExpr (BVType w) -&gt; LLVMBlockPerm w
<span class="lineno"> 4212 </span><span class="decl"><span class="nottickedoff">llvmArrayCellPerm ap cell =</span>
<span class="lineno"> 4213 </span><span class="spaces">  </span><span class="nottickedoff">let off = bvAdd (llvmArrayOffset ap) (bvMult (llvmArrayStride ap) cell) in</span>
<span class="lineno"> 4214 </span><span class="spaces">  </span><span class="nottickedoff">LLVMBlockPerm { llvmBlockRW = llvmArrayRW ap,</span>
<span class="lineno"> 4215 </span><span class="spaces">                  </span><span class="nottickedoff">llvmBlockLifetime = llvmArrayLifetime ap,</span>
<span class="lineno"> 4216 </span><span class="spaces">                  </span><span class="nottickedoff">llvmBlockOffset = off,</span>
<span class="lineno"> 4217 </span><span class="spaces">                  </span><span class="nottickedoff">llvmBlockLen = bvInt (toInteger $ llvmArrayStride ap),</span>
<span class="lineno"> 4218 </span><span class="spaces">                  </span><span class="nottickedoff">llvmBlockShape = llvmArrayCellShape ap }</span></span>
<span class="lineno"> 4219 </span>
<span class="lineno"> 4220 </span>-- | Get the permission for the first cell of an array permission
<span class="lineno"> 4221 </span>llvmArrayPermHead :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt; LLVMBlockPerm w
<span class="lineno"> 4222 </span><span class="decl"><span class="nottickedoff">llvmArrayPermHead ap = llvmArrayCellPerm ap (bvInt 0)</span></span>
<span class="lineno"> 4223 </span>
<span class="lineno"> 4224 </span>-- | Get the permission for all of an array permission after the first cell
<span class="lineno"> 4225 </span>llvmArrayPermTail :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt; LLVMArrayPerm w
<span class="lineno"> 4226 </span><span class="decl"><span class="nottickedoff">llvmArrayPermTail ap =</span>
<span class="lineno"> 4227 </span><span class="spaces">  </span><span class="nottickedoff">let off1 = bvInt $ bytesToInteger $ llvmArrayStride ap in</span>
<span class="lineno"> 4228 </span><span class="spaces">  </span><span class="nottickedoff">ap { llvmArrayOffset = bvAdd (llvmArrayOffset ap) off1,</span>
<span class="lineno"> 4229 </span><span class="spaces">       </span><span class="nottickedoff">llvmArrayLen = bvSub (llvmArrayLen ap) (bvInt 1) }</span></span>
<span class="lineno"> 4230 </span>
<span class="lineno"> 4231 </span>-- | Convert an atomic permission to a @memblock@, if possible
<span class="lineno"> 4232 </span>llvmAtomicPermToBlock :: AtomicPerm (LLVMPointerType w) -&gt;
<span class="lineno"> 4233 </span>                         Maybe (LLVMBlockPerm w)
<span class="lineno"> 4234 </span><span class="decl"><span class="nottickedoff">llvmAtomicPermToBlock (Perm_LLVMField fp) = Just $ llvmFieldPermToBlock fp</span>
<span class="lineno"> 4235 </span><span class="spaces"></span><span class="nottickedoff">llvmAtomicPermToBlock (Perm_LLVMArray ap) = llvmArrayPermToBlock ap</span>
<span class="lineno"> 4236 </span><span class="spaces"></span><span class="nottickedoff">llvmAtomicPermToBlock (Perm_LLVMBlock bp) = Just bp</span>
<span class="lineno"> 4237 </span><span class="spaces"></span><span class="nottickedoff">llvmAtomicPermToBlock _ = Nothing</span></span>
<span class="lineno"> 4238 </span>
<span class="lineno"> 4239 </span>-- | Convert an atomic permission to several @memblocks@, if possible
<span class="lineno"> 4240 </span>llvmAtomicPermToBlocks :: AtomicPerm (LLVMPointerType w) -&gt;
<span class="lineno"> 4241 </span>                          Maybe [LLVMBlockPerm w]
<span class="lineno"> 4242 </span><span class="decl"><span class="nottickedoff">llvmAtomicPermToBlocks (Perm_LLVMArray ap) = llvmArrayToBlocks ap</span>
<span class="lineno"> 4243 </span><span class="spaces"></span><span class="nottickedoff">llvmAtomicPermToBlocks p = pure &lt;$&gt; llvmAtomicPermToBlock p</span></span>
<span class="lineno"> 4244 </span>
<span class="lineno"> 4245 </span>-- | Convert an atomic permission whose type is unknown to a @memblock@, if
<span class="lineno"> 4246 </span>-- possible, along with a proof that its type is a valid llvm pointer type
<span class="lineno"> 4247 </span>llvmAtomicPermToSomeBlock :: AtomicPerm a -&gt; Maybe (SomeLLVMBlockPerm a)
<span class="lineno"> 4248 </span><span class="decl"><span class="nottickedoff">llvmAtomicPermToSomeBlock p@(Perm_LLVMField _) =</span>
<span class="lineno"> 4249 </span><span class="spaces">  </span><span class="nottickedoff">SomeLLVMBlockPerm &lt;$&gt; llvmAtomicPermToBlock p</span>
<span class="lineno"> 4250 </span><span class="spaces"></span><span class="nottickedoff">llvmAtomicPermToSomeBlock p@(Perm_LLVMArray _) =</span>
<span class="lineno"> 4251 </span><span class="spaces">  </span><span class="nottickedoff">SomeLLVMBlockPerm &lt;$&gt; llvmAtomicPermToBlock p</span>
<span class="lineno"> 4252 </span><span class="spaces"></span><span class="nottickedoff">llvmAtomicPermToSomeBlock (Perm_LLVMBlock bp) =</span>
<span class="lineno"> 4253 </span><span class="spaces">  </span><span class="nottickedoff">Just $ SomeLLVMBlockPerm $ bp</span>
<span class="lineno"> 4254 </span><span class="spaces"></span><span class="nottickedoff">llvmAtomicPermToSomeBlock _ = Nothing</span></span>
<span class="lineno"> 4255 </span>
<span class="lineno"> 4256 </span>-- | Get the lifetime of an atomic perm if it is a field, array, or memblock
<span class="lineno"> 4257 </span>atomicPermLifetime :: AtomicPerm a -&gt; Maybe (PermExpr LifetimeType)
<span class="lineno"> 4258 </span><span class="decl"><span class="nottickedoff">atomicPermLifetime (Perm_LLVMField fp) = Just $ llvmFieldLifetime fp</span>
<span class="lineno"> 4259 </span><span class="spaces"></span><span class="nottickedoff">atomicPermLifetime (Perm_LLVMArray ap) = Just $ llvmArrayLifetime ap</span>
<span class="lineno"> 4260 </span><span class="spaces"></span><span class="nottickedoff">atomicPermLifetime (Perm_LLVMBlock bp) = Just $ llvmBlockLifetime bp</span>
<span class="lineno"> 4261 </span><span class="spaces"></span><span class="nottickedoff">atomicPermLifetime _ = Nothing</span></span>
<span class="lineno"> 4262 </span>
<span class="lineno"> 4263 </span>-- | Get the modality of an atomic perm if it is a field, array, or memblock
<span class="lineno"> 4264 </span>atomicPermModality :: AtomicPerm a -&gt; Maybe (PermExpr RWModalityType)
<span class="lineno"> 4265 </span><span class="decl"><span class="nottickedoff">atomicPermModality (Perm_LLVMField fp) = Just $ llvmFieldRW fp</span>
<span class="lineno"> 4266 </span><span class="spaces"></span><span class="nottickedoff">atomicPermModality (Perm_LLVMArray ap) = Just $ llvmArrayRW ap</span>
<span class="lineno"> 4267 </span><span class="spaces"></span><span class="nottickedoff">atomicPermModality (Perm_LLVMBlock bp) = Just $ llvmBlockRW bp</span>
<span class="lineno"> 4268 </span><span class="spaces"></span><span class="nottickedoff">atomicPermModality _ = Nothing</span></span>
<span class="lineno"> 4269 </span>
<span class="lineno"> 4270 </span>-- | Get the starting offset of an atomic permission, if it has one. This
<span class="lineno"> 4271 </span>-- includes array permissions which may have some cells borrowed.
<span class="lineno"> 4272 </span>llvmAtomicPermOffset :: AtomicPerm (LLVMPointerType w) -&gt;
<span class="lineno"> 4273 </span>                        Maybe (PermExpr (BVType w))
<span class="lineno"> 4274 </span><span class="decl"><span class="nottickedoff">llvmAtomicPermOffset (Perm_LLVMField fp) = Just $ llvmFieldOffset fp</span>
<span class="lineno"> 4275 </span><span class="spaces"></span><span class="nottickedoff">llvmAtomicPermOffset (Perm_LLVMArray ap) = Just $ llvmArrayOffset ap</span>
<span class="lineno"> 4276 </span><span class="spaces"></span><span class="nottickedoff">llvmAtomicPermOffset (Perm_LLVMBlock bp) = Just $ llvmBlockOffset bp</span>
<span class="lineno"> 4277 </span><span class="spaces"></span><span class="nottickedoff">llvmAtomicPermOffset _ = Nothing</span></span>
<span class="lineno"> 4278 </span>
<span class="lineno"> 4279 </span>-- | Get the length of an atomic permission, if it has one. This includes array
<span class="lineno"> 4280 </span>-- permissions which may have some cells borrowed.
<span class="lineno"> 4281 </span>llvmAtomicPermLen :: AtomicPerm (LLVMPointerType w) -&gt;
<span class="lineno"> 4282 </span>                     Maybe (PermExpr (BVType w))
<span class="lineno"> 4283 </span><span class="decl"><span class="nottickedoff">llvmAtomicPermLen (Perm_LLVMField fp) = Just $ llvmFieldLen fp</span>
<span class="lineno"> 4284 </span><span class="spaces"></span><span class="nottickedoff">llvmAtomicPermLen (Perm_LLVMArray ap) = Just $ llvmArrayLengthBytes ap</span>
<span class="lineno"> 4285 </span><span class="spaces"></span><span class="nottickedoff">llvmAtomicPermLen (Perm_LLVMBlock bp) = Just $ llvmBlockLen bp</span>
<span class="lineno"> 4286 </span><span class="spaces"></span><span class="nottickedoff">llvmAtomicPermLen _ = Nothing</span></span>
<span class="lineno"> 4287 </span>
<span class="lineno"> 4288 </span>-- | Get the ending offset of an atomic permission, if it has one. This
<span class="lineno"> 4289 </span>-- includes array permissions which may have some cells borrowed.
<span class="lineno"> 4290 </span>llvmAtomicPermEndOffset :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 4291 </span>                           AtomicPerm (LLVMPointerType w) -&gt;
<span class="lineno"> 4292 </span>                           Maybe (PermExpr (BVType w))
<span class="lineno"> 4293 </span><span class="decl"><span class="nottickedoff">llvmAtomicPermEndOffset p =</span>
<span class="lineno"> 4294 </span><span class="spaces">  </span><span class="nottickedoff">bvAdd &lt;$&gt; llvmAtomicPermOffset p &lt;*&gt; llvmAtomicPermLen p</span></span>
<span class="lineno"> 4295 </span>
<span class="lineno"> 4296 </span>-- | Get the range of offsets of an atomic permission, if it has one. Note that
<span class="lineno"> 4297 </span>-- arrays with borrows do not have a well-defined range.
<span class="lineno"> 4298 </span>llvmAtomicPermRange :: AtomicPerm (LLVMPointerType w) -&gt; Maybe (BVRange w)
<span class="lineno"> 4299 </span><span class="decl"><span class="nottickedoff">llvmAtomicPermRange p = fmap llvmBlockRange $ llvmAtomicPermToBlock p</span></span>
<span class="lineno"> 4300 </span>
<span class="lineno"> 4301 </span>-- | Test if an LLVM atomic permission contains some range of offsets that have
<span class="lineno"> 4302 </span>-- an array shape
<span class="lineno"> 4303 </span>llvmPermContainsArray :: AtomicPerm (LLVMPointerType w) -&gt; Bool
<span class="lineno"> 4304 </span><span class="decl"><span class="nottickedoff">llvmPermContainsArray (Perm_LLVMArray _) = True</span>
<span class="lineno"> 4305 </span><span class="spaces"></span><span class="nottickedoff">llvmPermContainsArray (Perm_LLVMBlock bp) =</span>
<span class="lineno"> 4306 </span><span class="spaces">  </span><span class="nottickedoff">shapeContainsArray $ llvmBlockShape bp where</span>
<span class="lineno"> 4307 </span><span class="spaces">  </span><span class="nottickedoff">shapeContainsArray :: PermExpr (LLVMShapeType w) -&gt; Bool</span>
<span class="lineno"> 4308 </span><span class="spaces">  </span><span class="nottickedoff">shapeContainsArray (PExpr_ArrayShape _ _ _) = True</span>
<span class="lineno"> 4309 </span><span class="spaces">  </span><span class="nottickedoff">shapeContainsArray (PExpr_SeqShape sh1 sh2) =</span>
<span class="lineno"> 4310 </span><span class="spaces">    </span><span class="nottickedoff">shapeContainsArray sh1 || shapeContainsArray sh2</span>
<span class="lineno"> 4311 </span><span class="spaces">  </span><span class="nottickedoff">shapeContainsArray (PExpr_TupShape sh) = shapeContainsArray sh</span>
<span class="lineno"> 4312 </span><span class="spaces">  </span><span class="nottickedoff">shapeContainsArray _ = False</span>
<span class="lineno"> 4313 </span><span class="spaces"></span><span class="nottickedoff">llvmPermContainsArray _ = False</span></span>
<span class="lineno"> 4314 </span>
<span class="lineno"> 4315 </span>-- | Set the range of an 'LLVMBlock'
<span class="lineno"> 4316 </span>llvmBlockSetRange :: LLVMBlockPerm w -&gt; BVRange w -&gt; LLVMBlockPerm w
<span class="lineno"> 4317 </span><span class="decl"><span class="nottickedoff">llvmBlockSetRange bp (BVRange off len) =</span>
<span class="lineno"> 4318 </span><span class="spaces">  </span><span class="nottickedoff">bp { llvmBlockOffset = off, llvmBlockLen = len }</span></span>
<span class="lineno"> 4319 </span>
<span class="lineno"> 4320 </span>-- | Get the ending offset of a block permission
<span class="lineno"> 4321 </span>llvmBlockEndOffset :: (1 &lt;= w, KnownNat w) =&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 4322 </span>                      PermExpr (BVType w)
<span class="lineno"> 4323 </span><span class="decl"><span class="nottickedoff">llvmBlockEndOffset = bvRangeEnd . llvmBlockRange</span></span>
<span class="lineno"> 4324 </span>
<span class="lineno"> 4325 </span>-- | Return the length in bytes of an 'LLVMFieldShape'
<span class="lineno"> 4326 </span>llvmFieldShapeLength :: LLVMFieldShape w -&gt; Integer
<span class="lineno"> 4327 </span><span class="decl"><span class="nottickedoff">llvmFieldShapeLength (LLVMFieldShape p) = exprLLVMTypeBytes p</span></span>
<span class="lineno"> 4328 </span>
<span class="lineno"> 4329 </span>-- | Simplify a shape, removing any trailing empty shapes and unfolding any
<span class="lineno"> 4330 </span>-- unfoldable named shapes
<span class="lineno"> 4331 </span>simplifyShape :: PermExpr (LLVMShapeType w) -&gt; PermExpr (LLVMShapeType w)
<span class="lineno"> 4332 </span><span class="decl"><span class="nottickedoff">simplifyShape (PExpr_SeqShape sh PExpr_EmptyShape) = simplifyShape sh</span>
<span class="lineno"> 4333 </span><span class="spaces"></span><span class="nottickedoff">simplifyShape (PExpr_NamedShape rw l nmsh args)</span>
<span class="lineno"> 4334 </span><span class="spaces">  </span><span class="nottickedoff">| TrueRepr &lt;- namedShapeCanUnfoldRepr nmsh</span>
<span class="lineno"> 4335 </span><span class="spaces">  </span><span class="nottickedoff">, Just sh &lt;- unfoldModalizeNamedShape rw l nmsh args =</span>
<span class="lineno"> 4336 </span><span class="spaces">    </span><span class="nottickedoff">simplifyShape sh</span>
<span class="lineno"> 4337 </span><span class="spaces"></span><span class="nottickedoff">simplifyShape sh = sh</span></span>
<span class="lineno"> 4338 </span>
<span class="lineno"> 4339 </span>-- | Test if a shape describes a pointer
<span class="lineno"> 4340 </span>isLLVMPointerShape :: PermExpr (LLVMShapeType w) -&gt; Bool
<span class="lineno"> 4341 </span><span class="decl"><span class="nottickedoff">isLLVMPointerShape (PExpr_FieldShape (LLVMFieldShape (ValPerm_Conj1 p))) =</span>
<span class="lineno"> 4342 </span><span class="spaces">  </span><span class="nottickedoff">isLLVMPointerPerm p</span>
<span class="lineno"> 4343 </span><span class="spaces"></span><span class="nottickedoff">isLLVMPointerShape (PExpr_PtrShape _ _ _) = True</span>
<span class="lineno"> 4344 </span><span class="spaces"></span><span class="nottickedoff">isLLVMPointerShape _ = False</span></span>
<span class="lineno"> 4345 </span>
<span class="lineno"> 4346 </span>-- | Find any shapes of the form @fieldsh(eq(y))@ in a shape and return the @y@
<span class="lineno"> 4347 </span>-- variables
<span class="lineno"> 4348 </span>findEqVarFieldsInShape :: PermExpr (LLVMShapeType w) -&gt; NameSet CrucibleType
<span class="lineno"> 4349 </span><span class="decl"><span class="nottickedoff">findEqVarFieldsInShape sh =</span>
<span class="lineno"> 4350 </span><span class="spaces">  </span><span class="nottickedoff">runReader (findEqVarFieldsInShapeH sh) Set.empty</span></span>
<span class="lineno"> 4351 </span>
<span class="lineno"> 4352 </span>-- | Find any shapes of the form @fieldsh(eq(y))@ in a shape and return the @y@
<span class="lineno"> 4353 </span>-- variables, using the supplied 'Set' to indicate recursive named shapes that
<span class="lineno"> 4354 </span>-- have already been unfolded to get the current shape, to avoid infinite loops
<span class="lineno"> 4355 </span>findEqVarFieldsInShapeH :: PermExpr (LLVMShapeType w) -&gt;
<span class="lineno"> 4356 </span>                           Reader (Set String) (NameSet CrucibleType)
<span class="lineno"> 4357 </span><span class="decl"><span class="nottickedoff">findEqVarFieldsInShapeH (PExpr_NamedShape _ _ nmsh args)</span>
<span class="lineno"> 4358 </span><span class="spaces">  </span><span class="nottickedoff">| DefinedShapeBody _ &lt;- namedShapeBody nmsh =</span>
<span class="lineno"> 4359 </span><span class="spaces">    </span><span class="nottickedoff">-- NOTE: we don't need to modalize the unfolding because that doesn't change</span>
<span class="lineno"> 4360 </span><span class="spaces">    </span><span class="nottickedoff">-- the variable fields</span>
<span class="lineno"> 4361 </span><span class="spaces">    </span><span class="nottickedoff">findEqVarFieldsInShapeH (unfoldNamedShape nmsh args)</span>
<span class="lineno"> 4362 </span><span class="spaces"></span><span class="nottickedoff">findEqVarFieldsInShapeH (PExpr_NamedShape _ _ nmsh args)</span>
<span class="lineno"> 4363 </span><span class="spaces">  </span><span class="nottickedoff">| RecShapeBody _ _ _ &lt;- namedShapeBody nmsh =</span>
<span class="lineno"> 4364 </span><span class="spaces">    </span><span class="nottickedoff">do seen_names &lt;- ask</span>
<span class="lineno"> 4365 </span><span class="spaces">       </span><span class="nottickedoff">if Set.member (namedShapeName nmsh) seen_names then</span>
<span class="lineno"> 4366 </span><span class="spaces">         </span><span class="nottickedoff">return NameSet.empty</span>
<span class="lineno"> 4367 </span><span class="spaces">         </span><span class="nottickedoff">else</span>
<span class="lineno"> 4368 </span><span class="spaces">         </span><span class="nottickedoff">-- NOTE: we don't need to modalize the unfolding because that doesn't</span>
<span class="lineno"> 4369 </span><span class="spaces">         </span><span class="nottickedoff">-- change the variable fields</span>
<span class="lineno"> 4370 </span><span class="spaces">         </span><span class="nottickedoff">local (Set.insert (namedShapeName nmsh)) $</span>
<span class="lineno"> 4371 </span><span class="spaces">         </span><span class="nottickedoff">findEqVarFieldsInShapeH (unfoldNamedShape nmsh args)</span>
<span class="lineno"> 4372 </span><span class="spaces"></span><span class="nottickedoff">findEqVarFieldsInShapeH (PExpr_PtrShape _ _ sh) = findEqVarFieldsInShapeH sh</span>
<span class="lineno"> 4373 </span><span class="spaces"></span><span class="nottickedoff">findEqVarFieldsInShapeH (PExpr_FieldShape (LLVMFieldShape</span>
<span class="lineno"> 4374 </span><span class="spaces">                                           </span><span class="nottickedoff">(ValPerm_Eq (PExpr_Var y)))) =</span>
<span class="lineno"> 4375 </span><span class="spaces">  </span><span class="nottickedoff">return $ NameSet.singleton y</span>
<span class="lineno"> 4376 </span><span class="spaces"></span><span class="nottickedoff">findEqVarFieldsInShapeH (PExpr_FieldShape _) = return $ NameSet.empty</span>
<span class="lineno"> 4377 </span><span class="spaces"></span><span class="nottickedoff">findEqVarFieldsInShapeH (PExpr_ArrayShape _ _ sh) = findEqVarFieldsInShapeH sh</span>
<span class="lineno"> 4378 </span><span class="spaces"></span><span class="nottickedoff">findEqVarFieldsInShapeH (PExpr_TupShape sh) = findEqVarFieldsInShapeH sh</span>
<span class="lineno"> 4379 </span><span class="spaces"></span><span class="nottickedoff">findEqVarFieldsInShapeH (PExpr_SeqShape sh1 sh2) =</span>
<span class="lineno"> 4380 </span><span class="spaces">  </span><span class="nottickedoff">NameSet.union &lt;$&gt; findEqVarFieldsInShapeH sh1 &lt;*&gt; findEqVarFieldsInShapeH sh2</span>
<span class="lineno"> 4381 </span><span class="spaces"></span><span class="nottickedoff">findEqVarFieldsInShapeH (PExpr_OrShape sh1 sh2) =</span>
<span class="lineno"> 4382 </span><span class="spaces">  </span><span class="nottickedoff">NameSet.union &lt;$&gt; findEqVarFieldsInShapeH sh1 &lt;*&gt; findEqVarFieldsInShapeH sh2</span>
<span class="lineno"> 4383 </span><span class="spaces"></span><span class="nottickedoff">findEqVarFieldsInShapeH (PExpr_ExShape mb_sh) =</span>
<span class="lineno"> 4384 </span><span class="spaces">  </span><span class="nottickedoff">fmap NameSet.liftNameSet $ strongMbM $</span>
<span class="lineno"> 4385 </span><span class="spaces">  </span><span class="nottickedoff">fmap findEqVarFieldsInShapeH mb_sh</span>
<span class="lineno"> 4386 </span><span class="spaces"></span><span class="nottickedoff">findEqVarFieldsInShapeH _ = return $ NameSet.empty</span></span>
<span class="lineno"> 4387 </span>
<span class="lineno"> 4388 </span>-- | Return the expression for the length of a shape if there is one
<span class="lineno"> 4389 </span>llvmShapeLength :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (LLVMShapeType w) -&gt;
<span class="lineno"> 4390 </span>                   Maybe (PermExpr (BVType w))
<span class="lineno"> 4391 </span><span class="decl"><span class="nottickedoff">llvmShapeLength (PExpr_Var _) = Nothing</span>
<span class="lineno"> 4392 </span><span class="spaces"></span><span class="nottickedoff">llvmShapeLength PExpr_EmptyShape = Just $ bvInt 0</span>
<span class="lineno"> 4393 </span><span class="spaces"></span><span class="nottickedoff">llvmShapeLength (PExpr_NamedShape _ _ nmsh@(NamedShape _ _</span>
<span class="lineno"> 4394 </span><span class="spaces">                                            </span><span class="nottickedoff">(DefinedShapeBody _)) args) =</span>
<span class="lineno"> 4395 </span><span class="spaces">  </span><span class="nottickedoff">llvmShapeLength (unfoldNamedShape nmsh args)</span>
<span class="lineno"> 4396 </span><span class="spaces"></span><span class="nottickedoff">llvmShapeLength (PExpr_NamedShape _ _ (NamedShape _ _</span>
<span class="lineno"> 4397 </span><span class="spaces">                                       </span><span class="nottickedoff">(OpaqueShapeBody mb_len _ _)) args) =</span>
<span class="lineno"> 4398 </span><span class="spaces">  </span><span class="nottickedoff">Just $ subst (substOfExprs args) mb_len</span>
<span class="lineno"> 4399 </span><span class="spaces"></span><span class="nottickedoff">llvmShapeLength (PExpr_NamedShape _ _ nmsh@(NamedShape _ _</span>
<span class="lineno"> 4400 </span><span class="spaces">                                            </span><span class="nottickedoff">(RecShapeBody _ _ _)) args) =</span>
<span class="lineno"> 4401 </span><span class="spaces">  </span><span class="nottickedoff">-- FIXME: if the recursive shape contains itself *not* under a pointer, then</span>
<span class="lineno"> 4402 </span><span class="spaces">  </span><span class="nottickedoff">-- this could diverge</span>
<span class="lineno"> 4403 </span><span class="spaces">  </span><span class="nottickedoff">llvmShapeLength (unfoldNamedShape nmsh args)</span>
<span class="lineno"> 4404 </span><span class="spaces"></span><span class="nottickedoff">llvmShapeLength (PExpr_EqShape len _) = Just len</span>
<span class="lineno"> 4405 </span><span class="spaces"></span><span class="nottickedoff">llvmShapeLength (PExpr_PtrShape _ _ sh)</span>
<span class="lineno"> 4406 </span><span class="spaces">  </span><span class="nottickedoff">| w &lt;- shapeLLVMTypeWidth sh</span>
<span class="lineno"> 4407 </span><span class="spaces">  </span><span class="nottickedoff">= Just $ bvInt (intValue w `ceil_div` 8)</span>
<span class="lineno"> 4408 </span><span class="spaces"></span><span class="nottickedoff">llvmShapeLength (PExpr_FieldShape fsh) =</span>
<span class="lineno"> 4409 </span><span class="spaces">  </span><span class="nottickedoff">Just $ bvInt $ llvmFieldShapeLength fsh</span>
<span class="lineno"> 4410 </span><span class="spaces"></span><span class="nottickedoff">llvmShapeLength (PExpr_ArrayShape len stride _) = Just $ bvMult stride len</span>
<span class="lineno"> 4411 </span><span class="spaces"></span><span class="nottickedoff">llvmShapeLength (PExpr_TupShape sh) = llvmShapeLength sh</span>
<span class="lineno"> 4412 </span><span class="spaces"></span><span class="nottickedoff">llvmShapeLength (PExpr_SeqShape sh1 sh2) =</span>
<span class="lineno"> 4413 </span><span class="spaces">  </span><span class="nottickedoff">liftA2 bvAdd (llvmShapeLength sh1) (llvmShapeLength sh2)</span>
<span class="lineno"> 4414 </span><span class="spaces"></span><span class="nottickedoff">llvmShapeLength (PExpr_OrShape sh1 sh2) =</span>
<span class="lineno"> 4415 </span><span class="spaces">  </span><span class="nottickedoff">-- We cannot represent a max expression, so we have to statically know which</span>
<span class="lineno"> 4416 </span><span class="spaces">  </span><span class="nottickedoff">-- shape is bigger in order to compute the length of an or shape</span>
<span class="lineno"> 4417 </span><span class="spaces">  </span><span class="nottickedoff">do len1 &lt;- llvmShapeLength sh1</span>
<span class="lineno"> 4418 </span><span class="spaces">     </span><span class="nottickedoff">len2 &lt;- llvmShapeLength sh2</span>
<span class="lineno"> 4419 </span><span class="spaces">     </span><span class="nottickedoff">if (bvLeq len1 len2) then return len2 else</span>
<span class="lineno"> 4420 </span><span class="spaces">       </span><span class="nottickedoff">if (bvLeq len2 len1) then return len1</span>
<span class="lineno"> 4421 </span><span class="spaces">       </span><span class="nottickedoff">else Nothing</span>
<span class="lineno"> 4422 </span><span class="spaces"></span><span class="nottickedoff">llvmShapeLength (PExpr_ExShape mb_sh) =</span>
<span class="lineno"> 4423 </span><span class="spaces">  </span><span class="nottickedoff">-- The length of an existential cannot depend on the existential variable, or</span>
<span class="lineno"> 4424 </span><span class="spaces">  </span><span class="nottickedoff">-- we cannot return it</span>
<span class="lineno"> 4425 </span><span class="spaces">  </span><span class="nottickedoff">case mbMatch $ fmap llvmShapeLength mb_sh of</span>
<span class="lineno"> 4426 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Just mb_len |] -&gt;</span>
<span class="lineno"> 4427 </span><span class="spaces">      </span><span class="nottickedoff">partialSubst (emptyPSubst (MNil :&gt;: Proxy)) mb_len</span>
<span class="lineno"> 4428 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; Nothing</span>
<span class="lineno"> 4429 </span><span class="spaces"></span><span class="nottickedoff">llvmShapeLength PExpr_FalseShape = Just $ bvInt 0</span></span>
<span class="lineno"> 4430 </span>
<span class="lineno"> 4431 </span>-- | Adjust the read/write and lifetime modalities of a block permission by
<span class="lineno"> 4432 </span>-- setting those modalities that are supplied as arguments
<span class="lineno"> 4433 </span>llvmBlockAdjustModalities :: Maybe (PermExpr RWModalityType) -&gt;
<span class="lineno"> 4434 </span>                             Maybe (PermExpr LifetimeType) -&gt;
<span class="lineno"> 4435 </span>                             LLVMBlockPerm w -&gt; LLVMBlockPerm w
<span class="lineno"> 4436 </span><span class="decl"><span class="nottickedoff">llvmBlockAdjustModalities maybe_rw maybe_l bp =</span>
<span class="lineno"> 4437 </span><span class="spaces">  </span><span class="nottickedoff">let rw = maybe (llvmBlockRW bp) id maybe_rw</span>
<span class="lineno"> 4438 </span><span class="spaces">      </span><span class="nottickedoff">l = maybe (llvmBlockLifetime bp) id maybe_l in</span>
<span class="lineno"> 4439 </span><span class="spaces">  </span><span class="nottickedoff">bp { llvmBlockRW = rw, llvmBlockLifetime = l }</span></span>
<span class="lineno"> 4440 </span>
<span class="lineno"> 4441 </span>-- | Convert a block permission of pointer shape to the block permission of
<span class="lineno"> 4442 </span>-- field shape that it represents. That is, convert the block permission
<span class="lineno"> 4443 </span>--
<span class="lineno"> 4444 </span>-- &gt; [l]memblock(rw,off,w/8,[l2]ptrsh(rw2,sh))
<span class="lineno"> 4445 </span>--
<span class="lineno"> 4446 </span>-- to
<span class="lineno"> 4447 </span>--
<span class="lineno"> 4448 </span>-- &gt; [l]memblock(rw,off,w/8,fieldsh([l2]memblock(rw2,0,sh_len,sh)))
<span class="lineno"> 4449 </span>--
<span class="lineno"> 4450 </span>-- where @sh_len@ is the 'llvmShapeLength' of @sh@. It is an error if the input
<span class="lineno"> 4451 </span>-- block permission does not have the required form displayed above.
<span class="lineno"> 4452 </span>llvmBlockPtrShapeUnfold :: (1 &lt;= w, KnownNat w) =&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 4453 </span>                           Maybe (LLVMBlockPerm w)
<span class="lineno"> 4454 </span><span class="decl"><span class="nottickedoff">llvmBlockPtrShapeUnfold bp</span>
<span class="lineno"> 4455 </span><span class="spaces">  </span><span class="nottickedoff">| PExpr_PtrShape maybe_rw maybe_l sh &lt;- llvmBlockShape bp</span>
<span class="lineno"> 4456 </span><span class="spaces">  </span><span class="nottickedoff">, Just sh_len &lt;- llvmShapeLength sh</span>
<span class="lineno"> 4457 </span><span class="spaces">  </span><span class="nottickedoff">, bvEq (llvmBlockLen bp) (bvInt $ machineWordBytes bp) =</span>
<span class="lineno"> 4458 </span><span class="spaces">    </span><span class="nottickedoff">Just $ bp { llvmBlockShape =</span>
<span class="lineno"> 4459 </span><span class="spaces">                </span><span class="nottickedoff">PExpr_FieldShape $ LLVMFieldShape $ ValPerm_LLVMBlock $</span>
<span class="lineno"> 4460 </span><span class="spaces">                </span><span class="nottickedoff">LLVMBlockPerm</span>
<span class="lineno"> 4461 </span><span class="spaces">                </span><span class="nottickedoff">{ llvmBlockRW = maybe (llvmBlockRW bp) id maybe_rw,</span>
<span class="lineno"> 4462 </span><span class="spaces">                  </span><span class="nottickedoff">llvmBlockLifetime = maybe (llvmBlockLifetime bp) id maybe_l,</span>
<span class="lineno"> 4463 </span><span class="spaces">                  </span><span class="nottickedoff">llvmBlockOffset = bvInt 0,</span>
<span class="lineno"> 4464 </span><span class="spaces">                  </span><span class="nottickedoff">llvmBlockLen = sh_len,</span>
<span class="lineno"> 4465 </span><span class="spaces">                  </span><span class="nottickedoff">llvmBlockShape = sh } }</span>
<span class="lineno"> 4466 </span><span class="spaces"></span><span class="nottickedoff">llvmBlockPtrShapeUnfold _ = Nothing</span></span>
<span class="lineno"> 4467 </span>
<span class="lineno"> 4468 </span>-- | Create a read block permission with shape @sh@, i.e., the 'LLVMBlockPerm'
<span class="lineno"> 4469 </span>-- corresponding to the permission @memblock(R,0,'llvmShapeLength'(sh),sh)@
<span class="lineno"> 4470 </span>llvmReadBlockOfShape :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (LLVMShapeType w) -&gt;
<span class="lineno"> 4471 </span>                        LLVMBlockPerm w
<span class="lineno"> 4472 </span><span class="decl"><span class="nottickedoff">llvmReadBlockOfShape sh</span>
<span class="lineno"> 4473 </span><span class="spaces">  </span><span class="nottickedoff">| Just len &lt;- llvmShapeLength sh =</span>
<span class="lineno"> 4474 </span><span class="spaces">    </span><span class="nottickedoff">LLVMBlockPerm { llvmBlockRW = PExpr_Read,</span>
<span class="lineno"> 4475 </span><span class="spaces">                    </span><span class="nottickedoff">llvmBlockLifetime = PExpr_Always,</span>
<span class="lineno"> 4476 </span><span class="spaces">                    </span><span class="nottickedoff">llvmBlockOffset = bvInt 0,</span>
<span class="lineno"> 4477 </span><span class="spaces">                    </span><span class="nottickedoff">llvmBlockLen = len,</span>
<span class="lineno"> 4478 </span><span class="spaces">                    </span><span class="nottickedoff">llvmBlockShape = sh }</span>
<span class="lineno"> 4479 </span><span class="spaces"></span><span class="nottickedoff">llvmReadBlockOfShape _ =</span>
<span class="lineno"> 4480 </span><span class="spaces">  </span><span class="nottickedoff">error &quot;llvmReadBlockOfShape: shape without known length&quot;</span></span>
<span class="lineno"> 4481 </span>
<span class="lineno"> 4482 </span>-- | Test if an LLVM shape is a sequence of field shapes, and if so, return that
<span class="lineno"> 4483 </span>-- sequence
<span class="lineno"> 4484 </span>matchLLVMFieldShapeSeq :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (LLVMShapeType w) -&gt;
<span class="lineno"> 4485 </span>                          Maybe [LLVMFieldShape w]
<span class="lineno"> 4486 </span><span class="decl"><span class="nottickedoff">matchLLVMFieldShapeSeq (PExpr_FieldShape fsh) = Just [fsh]</span>
<span class="lineno"> 4487 </span><span class="spaces"></span><span class="nottickedoff">matchLLVMFieldShapeSeq (PExpr_SeqShape sh1 sh2) =</span>
<span class="lineno"> 4488 </span><span class="spaces">  </span><span class="nottickedoff">(++) &lt;$&gt; matchLLVMFieldShapeSeq sh1 &lt;*&gt; matchLLVMFieldShapeSeq sh2</span>
<span class="lineno"> 4489 </span><span class="spaces"></span><span class="nottickedoff">matchLLVMFieldShapeSeq _ = Nothing</span></span>
<span class="lineno"> 4490 </span>
<span class="lineno"> 4491 </span>-- | Get all the top-level ranges of offsets potentially covered by a permission
<span class="lineno"> 4492 </span>-- in any of its disjunctive branches
<span class="lineno"> 4493 </span>class GetOffsets f where
<span class="lineno"> 4494 </span>  getOffsets :: f a -&gt; [MbRangeForType a]
<span class="lineno"> 4495 </span>
<span class="lineno"> 4496 </span>instance GetOffsets ValuePerm where
<span class="lineno"> 4497 </span>  <span class="decl"><span class="nottickedoff">getOffsets (ValPerm_Eq _) = []</span>
<span class="lineno"> 4498 </span><span class="spaces">  </span><span class="nottickedoff">getOffsets (ValPerm_Or p1 p2) = getOffsets p1 ++ getOffsets p2</span>
<span class="lineno"> 4499 </span><span class="spaces">  </span><span class="nottickedoff">getOffsets (ValPerm_Exists mb_p) =</span>
<span class="lineno"> 4500 </span><span class="spaces">    </span><span class="nottickedoff">map (mbMbRangeForType knownRepr) $</span>
<span class="lineno"> 4501 </span><span class="spaces">    </span><span class="nottickedoff">mbList $ fmap getOffsets mb_p</span>
<span class="lineno"> 4502 </span><span class="spaces">  </span><span class="nottickedoff">getOffsets (ValPerm_Named _ _ _) = []</span>
<span class="lineno"> 4503 </span><span class="spaces">  </span><span class="nottickedoff">getOffsets (ValPerm_Var _ _) = []</span>
<span class="lineno"> 4504 </span><span class="spaces">  </span><span class="nottickedoff">getOffsets (ValPerm_Conj ps) = concatMap getOffsets ps</span>
<span class="lineno"> 4505 </span><span class="spaces">  </span><span class="nottickedoff">getOffsets ValPerm_False = []</span></span>
<span class="lineno"> 4506 </span>
<span class="lineno"> 4507 </span>instance GetOffsets AtomicPerm where
<span class="lineno"> 4508 </span>  <span class="decl"><span class="nottickedoff">getOffsets (Perm_LLVMField fp) =</span>
<span class="lineno"> 4509 </span><span class="spaces">    </span><span class="nottickedoff">[rangeForLLVMType</span>
<span class="lineno"> 4510 </span><span class="spaces">     </span><span class="nottickedoff">(llvmFieldRW fp) (llvmFieldLifetime fp) (llvmFieldRange fp)]</span>
<span class="lineno"> 4511 </span><span class="spaces">  </span><span class="nottickedoff">getOffsets (Perm_LLVMArray ap) =</span>
<span class="lineno"> 4512 </span><span class="spaces">    </span><span class="nottickedoff">[rangeForLLVMType</span>
<span class="lineno"> 4513 </span><span class="spaces">     </span><span class="nottickedoff">(llvmArrayRW ap) (llvmArrayLifetime ap) (llvmArrayRange ap)]</span>
<span class="lineno"> 4514 </span><span class="spaces">  </span><span class="nottickedoff">getOffsets (Perm_LLVMBlock bp) =</span>
<span class="lineno"> 4515 </span><span class="spaces">    </span><span class="nottickedoff">[rangeForLLVMType</span>
<span class="lineno"> 4516 </span><span class="spaces">     </span><span class="nottickedoff">(llvmBlockRW bp) (llvmBlockLifetime bp) (llvmBlockRange bp)]</span>
<span class="lineno"> 4517 </span><span class="spaces">  </span><span class="nottickedoff">getOffsets _ = []</span></span>
<span class="lineno"> 4518 </span>
<span class="lineno"> 4519 </span>-- | Get the range of offsets potentially covered by a permission in a binding
<span class="lineno"> 4520 </span>mbGetOffsets :: GetOffsets f =&gt; CruCtx ctx -&gt; Mb ctx (f a) -&gt; [MbRangeForType a]
<span class="lineno"> 4521 </span><span class="decl"><span class="nottickedoff">mbGetOffsets ctx =</span>
<span class="lineno"> 4522 </span><span class="spaces">  </span><span class="nottickedoff">map (mbMbRangeForType ctx) . mbList . mbMapCl $(mkClosed [| getOffsets |])</span></span>
<span class="lineno"> 4523 </span>
<span class="lineno"> 4524 </span>-- | Add the given read/write and lifetime modalities to all top-level pointer
<span class="lineno"> 4525 </span>-- permissions or shapes in a permission or shape. Top-level here means we do
<span class="lineno"> 4526 </span>-- not recurse inside pointer shapes, as pointer shape modalities also apply
<span class="lineno"> 4527 </span>-- recursively to the contained shapes. If there are any top-level variables in
<span class="lineno"> 4528 </span>-- the permission or shape, then this fails, since there is no way to modalize a
<span class="lineno"> 4529 </span>-- variable.
<span class="lineno"> 4530 </span>--
<span class="lineno"> 4531 </span>-- The high-level idea here is that pointer shapes take on the read/write and
<span class="lineno"> 4532 </span>-- lifetime modalities of the @memblock@ permission containing them, and
<span class="lineno"> 4533 </span>-- 'modalize' folds these modalities into the shape itself. This is also used to
<span class="lineno"> 4534 </span>-- compute the least version of a permission when building @lowned@ permissions.
<span class="lineno"> 4535 </span>class Modalize a where
<span class="lineno"> 4536 </span>  modalize :: Maybe (PermExpr RWModalityType) -&gt;
<span class="lineno"> 4537 </span>              Maybe (PermExpr LifetimeType) -&gt;
<span class="lineno"> 4538 </span>              a -&gt; Maybe a
<span class="lineno"> 4539 </span>
<span class="lineno"> 4540 </span>instance Modalize (PermExpr (LLVMShapeType w)) where
<span class="lineno"> 4541 </span>  <span class="decl"><span class="nottickedoff">modalize Nothing Nothing sh =</span>
<span class="lineno"> 4542 </span><span class="spaces">    </span><span class="nottickedoff">-- If neither modality is given, it is a no-op</span>
<span class="lineno"> 4543 </span><span class="spaces">    </span><span class="nottickedoff">Just sh</span>
<span class="lineno"> 4544 </span><span class="spaces">  </span><span class="nottickedoff">modalize _ _ (PExpr_Var _) =</span>
<span class="lineno"> 4545 </span><span class="spaces">    </span><span class="nottickedoff">-- Variables cannot be modalized; NOTE: we could fix this if necessary by</span>
<span class="lineno"> 4546 </span><span class="spaces">    </span><span class="nottickedoff">-- adding a modalized variable shape constructor</span>
<span class="lineno"> 4547 </span><span class="spaces">    </span><span class="nottickedoff">Nothing</span>
<span class="lineno"> 4548 </span><span class="spaces">  </span><span class="nottickedoff">modalize _ _ PExpr_EmptyShape = Just PExpr_EmptyShape</span>
<span class="lineno"> 4549 </span><span class="spaces">  </span><span class="nottickedoff">modalize _ _ sh@(PExpr_NamedShape _ _ nmsh _)</span>
<span class="lineno"> 4550 </span><span class="spaces">    </span><span class="nottickedoff">| not (namedShapeCanUnfold nmsh) =</span>
<span class="lineno"> 4551 </span><span class="spaces">      </span><span class="nottickedoff">-- Opaque shapes are not affected by modalization, because we assume they do</span>
<span class="lineno"> 4552 </span><span class="spaces">      </span><span class="nottickedoff">-- not have any top-level pointers in them</span>
<span class="lineno"> 4553 </span><span class="spaces">      </span><span class="nottickedoff">Just sh</span>
<span class="lineno"> 4554 </span><span class="spaces">  </span><span class="nottickedoff">modalize rw l (PExpr_NamedShape rw' l' nmsh args) =</span>
<span class="lineno"> 4555 </span><span class="spaces">    </span><span class="nottickedoff">-- If a named shape already has modalities, they take precedence</span>
<span class="lineno"> 4556 </span><span class="spaces">    </span><span class="nottickedoff">Just $ PExpr_NamedShape (rw' &lt;|&gt; rw) (l' &lt;|&gt; l) nmsh args</span>
<span class="lineno"> 4557 </span><span class="spaces">  </span><span class="nottickedoff">modalize _ _ sh@(PExpr_EqShape _ _) = Just sh</span>
<span class="lineno"> 4558 </span><span class="spaces">  </span><span class="nottickedoff">modalize rw l (PExpr_PtrShape rw' l' sh) =</span>
<span class="lineno"> 4559 </span><span class="spaces">    </span><span class="nottickedoff">-- If a pointer shape already has modalities, they take precedence</span>
<span class="lineno"> 4560 </span><span class="spaces">    </span><span class="nottickedoff">Just $ PExpr_PtrShape (rw' &lt;|&gt; rw) (l' &lt;|&gt; l) sh</span>
<span class="lineno"> 4561 </span><span class="spaces">  </span><span class="nottickedoff">modalize _ _ sh@(PExpr_FieldShape _) = Just sh</span>
<span class="lineno"> 4562 </span><span class="spaces">  </span><span class="nottickedoff">modalize _ _ sh@(PExpr_ArrayShape _ _ _) = Just sh</span>
<span class="lineno"> 4563 </span><span class="spaces">  </span><span class="nottickedoff">modalize rw l (PExpr_TupShape sh) = PExpr_TupShape &lt;$&gt; modalize rw l sh</span>
<span class="lineno"> 4564 </span><span class="spaces">  </span><span class="nottickedoff">modalize rw l (PExpr_SeqShape sh1 sh2) =</span>
<span class="lineno"> 4565 </span><span class="spaces">    </span><span class="nottickedoff">PExpr_SeqShape &lt;$&gt; modalize rw l sh1 &lt;*&gt; modalize rw l sh2</span>
<span class="lineno"> 4566 </span><span class="spaces">  </span><span class="nottickedoff">modalize rw l (PExpr_OrShape sh1 sh2) =</span>
<span class="lineno"> 4567 </span><span class="spaces">    </span><span class="nottickedoff">PExpr_OrShape &lt;$&gt; modalize rw l sh1 &lt;*&gt; modalize rw l sh2</span>
<span class="lineno"> 4568 </span><span class="spaces">  </span><span class="nottickedoff">modalize rw l (PExpr_ExShape mb_sh) =</span>
<span class="lineno"> 4569 </span><span class="spaces">    </span><span class="nottickedoff">PExpr_ExShape &lt;$&gt; mbM (fmap (modalize rw l) mb_sh)</span>
<span class="lineno"> 4570 </span><span class="spaces">  </span><span class="nottickedoff">modalize _ _ PExpr_FalseShape = Just PExpr_FalseShape</span></span>
<span class="lineno"> 4571 </span>
<span class="lineno"> 4572 </span>instance Modalize (ValuePerm a) where
<span class="lineno"> 4573 </span>  <span class="decl"><span class="nottickedoff">modalize _ _ p@(ValPerm_Eq _) = Just p</span>
<span class="lineno"> 4574 </span><span class="spaces">  </span><span class="nottickedoff">modalize rw l (ValPerm_Or p1 p2) =</span>
<span class="lineno"> 4575 </span><span class="spaces">    </span><span class="nottickedoff">ValPerm_Or &lt;$&gt; modalize rw l p1 &lt;*&gt; modalize rw l p2</span>
<span class="lineno"> 4576 </span><span class="spaces">  </span><span class="nottickedoff">modalize rw l (ValPerm_Exists mb_p) =</span>
<span class="lineno"> 4577 </span><span class="spaces">    </span><span class="nottickedoff">fmap ValPerm_Exists $ mbMaybe $ fmap (modalize rw l) mb_p</span>
<span class="lineno"> 4578 </span><span class="spaces">  </span><span class="nottickedoff">modalize _ _ (ValPerm_Named _ _ _) =</span>
<span class="lineno"> 4579 </span><span class="spaces">    </span><span class="nottickedoff">-- Cannot modalize an arbitrary opaque named permission; this would require</span>
<span class="lineno"> 4580 </span><span class="spaces">    </span><span class="nottickedoff">-- special-purpose modality arguments to every opaque named permission, so</span>
<span class="lineno"> 4581 </span><span class="spaces">    </span><span class="nottickedoff">-- we could be sure that changing these would modalize its unfolding</span>
<span class="lineno"> 4582 </span><span class="spaces">    </span><span class="nottickedoff">Nothing</span>
<span class="lineno"> 4583 </span><span class="spaces">  </span><span class="nottickedoff">modalize _ _ (ValPerm_Var _ _) = Nothing</span>
<span class="lineno"> 4584 </span><span class="spaces">  </span><span class="nottickedoff">modalize rw l (ValPerm_Conj ps) = ValPerm_Conj &lt;$&gt; mapM (modalize rw l) ps</span>
<span class="lineno"> 4585 </span><span class="spaces">  </span><span class="nottickedoff">modalize _ _ ValPerm_False = Just ValPerm_False</span></span>
<span class="lineno"> 4586 </span>
<span class="lineno"> 4587 </span>instance Modalize (AtomicPerm a) where
<span class="lineno"> 4588 </span>  <span class="decl"><span class="nottickedoff">modalize rw l (Perm_LLVMField fp) =</span>
<span class="lineno"> 4589 </span><span class="spaces">    </span><span class="nottickedoff">Just $ Perm_LLVMField $</span>
<span class="lineno"> 4590 </span><span class="spaces">    </span><span class="nottickedoff">fp { llvmFieldRW = fromMaybe (llvmFieldRW fp) rw,</span>
<span class="lineno"> 4591 </span><span class="spaces">         </span><span class="nottickedoff">llvmFieldLifetime = fromMaybe (llvmFieldLifetime fp) l }</span>
<span class="lineno"> 4592 </span><span class="spaces">  </span><span class="nottickedoff">modalize rw l (Perm_LLVMArray ap) =</span>
<span class="lineno"> 4593 </span><span class="spaces">    </span><span class="nottickedoff">Just $ Perm_LLVMArray $</span>
<span class="lineno"> 4594 </span><span class="spaces">    </span><span class="nottickedoff">ap { llvmArrayRW = fromMaybe (llvmArrayRW ap) rw,</span>
<span class="lineno"> 4595 </span><span class="spaces">         </span><span class="nottickedoff">llvmArrayLifetime = fromMaybe (llvmArrayLifetime ap) l }</span>
<span class="lineno"> 4596 </span><span class="spaces">  </span><span class="nottickedoff">modalize rw l (Perm_LLVMBlock bp) =</span>
<span class="lineno"> 4597 </span><span class="spaces">    </span><span class="nottickedoff">Just $ Perm_LLVMBlock $</span>
<span class="lineno"> 4598 </span><span class="spaces">    </span><span class="nottickedoff">bp { llvmBlockRW = fromMaybe (llvmBlockRW bp) rw,</span>
<span class="lineno"> 4599 </span><span class="spaces">         </span><span class="nottickedoff">llvmBlockLifetime = fromMaybe (llvmBlockLifetime bp) l }</span>
<span class="lineno"> 4600 </span><span class="spaces">  </span><span class="nottickedoff">modalize _ _ p@(Perm_LLVMFree _) = Just p</span>
<span class="lineno"> 4601 </span><span class="spaces">  </span><span class="nottickedoff">modalize _ _ p@(Perm_LLVMFunPtr _ _) = Just p</span>
<span class="lineno"> 4602 </span><span class="spaces">  </span><span class="nottickedoff">modalize rw l (Perm_LLVMBlockShape sh) =</span>
<span class="lineno"> 4603 </span><span class="spaces">    </span><span class="nottickedoff">Perm_LLVMBlockShape &lt;$&gt; modalize rw l sh</span>
<span class="lineno"> 4604 </span><span class="spaces">  </span><span class="nottickedoff">modalize _ _ p@(Perm_IsLLVMPtr) = Just p</span>
<span class="lineno"> 4605 </span><span class="spaces">  </span><span class="nottickedoff">modalize _ _ p@(Perm_NamedConj _ _ _) = Just p</span>
<span class="lineno"> 4606 </span><span class="spaces">  </span><span class="nottickedoff">modalize _ _ p@(Perm_LLVMFrame _) = Just p</span>
<span class="lineno"> 4607 </span><span class="spaces">  </span><span class="nottickedoff">modalize _ _ p@(Perm_LOwned _ _ _ _ _) = Just p</span>
<span class="lineno"> 4608 </span><span class="spaces">  </span><span class="nottickedoff">modalize _ _ p@(Perm_LOwnedSimple _ _) = Just p</span>
<span class="lineno"> 4609 </span><span class="spaces">  </span><span class="nottickedoff">modalize _ _ p@(Perm_LCurrent _) = Just p</span>
<span class="lineno"> 4610 </span><span class="spaces">  </span><span class="nottickedoff">modalize _ _ p@(Perm_LFinished) = Just p</span>
<span class="lineno"> 4611 </span><span class="spaces">  </span><span class="nottickedoff">modalize rw l (Perm_Struct ps) =</span>
<span class="lineno"> 4612 </span><span class="spaces">    </span><span class="nottickedoff">Perm_Struct &lt;$&gt; traverseRAssign (modalize rw l) ps</span>
<span class="lineno"> 4613 </span><span class="spaces">  </span><span class="nottickedoff">modalize _ _ p@(Perm_Fun _) = Just p</span>
<span class="lineno"> 4614 </span><span class="spaces">  </span><span class="nottickedoff">modalize _ _ p@(Perm_BVProp _) = Just p</span>
<span class="lineno"> 4615 </span><span class="spaces">  </span><span class="nottickedoff">modalize _ _ p@Perm_Any = Just p</span></span>
<span class="lineno"> 4616 </span>
<span class="lineno"> 4617 </span>instance Modalize (ExprAndPerm a) where
<span class="lineno"> 4618 </span>  <span class="decl"><span class="nottickedoff">modalize rw l (ExprAndPerm e p) =</span>
<span class="lineno"> 4619 </span><span class="spaces">    </span><span class="nottickedoff">ExprAndPerm e &lt;$&gt; modalize rw l p</span></span>
<span class="lineno"> 4620 </span>
<span class="lineno"> 4621 </span>instance Modalize (ExprPerms ctx) where
<span class="lineno"> 4622 </span>  <span class="decl"><span class="nottickedoff">modalize rw l perms = traverseRAssign (modalize rw l) perms</span></span>
<span class="lineno"> 4623 </span>
<span class="lineno"> 4624 </span>
<span class="lineno"> 4625 </span>-- | Apply 'modalize' to the shape of a block permission, using the
<span class="lineno"> 4626 </span>-- modalities of that block permission, raising an error if 'modalize'
<span class="lineno"> 4627 </span>-- cannot be applied
<span class="lineno"> 4628 </span>modalizeBlockShape :: LLVMBlockPerm w -&gt; PermExpr (LLVMShapeType w)
<span class="lineno"> 4629 </span><span class="decl"><span class="nottickedoff">modalizeBlockShape (LLVMBlockPerm {..}) =</span>
<span class="lineno"> 4630 </span><span class="spaces">  </span><span class="nottickedoff">maybe (error &quot;modalizeBlockShape&quot;) id $</span>
<span class="lineno"> 4631 </span><span class="spaces">  </span><span class="nottickedoff">modalize (Just llvmBlockRW) (Just llvmBlockLifetime) llvmBlockShape</span></span>
<span class="lineno"> 4632 </span>
<span class="lineno"> 4633 </span>-- | Convert an 'ExprPerms' list @ps@ to the input permission list @[l](R)ps@
<span class="lineno"> 4634 </span>-- used in a simple @lowned@ permission
<span class="lineno"> 4635 </span>lownedPermsSimpleIn :: ExprVar LifetimeType -&gt; ExprPerms ps -&gt;
<span class="lineno"> 4636 </span>                       Maybe (ExprPerms ps)
<span class="lineno"> 4637 </span><span class="decl"><span class="nottickedoff">lownedPermsSimpleIn l = modalize (Just PExpr_Read) (Just $ PExpr_Var l)</span></span>
<span class="lineno"> 4638 </span>
<span class="lineno"> 4639 </span>instance <span class="decl"><span class="nottickedoff">Functor SomeTypedMb</span></span> where
<span class="lineno"> 4640 </span>  <span class="decl"><span class="nottickedoff">fmap f (SomeTypedMb ctx mb_a) = SomeTypedMb ctx (fmap f mb_a)</span></span>
<span class="lineno"> 4641 </span>
<span class="lineno"> 4642 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Applicative SomeTypedMb</span></span></span></span></span></span> where
<span class="lineno"> 4643 </span>  <span class="decl"><span class="nottickedoff">pure a = SomeTypedMb CruCtxNil $ emptyMb a</span></span>
<span class="lineno"> 4644 </span>  <span class="decl"><span class="nottickedoff">liftA2 f (SomeTypedMb ctx1 mb_a1) (SomeTypedMb ctx2 mb_a2) =</span>
<span class="lineno"> 4645 </span><span class="spaces">    </span><span class="nottickedoff">SomeTypedMb (appendCruCtx ctx1 ctx2) $</span>
<span class="lineno"> 4646 </span><span class="spaces">    </span><span class="nottickedoff">mbCombine (cruCtxProxies ctx2) $</span>
<span class="lineno"> 4647 </span><span class="spaces">    </span><span class="nottickedoff">flip fmap mb_a1 $ \a1 -&gt; flip fmap mb_a2 $ \a2 -&gt; f a1 a2</span></span>
<span class="lineno"> 4648 </span>
<span class="lineno"> 4649 </span>-- | Commute a 'SomeTypedMb' out of a name-binding
<span class="lineno"> 4650 </span>mbSomeTypedMb :: NuMatching a =&gt; Mb ctx (SomeTypedMb a) -&gt;
<span class="lineno"> 4651 </span>                 SomeTypedMb (Mb ctx a)
<span class="lineno"> 4652 </span><span class="decl"><span class="nottickedoff">mbSomeTypedMb (mbMatch -&gt; [nuMP| SomeTypedMb ctx mb_a |]) =</span>
<span class="lineno"> 4653 </span><span class="spaces">  </span><span class="nottickedoff">SomeTypedMb (mbLift ctx) $ mbSwap (cruCtxProxies $ mbLift ctx) mb_a</span></span>
<span class="lineno"> 4654 </span>
<span class="lineno"> 4655 </span>-- | Generic function to abstract all the read/write and lifetime modalities in
<span class="lineno"> 4656 </span>-- a permission
<span class="lineno"> 4657 </span>class AbstractModalities a where
<span class="lineno"> 4658 </span>  abstractModalities :: a -&gt; SomeTypedMb a
<span class="lineno"> 4659 </span>
<span class="lineno"> 4660 </span>instance (NuMatching a, AbstractModalities a) =&gt;
<span class="lineno"> 4661 </span>         AbstractModalities (Mb ctx a) where
<span class="lineno"> 4662 </span>  <span class="decl"><span class="nottickedoff">abstractModalities mb_a = mbSomeTypedMb $ fmap abstractModalities mb_a</span></span>
<span class="lineno"> 4663 </span>
<span class="lineno"> 4664 </span>instance AbstractModalities (ExprAndPerm a) where
<span class="lineno"> 4665 </span>  <span class="decl"><span class="nottickedoff">abstractModalities (ExprAndPerm e p) =</span>
<span class="lineno"> 4666 </span><span class="spaces">    </span><span class="nottickedoff">ExprAndPerm e &lt;$&gt; abstractModalities p</span></span>
<span class="lineno"> 4667 </span>
<span class="lineno"> 4668 </span>instance AbstractModalities (RAssign ExprAndPerm a) where
<span class="lineno"> 4669 </span>  <span class="decl"><span class="nottickedoff">abstractModalities MNil = pure MNil</span>
<span class="lineno"> 4670 </span><span class="spaces">  </span><span class="nottickedoff">abstractModalities (eps :&gt;: ep) =</span>
<span class="lineno"> 4671 </span><span class="spaces">    </span><span class="nottickedoff">(:&gt;:) &lt;$&gt; abstractModalities eps &lt;*&gt; abstractModalities ep</span></span>
<span class="lineno"> 4672 </span>
<span class="lineno"> 4673 </span>instance AbstractModalities (ValuePerm a) where
<span class="lineno"> 4674 </span>  <span class="decl"><span class="nottickedoff">abstractModalities p@(ValPerm_Eq _) = pure p</span>
<span class="lineno"> 4675 </span><span class="spaces">  </span><span class="nottickedoff">abstractModalities (ValPerm_Or p1 p2) =</span>
<span class="lineno"> 4676 </span><span class="spaces">    </span><span class="nottickedoff">ValPerm_Or &lt;$&gt; abstractModalities p1 &lt;*&gt; abstractModalities p2</span>
<span class="lineno"> 4677 </span><span class="spaces">  </span><span class="nottickedoff">abstractModalities (ValPerm_Exists mb_p) =</span>
<span class="lineno"> 4678 </span><span class="spaces">    </span><span class="nottickedoff">ValPerm_Exists &lt;$&gt; abstractModalities mb_p</span>
<span class="lineno"> 4679 </span><span class="spaces">  </span><span class="nottickedoff">abstractModalities p@(ValPerm_Named _ _ _) =</span>
<span class="lineno"> 4680 </span><span class="spaces">    </span><span class="nottickedoff">-- Cannot abstract modalities out of an arbitrary named permission; this</span>
<span class="lineno"> 4681 </span><span class="spaces">    </span><span class="nottickedoff">-- would require special-purpose modality arguments to every named</span>
<span class="lineno"> 4682 </span><span class="spaces">    </span><span class="nottickedoff">-- permission, so we could be sure that abstract these would abstract its</span>
<span class="lineno"> 4683 </span><span class="spaces">    </span><span class="nottickedoff">-- unfolding</span>
<span class="lineno"> 4684 </span><span class="spaces">    </span><span class="nottickedoff">pure p</span>
<span class="lineno"> 4685 </span><span class="spaces">  </span><span class="nottickedoff">abstractModalities p@(ValPerm_Var _ _) = pure p</span>
<span class="lineno"> 4686 </span><span class="spaces">  </span><span class="nottickedoff">abstractModalities (ValPerm_Conj ps) =</span>
<span class="lineno"> 4687 </span><span class="spaces">    </span><span class="nottickedoff">ValPerm_Conj &lt;$&gt; traverse abstractModalities ps</span>
<span class="lineno"> 4688 </span><span class="spaces">  </span><span class="nottickedoff">abstractModalities ValPerm_False = pure ValPerm_False</span></span>
<span class="lineno"> 4689 </span>
<span class="lineno"> 4690 </span>instance AbstractModalities (AtomicPerm a) where
<span class="lineno"> 4691 </span>  <span class="decl"><span class="nottickedoff">abstractModalities (Perm_LLVMField fp) =</span>
<span class="lineno"> 4692 </span><span class="spaces">    </span><span class="nottickedoff">SomeTypedMb knownRepr $</span>
<span class="lineno"> 4693 </span><span class="spaces">    </span><span class="nottickedoff">nuMulti (MNil :&gt;: Proxy :&gt;: Proxy) $ \(_ :&gt;: rw :&gt;: l) -&gt;</span>
<span class="lineno"> 4694 </span><span class="spaces">    </span><span class="nottickedoff">Perm_LLVMField $ fp { llvmFieldRW = PExpr_Var rw,</span>
<span class="lineno"> 4695 </span><span class="spaces">                          </span><span class="nottickedoff">llvmFieldLifetime = PExpr_Var l }</span>
<span class="lineno"> 4696 </span><span class="spaces">  </span><span class="nottickedoff">abstractModalities (Perm_LLVMArray fp) =</span>
<span class="lineno"> 4697 </span><span class="spaces">    </span><span class="nottickedoff">SomeTypedMb knownRepr $</span>
<span class="lineno"> 4698 </span><span class="spaces">    </span><span class="nottickedoff">nuMulti (MNil :&gt;: Proxy :&gt;: Proxy) $ \(_ :&gt;: rw :&gt;: l) -&gt;</span>
<span class="lineno"> 4699 </span><span class="spaces">    </span><span class="nottickedoff">Perm_LLVMArray $ fp { llvmArrayRW = PExpr_Var rw,</span>
<span class="lineno"> 4700 </span><span class="spaces">                          </span><span class="nottickedoff">llvmArrayLifetime = PExpr_Var l }</span>
<span class="lineno"> 4701 </span><span class="spaces">  </span><span class="nottickedoff">abstractModalities (Perm_LLVMBlock fp) =</span>
<span class="lineno"> 4702 </span><span class="spaces">    </span><span class="nottickedoff">SomeTypedMb knownRepr $</span>
<span class="lineno"> 4703 </span><span class="spaces">    </span><span class="nottickedoff">nuMulti (MNil :&gt;: Proxy :&gt;: Proxy) $ \(_ :&gt;: rw :&gt;: l) -&gt;</span>
<span class="lineno"> 4704 </span><span class="spaces">    </span><span class="nottickedoff">Perm_LLVMBlock $ fp { llvmBlockRW = PExpr_Var rw,</span>
<span class="lineno"> 4705 </span><span class="spaces">                          </span><span class="nottickedoff">llvmBlockLifetime = PExpr_Var l }</span>
<span class="lineno"> 4706 </span><span class="spaces">  </span><span class="nottickedoff">abstractModalities p@(Perm_LLVMFree _) = pure p</span>
<span class="lineno"> 4707 </span><span class="spaces">  </span><span class="nottickedoff">abstractModalities p@(Perm_LLVMFunPtr _ _) = pure p</span>
<span class="lineno"> 4708 </span><span class="spaces">  </span><span class="nottickedoff">abstractModalities p@(Perm_LLVMBlockShape _) = pure p</span>
<span class="lineno"> 4709 </span><span class="spaces">  </span><span class="nottickedoff">abstractModalities p@(Perm_IsLLVMPtr) = pure p</span>
<span class="lineno"> 4710 </span><span class="spaces">  </span><span class="nottickedoff">abstractModalities p@(Perm_NamedConj _ _ _) = pure p</span>
<span class="lineno"> 4711 </span><span class="spaces">  </span><span class="nottickedoff">abstractModalities p@(Perm_LLVMFrame _) = pure p</span>
<span class="lineno"> 4712 </span><span class="spaces">  </span><span class="nottickedoff">abstractModalities p@(Perm_LOwned _ _ _ _ _) = pure p</span>
<span class="lineno"> 4713 </span><span class="spaces">  </span><span class="nottickedoff">abstractModalities p@(Perm_LOwnedSimple _ _) = pure p</span>
<span class="lineno"> 4714 </span><span class="spaces">  </span><span class="nottickedoff">abstractModalities p@(Perm_LCurrent _) = pure p</span>
<span class="lineno"> 4715 </span><span class="spaces">  </span><span class="nottickedoff">abstractModalities p@(Perm_LFinished) = pure p</span>
<span class="lineno"> 4716 </span><span class="spaces">  </span><span class="nottickedoff">abstractModalities (Perm_Struct ps) =</span>
<span class="lineno"> 4717 </span><span class="spaces">    </span><span class="nottickedoff">Perm_Struct &lt;$&gt; traverseRAssign abstractModalities ps</span>
<span class="lineno"> 4718 </span><span class="spaces">  </span><span class="nottickedoff">abstractModalities p@(Perm_Fun _) = pure p</span>
<span class="lineno"> 4719 </span><span class="spaces">  </span><span class="nottickedoff">abstractModalities p@(Perm_BVProp _) = pure p</span>
<span class="lineno"> 4720 </span><span class="spaces">  </span><span class="nottickedoff">abstractModalities p@Perm_Any = pure p</span></span>
<span class="lineno"> 4721 </span>
<span class="lineno"> 4722 </span>
<span class="lineno"> 4723 </span>-- | Extract the shape-in-bindings for an unfoldable shape
<span class="lineno"> 4724 </span>namedShapeBodyShape :: KnownNat w =&gt; NamedShape 'True args w -&gt;
<span class="lineno"> 4725 </span>                       Mb args (PermExpr (LLVMShapeType w))
<span class="lineno"> 4726 </span><span class="decl"><span class="nottickedoff">namedShapeBodyShape (NamedShape _ _ (DefinedShapeBody mb_sh)) = mb_sh</span>
<span class="lineno"> 4727 </span><span class="spaces"></span><span class="nottickedoff">namedShapeBodyShape sh@(NamedShape _ _ (RecShapeBody mb_sh _ _)) =</span>
<span class="lineno"> 4728 </span><span class="spaces">  </span><span class="nottickedoff">let (prxs :&gt;: _) = mbToProxy mb_sh in</span>
<span class="lineno"> 4729 </span><span class="spaces">  </span><span class="nottickedoff">nuMulti prxs $ \ns -&gt;</span>
<span class="lineno"> 4730 </span><span class="spaces">  </span><span class="nottickedoff">subst (substOfExprs (namesToExprs ns :&gt;:</span>
<span class="lineno"> 4731 </span><span class="spaces">                       </span><span class="nottickedoff">PExpr_NamedShape Nothing Nothing sh (namesToExprs ns)))</span>
<span class="lineno"> 4732 </span><span class="spaces">  </span><span class="nottickedoff">mb_sh</span></span>
<span class="lineno"> 4733 </span>
<span class="lineno"> 4734 </span>-- | Unfold a named shape
<span class="lineno"> 4735 </span>unfoldNamedShape :: KnownNat w =&gt; NamedShape 'True args w -&gt; PermExprs args -&gt;
<span class="lineno"> 4736 </span>                    PermExpr (LLVMShapeType w)
<span class="lineno"> 4737 </span><span class="decl"><span class="nottickedoff">unfoldNamedShape (NamedShape _ _ (DefinedShapeBody mb_sh)) args =</span>
<span class="lineno"> 4738 </span><span class="spaces">  </span><span class="nottickedoff">subst (substOfExprs args) mb_sh</span>
<span class="lineno"> 4739 </span><span class="spaces"></span><span class="nottickedoff">unfoldNamedShape sh@(NamedShape _ _ (RecShapeBody mb_sh _ _)) args =</span>
<span class="lineno"> 4740 </span><span class="spaces">  </span><span class="nottickedoff">subst (substOfExprs (args :&gt;: PExpr_NamedShape Nothing Nothing sh args)) mb_sh</span></span>
<span class="lineno"> 4741 </span>
<span class="lineno"> 4742 </span>-- | Unfold a named shape and apply 'modalize' to the result
<span class="lineno"> 4743 </span>unfoldModalizeNamedShape :: KnownNat w =&gt; Maybe (PermExpr RWModalityType) -&gt;
<span class="lineno"> 4744 </span>                            Maybe (PermExpr LifetimeType) -&gt;
<span class="lineno"> 4745 </span>                            NamedShape 'True args w -&gt; PermExprs args -&gt;
<span class="lineno"> 4746 </span>                            Maybe (PermExpr (LLVMShapeType w))
<span class="lineno"> 4747 </span><span class="decl"><span class="nottickedoff">unfoldModalizeNamedShape rw l nmsh args =</span>
<span class="lineno"> 4748 </span><span class="spaces">  </span><span class="nottickedoff">modalize rw l $ unfoldNamedShape nmsh args</span></span>
<span class="lineno"> 4749 </span>
<span class="lineno"> 4750 </span>-- | Unfold the shape of a block permission using 'unfoldModalizeNamedShape' if
<span class="lineno"> 4751 </span>-- it has a named shape
<span class="lineno"> 4752 </span>unfoldModalizeNamedShapeBlock :: KnownNat w =&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 4753 </span>                                 Maybe (LLVMBlockPerm w)
<span class="lineno"> 4754 </span><span class="decl"><span class="nottickedoff">unfoldModalizeNamedShapeBlock bp</span>
<span class="lineno"> 4755 </span><span class="spaces">  </span><span class="nottickedoff">| PExpr_NamedShape rw l nmsh args &lt;- llvmBlockShape bp</span>
<span class="lineno"> 4756 </span><span class="spaces">  </span><span class="nottickedoff">, TrueRepr &lt;- namedShapeCanUnfoldRepr nmsh</span>
<span class="lineno"> 4757 </span><span class="spaces">  </span><span class="nottickedoff">, Just sh' &lt;- unfoldModalizeNamedShape rw l nmsh args =</span>
<span class="lineno"> 4758 </span><span class="spaces">    </span><span class="nottickedoff">Just (bp { llvmBlockShape = sh' })</span>
<span class="lineno"> 4759 </span><span class="spaces"></span><span class="nottickedoff">unfoldModalizeNamedShapeBlock _ = Nothing</span></span>
<span class="lineno"> 4760 </span>
<span class="lineno"> 4761 </span>-- | Unfold the shape of a block permission in a binding using
<span class="lineno"> 4762 </span>-- 'unfoldModalizeNamedShape' if it has a named shape
<span class="lineno"> 4763 </span>mbUnfoldModalizeNamedShapeBlock :: KnownNat w =&gt; Mb ctx (LLVMBlockPerm w) -&gt;
<span class="lineno"> 4764 </span>                                   Maybe (Mb ctx (LLVMBlockPerm w))
<span class="lineno"> 4765 </span><span class="decl"><span class="nottickedoff">mbUnfoldModalizeNamedShapeBlock =</span>
<span class="lineno"> 4766 </span><span class="spaces">  </span><span class="nottickedoff">mbMaybe . mbMapCl $(mkClosed [| unfoldModalizeNamedShapeBlock |])</span></span>
<span class="lineno"> 4767 </span>
<span class="lineno"> 4768 </span>-- | Change the shape of a disjunctive block to either its left or right
<span class="lineno"> 4769 </span>-- disjunct, depending on whether the supplied 'Bool' is 'True' or 'False'
<span class="lineno"> 4770 </span>disjBlockToSubShape :: Bool -&gt; LLVMBlockPerm w -&gt; LLVMBlockPerm w
<span class="lineno"> 4771 </span><span class="decl"><span class="nottickedoff">disjBlockToSubShape flag bp</span>
<span class="lineno"> 4772 </span><span class="spaces">  </span><span class="nottickedoff">| PExpr_OrShape sh1 sh2 &lt;- llvmBlockShape bp =</span>
<span class="lineno"> 4773 </span><span class="spaces">    </span><span class="nottickedoff">bp { llvmBlockShape = if flag then sh1 else sh2 }</span>
<span class="lineno"> 4774 </span><span class="spaces"></span><span class="nottickedoff">disjBlockToSubShape _ _ = error &quot;disjBlockToSubShape&quot;</span></span>
<span class="lineno"> 4775 </span>
<span class="lineno"> 4776 </span>-- | Change the shape of a disjunctive block in a binding to either its left or
<span class="lineno"> 4777 </span>-- right disjunct, depending on whether the supplied 'Bool' is 'True' or 'False'
<span class="lineno"> 4778 </span>mbDisjBlockToSubShape :: Bool -&gt; Mb ctx (LLVMBlockPerm w) -&gt;
<span class="lineno"> 4779 </span>                         Mb ctx (LLVMBlockPerm w)
<span class="lineno"> 4780 </span><span class="decl"><span class="nottickedoff">mbDisjBlockToSubShape flag =</span>
<span class="lineno"> 4781 </span><span class="spaces">  </span><span class="nottickedoff">mbMapCl ($(mkClosed [| disjBlockToSubShape |]) `clApply` toClosed flag)</span></span>
<span class="lineno"> 4782 </span>
<span class="lineno"> 4783 </span>-- | Match an existential shape with the given bidning type
<span class="lineno"> 4784 </span>matchExShape :: TypeRepr a -&gt; PermExpr (LLVMShapeType w) -&gt;
<span class="lineno"> 4785 </span>                Maybe (Binding a (PermExpr (LLVMShapeType w)))
<span class="lineno"> 4786 </span><span class="decl"><span class="nottickedoff">matchExShape a (PExpr_ExShape (mb_sh :: Binding b (PermExpr (LLVMShapeType w))))</span>
<span class="lineno"> 4787 </span><span class="spaces">  </span><span class="nottickedoff">| Just Refl &lt;- testEquality a (knownRepr :: TypeRepr b) =</span>
<span class="lineno"> 4788 </span><span class="spaces">    </span><span class="nottickedoff">Just mb_sh</span>
<span class="lineno"> 4789 </span><span class="spaces"></span><span class="nottickedoff">matchExShape _ _ = Nothing</span></span>
<span class="lineno"> 4790 </span>
<span class="lineno"> 4791 </span>-- | Change the shape of an existential block to the body of its existential
<span class="lineno"> 4792 </span>exBlockToSubShape :: TypeRepr a -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 4793 </span>                     Binding a (LLVMBlockPerm w)
<span class="lineno"> 4794 </span><span class="decl"><span class="nottickedoff">exBlockToSubShape a bp</span>
<span class="lineno"> 4795 </span><span class="spaces">  </span><span class="nottickedoff">| Just mb_sh &lt;- matchExShape a $ llvmBlockShape bp =</span>
<span class="lineno"> 4796 </span><span class="spaces">    </span><span class="nottickedoff">-- NOTE: even when exBlockToSubShape is called inside a binding as part of</span>
<span class="lineno"> 4797 </span><span class="spaces">    </span><span class="nottickedoff">-- mbExBlockToSubShape, the existential binding will probably be a fresh</span>
<span class="lineno"> 4798 </span><span class="spaces">    </span><span class="nottickedoff">-- function instead of a fresh pair, because it itself has not been</span>
<span class="lineno"> 4799 </span><span class="spaces">    </span><span class="nottickedoff">-- mbMatched, so this fmap shouldn't be re-subsituting names</span>
<span class="lineno"> 4800 </span><span class="spaces">    </span><span class="nottickedoff">fmap (\sh -&gt; bp { llvmBlockShape = sh }) mb_sh</span>
<span class="lineno"> 4801 </span><span class="spaces"></span><span class="nottickedoff">exBlockToSubShape _ _ = error &quot;exBlockToSubShape&quot;</span></span>
<span class="lineno"> 4802 </span>
<span class="lineno"> 4803 </span>-- | Change the shape of an existential block in a binding to the body of its
<span class="lineno"> 4804 </span>-- existential
<span class="lineno"> 4805 </span>mbExBlockToSubShape :: TypeRepr a -&gt; Mb ctx (LLVMBlockPerm w) -&gt;
<span class="lineno"> 4806 </span>                       Mb (ctx :&gt; a) (LLVMBlockPerm w)
<span class="lineno"> 4807 </span><span class="decl"><span class="nottickedoff">mbExBlockToSubShape a =</span>
<span class="lineno"> 4808 </span><span class="spaces">  </span><span class="nottickedoff">mbCombine RL.typeCtxProxies .</span>
<span class="lineno"> 4809 </span><span class="spaces">  </span><span class="nottickedoff">mbMapCl ($(mkClosed [| exBlockToSubShape |]) `clApply` toClosed a)</span></span>
<span class="lineno"> 4810 </span>
<span class="lineno"> 4811 </span>-- | Split a block permission into portions that are before and after a given
<span class="lineno"> 4812 </span>-- offset, if possible, assuming the offset is in the block permission. The
<span class="lineno"> 4813 </span>-- supplied function provides a partial substitution from variables of
<span class="lineno"> 4814 </span>-- 'LLVMBlockType' to their shapes, in order to split @eqsh@ shapes.
<span class="lineno"> 4815 </span>splitLLVMBlockPerm ::
<span class="lineno"> 4816 </span>  (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 4817 </span>  (ExprVar (LLVMBlockType w) -&gt; Maybe (PermExpr (LLVMShapeType w))) -&gt;
<span class="lineno"> 4818 </span>  PermExpr (BVType w) -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 4819 </span>  Maybe (LLVMBlockPerm w, LLVMBlockPerm w)
<span class="lineno"> 4820 </span><span class="decl"><span class="nottickedoff">splitLLVMBlockPerm _ off bp</span>
<span class="lineno"> 4821 </span><span class="spaces">  </span><span class="nottickedoff">| bvEq off (llvmBlockOffset bp)</span>
<span class="lineno"> 4822 </span><span class="spaces">  </span><span class="nottickedoff">= Just (bp { llvmBlockLen = bvInt 0, llvmBlockShape = PExpr_EmptyShape },</span>
<span class="lineno"> 4823 </span><span class="spaces">          </span><span class="nottickedoff">bp)</span>
<span class="lineno"> 4824 </span><span class="spaces"></span><span class="nottickedoff">splitLLVMBlockPerm _ off bp@(llvmBlockShape -&gt; PExpr_EmptyShape) =</span>
<span class="lineno"> 4825 </span><span class="spaces">  </span><span class="nottickedoff">Just (bp { llvmBlockLen = bvSub off (llvmBlockOffset bp) },</span>
<span class="lineno"> 4826 </span><span class="spaces">        </span><span class="nottickedoff">bp { llvmBlockOffset = off,</span>
<span class="lineno"> 4827 </span><span class="spaces">             </span><span class="nottickedoff">llvmBlockLen = bvSub (llvmBlockEndOffset bp) off })</span>
<span class="lineno"> 4828 </span><span class="spaces"></span><span class="nottickedoff">splitLLVMBlockPerm blsubst off bp@(LLVMBlockPerm { llvmBlockShape = sh })</span>
<span class="lineno"> 4829 </span><span class="spaces">  </span><span class="nottickedoff">| Just sh_len &lt;- llvmShapeLength sh</span>
<span class="lineno"> 4830 </span><span class="spaces">  </span><span class="nottickedoff">, bvLt sh_len (bvSub off (llvmBlockOffset bp)) =</span>
<span class="lineno"> 4831 </span><span class="spaces">    </span><span class="nottickedoff">-- If we are splitting after the end of the natural length of a shape, then</span>
<span class="lineno"> 4832 </span><span class="spaces">    </span><span class="nottickedoff">-- pad out the block permission to its natural length and fall back to the</span>
<span class="lineno"> 4833 </span><span class="spaces">    </span><span class="nottickedoff">-- sequence shape case below</span>
<span class="lineno"> 4834 </span><span class="spaces">    </span><span class="nottickedoff">splitLLVMBlockPerm blsubst off (bp { llvmBlockShape =</span>
<span class="lineno"> 4835 </span><span class="spaces">                                         </span><span class="nottickedoff">PExpr_SeqShape sh PExpr_EmptyShape })</span>
<span class="lineno"> 4836 </span><span class="spaces"></span><span class="nottickedoff">splitLLVMBlockPerm _ _ (llvmBlockShape -&gt; PExpr_Var _) = Nothing</span>
<span class="lineno"> 4837 </span><span class="spaces"></span><span class="nottickedoff">splitLLVMBlockPerm blsubst off bp@(llvmBlockShape -&gt;</span>
<span class="lineno"> 4838 </span><span class="spaces">                                   </span><span class="nottickedoff">PExpr_NamedShape maybe_rw maybe_l nmsh args)</span>
<span class="lineno"> 4839 </span><span class="spaces">  </span><span class="nottickedoff">| TrueRepr &lt;- namedShapeCanUnfoldRepr nmsh</span>
<span class="lineno"> 4840 </span><span class="spaces">  </span><span class="nottickedoff">, Just sh' &lt;- unfoldModalizeNamedShape maybe_rw maybe_l nmsh args =</span>
<span class="lineno"> 4841 </span><span class="spaces">    </span><span class="nottickedoff">splitLLVMBlockPerm blsubst off (bp { llvmBlockShape = sh' })</span>
<span class="lineno"> 4842 </span><span class="spaces"></span><span class="nottickedoff">splitLLVMBlockPerm _ _ (llvmBlockShape -&gt; PExpr_NamedShape _ _ _ _) = Nothing</span>
<span class="lineno"> 4843 </span><span class="spaces"></span><span class="nottickedoff">splitLLVMBlockPerm blsubst off bp@(llvmBlockShape -&gt;</span>
<span class="lineno"> 4844 </span><span class="spaces">                                   </span><span class="nottickedoff">PExpr_EqShape _len (PExpr_Var b))</span>
<span class="lineno"> 4845 </span><span class="spaces">  </span><span class="nottickedoff">-- FIXME: make sure the returned shape fits into len bytes!</span>
<span class="lineno"> 4846 </span><span class="spaces">  </span><span class="nottickedoff">| Just sh &lt;- blsubst b</span>
<span class="lineno"> 4847 </span><span class="spaces">  </span><span class="nottickedoff">= splitLLVMBlockPerm blsubst off (bp { llvmBlockShape = sh })</span>
<span class="lineno"> 4848 </span><span class="spaces"></span><span class="nottickedoff">splitLLVMBlockPerm _ _ (llvmBlockShape -&gt; PExpr_EqShape _ _) = Nothing</span>
<span class="lineno"> 4849 </span><span class="spaces"></span><span class="nottickedoff">splitLLVMBlockPerm _ _ (llvmBlockShape -&gt; PExpr_PtrShape _ _ _) = Nothing</span>
<span class="lineno"> 4850 </span><span class="spaces"></span><span class="nottickedoff">splitLLVMBlockPerm _ _ (llvmBlockShape -&gt; PExpr_FieldShape _) = Nothing</span>
<span class="lineno"> 4851 </span><span class="spaces"></span><span class="nottickedoff">splitLLVMBlockPerm _ off bp@(llvmBlockShape -&gt; PExpr_ArrayShape len stride sh)</span>
<span class="lineno"> 4852 </span><span class="spaces">  </span><span class="nottickedoff">| Just (ix, BV.BV 0) &lt;-</span>
<span class="lineno"> 4853 </span><span class="spaces">      </span><span class="nottickedoff">bvMatchFactorPlusConst (bytesToInteger stride) (bvSub off $</span>
<span class="lineno"> 4854 </span><span class="spaces">                                                      </span><span class="nottickedoff">llvmBlockOffset bp)</span>
<span class="lineno"> 4855 </span><span class="spaces">  </span><span class="nottickedoff">, off_diff &lt;- bvSub off (llvmBlockOffset bp)</span>
<span class="lineno"> 4856 </span><span class="spaces">  </span><span class="nottickedoff">= Just (bp { llvmBlockLen = off_diff,</span>
<span class="lineno"> 4857 </span><span class="spaces">               </span><span class="nottickedoff">llvmBlockShape = PExpr_ArrayShape ix stride sh },</span>
<span class="lineno"> 4858 </span><span class="spaces">          </span><span class="nottickedoff">bp { llvmBlockOffset = off,</span>
<span class="lineno"> 4859 </span><span class="spaces">               </span><span class="nottickedoff">llvmBlockLen = bvSub (llvmBlockLen bp) off_diff,</span>
<span class="lineno"> 4860 </span><span class="spaces">               </span><span class="nottickedoff">llvmBlockShape = PExpr_ArrayShape (bvSub len ix) stride sh })</span>
<span class="lineno"> 4861 </span><span class="spaces"></span><span class="nottickedoff">splitLLVMBlockPerm blsubst off bp@(llvmBlockShape -&gt; PExpr_TupShape sh) =</span>
<span class="lineno"> 4862 </span><span class="spaces">  </span><span class="nottickedoff">splitLLVMBlockPerm blsubst off (bp { llvmBlockShape = sh })</span>
<span class="lineno"> 4863 </span><span class="spaces"></span><span class="nottickedoff">splitLLVMBlockPerm blsubst off bp@(llvmBlockShape -&gt; PExpr_SeqShape sh1 sh2)</span>
<span class="lineno"> 4864 </span><span class="spaces">  </span><span class="nottickedoff">| Just sh1_len &lt;- llvmShapeLength sh1</span>
<span class="lineno"> 4865 </span><span class="spaces">  </span><span class="nottickedoff">, off_diff &lt;- bvSub off (llvmBlockOffset bp)</span>
<span class="lineno"> 4866 </span><span class="spaces">  </span><span class="nottickedoff">, bvLt off_diff sh1_len</span>
<span class="lineno"> 4867 </span><span class="spaces">  </span><span class="nottickedoff">= splitLLVMBlockPerm blsubst off (bp { llvmBlockLen = sh1_len,</span>
<span class="lineno"> 4868 </span><span class="spaces">                                         </span><span class="nottickedoff">llvmBlockShape = sh1 }) &gt;&gt;= \(bp1,bp2) -&gt;</span>
<span class="lineno"> 4869 </span><span class="spaces">    </span><span class="nottickedoff">Just (bp1,</span>
<span class="lineno"> 4870 </span><span class="spaces">          </span><span class="nottickedoff">bp2 { llvmBlockLen = bvSub (llvmBlockLen bp) off_diff,</span>
<span class="lineno"> 4871 </span><span class="spaces">                </span><span class="nottickedoff">llvmBlockShape = PExpr_SeqShape (llvmBlockShape bp2) sh2 })</span>
<span class="lineno"> 4872 </span><span class="spaces"></span><span class="nottickedoff">splitLLVMBlockPerm blsubst off bp@(llvmBlockShape -&gt; PExpr_SeqShape sh1 sh2)</span>
<span class="lineno"> 4873 </span><span class="spaces">  </span><span class="nottickedoff">| Just sh1_len &lt;- llvmShapeLength sh1</span>
<span class="lineno"> 4874 </span><span class="spaces">  </span><span class="nottickedoff">= splitLLVMBlockPerm blsubst off</span>
<span class="lineno"> 4875 </span><span class="spaces">    </span><span class="nottickedoff">(bp { llvmBlockOffset = bvAdd (llvmBlockOffset bp) sh1_len,</span>
<span class="lineno"> 4876 </span><span class="spaces">          </span><span class="nottickedoff">llvmBlockLen = bvSub (llvmBlockLen bp) sh1_len,</span>
<span class="lineno"> 4877 </span><span class="spaces">          </span><span class="nottickedoff">llvmBlockShape = sh2 }) &gt;&gt;= \(bp1,bp2) -&gt;</span>
<span class="lineno"> 4878 </span><span class="spaces">    </span><span class="nottickedoff">Just (bp1 { llvmBlockOffset = llvmBlockOffset bp,</span>
<span class="lineno"> 4879 </span><span class="spaces">                </span><span class="nottickedoff">llvmBlockLen = bvAdd (llvmBlockLen bp1) sh1_len,</span>
<span class="lineno"> 4880 </span><span class="spaces">                </span><span class="nottickedoff">llvmBlockShape = PExpr_SeqShape sh1 (llvmBlockShape bp1) },</span>
<span class="lineno"> 4881 </span><span class="spaces">          </span><span class="nottickedoff">bp2)</span>
<span class="lineno"> 4882 </span><span class="spaces"></span><span class="nottickedoff">splitLLVMBlockPerm blsubst off bp@(llvmBlockShape -&gt; PExpr_OrShape sh1 sh2) =</span>
<span class="lineno"> 4883 </span><span class="spaces">  </span><span class="nottickedoff">do (bp1_L,bp1_R) &lt;- splitLLVMBlockPerm blsubst off (bp { llvmBlockShape = sh1 })</span>
<span class="lineno"> 4884 </span><span class="spaces">     </span><span class="nottickedoff">(bp2_L,bp2_R) &lt;- splitLLVMBlockPerm blsubst off (bp { llvmBlockShape = sh2 })</span>
<span class="lineno"> 4885 </span><span class="spaces">     </span><span class="nottickedoff">let or_helper bp1 bp2 =</span>
<span class="lineno"> 4886 </span><span class="spaces">           </span><span class="nottickedoff">bp1 { llvmBlockShape =</span>
<span class="lineno"> 4887 </span><span class="spaces">                   </span><span class="nottickedoff">PExpr_OrShape (llvmBlockShape bp1) (llvmBlockShape bp2)}</span>
<span class="lineno"> 4888 </span><span class="spaces">     </span><span class="nottickedoff">Just (or_helper bp1_L bp2_L, or_helper bp1_R bp2_R)</span>
<span class="lineno"> 4889 </span><span class="spaces"></span><span class="nottickedoff">splitLLVMBlockPerm blsubst off bp@(llvmBlockShape -&gt; PExpr_ExShape mb_sh) =</span>
<span class="lineno"> 4890 </span><span class="spaces">  </span><span class="nottickedoff">case mbMatch $ fmap (\sh -&gt; splitLLVMBlockPerm blsubst off</span>
<span class="lineno"> 4891 </span><span class="spaces">                              </span><span class="nottickedoff">(bp { llvmBlockShape = sh })) mb_sh of</span>
<span class="lineno"> 4892 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Just (mb_bp1,mb_bp2) |] -&gt;</span>
<span class="lineno"> 4893 </span><span class="spaces">      </span><span class="nottickedoff">let off_diff = bvSub off (llvmBlockOffset bp) in</span>
<span class="lineno"> 4894 </span><span class="spaces">      </span><span class="nottickedoff">Just (bp { llvmBlockLen = off_diff,</span>
<span class="lineno"> 4895 </span><span class="spaces">                 </span><span class="nottickedoff">llvmBlockShape = PExpr_ExShape (fmap llvmBlockShape mb_bp1) },</span>
<span class="lineno"> 4896 </span><span class="spaces">            </span><span class="nottickedoff">bp { llvmBlockOffset = off,</span>
<span class="lineno"> 4897 </span><span class="spaces">                 </span><span class="nottickedoff">llvmBlockLen = bvSub (llvmBlockLen bp) off_diff,</span>
<span class="lineno"> 4898 </span><span class="spaces">                 </span><span class="nottickedoff">llvmBlockShape = PExpr_ExShape (fmap llvmBlockShape mb_bp2) })</span>
<span class="lineno"> 4899 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; Nothing</span>
<span class="lineno"> 4900 </span><span class="spaces"></span><span class="nottickedoff">splitLLVMBlockPerm _ _ _ = Nothing</span></span>
<span class="lineno"> 4901 </span>
<span class="lineno"> 4902 </span>-- | Remove a range of offsets from a block permission, if possible, yielding a
<span class="lineno"> 4903 </span>-- list of block permissions for the remaining offsets
<span class="lineno"> 4904 </span>remLLVMBlockPermRange :: (1 &lt;= w, KnownNat w) =&gt; BVRange w -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 4905 </span>                         Maybe [LLVMBlockPerm w]
<span class="lineno"> 4906 </span><span class="decl"><span class="nottickedoff">remLLVMBlockPermRange rng bp</span>
<span class="lineno"> 4907 </span><span class="spaces">  </span><span class="nottickedoff">| bvRangeSubset (llvmBlockRange bp) rng = Just []</span>
<span class="lineno"> 4908 </span><span class="spaces"></span><span class="nottickedoff">remLLVMBlockPermRange rng bp =</span>
<span class="lineno"> 4909 </span><span class="spaces">  </span><span class="nottickedoff">do (bps_l, bp') &lt;-</span>
<span class="lineno"> 4910 </span><span class="spaces">       </span><span class="nottickedoff">-- If the beginning of rng lies inside the range of bp, split bp into</span>
<span class="lineno"> 4911 </span><span class="spaces">       </span><span class="nottickedoff">-- block permissions before and after the beginning of rng; otherwise,</span>
<span class="lineno"> 4912 </span><span class="spaces">       </span><span class="nottickedoff">-- lump all of bp into the \&quot;after\&quot; bucket. The call to splitLLVMBlockPerm</span>
<span class="lineno"> 4913 </span><span class="spaces">       </span><span class="nottickedoff">-- uses an empty substitution because remLLVMBlockPermRange itself is</span>
<span class="lineno"> 4914 </span><span class="spaces">       </span><span class="nottickedoff">-- assuming an empty substitution</span>
<span class="lineno"> 4915 </span><span class="spaces">       </span><span class="nottickedoff">if bvInRange (bvRangeOffset rng) (llvmBlockRange bp) then</span>
<span class="lineno"> 4916 </span><span class="spaces">         </span><span class="nottickedoff">do (bp_l,bp') &lt;- splitLLVMBlockPerm (const Nothing) (bvRangeOffset rng) bp</span>
<span class="lineno"> 4917 </span><span class="spaces">            </span><span class="nottickedoff">return ([bp_l],bp')</span>
<span class="lineno"> 4918 </span><span class="spaces">       </span><span class="nottickedoff">else return ([],bp)</span>
<span class="lineno"> 4919 </span><span class="spaces">     </span><span class="nottickedoff">bp_r &lt;-</span>
<span class="lineno"> 4920 </span><span class="spaces">       </span><span class="nottickedoff">-- Split bp', the permissions after the beginning of rng, into those</span>
<span class="lineno"> 4921 </span><span class="spaces">       </span><span class="nottickedoff">-- before and after the end of rng</span>
<span class="lineno"> 4922 </span><span class="spaces">       </span><span class="nottickedoff">if bvInRange (bvRangeEnd rng) (llvmBlockRange bp) then</span>
<span class="lineno"> 4923 </span><span class="spaces">         </span><span class="nottickedoff">snd &lt;$&gt; splitLLVMBlockPerm (const Nothing) (bvRangeEnd rng) bp'</span>
<span class="lineno"> 4924 </span><span class="spaces">       </span><span class="nottickedoff">else return bp'</span>
<span class="lineno"> 4925 </span><span class="spaces">     </span><span class="nottickedoff">return (bps_l ++ [bp_r])</span></span>
<span class="lineno"> 4926 </span>
<span class="lineno"> 4927 </span>
<span class="lineno"> 4928 </span>-- | Extract the disjunctive shapes from a 'TaggedUnionShape'
<span class="lineno"> 4929 </span>taggedUnionDisjs :: TaggedUnionShape w sz -&gt; [PermExpr (LLVMShapeType w)]
<span class="lineno"> 4930 </span><span class="decl"><span class="nottickedoff">taggedUnionDisjs (TaggedUnionShape disjs) =</span>
<span class="lineno"> 4931 </span><span class="spaces">  </span><span class="nottickedoff">map snd $ NonEmpty.toList disjs</span></span>
<span class="lineno"> 4932 </span>
<span class="lineno"> 4933 </span>-- | Extract the disjunctive shapes from a 'TaggedUnionShape' in a binding
<span class="lineno"> 4934 </span>mbTaggedUnionDisjs :: Mb ctx (TaggedUnionShape w sz) -&gt;
<span class="lineno"> 4935 </span>                      Mb ctx [PermExpr (LLVMShapeType w)]
<span class="lineno"> 4936 </span><span class="decl"><span class="nottickedoff">mbTaggedUnionDisjs = mbMapCl $(mkClosed [| taggedUnionDisjs |])</span></span>
<span class="lineno"> 4937 </span>
<span class="lineno"> 4938 </span>-- | Get the @n@th disjunct of a 'TaggedUnionShape' in a binding
<span class="lineno"> 4939 </span>mbTaggedUnionNthDisj :: Int -&gt; Mb ctx (TaggedUnionShape w sz) -&gt;
<span class="lineno"> 4940 </span>                        Mb ctx (PermExpr (LLVMShapeType w))
<span class="lineno"> 4941 </span><span class="decl"><span class="nottickedoff">mbTaggedUnionNthDisj n_top =</span>
<span class="lineno"> 4942 </span><span class="spaces">  </span><span class="nottickedoff">mbMapCl ($(mkClosed [| \n -&gt; (!!n) . taggedUnionDisjs |])</span>
<span class="lineno"> 4943 </span><span class="spaces">           </span><span class="nottickedoff">`clApply` toClosed n_top)</span></span>
<span class="lineno"> 4944 </span>
<span class="lineno"> 4945 </span>-- | Change a block permisison with a tagged union shape to have the @n@th
<span class="lineno"> 4946 </span>-- disjunct shape of this tagged union
<span class="lineno"> 4947 </span>taggedUnionNthDisjBlock :: Int -&gt; LLVMBlockPerm w -&gt; LLVMBlockPerm w
<span class="lineno"> 4948 </span><span class="decl"><span class="nottickedoff">taggedUnionNthDisjBlock 0 bp</span>
<span class="lineno"> 4949 </span><span class="spaces">  </span><span class="nottickedoff">| PExpr_OrShape sh1 _ &lt;- llvmBlockShape bp =</span>
<span class="lineno"> 4950 </span><span class="spaces">    </span><span class="nottickedoff">bp { llvmBlockShape = sh1 }</span>
<span class="lineno"> 4951 </span><span class="spaces"></span><span class="nottickedoff">taggedUnionNthDisjBlock 0 bp =</span>
<span class="lineno"> 4952 </span><span class="spaces">  </span><span class="nottickedoff">-- NOTE: this case happens for the last shape in a tagged union, which is not</span>
<span class="lineno"> 4953 </span><span class="spaces">  </span><span class="nottickedoff">-- or-ed with anything, and is guaranteed not to be an or itsef (so it won't</span>
<span class="lineno"> 4954 </span><span class="spaces">  </span><span class="nottickedoff">-- match the above case)</span>
<span class="lineno"> 4955 </span><span class="spaces">  </span><span class="nottickedoff">bp</span>
<span class="lineno"> 4956 </span><span class="spaces"></span><span class="nottickedoff">taggedUnionNthDisjBlock n bp</span>
<span class="lineno"> 4957 </span><span class="spaces">  </span><span class="nottickedoff">| PExpr_OrShape _ sh2 &lt;- llvmBlockShape bp =</span>
<span class="lineno"> 4958 </span><span class="spaces">    </span><span class="nottickedoff">taggedUnionNthDisjBlock (n-1) $ bp { llvmBlockShape = sh2 }</span>
<span class="lineno"> 4959 </span><span class="spaces"></span><span class="nottickedoff">taggedUnionNthDisjBlock _ _ = error &quot;taggedUnionNthDisjBlock&quot;</span></span>
<span class="lineno"> 4960 </span>
<span class="lineno"> 4961 </span>-- | Change the a block permisison in a binding with a tagged union shape to
<span class="lineno"> 4962 </span>-- have the @n@th disjunct shape of this tagged union
<span class="lineno"> 4963 </span>mbTaggedUnionNthDisjBlock :: Int -&gt; Mb ctx (LLVMBlockPerm w) -&gt;
<span class="lineno"> 4964 </span>                             Mb ctx (LLVMBlockPerm w)
<span class="lineno"> 4965 </span><span class="decl"><span class="nottickedoff">mbTaggedUnionNthDisjBlock n =</span>
<span class="lineno"> 4966 </span><span class="spaces">  </span><span class="nottickedoff">mbMapCl ($(mkClosed [| taggedUnionNthDisjBlock |]) `clApply` toClosed n)</span></span>
<span class="lineno"> 4967 </span>
<span class="lineno"> 4968 </span>-- | Get the tags from a 'TaggedUnionShape'
<span class="lineno"> 4969 </span>taggedUnionTags :: TaggedUnionShape w sz -&gt; [BV sz]
<span class="lineno"> 4970 </span><span class="decl"><span class="nottickedoff">taggedUnionTags (TaggedUnionShape disjs) = map fst $ NonEmpty.toList disjs</span></span>
<span class="lineno"> 4971 </span>
<span class="lineno"> 4972 </span>-- | Build a 'TaggedUnionShape' with a single disjunct
<span class="lineno"> 4973 </span>taggedUnionSingle :: BV sz -&gt; PermExpr (LLVMShapeType w) -&gt;
<span class="lineno"> 4974 </span>                     TaggedUnionShape w sz
<span class="lineno"> 4975 </span><span class="decl"><span class="nottickedoff">taggedUnionSingle tag sh = TaggedUnionShape ((tag,sh) :| [])</span></span>
<span class="lineno"> 4976 </span>
<span class="lineno"> 4977 </span>-- | Add a disjunct to the front of a 'TaggedUnionShape'
<span class="lineno"> 4978 </span>taggedUnionCons :: BV sz -&gt; PermExpr (LLVMShapeType w) -&gt;
<span class="lineno"> 4979 </span>                   TaggedUnionShape w sz -&gt; TaggedUnionShape w sz
<span class="lineno"> 4980 </span><span class="decl"><span class="nottickedoff">taggedUnionCons tag sh (TaggedUnionShape disjs) =</span>
<span class="lineno"> 4981 </span><span class="spaces">  </span><span class="nottickedoff">TaggedUnionShape $ NonEmpty.cons (tag,sh) disjs</span></span>
<span class="lineno"> 4982 </span>
<span class="lineno"> 4983 </span>-- | Convert a 'TaggedUnionShape' to the shape it represents
<span class="lineno"> 4984 </span>taggedUnionToShape :: TaggedUnionShape w sz -&gt; PermExpr (LLVMShapeType w)
<span class="lineno"> 4985 </span><span class="decl"><span class="nottickedoff">taggedUnionToShape (TaggedUnionShape disjs) =</span>
<span class="lineno"> 4986 </span><span class="spaces">  </span><span class="nottickedoff">foldr1 PExpr_OrShape $ NonEmpty.map snd disjs</span></span>
<span class="lineno"> 4987 </span>
<span class="lineno"> 4988 </span>-- | A bitvector value of some unknown size
<span class="lineno"> 4989 </span>data SomeBV = forall sz. (1 &lt;= sz, KnownNat sz) =&gt; SomeBV (BV sz)
<span class="lineno"> 4990 </span>
<span class="lineno"> 4991 </span>-- | Test if a shape is of the form @fieldsh(eq(llvmword(bv)))@ for some @bv@.
<span class="lineno"> 4992 </span>-- If so, return @bv@.
<span class="lineno"> 4993 </span>shapeToTag :: PermExpr (LLVMShapeType w) -&gt; Maybe SomeBV
<span class="lineno"> 4994 </span><span class="decl"><span class="nottickedoff">shapeToTag (PExpr_FieldShape</span>
<span class="lineno"> 4995 </span><span class="spaces">            </span><span class="nottickedoff">(LLVMFieldShape</span>
<span class="lineno"> 4996 </span><span class="spaces">             </span><span class="nottickedoff">(ValPerm_Eq (PExpr_LLVMWord (PExpr_BV [] bv))))) =</span>
<span class="lineno"> 4997 </span><span class="spaces">  </span><span class="nottickedoff">Just (SomeBV bv)</span>
<span class="lineno"> 4998 </span><span class="spaces"></span><span class="nottickedoff">shapeToTag _ = Nothing</span></span>
<span class="lineno"> 4999 </span>
<span class="lineno"> 5000 </span>-- | Test if a shape begins with an equality permission to a bitvector value and
<span class="lineno"> 5001 </span>-- return that bitvector value
<span class="lineno"> 5002 </span>getShapeBVTag :: PermExpr (LLVMShapeType w) -&gt; Maybe SomeBV
<span class="lineno"> 5003 </span><span class="decl"><span class="nottickedoff">getShapeBVTag sh | Just some_bv &lt;- shapeToTag sh = Just some_bv</span>
<span class="lineno"> 5004 </span><span class="spaces"></span><span class="nottickedoff">getShapeBVTag (PExpr_TupShape sh) = getShapeBVTag sh</span>
<span class="lineno"> 5005 </span><span class="spaces"></span><span class="nottickedoff">getShapeBVTag (PExpr_SeqShape sh1 _) = getShapeBVTag sh1</span>
<span class="lineno"> 5006 </span><span class="spaces"></span><span class="nottickedoff">getShapeBVTag _ = Nothing</span></span>
<span class="lineno"> 5007 </span>
<span class="lineno"> 5008 </span>-- | Remove the leading tag from a shape where 'getShapeBVTag' succeeded
<span class="lineno"> 5009 </span>shapeRemoveTag :: PermExpr (LLVMShapeType w) -&gt; PermExpr (LLVMShapeType w)
<span class="lineno"> 5010 </span><span class="decl"><span class="nottickedoff">shapeRemoveTag (PExpr_TupShape sh) = shapeRemoveTag sh</span>
<span class="lineno"> 5011 </span><span class="spaces"></span><span class="nottickedoff">shapeRemoveTag (PExpr_SeqShape sh1 sh2) | isJust (shapeToTag sh1) = sh2</span>
<span class="lineno"> 5012 </span><span class="spaces"></span><span class="nottickedoff">shapeRemoveTag (PExpr_SeqShape sh1 sh2) =</span>
<span class="lineno"> 5013 </span><span class="spaces">  </span><span class="nottickedoff">PExpr_SeqShape (shapeRemoveTag sh1) sh2</span>
<span class="lineno"> 5014 </span><span class="spaces"></span><span class="nottickedoff">shapeRemoveTag sh | isJust (shapeToTag sh) = PExpr_EmptyShape</span>
<span class="lineno"> 5015 </span><span class="spaces"></span><span class="nottickedoff">shapeRemoveTag sh =</span>
<span class="lineno"> 5016 </span><span class="spaces">  </span><span class="nottickedoff">error (&quot;shapeRemoveTag: &quot; ++ permPrettyString emptyPPInfo sh)</span></span>
<span class="lineno"> 5017 </span>
<span class="lineno"> 5018 </span>-- | Extract the disjunctive shapes from a 'TaggedUnionShape' but removing the
<span class="lineno"> 5019 </span>-- leading tags
<span class="lineno"> 5020 </span>taggedUnionDisjsNoTags :: TaggedUnionShape w sz -&gt; [PermExpr (LLVMShapeType w)]
<span class="lineno"> 5021 </span><span class="decl"><span class="nottickedoff">taggedUnionDisjsNoTags = map shapeRemoveTag . taggedUnionDisjs</span></span>
<span class="lineno"> 5022 </span>
<span class="lineno"> 5023 </span>-- | Test if a shape is a tagged union shape and, if so, convert it to the
<span class="lineno"> 5024 </span>-- 'TaggedUnionShape' representation
<span class="lineno"> 5025 </span>asTaggedUnionShape :: PermExpr (LLVMShapeType w) -&gt;
<span class="lineno"> 5026 </span>                      Maybe (SomeTaggedUnionShape w)
<span class="lineno"> 5027 </span><span class="decl"><span class="nottickedoff">asTaggedUnionShape (PExpr_OrShape sh1 sh2)</span>
<span class="lineno"> 5028 </span><span class="spaces">  </span><span class="nottickedoff">| Just (SomeBV tag1) &lt;- getShapeBVTag sh1</span>
<span class="lineno"> 5029 </span><span class="spaces">  </span><span class="nottickedoff">, Just (SomeTaggedUnionShape tag_u2) &lt;- asTaggedUnionShape sh2</span>
<span class="lineno"> 5030 </span><span class="spaces">  </span><span class="nottickedoff">, Just Refl &lt;- testEquality (natRepr tag1) (natRepr tag_u2) =</span>
<span class="lineno"> 5031 </span><span class="spaces">    </span><span class="nottickedoff">Just $ SomeTaggedUnionShape $ taggedUnionCons tag1 sh1 tag_u2</span>
<span class="lineno"> 5032 </span><span class="spaces"></span><span class="nottickedoff">asTaggedUnionShape sh</span>
<span class="lineno"> 5033 </span><span class="spaces">  </span><span class="nottickedoff">| Just (SomeBV tag) &lt;- getShapeBVTag sh =</span>
<span class="lineno"> 5034 </span><span class="spaces">    </span><span class="nottickedoff">Just $ SomeTaggedUnionShape $ taggedUnionSingle tag sh</span>
<span class="lineno"> 5035 </span><span class="spaces"></span><span class="nottickedoff">asTaggedUnionShape _ = Nothing</span></span>
<span class="lineno"> 5036 </span>
<span class="lineno"> 5037 </span>-- | Try to convert a @memblock@ permission in a binding to a tagged union shape
<span class="lineno"> 5038 </span>-- in a binding
<span class="lineno"> 5039 </span>mbLLVMBlockToTaggedUnion :: Mb ctx (LLVMBlockPerm w) -&gt;
<span class="lineno"> 5040 </span>                            Maybe (Mb ctx (SomeTaggedUnionShape w))
<span class="lineno"> 5041 </span><span class="decl"><span class="nottickedoff">mbLLVMBlockToTaggedUnion =</span>
<span class="lineno"> 5042 </span><span class="spaces">  </span><span class="nottickedoff">mbMaybe . mbMapCl $(mkClosed [| asTaggedUnionShape . llvmBlockShape |])</span></span>
<span class="lineno"> 5043 </span>
<span class="lineno"> 5044 </span>-- | Convert a @memblock@ permission with a union shape to a field permission
<span class="lineno"> 5045 </span>-- with an equality permission @eq(z)@ with evar @z@ for the tag
<span class="lineno"> 5046 </span>taggedUnionExTagPerm :: (1 &lt;= sz, KnownNat sz) =&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 5047 </span>                        Binding (BVType sz) (LLVMFieldPerm w sz)
<span class="lineno"> 5048 </span><span class="decl"><span class="nottickedoff">taggedUnionExTagPerm bp =</span>
<span class="lineno"> 5049 </span><span class="spaces">  </span><span class="nottickedoff">nu $ \z -&gt; LLVMFieldPerm { llvmFieldRW = llvmBlockRW bp,</span>
<span class="lineno"> 5050 </span><span class="spaces">                             </span><span class="nottickedoff">llvmFieldLifetime = llvmBlockLifetime bp,</span>
<span class="lineno"> 5051 </span><span class="spaces">                             </span><span class="nottickedoff">llvmFieldOffset = llvmBlockOffset bp,</span>
<span class="lineno"> 5052 </span><span class="spaces">                             </span><span class="nottickedoff">llvmFieldContents =</span>
<span class="lineno"> 5053 </span><span class="spaces">                               </span><span class="nottickedoff">ValPerm_Eq (PExpr_LLVMWord $ PExpr_Var z) }</span></span>
<span class="lineno"> 5054 </span>
<span class="lineno"> 5055 </span>-- | Convert a @memblock@ permission in a binding with a tagged union shape to a
<span class="lineno"> 5056 </span>-- field permission with permission @eq(z)@ using evar @z@ for the tag
<span class="lineno"> 5057 </span>mbTaggedUnionExTagPerm :: (1 &lt;= sz, KnownNat sz) =&gt; Mb ctx (LLVMBlockPerm w) -&gt;
<span class="lineno"> 5058 </span>                          Mb (ctx :&gt; BVType sz) (LLVMFieldPerm w sz)
<span class="lineno"> 5059 </span><span class="decl"><span class="nottickedoff">mbTaggedUnionExTagPerm =</span>
<span class="lineno"> 5060 </span><span class="spaces">  </span><span class="nottickedoff">mbCombine RL.typeCtxProxies . mbMapCl $(mkClosed [| taggedUnionExTagPerm |])</span></span>
<span class="lineno"> 5061 </span>
<span class="lineno"> 5062 </span>-- | Find a disjunct in a 'TaggedUnionShape' with the given tag
<span class="lineno"> 5063 </span>findTaggedUnionIndex :: BV.BV sz -&gt; TaggedUnionShape w sz -&gt; Maybe Int
<span class="lineno"> 5064 </span><span class="decl"><span class="nottickedoff">findTaggedUnionIndex tag_bv (TaggedUnionShape disjs) =</span>
<span class="lineno"> 5065 </span><span class="spaces">  </span><span class="nottickedoff">findIndex (== tag_bv) $ map fst $ NonEmpty.toList disjs</span></span>
<span class="lineno"> 5066 </span>
<span class="lineno"> 5067 </span>-- | Find a disjunct in a 'TaggedUnionShape' in a binding with the given tag
<span class="lineno"> 5068 </span>mbFindTaggedUnionIndex :: BV.BV sz -&gt; Mb ctx (TaggedUnionShape w sz) -&gt;
<span class="lineno"> 5069 </span>                          Maybe Int
<span class="lineno"> 5070 </span><span class="decl"><span class="nottickedoff">mbFindTaggedUnionIndex tag_bv =</span>
<span class="lineno"> 5071 </span><span class="spaces">  </span><span class="nottickedoff">mbLift . mbMapCl ($(mkClosed [| findTaggedUnionIndex |])</span>
<span class="lineno"> 5072 </span><span class="spaces">                    </span><span class="nottickedoff">`clApply` toClosed tag_bv)</span></span>
<span class="lineno"> 5073 </span>
<span class="lineno"> 5074 </span>-- FIXME: delete these?
<span class="lineno"> 5075 </span>{-
<span class="lineno"> 5076 </span>-- | Find a disjunct in a 'TaggedUnionShape' that could be proven at the given
<span class="lineno"> 5077 </span>-- offset from the given atomic permission, by checking if it is a field or
<span class="lineno"> 5078 </span>-- block permission containing an equality permission to one of the tags. If
<span class="lineno"> 5079 </span>-- some disjunct can be proved, return its index in the list of disjuncts.
<span class="lineno"> 5080 </span>findTaggedUnionIndexForPerm :: PermExpr (BVType w) -&gt;
<span class="lineno"> 5081 </span>                               AtomicPerm (LLVMPointerType w) -&gt;
<span class="lineno"> 5082 </span>                               TaggedUnionShape w -&gt; Maybe Int
<span class="lineno"> 5083 </span>findTaggedUnionIndexForPerm off p (TaggedUnionShape disjs@((bv1,_) :| _))
<span class="lineno"> 5084 </span>  | Just bp &lt;- llvmAtomicPermToBlock p
<span class="lineno"> 5085 </span>  , bvEq off (llvmBlockOffset bp)
<span class="lineno"> 5086 </span>  , Just (SomeBV tag_bv) &lt;- getShapeBVTag $ llvmBlockShape bp
<span class="lineno"> 5087 </span>  , Just Refl &lt;- testEquality (natRepr tag_bv) (natRepr bv1)
<span class="lineno"> 5088 </span>  , Just i &lt;- findIndex (== tag_bv) $ map fst $ NonEmpty.toList disjs
<span class="lineno"> 5089 </span>  = Just i
<span class="lineno"> 5090 </span>findTaggedUnionIndexForPerm _ _ _ = Nothing
<span class="lineno"> 5091 </span>
<span class="lineno"> 5092 </span>
<span class="lineno"> 5093 </span>-- | Find a disjunct in a 'TaggedUnionShape' that could be proven at the given
<span class="lineno"> 5094 </span>-- offset from the given atomic permissions, by looking for a field or block
<span class="lineno"> 5095 </span>-- permission containing an equality permission to one of the tags. If some
<span class="lineno"> 5096 </span>-- disjunct can be proved, return its index in the list of disjuncts.
<span class="lineno"> 5097 </span>findTaggedUnionIndexForPerms :: PermExpr (BVType w) -&gt;
<span class="lineno"> 5098 </span>                                [AtomicPerm (LLVMPointerType w)] -&gt;
<span class="lineno"> 5099 </span>                                TaggedUnionShape w -&gt; Maybe Int
<span class="lineno"> 5100 </span>findTaggedUnionIndexForPerms off ps tag_un =
<span class="lineno"> 5101 </span>  asum $ map (\p -&gt; findTaggedUnionIndexForPerm off p tag_un) ps
<span class="lineno"> 5102 </span>-}
<span class="lineno"> 5103 </span>
<span class="lineno"> 5104 </span>
<span class="lineno"> 5105 </span>-- | Convert an array cell number @cell@ to the byte offset for that cell, given
<span class="lineno"> 5106 </span>-- by @stride * cell@
<span class="lineno"> 5107 </span>llvmArrayCellToOffset :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5108 </span>                         PermExpr (BVType w) -&gt; PermExpr (BVType w)
<span class="lineno"> 5109 </span><span class="decl"><span class="nottickedoff">llvmArrayCellToOffset ap cell =</span>
<span class="lineno"> 5110 </span><span class="spaces">  </span><span class="nottickedoff">bvMult (bytesToInteger $ llvmArrayStride ap) cell</span></span>
<span class="lineno"> 5111 </span>
<span class="lineno"> 5112 </span>-- | Convert an array cell number @cell@ to the \&quot;absolute\&quot; byte offset for that
<span class="lineno"> 5113 </span>-- cell, given by @off + stride * cell@, where @off@ is the offset of the
<span class="lineno"> 5114 </span>-- supplied array permission
<span class="lineno"> 5115 </span>llvmArrayCellToAbsOffset :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5116 </span>                            PermExpr (BVType w) -&gt; PermExpr (BVType w)
<span class="lineno"> 5117 </span><span class="decl"><span class="nottickedoff">llvmArrayCellToAbsOffset ap cell =</span>
<span class="lineno"> 5118 </span><span class="spaces">  </span><span class="nottickedoff">bvAdd (llvmArrayOffset ap) (llvmArrayCellToOffset ap cell)</span></span>
<span class="lineno"> 5119 </span>
<span class="lineno"> 5120 </span>-- | Convert a range of cell numbers to a range of byte offsets from the
<span class="lineno"> 5121 </span>-- beginning of the array permission
<span class="lineno"> 5122 </span>llvmArrayCellsToOffsets :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5123 </span>                           BVRange w -&gt; BVRange w
<span class="lineno"> 5124 </span><span class="decl"><span class="nottickedoff">llvmArrayCellsToOffsets ap (BVRange cell num_cells) =</span>
<span class="lineno"> 5125 </span><span class="spaces">  </span><span class="nottickedoff">BVRange (llvmArrayCellToOffset ap cell) (llvmArrayCellToOffset ap num_cells)</span></span>
<span class="lineno"> 5126 </span>
<span class="lineno"> 5127 </span>-- | Convert a range of absolute byte offsets to a range of cell numbers in an
<span class="lineno"> 5128 </span>-- array permission, if possible
<span class="lineno"> 5129 </span>llvmArrayAbsOffsetsToCells :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5130 </span>                              BVRange w -&gt; Maybe (BVRange w)
<span class="lineno"> 5131 </span><span class="decl"><span class="nottickedoff">llvmArrayAbsOffsetsToCells ap rng</span>
<span class="lineno"> 5132 </span><span class="spaces">  </span><span class="nottickedoff">| Just cell &lt;- matchLLVMArrayCell ap (bvRangeOffset rng) =</span>
<span class="lineno"> 5133 </span><span class="spaces">    </span><span class="nottickedoff">Just $ BVRange cell (bvDiv (bvRangeLength rng) (llvmArrayStride ap))</span>
<span class="lineno"> 5134 </span><span class="spaces"></span><span class="nottickedoff">llvmArrayAbsOffsetsToCells _ _ = Nothing</span></span>
<span class="lineno"> 5135 </span>
<span class="lineno"> 5136 </span>-- | Return the clopen range @[0,len)@ of the cells of an array permission
<span class="lineno"> 5137 </span>llvmArrayCells :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt; BVRange w
<span class="lineno"> 5138 </span><span class="decl"><span class="nottickedoff">llvmArrayCells ap = BVRange (bvInt 0) (llvmArrayLen ap)</span></span>
<span class="lineno"> 5139 </span>
<span class="lineno"> 5140 </span>-- | Build the 'BVRange' of \&quot;absolute\&quot; offsets @[off,off+len_bytes)@
<span class="lineno"> 5141 </span>llvmArrayAbsOffsets :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt; BVRange w
<span class="lineno"> 5142 </span><span class="decl"><span class="nottickedoff">llvmArrayAbsOffsets ap =</span>
<span class="lineno"> 5143 </span><span class="spaces">  </span><span class="nottickedoff">BVRange (llvmArrayOffset ap) (llvmArrayCellToOffset ap $ llvmArrayLen ap)</span></span>
<span class="lineno"> 5144 </span>
<span class="lineno"> 5145 </span>-- | Return the number of bytes per machine word; @w@ is the number of bits
<span class="lineno"> 5146 </span>machineWordBytes :: KnownNat w =&gt; f w -&gt; Integer
<span class="lineno"> 5147 </span><span class="decl"><span class="nottickedoff">machineWordBytes w</span>
<span class="lineno"> 5148 </span><span class="spaces">  </span><span class="nottickedoff">| natVal w `mod` 8 /= 0 =</span>
<span class="lineno"> 5149 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;machineWordBytes: word size is not a multiple of 8!&quot;</span>
<span class="lineno"> 5150 </span><span class="spaces"></span><span class="nottickedoff">machineWordBytes w = natVal w `ceil_div` 8</span></span>
<span class="lineno"> 5151 </span>
<span class="lineno"> 5152 </span>-- | Convert bytes to machine words, rounded up, i.e., return @ceil(n/W)@,
<span class="lineno"> 5153 </span>-- where @W@ is the number of bytes per machine word
<span class="lineno"> 5154 </span>bytesToMachineWords :: KnownNat w =&gt; f w -&gt; Integer -&gt; Integer
<span class="lineno"> 5155 </span><span class="decl"><span class="nottickedoff">bytesToMachineWords w n = n `ceil_div` machineWordBytes w</span></span>
<span class="lineno"> 5156 </span>
<span class="lineno"> 5157 </span>-- | Return the largest multiple of 'machineWordBytes' less than the input
<span class="lineno"> 5158 </span>prevMachineWord :: KnownNat w =&gt; f w -&gt; Integer -&gt; Integer
<span class="lineno"> 5159 </span><span class="decl"><span class="nottickedoff">prevMachineWord w n = (bytesToMachineWords w n - 1) * machineWordBytes w</span></span>
<span class="lineno"> 5160 </span>
<span class="lineno"> 5161 </span>-- | Build the permission that corresponds to a borrow from an array, i.e., that
<span class="lineno"> 5162 </span>-- would need to be returned in order to remove this borrow. For 'RangeBorrow's,
<span class="lineno"> 5163 </span>-- that is the sub-array permission with no borrows of its own.
<span class="lineno"> 5164 </span>permForLLVMArrayBorrow :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5165 </span>                          LLVMArrayBorrow w -&gt; ValuePerm (LLVMPointerType w)
<span class="lineno"> 5166 </span><span class="decl"><span class="nottickedoff">permForLLVMArrayBorrow ap (FieldBorrow cell) =</span>
<span class="lineno"> 5167 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_LLVMBlock $ llvmArrayCellPerm ap cell</span>
<span class="lineno"> 5168 </span><span class="spaces"></span><span class="nottickedoff">permForLLVMArrayBorrow ap (RangeBorrow (BVRange off len)) =</span>
<span class="lineno"> 5169 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_Conj1 $ Perm_LLVMArray $</span>
<span class="lineno"> 5170 </span><span class="spaces">  </span><span class="nottickedoff">ap { llvmArrayOffset = llvmArrayCellToAbsOffset ap off,</span>
<span class="lineno"> 5171 </span><span class="spaces">       </span><span class="nottickedoff">llvmArrayLen = len,</span>
<span class="lineno"> 5172 </span><span class="spaces">       </span><span class="nottickedoff">llvmArrayBorrows = [] }</span></span>
<span class="lineno"> 5173 </span>
<span class="lineno"> 5174 </span>-- | Build the borrow corresponding to borrowing a given permission from the array.
<span class="lineno"> 5175 </span>-- This is a partial function as the permission @p@ must be:
<span class="lineno"> 5176 </span>-- (1) An array whose offset corresponds to a cell of @ap@
<span class="lineno"> 5177 </span>-- (2) A field or block corresponding to an array cell
<span class="lineno"> 5178 </span>-- TODO: Extend this to allow blocks that span multiple cells
<span class="lineno"> 5179 </span>permToLLVMArrayBorrow ::
<span class="lineno"> 5180 </span>  forall w. (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 5181 </span>  LLVMArrayPerm w -&gt;
<span class="lineno"> 5182 </span>  AtomicPerm (LLVMPointerType w) -&gt;
<span class="lineno"> 5183 </span>  Maybe (LLVMArrayBorrow w)
<span class="lineno"> 5184 </span><span class="decl"><span class="nottickedoff">permToLLVMArrayBorrow ap p =</span>
<span class="lineno"> 5185 </span><span class="spaces">  </span><span class="nottickedoff">case p of</span>
<span class="lineno"> 5186 </span><span class="spaces">    </span><span class="nottickedoff">Perm_LLVMArray ap'</span>
<span class="lineno"> 5187 </span><span class="spaces">      </span><span class="nottickedoff">| Just idx &lt;- matchLLVMArrayCell ap (llvmArrayOffset ap') -&gt;</span>
<span class="lineno"> 5188 </span><span class="spaces">        </span><span class="nottickedoff">Just (RangeBorrow (BVRange idx n))</span>
<span class="lineno"> 5189 </span><span class="spaces">        </span><span class="nottickedoff">where</span>
<span class="lineno"> 5190 </span><span class="spaces">          </span><span class="nottickedoff">n = llvmArrayLen ap'</span>
<span class="lineno"> 5191 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5192 </span><span class="spaces">    </span><span class="nottickedoff">Perm_LLVMBlock bp</span>
<span class="lineno"> 5193 </span><span class="spaces">      </span><span class="nottickedoff">| PExpr_ArrayShape len bytes _ &lt;- llvmBlockShape bp</span>
<span class="lineno"> 5194 </span><span class="spaces">      </span><span class="nottickedoff">, bytes == llvmArrayStride ap</span>
<span class="lineno"> 5195 </span><span class="spaces">      </span><span class="nottickedoff">, Just idx &lt;- matchLLVMArrayCell ap (llvmBlockOffset bp) -&gt;</span>
<span class="lineno"> 5196 </span><span class="spaces">        </span><span class="nottickedoff">Just (RangeBorrow (BVRange idx len))</span>
<span class="lineno"> 5197 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5198 </span><span class="spaces">    </span><span class="nottickedoff">Perm_LLVMField fp</span>
<span class="lineno"> 5199 </span><span class="spaces">      </span><span class="nottickedoff">| intValue (llvmFieldSize fp) /= llvmArrayStrideBits ap -&gt; Nothing</span>
<span class="lineno"> 5200 </span><span class="spaces">    </span><span class="nottickedoff">Perm_LLVMBlock bp</span>
<span class="lineno"> 5201 </span><span class="spaces">      </span><span class="nottickedoff">| not (bvEq (llvmBlockLen bp) (bvInt (bytesToInteger (llvmArrayStride ap)))) -&gt; Nothing</span>
<span class="lineno"> 5202 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5203 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5204 </span><span class="spaces">    </span><span class="nottickedoff">_ | Just r &lt;- llvmAtomicPermRange p</span>
<span class="lineno"> 5205 </span><span class="spaces">      </span><span class="nottickedoff">, Just idx &lt;- matchLLVMArrayCell ap (bvRangeOffset r) -&gt;</span>
<span class="lineno"> 5206 </span><span class="spaces">        </span><span class="nottickedoff">Just (FieldBorrow idx)</span>
<span class="lineno"> 5207 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5208 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; Nothing</span></span>
<span class="lineno"> 5209 </span>
<span class="lineno"> 5210 </span>-- | Get the range of offsets spanned by a borrow relative to the start of an
<span class="lineno"> 5211 </span>-- array permission
<span class="lineno"> 5212 </span>llvmArrayBorrowRange :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 5213 </span>                        LLVMArrayPerm w -&gt; LLVMArrayBorrow w -&gt; BVRange w
<span class="lineno"> 5214 </span><span class="decl"><span class="nottickedoff">llvmArrayBorrowRange ap borrow =</span>
<span class="lineno"> 5215 </span><span class="spaces">  </span><span class="nottickedoff">llvmArrayCellsToOffsets ap (llvmArrayBorrowCells borrow)</span></span>
<span class="lineno"> 5216 </span>
<span class="lineno"> 5217 </span>-- | Get the \&quot;absolute\&quot; range of offsets spanned by a borrow relative to the
<span class="lineno"> 5218 </span>-- pointer with this array permission
<span class="lineno"> 5219 </span>llvmArrayAbsBorrowRange :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 5220 </span>                           LLVMArrayPerm w -&gt; LLVMArrayBorrow w -&gt; BVRange w
<span class="lineno"> 5221 </span><span class="decl"><span class="nottickedoff">llvmArrayAbsBorrowRange ap borrow =</span>
<span class="lineno"> 5222 </span><span class="spaces">  </span><span class="nottickedoff">range { bvRangeOffset = bvAdd (llvmArrayOffset ap) (bvRangeOffset range) }</span>
<span class="lineno"> 5223 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno"> 5224 </span><span class="spaces">    </span><span class="nottickedoff">range = llvmArrayCellsToOffsets ap (llvmArrayBorrowCells borrow)</span></span>
<span class="lineno"> 5225 </span>
<span class="lineno"> 5226 </span>-- | Get the absolute offset at which an array borrow starts
<span class="lineno"> 5227 </span>llvmArrayBorrowAbsOffset :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5228 </span>                            LLVMArrayBorrow w -&gt; PermExpr (BVType w)
<span class="lineno"> 5229 </span><span class="decl"><span class="nottickedoff">llvmArrayBorrowAbsOffset ap b = bvRangeOffset $ llvmArrayAbsBorrowRange ap b</span></span>
<span class="lineno"> 5230 </span>
<span class="lineno"> 5231 </span>-- | Add a borrow to an 'LLVMArrayPerm'
<span class="lineno"> 5232 </span>llvmArrayAddBorrow :: LLVMArrayBorrow w -&gt; LLVMArrayPerm w -&gt; LLVMArrayPerm w
<span class="lineno"> 5233 </span><span class="decl"><span class="nottickedoff">llvmArrayAddBorrow b ap = ap { llvmArrayBorrows = b : llvmArrayBorrows ap }</span></span>
<span class="lineno"> 5234 </span>
<span class="lineno"> 5235 </span>-- | Add a list of borrows to an 'LLVMArrayPerm'
<span class="lineno"> 5236 </span>llvmArrayAddBorrows :: [LLVMArrayBorrow w] -&gt; LLVMArrayPerm w -&gt; LLVMArrayPerm w
<span class="lineno"> 5237 </span><span class="decl"><span class="nottickedoff">llvmArrayAddBorrows bs ap = foldr llvmArrayAddBorrow ap bs</span></span>
<span class="lineno"> 5238 </span>
<span class="lineno"> 5239 </span>-- | Add all borrows from the second array to the first, assuming the one is an
<span class="lineno"> 5240 </span>-- offset array as in 'llvmArrayIsOffsetArray'
<span class="lineno"> 5241 </span>llvmArrayAddArrayBorrows :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5242 </span>                            LLVMArrayPerm w -&gt; LLVMArrayPerm w
<span class="lineno"> 5243 </span><span class="decl"><span class="nottickedoff">llvmArrayAddArrayBorrows ap sub_ap</span>
<span class="lineno"> 5244 </span><span class="spaces">  </span><span class="nottickedoff">| Just cell_num &lt;- llvmArrayIsOffsetArray ap sub_ap =</span>
<span class="lineno"> 5245 </span><span class="spaces">    </span><span class="nottickedoff">llvmArrayAddBorrows</span>
<span class="lineno"> 5246 </span><span class="spaces">    </span><span class="nottickedoff">(map (cellOffsetLLVMArrayBorrow cell_num) (llvmArrayBorrows sub_ap))</span>
<span class="lineno"> 5247 </span><span class="spaces">    </span><span class="nottickedoff">ap</span>
<span class="lineno"> 5248 </span><span class="spaces"></span><span class="nottickedoff">llvmArrayAddArrayBorrows _ _ = error &quot;llvmArrayAddArrayBorrows&quot;</span></span>
<span class="lineno"> 5249 </span>
<span class="lineno"> 5250 </span>-- | Find the position in the list of borrows of an 'LLVMArrayPerm' of a
<span class="lineno"> 5251 </span>-- specific borrow
<span class="lineno"> 5252 </span>llvmArrayFindBorrow :: HasCallStack =&gt; LLVMArrayBorrow w -&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5253 </span>                       Int
<span class="lineno"> 5254 </span><span class="decl"><span class="nottickedoff">llvmArrayFindBorrow b ap =</span>
<span class="lineno"> 5255 </span><span class="spaces">  </span><span class="nottickedoff">case findIndex (== b) (llvmArrayBorrows ap) of</span>
<span class="lineno"> 5256 </span><span class="spaces">    </span><span class="nottickedoff">Just i -&gt; i</span>
<span class="lineno"> 5257 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; error &quot;llvmArrayFindBorrow: borrow not found&quot;</span></span>
<span class="lineno"> 5258 </span>
<span class="lineno"> 5259 </span>-- | Remove a borrow from an 'LLVMArrayPerm'
<span class="lineno"> 5260 </span>llvmArrayRemBorrow :: HasCallStack =&gt; LLVMArrayBorrow w -&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5261 </span>                      LLVMArrayPerm w
<span class="lineno"> 5262 </span><span class="decl"><span class="nottickedoff">llvmArrayRemBorrow b ap =</span>
<span class="lineno"> 5263 </span><span class="spaces">  </span><span class="nottickedoff">ap { llvmArrayBorrows =</span>
<span class="lineno"> 5264 </span><span class="spaces">         </span><span class="nottickedoff">deleteNth (llvmArrayFindBorrow b ap) (llvmArrayBorrows ap) }</span></span>
<span class="lineno"> 5265 </span>
<span class="lineno"> 5266 </span>-- | Remove a sequence of borrows from an 'LLVMArrayPerm'
<span class="lineno"> 5267 </span>llvmArrayRemBorrows :: HasCallStack =&gt; [LLVMArrayBorrow w] -&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5268 </span>                       LLVMArrayPerm w
<span class="lineno"> 5269 </span><span class="decl"><span class="nottickedoff">llvmArrayRemBorrows bs ap = foldr llvmArrayRemBorrow ap bs</span></span>
<span class="lineno"> 5270 </span>
<span class="lineno"> 5271 </span>-- | Remove all borrows from the second array to the first, assuming the one is
<span class="lineno"> 5272 </span>-- an offset array as in 'llvmArrayIsOffsetArray'
<span class="lineno"> 5273 </span>llvmArrayRemArrayBorrows :: HasCallStack =&gt; (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 5274 </span>                            LLVMArrayPerm w -&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5275 </span>                            LLVMArrayPerm w
<span class="lineno"> 5276 </span><span class="decl"><span class="nottickedoff">llvmArrayRemArrayBorrows ap sub_ap</span>
<span class="lineno"> 5277 </span><span class="spaces">  </span><span class="nottickedoff">| Just cell_num &lt;- llvmArrayIsOffsetArray ap sub_ap =</span>
<span class="lineno"> 5278 </span><span class="spaces">    </span><span class="nottickedoff">let sub_bs =</span>
<span class="lineno"> 5279 </span><span class="spaces">          </span><span class="nottickedoff">map (cellOffsetLLVMArrayBorrow cell_num) (llvmArrayBorrows sub_ap)</span>
<span class="lineno"> 5280 </span><span class="spaces">        </span><span class="nottickedoff">bs' = filter (flip notElem sub_bs) $ llvmArrayBorrows ap in</span>
<span class="lineno"> 5281 </span><span class="spaces">    </span><span class="nottickedoff">ap { llvmArrayBorrows = bs' }</span>
<span class="lineno"> 5282 </span><span class="spaces"></span><span class="nottickedoff">llvmArrayRemArrayBorrows _ _ = error &quot;llvmArrayRemArrayBorrows&quot;</span></span>
<span class="lineno"> 5283 </span>
<span class="lineno"> 5284 </span>-- | Test if the borrows of an array can be permuted to another order
<span class="lineno"> 5285 </span>llvmArrayBorrowsPermuteTo :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5286 </span>                             [LLVMArrayBorrow w] -&gt; Bool
<span class="lineno"> 5287 </span><span class="decl"><span class="nottickedoff">llvmArrayBorrowsPermuteTo ap bs =</span>
<span class="lineno"> 5288 </span><span class="spaces">  </span><span class="nottickedoff">all (flip elem (llvmArrayBorrows ap)) bs &amp;&amp;</span>
<span class="lineno"> 5289 </span><span class="spaces">  </span><span class="nottickedoff">all (flip elem bs) (llvmArrayBorrows ap)</span></span>
<span class="lineno"> 5290 </span>
<span class="lineno"> 5291 </span>-- | Add a cell offset to an 'LLVMArrayBorrow', meaning we change the borrow to
<span class="lineno"> 5292 </span>-- be relative to an array with that many more cells added to the front
<span class="lineno"> 5293 </span>cellOffsetLLVMArrayBorrow :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 5294 </span>                             LLVMArrayBorrow w -&gt; LLVMArrayBorrow w
<span class="lineno"> 5295 </span><span class="decl"><span class="nottickedoff">cellOffsetLLVMArrayBorrow off (FieldBorrow ix) =</span>
<span class="lineno"> 5296 </span><span class="spaces">  </span><span class="nottickedoff">FieldBorrow (bvAdd ix off)</span>
<span class="lineno"> 5297 </span><span class="spaces"></span><span class="nottickedoff">cellOffsetLLVMArrayBorrow off (RangeBorrow rng) =</span>
<span class="lineno"> 5298 </span><span class="spaces">  </span><span class="nottickedoff">RangeBorrow $ offsetBVRange off rng</span></span>
<span class="lineno"> 5299 </span>
<span class="lineno"> 5300 </span>-- | Produce a @BVRange@ of borrowed cells from a borrow, which will be either a
<span class="lineno"> 5301 </span>-- unit range (in the case of a @FieldBorrow@) or just the ranged spanned by the
<span class="lineno"> 5302 </span>-- given @RangeBorrow@.
<span class="lineno"> 5303 </span>llvmArrayBorrowCells :: (KnownNat w, 1 &lt;= w) =&gt; LLVMArrayBorrow w -&gt; BVRange w
<span class="lineno"> 5304 </span><span class="decl"><span class="nottickedoff">llvmArrayBorrowCells (FieldBorrow idx) = bvRangeOfIndex idx</span>
<span class="lineno"> 5305 </span><span class="spaces"></span><span class="nottickedoff">llvmArrayBorrowCells (RangeBorrow r) = r</span></span>
<span class="lineno"> 5306 </span>
<span class="lineno"> 5307 </span>-- FIXME: delete? not used, and should be implementable via bvRangeDelete
<span class="lineno"> 5308 </span>{-
<span class="lineno"> 5309 </span>-- | Given a borrow @borrow@ and range (of borrowed indices) @rng@,
<span class="lineno"> 5310 </span>-- delete @rng@ from @borrow@, and return the borrows that describe
<span class="lineno"> 5311 </span>-- the remaining borrowed cells.
<span class="lineno"> 5312 </span>llvmArrayBorrowRangeDelete ::
<span class="lineno"> 5313 </span>  (HasCallStack, 1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 5314 </span>  LLVMArrayBorrow w -&gt;
<span class="lineno"> 5315 </span>  BVRange w -&gt;
<span class="lineno"> 5316 </span>  [LLVMArrayBorrow w]
<span class="lineno"> 5317 </span>llvmArrayBorrowRangeDelete borrow rng =
<span class="lineno"> 5318 </span>  catMaybes (go &lt;$&gt; bvRangeDelete borrow_range rng)
<span class="lineno"> 5319 </span>  where
<span class="lineno"> 5320 </span>    borrow_range = llvmArrayBorrowCells borrow
<span class="lineno"> 5321 </span>
<span class="lineno"> 5322 </span>    go new_range
<span class="lineno"> 5323 </span>      | bvIsZero (bvRangeLength new_range) = Nothing
<span class="lineno"> 5324 </span>      | RangeBorrow _ &lt;- borrow  = Just $ RangeBorrow new_range
<span class="lineno"> 5325 </span>      | FieldBorrow idx &lt;- borrow
<span class="lineno"> 5326 </span>      , bvEq (bvRangeLength new_range) (bvInt 1) = Just $ FieldBorrow idx
<span class="lineno"> 5327 </span>      | otherwise =
<span class="lineno"> 5328 </span>        error &quot;llvmArrayBorrowRangeDelete: found non unit new_range for FieldBorrow&quot;
<span class="lineno"> 5329 </span>-}
<span class="lineno"> 5330 </span>
<span class="lineno"> 5331 </span>-- | Take in a range @rng@ and a list of ranges @rngs@ and try to find a
<span class="lineno"> 5332 </span>-- sequence of non-overlapping but contiguous ranges in @rngs@ that covers the
<span class="lineno"> 5333 </span>-- desired range @rng@
<span class="lineno"> 5334 </span>gatherCoveringRanges :: (1 &lt;= w, KnownNat w) =&gt; BVRange w -&gt; [BVRange w] -&gt;
<span class="lineno"> 5335 </span>                        Maybe [BVRange w]
<span class="lineno"> 5336 </span><span class="decl"><span class="nottickedoff">gatherCoveringRanges rng _ | bvIsZero (bvRangeLength rng) = Just []</span>
<span class="lineno"> 5337 </span><span class="spaces"></span><span class="nottickedoff">gatherCoveringRanges rng rngs</span>
<span class="lineno"> 5338 </span><span class="spaces">  </span><span class="nottickedoff">| Just i &lt;- findIndex (bvInRange (bvRangeOffset rng)) rngs</span>
<span class="lineno"> 5339 </span><span class="spaces">  </span><span class="nottickedoff">, rng' &lt;- rngs!!i =</span>
<span class="lineno"> 5340 </span><span class="spaces">    </span><span class="nottickedoff">-- If rng' covers all of rng, then we are done</span>
<span class="lineno"> 5341 </span><span class="spaces">    </span><span class="nottickedoff">if bvRangeSubset rng rng' then Just [rng'] else</span>
<span class="lineno"> 5342 </span><span class="spaces">      </span><span class="nottickedoff">(rng' :) &lt;$&gt;</span>
<span class="lineno"> 5343 </span><span class="spaces">      </span><span class="nottickedoff">gatherCoveringRanges (bvRangeSuffix (bvRangeEnd rng') rng)</span>
<span class="lineno"> 5344 </span><span class="spaces">                           </span><span class="nottickedoff">(deleteNth i rngs)</span>
<span class="lineno"> 5345 </span><span class="spaces"></span><span class="nottickedoff">gatherCoveringRanges _ _ = Nothing</span></span>
<span class="lineno"> 5346 </span>
<span class="lineno"> 5347 </span>-- | Test if the borrows in @ap@ cover a given range of offsets. That is, test
<span class="lineno"> 5348 </span>-- if the ranges of the borrows in @ap@ can be arranged as a sequence of
<span class="lineno"> 5349 </span>-- non-overlapping but contiguous ranges that extends at least as far as @len@
<span class="lineno"> 5350 </span>-- (in the sense of @bvLeq@).
<span class="lineno"> 5351 </span>llvmArrayRangeIsBorrowed :: (HasCallStack, 1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 5352 </span>                            LLVMArrayPerm w -&gt; BVRange w -&gt; Bool
<span class="lineno"> 5353 </span><span class="decl"><span class="nottickedoff">llvmArrayRangeIsBorrowed ap rng =</span>
<span class="lineno"> 5354 </span><span class="spaces">  </span><span class="nottickedoff">isJust $ gatherCoveringRanges rng $</span>
<span class="lineno"> 5355 </span><span class="spaces">  </span><span class="nottickedoff">map (llvmArrayBorrowAbsOffsets ap) (llvmArrayBorrows ap)</span></span>
<span class="lineno"> 5356 </span>
<span class="lineno"> 5357 </span>-- | Test whether the borrows in @ap@ cover the range of cells @[0, len)@. That
<span class="lineno"> 5358 </span>-- is, test if the ranges of the borrows in @ap@ can be arranged as a sequence
<span class="lineno"> 5359 </span>-- of non-overlapping but contiguous ranges that extends at least as far as
<span class="lineno"> 5360 </span>-- @len@ (in the sense of @bvLeq@)
<span class="lineno"> 5361 </span>llvmArrayIsBorrowed :: (HasCallStack, 1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5362 </span>                       Bool
<span class="lineno"> 5363 </span><span class="decl"><span class="nottickedoff">llvmArrayIsBorrowed ap =</span>
<span class="lineno"> 5364 </span><span class="spaces">  </span><span class="nottickedoff">llvmArrayRangeIsBorrowed ap (llvmArrayAbsOffsets ap)</span></span>
<span class="lineno"> 5365 </span>
<span class="lineno"> 5366 </span>-- | Test if a byte offset @o@ statically aligns with a statically-known offset
<span class="lineno"> 5367 </span>-- into some array cell, i.e., whether
<span class="lineno"> 5368 </span>--
<span class="lineno"> 5369 </span>-- &gt; o - off = stride*ix + cell_off
<span class="lineno"> 5370 </span>--
<span class="lineno"> 5371 </span>-- for some @ix@ and @cell_off@, where @off@ is the array offset and @stride@ is
<span class="lineno"> 5372 </span>-- the array stride. Return @ix@ and @cell_off@ as an 'LLVMArrayIndex' on
<span class="lineno"> 5373 </span>-- success.
<span class="lineno"> 5374 </span>matchLLVMArrayIndex :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5375 </span>                       PermExpr (BVType w) -&gt; Maybe (LLVMArrayIndex w)
<span class="lineno"> 5376 </span><span class="decl"><span class="nottickedoff">matchLLVMArrayIndex ap o =</span>
<span class="lineno"> 5377 </span><span class="spaces">  </span><span class="nottickedoff">do let rel_off = bvSub o (llvmArrayOffset ap)</span>
<span class="lineno"> 5378 </span><span class="spaces">     </span><span class="nottickedoff">(ix, cell_off) &lt;-</span>
<span class="lineno"> 5379 </span><span class="spaces">       </span><span class="nottickedoff">bvMatchFactorPlusConst (bytesToInteger $ llvmArrayStride ap) rel_off</span>
<span class="lineno"> 5380 </span><span class="spaces">     </span><span class="nottickedoff">return $ LLVMArrayIndex ix cell_off</span></span>
<span class="lineno"> 5381 </span>
<span class="lineno"> 5382 </span>-- | Test if a byte offset @o@ statically aligns with a cell boundary in an
<span class="lineno"> 5383 </span>-- array, i.e., whether
<span class="lineno"> 5384 </span>--
<span class="lineno"> 5385 </span>-- &gt; o - off = stride*cell
<span class="lineno"> 5386 </span>--
<span class="lineno"> 5387 </span>-- for some @cell@. Return @cell@ on success.
<span class="lineno"> 5388 </span>matchLLVMArrayCell :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5389 </span>                      PermExpr (BVType w) -&gt; Maybe (PermExpr (BVType w))
<span class="lineno"> 5390 </span><span class="decl"><span class="nottickedoff">matchLLVMArrayCell ap off</span>
<span class="lineno"> 5391 </span><span class="spaces">  </span><span class="nottickedoff">| Just (LLVMArrayIndex cell (BV.BV 0)) &lt;- matchLLVMArrayIndex ap off =</span>
<span class="lineno"> 5392 </span><span class="spaces">    </span><span class="nottickedoff">Just cell</span>
<span class="lineno"> 5393 </span><span class="spaces"></span><span class="nottickedoff">matchLLVMArrayCell _ _ = Nothing</span></span>
<span class="lineno"> 5394 </span>
<span class="lineno"> 5395 </span>-- | Return a list 'BVProp' stating that the cell(s) represented by an array
<span class="lineno"> 5396 </span>-- borrow are in the \&quot;base\&quot; set of cells in an array, before the borrows are
<span class="lineno"> 5397 </span>-- considered
<span class="lineno"> 5398 </span>llvmArrayBorrowInArrayBase :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 5399 </span>                              LLVMArrayPerm w -&gt; LLVMArrayBorrow w -&gt;
<span class="lineno"> 5400 </span>                              [BVProp w]
<span class="lineno"> 5401 </span><span class="decl"><span class="nottickedoff">llvmArrayBorrowInArrayBase ap (FieldBorrow ix) =</span>
<span class="lineno"> 5402 </span><span class="spaces">  </span><span class="nottickedoff">[bvPropInRange ix (llvmArrayCells ap)]</span>
<span class="lineno"> 5403 </span><span class="spaces"></span><span class="nottickedoff">llvmArrayBorrowInArrayBase ap (RangeBorrow rng) =</span>
<span class="lineno"> 5404 </span><span class="spaces">  </span><span class="nottickedoff">bvPropRangeSubset rng (llvmArrayCells ap)</span></span>
<span class="lineno"> 5405 </span>
<span class="lineno"> 5406 </span>-- | Return a list of 'BVProp's stating that two array borrows are disjoint. The
<span class="lineno"> 5407 </span>-- empty list is returned if they are trivially disjoint because they refer to
<span class="lineno"> 5408 </span>-- statically distinct field numbers.
<span class="lineno"> 5409 </span>llvmArrayBorrowsDisjoint :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 5410 </span>                            LLVMArrayBorrow w -&gt; LLVMArrayBorrow w -&gt; [BVProp w]
<span class="lineno"> 5411 </span><span class="decl"><span class="nottickedoff">llvmArrayBorrowsDisjoint (FieldBorrow ix1) (FieldBorrow ix2) =</span>
<span class="lineno"> 5412 </span><span class="spaces">  </span><span class="nottickedoff">[BVProp_Neq ix1 ix2]</span>
<span class="lineno"> 5413 </span><span class="spaces"></span><span class="nottickedoff">llvmArrayBorrowsDisjoint (FieldBorrow ix) (RangeBorrow rng) =</span>
<span class="lineno"> 5414 </span><span class="spaces">  </span><span class="nottickedoff">[bvPropNotInRange ix rng]</span>
<span class="lineno"> 5415 </span><span class="spaces"></span><span class="nottickedoff">llvmArrayBorrowsDisjoint (RangeBorrow rng) (FieldBorrow ix) =</span>
<span class="lineno"> 5416 </span><span class="spaces">  </span><span class="nottickedoff">[bvPropNotInRange ix rng]</span>
<span class="lineno"> 5417 </span><span class="spaces"></span><span class="nottickedoff">llvmArrayBorrowsDisjoint (RangeBorrow rng1) (RangeBorrow rng2) =</span>
<span class="lineno"> 5418 </span><span class="spaces">  </span><span class="nottickedoff">bvPropRangesDisjoint rng1 rng2</span></span>
<span class="lineno"> 5419 </span>
<span class="lineno"> 5420 </span>-- | Return a list of propositions stating that the cell(s) represented by an
<span class="lineno"> 5421 </span>-- array borrow are in the set of fields of an array permission. This takes into
<span class="lineno"> 5422 </span>-- account the current borrows on the array permission, which are fields that
<span class="lineno"> 5423 </span>-- are /not/ currently in that array permission.
<span class="lineno"> 5424 </span>llvmArrayBorrowInArray :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 5425 </span>                          LLVMArrayPerm w -&gt; LLVMArrayBorrow w -&gt; [BVProp w]
<span class="lineno"> 5426 </span><span class="decl"><span class="nottickedoff">llvmArrayBorrowInArray ap b =</span>
<span class="lineno"> 5427 </span><span class="spaces">  </span><span class="nottickedoff">llvmArrayBorrowInArrayBase ap b ++</span>
<span class="lineno"> 5428 </span><span class="spaces">  </span><span class="nottickedoff">concatMap (llvmArrayBorrowsDisjoint b) (llvmArrayBorrows ap)</span></span>
<span class="lineno"> 5429 </span>
<span class="lineno"> 5430 </span>-- | Shorthand for 'llvmArrayBorrowInArray' with a single index
<span class="lineno"> 5431 </span>llvmArrayIndexInArray :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5432 </span>                         LLVMArrayIndex w -&gt; [BVProp w]
<span class="lineno"> 5433 </span><span class="decl"><span class="nottickedoff">llvmArrayIndexInArray ap ix =</span>
<span class="lineno"> 5434 </span><span class="spaces">  </span><span class="nottickedoff">llvmArrayBorrowInArray ap (FieldBorrow $ llvmArrayIndexCell ix)</span></span>
<span class="lineno"> 5435 </span>
<span class="lineno"> 5436 </span>-- | Test if a cell is in an array permission and is not currently being
<span class="lineno"> 5437 </span>-- borrowed
<span class="lineno"> 5438 </span>llvmArrayCellInArray :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 5439 </span>                        LLVMArrayPerm w -&gt; PermExpr (BVType w) -&gt; [BVProp w]
<span class="lineno"> 5440 </span><span class="decl"><span class="nottickedoff">llvmArrayCellInArray ap cell = llvmArrayBorrowInArray ap (FieldBorrow cell)</span></span>
<span class="lineno"> 5441 </span>
<span class="lineno"> 5442 </span>-- | Test if all cell numbers in a 'BVRange' are in an array permission and are
<span class="lineno"> 5443 </span>-- not currently being borrowed
<span class="lineno"> 5444 </span>llvmArrayCellsInArray :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5445 </span>                         BVRange w -&gt; [BVProp w]
<span class="lineno"> 5446 </span><span class="decl"><span class="nottickedoff">llvmArrayCellsInArray ap rng = llvmArrayBorrowInArray ap (RangeBorrow rng)</span></span>
<span class="lineno"> 5447 </span>
<span class="lineno"> 5448 </span>-- | Test if an array permission @ap2@ is offset by an even multiple of cell
<span class="lineno"> 5449 </span>-- sizes from the start of @ap1@, and return that number of cells if so. Note
<span class="lineno"> 5450 </span>-- that 'llvmArrayIsOffsetArray' @ap1@ @ap2@ returns the negative of
<span class="lineno"> 5451 </span>-- 'llvmArrayIsOffsetArray' @ap2@ @ap1@ whenever either returns a value.
<span class="lineno"> 5452 </span>llvmArrayIsOffsetArray :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5453 </span>                          LLVMArrayPerm w -&gt; Maybe (PermExpr (BVType w))
<span class="lineno"> 5454 </span><span class="decl"><span class="nottickedoff">llvmArrayIsOffsetArray ap1 ap2</span>
<span class="lineno"> 5455 </span><span class="spaces">  </span><span class="nottickedoff">| llvmArrayStride ap1 == llvmArrayStride ap2 =</span>
<span class="lineno"> 5456 </span><span class="spaces">    </span><span class="nottickedoff">matchLLVMArrayCell ap1 (llvmArrayOffset ap2)</span>
<span class="lineno"> 5457 </span><span class="spaces"></span><span class="nottickedoff">llvmArrayIsOffsetArray _ _ = Nothing</span></span>
<span class="lineno"> 5458 </span>
<span class="lineno"> 5459 </span>-- | Build a 'BVRange' for the cells of a sub-array @ap2@ in @ap1@
<span class="lineno"> 5460 </span>llvmSubArrayRange :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5461 </span>                     LLVMArrayPerm w -&gt; BVRange w
<span class="lineno"> 5462 </span><span class="decl"><span class="nottickedoff">llvmSubArrayRange ap1 ap2</span>
<span class="lineno"> 5463 </span><span class="spaces">  </span><span class="nottickedoff">| Just cell_num &lt;- llvmArrayIsOffsetArray ap1 ap2 =</span>
<span class="lineno"> 5464 </span><span class="spaces">    </span><span class="nottickedoff">BVRange cell_num (llvmArrayLen ap2)</span>
<span class="lineno"> 5465 </span><span class="spaces"></span><span class="nottickedoff">llvmSubArrayRange _ _ = error &quot;llvmSubArrayRange&quot;</span></span>
<span class="lineno"> 5466 </span>
<span class="lineno"> 5467 </span>-- | Build a 'RangeBorrow' for the cells of a sub-array @ap2@ of @ap1@
<span class="lineno"> 5468 </span>llvmSubArrayBorrow :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5469 </span>                      LLVMArrayPerm w -&gt; LLVMArrayBorrow w
<span class="lineno"> 5470 </span><span class="decl"><span class="nottickedoff">llvmSubArrayBorrow ap1 ap2 = RangeBorrow $ llvmSubArrayRange ap1 ap2</span></span>
<span class="lineno"> 5471 </span>
<span class="lineno"> 5472 </span>-- | Given atomic permissions ps, filters out any q from ps such that q is
<span class="lineno"> 5473 </span>-- borrowed from some q' also in ps
<span class="lineno"> 5474 </span>filterBorrowedPermissions :: forall w. (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 5475 </span>                             [AtomicPerm (LLVMPointerType w)] -&gt;
<span class="lineno"> 5476 </span>                             [AtomicPerm (LLVMPointerType w)]
<span class="lineno"> 5477 </span><span class="decl"><span class="nottickedoff">filterBorrowedPermissions ps = filter (not . isABorrow) ps</span>
<span class="lineno"> 5478 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno"> 5479 </span><span class="spaces">    </span><span class="nottickedoff">isABorrow :: AtomicPerm (LLVMPointerType w) -&gt; Bool</span>
<span class="lineno"> 5480 </span><span class="spaces">    </span><span class="nottickedoff">isABorrow p =</span>
<span class="lineno"> 5481 </span><span class="spaces">      </span><span class="nottickedoff">case p of</span>
<span class="lineno"> 5482 </span><span class="spaces">        </span><span class="nottickedoff">(llvmAtomicPermRange -&gt; Just r) -&gt;</span>
<span class="lineno"> 5483 </span><span class="spaces">            </span><span class="nottickedoff">r `elem` borrowedRanges</span>
<span class="lineno"> 5484 </span><span class="spaces">        </span><span class="nottickedoff">Perm_LLVMArray a -&gt;</span>
<span class="lineno"> 5485 </span><span class="spaces">          </span><span class="nottickedoff">llvmArrayAbsOffsets a `elem` borrowedRanges</span>
<span class="lineno"> 5486 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt; False</span>
<span class="lineno"> 5487 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5488 </span><span class="spaces">    </span><span class="nottickedoff">borrowedRanges :: [BVRange w]</span>
<span class="lineno"> 5489 </span><span class="spaces">    </span><span class="nottickedoff">borrowedRanges = ps &gt;&gt;= go</span>
<span class="lineno"> 5490 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5491 </span><span class="spaces">    </span><span class="nottickedoff">go :: AtomicPerm (LLVMPointerType w) -&gt; [BVRange w]</span>
<span class="lineno"> 5492 </span><span class="spaces">    </span><span class="nottickedoff">go p =</span>
<span class="lineno"> 5493 </span><span class="spaces">      </span><span class="nottickedoff">case p of</span>
<span class="lineno"> 5494 </span><span class="spaces">        </span><span class="nottickedoff">Perm_LLVMArray arrayPerm -&gt;</span>
<span class="lineno"> 5495 </span><span class="spaces">          </span><span class="nottickedoff">goBorrow arrayPerm &lt;$&gt; llvmArrayBorrows arrayPerm</span>
<span class="lineno"> 5496 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt; []</span>
<span class="lineno"> 5497 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5498 </span><span class="spaces">    </span><span class="nottickedoff">goBorrow :: LLVMArrayPerm w -&gt; LLVMArrayBorrow w -&gt; BVRange w</span>
<span class="lineno"> 5499 </span><span class="spaces">    </span><span class="nottickedoff">goBorrow = llvmArrayBorrowOffsets</span></span>
<span class="lineno"> 5500 </span>
<span class="lineno"> 5501 </span>
<span class="lineno"> 5502 </span>-- | Return the propositions stating that the first array permission @ap@
<span class="lineno"> 5503 </span>-- contains the second @sub_ap@, meaning that array indices that are in @sub_ap@
<span class="lineno"> 5504 </span>-- (in the sense of 'llvmArrayIndexInArray') are in @ap@. This requires that the
<span class="lineno"> 5505 </span>-- range of @sub_ap@ be a subset of that of @ap@ and that it be disjoint from
<span class="lineno"> 5506 </span>-- all borrows in @ap@ that aren't also in @sub_ap@, i.e., that after removing
<span class="lineno"> 5507 </span>-- all borrows in @sub_ap@ from @ap@ we have that the 'llvmArrayCellsInArray'
<span class="lineno"> 5508 </span>-- propositions hold for the range of @sub_ap@.
<span class="lineno"> 5509 </span>--
<span class="lineno"> 5510 </span>-- NOTE: @sub_ap@ must satisfy 'llvmArrayIsOffsetArray', i.e., have the same
<span class="lineno"> 5511 </span>-- stride as @ap@ and be at a cell boundary in @ap@, or it is an error
<span class="lineno"> 5512 </span>llvmArrayContainsArray :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5513 </span>                          LLVMArrayPerm w -&gt; [BVProp w]
<span class="lineno"> 5514 </span><span class="decl"><span class="nottickedoff">llvmArrayContainsArray ap sub_ap =</span>
<span class="lineno"> 5515 </span><span class="spaces">  </span><span class="nottickedoff">llvmArrayCellsInArray</span>
<span class="lineno"> 5516 </span><span class="spaces">  </span><span class="nottickedoff">(llvmArrayRemArrayBorrows ap sub_ap)</span>
<span class="lineno"> 5517 </span><span class="spaces">  </span><span class="nottickedoff">(llvmSubArrayRange ap sub_ap)</span></span>
<span class="lineno"> 5518 </span>
<span class="lineno"> 5519 </span>-- | Build a sub-array of an array permission at a given offset with a given
<span class="lineno"> 5520 </span>-- length, keeping only those borrows from the original array that could (in the
<span class="lineno"> 5521 </span>-- sense of 'bvPropCouldHold') overlap with the range of the sub-array. This
<span class="lineno"> 5522 </span>-- means that the borrows in the returned sub-array are an over-approximation of
<span class="lineno"> 5523 </span>-- the borrows that overlap with it, i.e., there could be borrows in the
<span class="lineno"> 5524 </span>-- returned sub-array permission that are not in its range.
<span class="lineno"> 5525 </span>llvmMakeSubArray :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5526 </span>                    PermExpr (BVType w) -&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 5527 </span>                    LLVMArrayPerm w
<span class="lineno"> 5528 </span><span class="decl"><span class="nottickedoff">llvmMakeSubArray ap off len</span>
<span class="lineno"> 5529 </span><span class="spaces">  </span><span class="nottickedoff">| Just cell &lt;- matchLLVMArrayCell ap off</span>
<span class="lineno"> 5530 </span><span class="spaces">  </span><span class="nottickedoff">, cell_rng &lt;- BVRange cell len =</span>
<span class="lineno"> 5531 </span><span class="spaces">    </span><span class="nottickedoff">ap { llvmArrayOffset = off, llvmArrayLen = len,</span>
<span class="lineno"> 5532 </span><span class="spaces">         </span><span class="nottickedoff">llvmArrayBorrows =</span>
<span class="lineno"> 5533 </span><span class="spaces">           </span><span class="nottickedoff">map (cellOffsetLLVMArrayBorrow (bvNegate cell)) $</span>
<span class="lineno"> 5534 </span><span class="spaces">           </span><span class="nottickedoff">filter (not . all bvPropHolds .</span>
<span class="lineno"> 5535 </span><span class="spaces">                   </span><span class="nottickedoff">llvmArrayBorrowsDisjoint (RangeBorrow cell_rng)) $</span>
<span class="lineno"> 5536 </span><span class="spaces">           </span><span class="nottickedoff">llvmArrayBorrows ap }</span>
<span class="lineno"> 5537 </span><span class="spaces"></span><span class="nottickedoff">llvmMakeSubArray _ _ _ = error &quot;llvmMakeSubArray&quot;</span></span>
<span class="lineno"> 5538 </span>
<span class="lineno"> 5539 </span>-- | Test if an atomic LLVM permission potentially allows a read or write of a
<span class="lineno"> 5540 </span>-- given offset. If so, return a list of the propositions required for the read
<span class="lineno"> 5541 </span>-- to be allowed, and whether the propositions definitely hold (as in
<span class="lineno"> 5542 </span>-- 'bvPropHolds') or only could hold (as in 'bvPropCouldHold'). For fields and
<span class="lineno"> 5543 </span>-- blocks, the offset must simply be in their range, while for arrays, the
<span class="lineno"> 5544 </span>-- offset must only /not/ match any outstanding borrows, and the propositions
<span class="lineno"> 5545 </span>-- returned codify that as well as the requirement that the offset is in the
<span class="lineno"> 5546 </span>-- array range.
<span class="lineno"> 5547 </span>llvmPermContainsOffset :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 5548 </span>                          AtomicPerm (LLVMPointerType w) -&gt;
<span class="lineno"> 5549 </span>                          Maybe ([BVProp w], Bool)
<span class="lineno"> 5550 </span><span class="decl"><span class="nottickedoff">llvmPermContainsOffset off (Perm_LLVMField fp)</span>
<span class="lineno"> 5551 </span><span class="spaces">  </span><span class="nottickedoff">| prop &lt;- bvPropInRange off (llvmFieldRange fp)</span>
<span class="lineno"> 5552 </span><span class="spaces">  </span><span class="nottickedoff">, bvPropCouldHold prop =</span>
<span class="lineno"> 5553 </span><span class="spaces">    </span><span class="nottickedoff">Just ([prop], bvPropHolds prop)</span>
<span class="lineno"> 5554 </span><span class="spaces"></span><span class="nottickedoff">llvmPermContainsOffset off (Perm_LLVMArray ap)</span>
<span class="lineno"> 5555 </span><span class="spaces">  </span><span class="nottickedoff">| Just ix &lt;- matchLLVMArrayIndex ap off</span>
<span class="lineno"> 5556 </span><span class="spaces">  </span><span class="nottickedoff">, props &lt;- llvmArrayIndexInArray ap ix</span>
<span class="lineno"> 5557 </span><span class="spaces">  </span><span class="nottickedoff">, all bvPropCouldHold props =</span>
<span class="lineno"> 5558 </span><span class="spaces">    </span><span class="nottickedoff">Just (props, all bvPropHolds props)</span>
<span class="lineno"> 5559 </span><span class="spaces"></span><span class="nottickedoff">llvmPermContainsOffset off (Perm_LLVMBlock bp)</span>
<span class="lineno"> 5560 </span><span class="spaces">  </span><span class="nottickedoff">| prop &lt;- bvPropInRange off (llvmBlockRange bp)</span>
<span class="lineno"> 5561 </span><span class="spaces">  </span><span class="nottickedoff">, bvPropCouldHold prop =</span>
<span class="lineno"> 5562 </span><span class="spaces">    </span><span class="nottickedoff">Just ([prop], bvPropHolds prop)</span>
<span class="lineno"> 5563 </span><span class="spaces"></span><span class="nottickedoff">llvmPermContainsOffset _ _ = Nothing</span></span>
<span class="lineno"> 5564 </span>
<span class="lineno"> 5565 </span>-- | Test if an atomic LLVM permission definitely contains an offset. This is
<span class="lineno"> 5566 </span>-- the 'Bool' flag returned by 'llvmPermContainsOffset', or 'False' if that is
<span class="lineno"> 5567 </span>-- undefined.
<span class="lineno"> 5568 </span>llvmPermContainsOffsetBool :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 5569 </span>                              AtomicPerm (LLVMPointerType w) -&gt; Bool
<span class="lineno"> 5570 </span><span class="decl"><span class="nottickedoff">llvmPermContainsOffsetBool off p =</span>
<span class="lineno"> 5571 </span><span class="spaces">  </span><span class="nottickedoff">maybe False snd $ llvmPermContainsOffset off p</span></span>
<span class="lineno"> 5572 </span>
<span class="lineno"> 5573 </span>-- | Build the propositions stating that an atomic LLVM permission contains all
<span class="lineno"> 5574 </span>-- offsets in a given range
<span class="lineno"> 5575 </span>llvmAtomicPermContainsRangeProps :: (1 &lt;= w, KnownNat w) =&gt; BVRange w -&gt;
<span class="lineno"> 5576 </span>                                    AtomicPerm (LLVMPointerType w) -&gt;
<span class="lineno"> 5577 </span>                                    Maybe [BVProp w]
<span class="lineno"> 5578 </span><span class="decl"><span class="nottickedoff">llvmAtomicPermContainsRangeProps rng (Perm_LLVMArray ap)</span>
<span class="lineno"> 5579 </span><span class="spaces">  </span><span class="nottickedoff">| Just ix1 &lt;- matchLLVMArrayIndex ap (bvRangeOffset rng)</span>
<span class="lineno"> 5580 </span><span class="spaces">  </span><span class="nottickedoff">, Just ix2 &lt;- matchLLVMArrayIndex ap (bvRangeEnd rng)</span>
<span class="lineno"> 5581 </span><span class="spaces">  </span><span class="nottickedoff">, props &lt;- llvmArrayBorrowInArray ap (RangeBorrow $ BVRange</span>
<span class="lineno"> 5582 </span><span class="spaces">                                        </span><span class="nottickedoff">(llvmArrayIndexCell ix1)</span>
<span class="lineno"> 5583 </span><span class="spaces">                                        </span><span class="nottickedoff">(llvmArrayIndexCell ix2)) =</span>
<span class="lineno"> 5584 </span><span class="spaces">    </span><span class="nottickedoff">Just props</span>
<span class="lineno"> 5585 </span><span class="spaces"></span><span class="nottickedoff">llvmAtomicPermContainsRangeProps rng (Perm_LLVMField fp) =</span>
<span class="lineno"> 5586 </span><span class="spaces">  </span><span class="nottickedoff">Just $ bvPropRangeSubset rng (llvmFieldRange fp)</span>
<span class="lineno"> 5587 </span><span class="spaces"></span><span class="nottickedoff">llvmAtomicPermContainsRangeProps rng (Perm_LLVMBlock bp) =</span>
<span class="lineno"> 5588 </span><span class="spaces">  </span><span class="nottickedoff">Just $ bvPropRangeSubset rng (llvmBlockRange bp)</span>
<span class="lineno"> 5589 </span><span class="spaces"></span><span class="nottickedoff">llvmAtomicPermContainsRangeProps _ _ = Nothing</span></span>
<span class="lineno"> 5590 </span>
<span class="lineno"> 5591 </span>-- | Test if an atomic LLVM permission contains (in the sense of 'bvPropHolds')
<span class="lineno"> 5592 </span>-- all offsets in a given range
<span class="lineno"> 5593 </span>llvmAtomicPermContainsRange :: (1 &lt;= w, KnownNat w) =&gt; BVRange w -&gt;
<span class="lineno"> 5594 </span>                               AtomicPerm (LLVMPointerType w) -&gt; Bool
<span class="lineno"> 5595 </span><span class="decl"><span class="nottickedoff">llvmAtomicPermContainsRange rng p</span>
<span class="lineno"> 5596 </span><span class="spaces">  </span><span class="nottickedoff">| Just props &lt;- llvmAtomicPermContainsRangeProps rng p =</span>
<span class="lineno"> 5597 </span><span class="spaces">    </span><span class="nottickedoff">all bvPropHolds props</span>
<span class="lineno"> 5598 </span><span class="spaces"></span><span class="nottickedoff">llvmAtomicPermContainsRange _ _ = False</span></span>
<span class="lineno"> 5599 </span>
<span class="lineno"> 5600 </span>-- | Test if an atomic LLVM permission could contain (in the sense of
<span class="lineno"> 5601 </span>-- 'bvPropCouldHold') all offsets in a given range
<span class="lineno"> 5602 </span>llvmAtomicPermCouldContainRange :: (1 &lt;= w, KnownNat w) =&gt; BVRange w -&gt;
<span class="lineno"> 5603 </span>                                   AtomicPerm (LLVMPointerType w) -&gt; Bool
<span class="lineno"> 5604 </span><span class="decl"><span class="nottickedoff">llvmAtomicPermCouldContainRange rng p</span>
<span class="lineno"> 5605 </span><span class="spaces">  </span><span class="nottickedoff">| Just props &lt;- llvmAtomicPermContainsRangeProps rng p =</span>
<span class="lineno"> 5606 </span><span class="spaces">    </span><span class="nottickedoff">all bvPropCouldHold props</span>
<span class="lineno"> 5607 </span><span class="spaces"></span><span class="nottickedoff">llvmAtomicPermCouldContainRange _ _ = False</span></span>
<span class="lineno"> 5608 </span>
<span class="lineno"> 5609 </span>-- | Test if an atomic LLVM permission has a range that overlaps with (in the
<span class="lineno"> 5610 </span>-- sense of 'bvPropHolds') the offsets in a given range
<span class="lineno"> 5611 </span>llvmAtomicPermOverlapsRange :: (1 &lt;= w, KnownNat w) =&gt; BVRange w -&gt;
<span class="lineno"> 5612 </span>                               AtomicPerm (LLVMPointerType w) -&gt; Bool
<span class="lineno"> 5613 </span><span class="decl"><span class="nottickedoff">llvmAtomicPermOverlapsRange rng (Perm_LLVMArray ap) =</span>
<span class="lineno"> 5614 </span><span class="spaces">  </span><span class="nottickedoff">bvRangesOverlap rng (llvmArrayAbsOffsets ap) &amp;&amp;</span>
<span class="lineno"> 5615 </span><span class="spaces">  </span><span class="nottickedoff">not (null $ bvRangesDelete rng $</span>
<span class="lineno"> 5616 </span><span class="spaces">       </span><span class="nottickedoff">map (llvmArrayBorrowOffsets ap) (llvmArrayBorrows ap))</span>
<span class="lineno"> 5617 </span><span class="spaces"></span><span class="nottickedoff">llvmAtomicPermOverlapsRange rng (Perm_LLVMField fp) =</span>
<span class="lineno"> 5618 </span><span class="spaces">  </span><span class="nottickedoff">bvRangesOverlap rng (llvmFieldRange fp)</span>
<span class="lineno"> 5619 </span><span class="spaces"></span><span class="nottickedoff">llvmAtomicPermOverlapsRange rng (Perm_LLVMBlock bp) =</span>
<span class="lineno"> 5620 </span><span class="spaces">  </span><span class="nottickedoff">bvRangesOverlap rng (llvmBlockRange bp)</span>
<span class="lineno"> 5621 </span><span class="spaces"></span><span class="nottickedoff">llvmAtomicPermOverlapsRange _ _ = False</span></span>
<span class="lineno"> 5622 </span>
<span class="lineno"> 5623 </span>-- | Test if an atomic LLVM permission has a range that could overlap with (in the
<span class="lineno"> 5624 </span>-- sense of 'bvPropCouldHold') the offsets in a given range
<span class="lineno"> 5625 </span>llvmAtomicPermCouldOverlapRange :: (1 &lt;= w, KnownNat w) =&gt; BVRange w -&gt;
<span class="lineno"> 5626 </span>                               AtomicPerm (LLVMPointerType w) -&gt; Bool
<span class="lineno"> 5627 </span><span class="decl"><span class="nottickedoff">llvmAtomicPermCouldOverlapRange rng (Perm_LLVMArray ap) =</span>
<span class="lineno"> 5628 </span><span class="spaces">  </span><span class="nottickedoff">bvRangesCouldOverlap rng (llvmArrayAbsOffsets ap) &amp;&amp;</span>
<span class="lineno"> 5629 </span><span class="spaces">  </span><span class="nottickedoff">not (null $ bvRangesDelete rng $</span>
<span class="lineno"> 5630 </span><span class="spaces">       </span><span class="nottickedoff">map (llvmArrayBorrowOffsets ap) (llvmArrayBorrows ap))</span>
<span class="lineno"> 5631 </span><span class="spaces"></span><span class="nottickedoff">llvmAtomicPermCouldOverlapRange rng (Perm_LLVMField fp) =</span>
<span class="lineno"> 5632 </span><span class="spaces">  </span><span class="nottickedoff">bvRangesCouldOverlap rng (llvmFieldRange fp)</span>
<span class="lineno"> 5633 </span><span class="spaces"></span><span class="nottickedoff">llvmAtomicPermCouldOverlapRange rng (Perm_LLVMBlock bp) =</span>
<span class="lineno"> 5634 </span><span class="spaces">  </span><span class="nottickedoff">bvRangesCouldOverlap rng (llvmBlockRange bp)</span>
<span class="lineno"> 5635 </span><span class="spaces"></span><span class="nottickedoff">llvmAtomicPermCouldOverlapRange _ _ = False</span></span>
<span class="lineno"> 5636 </span>
<span class="lineno"> 5637 </span>-- | Return the total length of an LLVM array permission in bytes
<span class="lineno"> 5638 </span>llvmArrayLengthBytes :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5639 </span>                        PermExpr (BVType w)
<span class="lineno"> 5640 </span><span class="decl"><span class="nottickedoff">llvmArrayLengthBytes ap = llvmArrayCellToOffset ap (llvmArrayLen ap)</span></span>
<span class="lineno"> 5641 </span>
<span class="lineno"> 5642 </span>-- | Return the byte offset of an array index from the beginning of the array
<span class="lineno"> 5643 </span>llvmArrayIndexByteOffset :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5644 </span>                            LLVMArrayIndex w -&gt; PermExpr (BVType w)
<span class="lineno"> 5645 </span><span class="decl"><span class="nottickedoff">llvmArrayIndexByteOffset ap (LLVMArrayIndex cell cell_off) =</span>
<span class="lineno"> 5646 </span><span class="spaces">  </span><span class="nottickedoff">bvAdd (llvmArrayCellToOffset ap cell) (bvBV cell_off)</span></span>
<span class="lineno"> 5647 </span>
<span class="lineno"> 5648 </span>-- | Convert an array permission with a statically-known size @N@ to a list of
<span class="lineno"> 5649 </span>-- @memblock@ permissions for cells @0@ through @N-1@
<span class="lineno"> 5650 </span>llvmArrayToBlocks :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5651 </span>                     Maybe [LLVMBlockPerm w]
<span class="lineno"> 5652 </span><span class="decl"><span class="nottickedoff">llvmArrayToBlocks ap</span>
<span class="lineno"> 5653 </span><span class="spaces">  </span><span class="nottickedoff">| Just len &lt;- bvMatchConstInt $ llvmArrayLen ap =</span>
<span class="lineno"> 5654 </span><span class="spaces">    </span><span class="nottickedoff">Just $ map (llvmArrayCellPerm ap . bvInt) [0..len-1]</span>
<span class="lineno"> 5655 </span><span class="spaces"></span><span class="nottickedoff">llvmArrayToBlocks _ = Nothing</span></span>
<span class="lineno"> 5656 </span>
<span class="lineno"> 5657 </span>-- | Get the range of byte offsets represented by an array borrow relative to
<span class="lineno"> 5658 </span>-- the beginning of the array permission
<span class="lineno"> 5659 </span>llvmArrayBorrowOffsets :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5660 </span>                          LLVMArrayBorrow w -&gt; BVRange w
<span class="lineno"> 5661 </span><span class="decl"><span class="nottickedoff">llvmArrayBorrowOffsets ap (FieldBorrow ix) =</span>
<span class="lineno"> 5662 </span><span class="spaces">  </span><span class="nottickedoff">BVRange (llvmArrayCellToOffset ap ix) (bvInt $ toInteger $ llvmArrayStride ap)</span>
<span class="lineno"> 5663 </span><span class="spaces"></span><span class="nottickedoff">llvmArrayBorrowOffsets ap (RangeBorrow r) = llvmArrayCellsToOffsets ap r</span></span>
<span class="lineno"> 5664 </span>
<span class="lineno"> 5665 </span>-- | Get the range of byte offsets represented by an array borrow relative to
<span class="lineno"> 5666 </span>-- the variable @x@ that has the supplied array permission. This is equivalent
<span class="lineno"> 5667 </span>-- to the addition of 'llvmArrayOffset' to the range of relative offsets
<span class="lineno"> 5668 </span>-- returned by 'llvmArrayBorrowOffsets'.
<span class="lineno"> 5669 </span>llvmArrayBorrowAbsOffsets :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5670 </span>                             LLVMArrayBorrow w -&gt; BVRange w
<span class="lineno"> 5671 </span><span class="decl"><span class="nottickedoff">llvmArrayBorrowAbsOffsets ap b =</span>
<span class="lineno"> 5672 </span><span class="spaces">  </span><span class="nottickedoff">offsetBVRange (llvmArrayOffset ap) (llvmArrayBorrowOffsets ap b)</span></span>
<span class="lineno"> 5673 </span>
<span class="lineno"> 5674 </span>-- | Divide an array permission @x:array(off,&lt;len,*1,flds,bs)@ into two arrays,
<span class="lineno"> 5675 </span>-- one of length @len'@ starting at @off@ and one of length @len-len'@ starting
<span class="lineno"> 5676 </span>-- at offset @off+len'*stride@. All borrows that are definitely (in the sense of
<span class="lineno"> 5677 </span>-- 'bvPropHolds') in the first portion of the array are moved to that first
<span class="lineno"> 5678 </span>-- portion, and otherwise they are left in the second.
<span class="lineno"> 5679 </span>llvmArrayPermDivide :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5680 </span>                       PermExpr (BVType w) -&gt; (LLVMArrayPerm w, LLVMArrayPerm w)
<span class="lineno"> 5681 </span><span class="decl"><span class="nottickedoff">llvmArrayPermDivide ap len =</span>
<span class="lineno"> 5682 </span><span class="spaces">  </span><span class="nottickedoff">let len_bytes = llvmArrayCellToOffset ap len</span>
<span class="lineno"> 5683 </span><span class="spaces">      </span><span class="nottickedoff">borrow_in_first b =</span>
<span class="lineno"> 5684 </span><span class="spaces">        </span><span class="nottickedoff">all bvPropHolds (bvPropRangeSubset</span>
<span class="lineno"> 5685 </span><span class="spaces">                         </span><span class="nottickedoff">(llvmArrayBorrowOffsets ap b)</span>
<span class="lineno"> 5686 </span><span class="spaces">                         </span><span class="nottickedoff">(BVRange (bvInt 0) len_bytes)) in</span>
<span class="lineno"> 5687 </span><span class="spaces">  </span><span class="nottickedoff">(ap { llvmArrayLen = len,</span>
<span class="lineno"> 5688 </span><span class="spaces">        </span><span class="nottickedoff">llvmArrayBorrows = filter borrow_in_first (llvmArrayBorrows ap) }</span>
<span class="lineno"> 5689 </span><span class="spaces">  </span><span class="nottickedoff">,</span>
<span class="lineno"> 5690 </span><span class="spaces">   </span><span class="nottickedoff">ap { llvmArrayOffset = bvAdd (llvmArrayOffset ap) len_bytes</span>
<span class="lineno"> 5691 </span><span class="spaces">      </span><span class="nottickedoff">, llvmArrayLen = bvSub (llvmArrayLen ap) len</span>
<span class="lineno"> 5692 </span><span class="spaces">      </span><span class="nottickedoff">, llvmArrayBorrows =</span>
<span class="lineno"> 5693 </span><span class="spaces">          </span><span class="nottickedoff">filter (not . borrow_in_first) (llvmArrayBorrows ap) })</span></span>
<span class="lineno"> 5694 </span>
<span class="lineno"> 5695 </span>
<span class="lineno"> 5696 </span>-- | Create a list of field permissions that cover @N@ bytes:
<span class="lineno"> 5697 </span>--
<span class="lineno"> 5698 </span>-- &gt; ptr((W,0) |-&gt; true, (W,M) |-&gt; true, (W,2*M) |-&gt; true,
<span class="lineno"> 5699 </span>-- &gt;   ..., (W, (i-1)*M, 8*(sz-(i-1)*M)) |-&gt; true)
<span class="lineno"> 5700 </span>--
<span class="lineno"> 5701 </span>-- where @sz@ is the number of bytes allocated, @M@ is the machine word size in
<span class="lineno"> 5702 </span>-- bytes, and @i@ is the greatest natural number such that @(i-1)*M &lt; sz@
<span class="lineno"> 5703 </span>llvmFieldsOfSize :: (1 &lt;= w, KnownNat w) =&gt; f w -&gt; Integer -&gt;
<span class="lineno"> 5704 </span>                    [AtomicPerm (LLVMPointerType w)]
<span class="lineno"> 5705 </span><span class="decl"><span class="nottickedoff">llvmFieldsOfSize (w :: f w) sz</span>
<span class="lineno"> 5706 </span><span class="spaces">  </span><span class="nottickedoff">| sz_last_int &lt;- 8 * (sz - prevMachineWord w sz)</span>
<span class="lineno"> 5707 </span><span class="spaces">  </span><span class="nottickedoff">, Just (Some sz_last) &lt;- someNat sz_last_int</span>
<span class="lineno"> 5708 </span><span class="spaces">  </span><span class="nottickedoff">, Left LeqProof &lt;- decideLeq (knownNat @1) sz_last =</span>
<span class="lineno"> 5709 </span><span class="spaces">    </span><span class="nottickedoff">withKnownNat sz_last $</span>
<span class="lineno"> 5710 </span><span class="spaces">    </span><span class="nottickedoff">map (\i -&gt; Perm_LLVMField $</span>
<span class="lineno"> 5711 </span><span class="spaces">               </span><span class="nottickedoff">(llvmFieldWrite0True @w) { llvmFieldOffset =</span>
<span class="lineno"> 5712 </span><span class="spaces">                                            </span><span class="nottickedoff">bvInt (i * machineWordBytes w) })</span>
<span class="lineno"> 5713 </span><span class="spaces">    </span><span class="nottickedoff">[0 .. bytesToMachineWords w sz - 2]</span>
<span class="lineno"> 5714 </span><span class="spaces">    </span><span class="nottickedoff">++</span>
<span class="lineno"> 5715 </span><span class="spaces">    </span><span class="nottickedoff">[Perm_LLVMField $</span>
<span class="lineno"> 5716 </span><span class="spaces">     </span><span class="nottickedoff">(llvmSizedFieldWrite0True w sz_last)</span>
<span class="lineno"> 5717 </span><span class="spaces">     </span><span class="nottickedoff">{ llvmFieldOffset =</span>
<span class="lineno"> 5718 </span><span class="spaces">         </span><span class="nottickedoff">bvInt ((bytesToMachineWords w sz - 1) * machineWordBytes w) }]</span>
<span class="lineno"> 5719 </span><span class="spaces">  </span><span class="nottickedoff">| otherwise = error &quot;impossible (sz_last_int is always &gt;= 8)&quot;</span></span>
<span class="lineno"> 5720 </span>
<span class="lineno"> 5721 </span>-- | Return the permission built from the field permissions returned by
<span class="lineno"> 5722 </span>-- 'llvmFieldsOfSize'
<span class="lineno"> 5723 </span>llvmFieldsPermOfSize :: (1 &lt;= w, KnownNat w) =&gt; f w -&gt; Integer -&gt;
<span class="lineno"> 5724 </span>                        ValuePerm (LLVMPointerType w)
<span class="lineno"> 5725 </span><span class="decl"><span class="nottickedoff">llvmFieldsPermOfSize w n = ValPerm_Conj $ llvmFieldsOfSize w n</span></span>
<span class="lineno"> 5726 </span>
<span class="lineno"> 5727 </span>-- | Return a memblock permission with empty shape of given size
<span class="lineno"> 5728 </span>llvmEmptyBlockPermOfSize :: (1 &lt;= w, KnownNat w) =&gt; f w -&gt; Integer -&gt;
<span class="lineno"> 5729 </span>                        ValuePerm (LLVMPointerType w)
<span class="lineno"> 5730 </span><span class="decl"><span class="nottickedoff">llvmEmptyBlockPermOfSize _ n = ValPerm_LLVMBlock $</span>
<span class="lineno"> 5731 </span><span class="spaces">    </span><span class="nottickedoff">LLVMBlockPerm { llvmBlockRW       = PExpr_RWModality Write</span>
<span class="lineno"> 5732 </span><span class="spaces">                  </span><span class="nottickedoff">, llvmBlockLifetime = PExpr_Always</span>
<span class="lineno"> 5733 </span><span class="spaces">                  </span><span class="nottickedoff">, llvmBlockOffset   = bvInt 0</span>
<span class="lineno"> 5734 </span><span class="spaces">                  </span><span class="nottickedoff">, llvmBlockLen      = bvInt n</span>
<span class="lineno"> 5735 </span><span class="spaces">                  </span><span class="nottickedoff">, llvmBlockShape    = PExpr_EmptyShape</span>
<span class="lineno"> 5736 </span><span class="spaces">                  </span><span class="nottickedoff">}</span></span>
<span class="lineno"> 5737 </span>
<span class="lineno"> 5738 </span>-- | Create an LLVM shape for a single byte with @true@ permissions
<span class="lineno"> 5739 </span>llvmByteTrueShape :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (LLVMShapeType w)
<span class="lineno"> 5740 </span><span class="decl"><span class="nottickedoff">llvmByteTrueShape =</span>
<span class="lineno"> 5741 </span><span class="spaces">  </span><span class="nottickedoff">PExpr_FieldShape $ LLVMFieldShape (ValPerm_True</span>
<span class="lineno"> 5742 </span><span class="spaces">                                     </span><span class="nottickedoff">:: ValuePerm (LLVMPointerType 8))</span></span>
<span class="lineno"> 5743 </span>
<span class="lineno"> 5744 </span>-- | Create an 'LLVMArrayPerm' for an array of uninitialized bytes
<span class="lineno"> 5745 </span>llvmByteArrayArrayPerm :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 5746 </span>                          PermExpr (BVType w) -&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 5747 </span>                          PermExpr RWModalityType -&gt; PermExpr LifetimeType -&gt;
<span class="lineno"> 5748 </span>                          LLVMArrayPerm w
<span class="lineno"> 5749 </span><span class="decl"><span class="nottickedoff">llvmByteArrayArrayPerm off len rw l =</span>
<span class="lineno"> 5750 </span><span class="spaces">  </span><span class="nottickedoff">LLVMArrayPerm { llvmArrayRW = rw, llvmArrayLifetime = l,</span>
<span class="lineno"> 5751 </span><span class="spaces">                  </span><span class="nottickedoff">llvmArrayOffset = off, llvmArrayLen = len,</span>
<span class="lineno"> 5752 </span><span class="spaces">                  </span><span class="nottickedoff">llvmArrayStride = 1, llvmArrayCellShape = llvmByteTrueShape,</span>
<span class="lineno"> 5753 </span><span class="spaces">                  </span><span class="nottickedoff">llvmArrayBorrows = [] }</span></span>
<span class="lineno"> 5754 </span>
<span class="lineno"> 5755 </span>-- | Create a permission for an array of bytes
<span class="lineno"> 5756 </span>llvmByteArrayPerm :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 5757 </span>                     PermExpr (BVType w) -&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 5758 </span>                     PermExpr RWModalityType -&gt; PermExpr LifetimeType -&gt;
<span class="lineno"> 5759 </span>                     ValuePerm (LLVMPointerType w)
<span class="lineno"> 5760 </span><span class="decl"><span class="nottickedoff">llvmByteArrayPerm off len rw l =</span>
<span class="lineno"> 5761 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_Conj1 $ Perm_LLVMArray $ llvmByteArrayArrayPerm off len rw l</span></span>
<span class="lineno"> 5762 </span>
<span class="lineno"> 5763 </span>-- | Map an 'LLVMBlockPerm' to a byte array perm with the same components
<span class="lineno"> 5764 </span>llvmBlockPermToByteArrayPerm :: (1 &lt;= w, KnownNat w) =&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 5765 </span>                                ValuePerm (LLVMPointerType w)
<span class="lineno"> 5766 </span><span class="decl"><span class="nottickedoff">llvmBlockPermToByteArrayPerm (LLVMBlockPerm {..}) =</span>
<span class="lineno"> 5767 </span><span class="spaces">  </span><span class="nottickedoff">llvmByteArrayPerm llvmBlockOffset llvmBlockLen llvmBlockRW llvmBlockLifetime</span></span>
<span class="lineno"> 5768 </span>
<span class="lineno"> 5769 </span>-- | Create a @memblock(W,0,sz,emptysh)@ permission for a given size @sz@
<span class="lineno"> 5770 </span>llvmBlockPermOfSize :: (1 &lt;= w, KnownNat w) =&gt; Integer -&gt;
<span class="lineno"> 5771 </span>                       ValuePerm (LLVMPointerType w)
<span class="lineno"> 5772 </span><span class="decl"><span class="nottickedoff">llvmBlockPermOfSize sz =</span>
<span class="lineno"> 5773 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_Conj1 $ Perm_LLVMBlock $</span>
<span class="lineno"> 5774 </span><span class="spaces">  </span><span class="nottickedoff">LLVMBlockPerm { llvmBlockRW = PExpr_Write, llvmBlockLifetime = PExpr_Always,</span>
<span class="lineno"> 5775 </span><span class="spaces">                  </span><span class="nottickedoff">llvmBlockOffset = bvInt 0, llvmBlockLen = bvInt sz,</span>
<span class="lineno"> 5776 </span><span class="spaces">                  </span><span class="nottickedoff">llvmBlockShape = PExpr_EmptyShape }</span></span>
<span class="lineno"> 5777 </span>
<span class="lineno"> 5778 </span>-- | Add an offset @off@ to an LLVM permission @p@, meaning change @p@ so that
<span class="lineno"> 5779 </span>-- it indicates that @x+off@ has permission @p@.
<span class="lineno"> 5780 </span>--
<span class="lineno"> 5781 </span>-- FIXME: this should be the general-purpose function 'offsetPerm' that recurses
<span class="lineno"> 5782 </span>-- through permissions; that would allow other sorts of offsets at other types
<span class="lineno"> 5783 </span>offsetLLVMPerm :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 5784 </span>                  ValuePerm (LLVMPointerType w) -&gt; ValuePerm (LLVMPointerType w)
<span class="lineno"> 5785 </span><span class="decl"><span class="nottickedoff">offsetLLVMPerm off (ValPerm_Eq e) = ValPerm_Eq $ addLLVMOffset e (bvNegate off)</span>
<span class="lineno"> 5786 </span><span class="spaces"></span><span class="nottickedoff">offsetLLVMPerm off (ValPerm_Or p1 p2) =</span>
<span class="lineno"> 5787 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_Or (offsetLLVMPerm off p1) (offsetLLVMPerm off p2)</span>
<span class="lineno"> 5788 </span><span class="spaces"></span><span class="nottickedoff">offsetLLVMPerm off (ValPerm_Exists mb_p) =</span>
<span class="lineno"> 5789 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_Exists $ fmap (offsetLLVMPerm off) mb_p</span>
<span class="lineno"> 5790 </span><span class="spaces"></span><span class="nottickedoff">offsetLLVMPerm off (ValPerm_Named n args off') =</span>
<span class="lineno"> 5791 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_Named n args (addPermOffsets off' (mkLLVMPermOffset off))</span>
<span class="lineno"> 5792 </span><span class="spaces"></span><span class="nottickedoff">offsetLLVMPerm off (ValPerm_Var x off') =</span>
<span class="lineno"> 5793 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_Var x $ addPermOffsets off' (mkLLVMPermOffset off)</span>
<span class="lineno"> 5794 </span><span class="spaces"></span><span class="nottickedoff">offsetLLVMPerm off (ValPerm_Conj ps) =</span>
<span class="lineno"> 5795 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_Conj $ mapMaybe (offsetLLVMAtomicPerm off) ps</span>
<span class="lineno"> 5796 </span><span class="spaces"></span><span class="nottickedoff">offsetLLVMPerm _ ValPerm_False = ValPerm_False</span></span>
<span class="lineno"> 5797 </span>
<span class="lineno"> 5798 </span>-- | Test if an LLVM pointer permission can be offset by the given offset; i.e.,
<span class="lineno"> 5799 </span>-- whether 'offsetLLVMAtomicPerm' returns a value
<span class="lineno"> 5800 </span>canOffsetLLVMAtomicPerm :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 5801 </span>                           LLVMPtrPerm w -&gt; Bool
<span class="lineno"> 5802 </span><span class="decl"><span class="nottickedoff">canOffsetLLVMAtomicPerm off p = isJust $ offsetLLVMAtomicPerm off p</span></span>
<span class="lineno"> 5803 </span>
<span class="lineno"> 5804 </span>-- | Add an offset to an LLVM pointer permission, returning 'Nothing' for
<span class="lineno"> 5805 </span>-- permissions like @free@ and @llvm_funptr@ that cannot be offset
<span class="lineno"> 5806 </span>offsetLLVMAtomicPerm :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 5807 </span>                        LLVMPtrPerm w -&gt; Maybe (LLVMPtrPerm w)
<span class="lineno"> 5808 </span><span class="decl"><span class="nottickedoff">offsetLLVMAtomicPerm (bvMatchConstInt -&gt; Just 0) p = Just p</span>
<span class="lineno"> 5809 </span><span class="spaces"></span><span class="nottickedoff">offsetLLVMAtomicPerm off (Perm_LLVMField fp) =</span>
<span class="lineno"> 5810 </span><span class="spaces">  </span><span class="nottickedoff">Just $ Perm_LLVMField $ offsetLLVMFieldPerm off fp</span>
<span class="lineno"> 5811 </span><span class="spaces"></span><span class="nottickedoff">offsetLLVMAtomicPerm off (Perm_LLVMArray ap) =</span>
<span class="lineno"> 5812 </span><span class="spaces">  </span><span class="nottickedoff">Just $ Perm_LLVMArray $ offsetLLVMArrayPerm off ap</span>
<span class="lineno"> 5813 </span><span class="spaces"></span><span class="nottickedoff">offsetLLVMAtomicPerm off (Perm_LLVMBlock bp) =</span>
<span class="lineno"> 5814 </span><span class="spaces">  </span><span class="nottickedoff">Just $ Perm_LLVMBlock $ offsetLLVMBlockPerm off bp</span>
<span class="lineno"> 5815 </span><span class="spaces"></span><span class="nottickedoff">offsetLLVMAtomicPerm _ (Perm_LLVMFree _) = Nothing</span>
<span class="lineno"> 5816 </span><span class="spaces"></span><span class="nottickedoff">offsetLLVMAtomicPerm _ (Perm_LLVMFunPtr _ _) = Nothing</span>
<span class="lineno"> 5817 </span><span class="spaces"></span><span class="nottickedoff">offsetLLVMAtomicPerm _ p@Perm_IsLLVMPtr = Just p</span>
<span class="lineno"> 5818 </span><span class="spaces"></span><span class="nottickedoff">offsetLLVMAtomicPerm off (Perm_NamedConj n args off') =</span>
<span class="lineno"> 5819 </span><span class="spaces">  </span><span class="nottickedoff">Just $ Perm_NamedConj n args $ addPermOffsets off' (mkLLVMPermOffset off)</span>
<span class="lineno"> 5820 </span><span class="spaces"></span><span class="nottickedoff">offsetLLVMAtomicPerm _ p@(Perm_BVProp _) = Just p</span>
<span class="lineno"> 5821 </span><span class="spaces"></span><span class="nottickedoff">offsetLLVMAtomicPerm _ p@Perm_Any = Just p</span></span>
<span class="lineno"> 5822 </span>
<span class="lineno"> 5823 </span>-- | Add an offset to a field permission
<span class="lineno"> 5824 </span>offsetLLVMFieldPerm :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 5825 </span>                       LLVMFieldPerm w sz -&gt; LLVMFieldPerm w sz
<span class="lineno"> 5826 </span><span class="decl"><span class="nottickedoff">offsetLLVMFieldPerm off (LLVMFieldPerm {..}) =</span>
<span class="lineno"> 5827 </span><span class="spaces">  </span><span class="nottickedoff">LLVMFieldPerm { llvmFieldOffset = bvAdd llvmFieldOffset off, ..}</span></span>
<span class="lineno"> 5828 </span>
<span class="lineno"> 5829 </span>-- | Add an offset to an array permission
<span class="lineno"> 5830 </span>offsetLLVMArrayPerm :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 5831 </span>                       LLVMArrayPerm w -&gt; LLVMArrayPerm w
<span class="lineno"> 5832 </span><span class="decl"><span class="nottickedoff">offsetLLVMArrayPerm off (LLVMArrayPerm {..}) =</span>
<span class="lineno"> 5833 </span><span class="spaces">  </span><span class="nottickedoff">LLVMArrayPerm { llvmArrayOffset = bvAdd llvmArrayOffset off, ..}</span></span>
<span class="lineno"> 5834 </span>
<span class="lineno"> 5835 </span>-- | Add an offset to a block permission
<span class="lineno"> 5836 </span>offsetLLVMBlockPerm :: (1 &lt;= w, KnownNat w) =&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 5837 </span>                       LLVMBlockPerm w -&gt; LLVMBlockPerm w
<span class="lineno"> 5838 </span><span class="decl"><span class="nottickedoff">offsetLLVMBlockPerm off (LLVMBlockPerm {..}) =</span>
<span class="lineno"> 5839 </span><span class="spaces">  </span><span class="nottickedoff">LLVMBlockPerm { llvmBlockOffset = bvAdd llvmBlockOffset off, ..}</span></span>
<span class="lineno"> 5840 </span>
<span class="lineno"> 5841 </span>-- | Add a 'PermOffset' to a permission, assuming that it is a conjunctive
<span class="lineno"> 5842 </span>-- permission, meaning that it is built inductively using only existentials,
<span class="lineno"> 5843 </span>-- disjunctions, conjunctive named permissions, and conjunctions of atomic
<span class="lineno"> 5844 </span>-- permissions (though these atomic permissions can contain equality permissions
<span class="lineno"> 5845 </span>-- in, e.g., LLVM field permissions)
<span class="lineno"> 5846 </span>offsetPerm :: PermOffset a -&gt; ValuePerm a -&gt; ValuePerm a
<span class="lineno"> 5847 </span><span class="decl"><span class="nottickedoff">offsetPerm (LLVMPermOffset off) p = offsetLLVMPerm off p</span>
<span class="lineno"> 5848 </span><span class="spaces"></span><span class="nottickedoff">offsetPerm NoPermOffset p = p</span></span>
<span class="lineno"> 5849 </span>
<span class="lineno"> 5850 </span>-- | Lens for the atomic permissions in a 'ValPerm_Conj'; it is an error to use
<span class="lineno"> 5851 </span>-- this lens with a value permission not of this form
<span class="lineno"> 5852 </span>conjAtomicPerms :: Lens' (ValuePerm a) [AtomicPerm a]
<span class="lineno"> 5853 </span><span class="decl"><span class="nottickedoff">conjAtomicPerms =</span>
<span class="lineno"> 5854 </span><span class="spaces">  </span><span class="nottickedoff">lens</span>
<span class="lineno"> 5855 </span><span class="spaces">  </span><span class="nottickedoff">(\p -&gt; case p of</span>
<span class="lineno"> 5856 </span><span class="spaces">      </span><span class="nottickedoff">ValPerm_Conj ps -&gt; ps</span>
<span class="lineno"> 5857 </span><span class="spaces">      </span><span class="nottickedoff">_ -&gt; error &quot;conjAtomicPerms: not a conjuction of atomic permissions&quot;)</span>
<span class="lineno"> 5858 </span><span class="spaces">  </span><span class="nottickedoff">(\p ps -&gt;</span>
<span class="lineno"> 5859 </span><span class="spaces">    </span><span class="nottickedoff">case p of</span>
<span class="lineno"> 5860 </span><span class="spaces">      </span><span class="nottickedoff">ValPerm_Conj _ -&gt; ValPerm_Conj ps</span>
<span class="lineno"> 5861 </span><span class="spaces">      </span><span class="nottickedoff">_ -&gt; error &quot;conjAtomicPerms: not a conjuction of atomic permissions&quot;)</span></span>
<span class="lineno"> 5862 </span>
<span class="lineno"> 5863 </span>-- | Lens for the @i@th atomic permission in a 'ValPerm_Conj'; it is an error to
<span class="lineno"> 5864 </span>-- use this lens with a value permission not of this form
<span class="lineno"> 5865 </span>conjAtomicPerm :: Int -&gt; Lens' (ValuePerm a) (AtomicPerm a)
<span class="lineno"> 5866 </span><span class="decl"><span class="nottickedoff">conjAtomicPerm i =</span>
<span class="lineno"> 5867 </span><span class="spaces">  </span><span class="nottickedoff">lens</span>
<span class="lineno"> 5868 </span><span class="spaces">  </span><span class="nottickedoff">(\p -&gt; if i &gt;= length (p ^. conjAtomicPerms) then</span>
<span class="lineno"> 5869 </span><span class="spaces">           </span><span class="nottickedoff">error &quot;conjAtomicPerm: index out of bounds&quot;</span>
<span class="lineno"> 5870 </span><span class="spaces">         </span><span class="nottickedoff">else (p ^. conjAtomicPerms) !! i)</span>
<span class="lineno"> 5871 </span><span class="spaces">  </span><span class="nottickedoff">(\p pp -&gt;</span>
<span class="lineno"> 5872 </span><span class="spaces">    </span><span class="nottickedoff">-- FIXME: there has got to be a nicer, more lens-like way to do this</span>
<span class="lineno"> 5873 </span><span class="spaces">    </span><span class="nottickedoff">let pps = p ^. conjAtomicPerms in</span>
<span class="lineno"> 5874 </span><span class="spaces">    </span><span class="nottickedoff">if i &gt;= length pps then</span>
<span class="lineno"> 5875 </span><span class="spaces">      </span><span class="nottickedoff">error &quot;conjAtomicPerm: index out of bounds&quot;</span>
<span class="lineno"> 5876 </span><span class="spaces">    </span><span class="nottickedoff">else set conjAtomicPerms (take i pps ++ (pp : drop (i+1) pps)) p)</span></span>
<span class="lineno"> 5877 </span>
<span class="lineno"> 5878 </span>-- | Add a new atomic permission to the end of the list of those contained in
<span class="lineno"> 5879 </span>-- the 'conjAtomicPerms' of a permission
<span class="lineno"> 5880 </span>addAtomicPerm :: AtomicPerm a -&gt; ValuePerm a -&gt; ValuePerm a
<span class="lineno"> 5881 </span><span class="decl"><span class="nottickedoff">addAtomicPerm pp = over conjAtomicPerms (++ [pp])</span></span>
<span class="lineno"> 5882 </span>
<span class="lineno"> 5883 </span>-- | Delete the atomic permission at the given index from the list of those
<span class="lineno"> 5884 </span>-- contained in the 'conjAtomicPerms' of a permission
<span class="lineno"> 5885 </span>deleteAtomicPerm :: Int -&gt; ValuePerm a -&gt; ValuePerm a
<span class="lineno"> 5886 </span><span class="decl"><span class="nottickedoff">deleteAtomicPerm i =</span>
<span class="lineno"> 5887 </span><span class="spaces">  </span><span class="nottickedoff">over conjAtomicPerms (\pps -&gt;</span>
<span class="lineno"> 5888 </span><span class="spaces">                         </span><span class="nottickedoff">if i &gt;= length pps then</span>
<span class="lineno"> 5889 </span><span class="spaces">                           </span><span class="nottickedoff">error &quot;deleteAtomicPerm: index out of bounds&quot;</span>
<span class="lineno"> 5890 </span><span class="spaces">                         </span><span class="nottickedoff">else take i pps ++ drop (i+1) pps)</span></span>
<span class="lineno"> 5891 </span>
<span class="lineno"> 5892 </span>-- | Lens for the LLVM pointer permissions in a 'ValPerm_Conj'; it is an error
<span class="lineno"> 5893 </span>-- to use this lens with a value permission not of this form
<span class="lineno"> 5894 </span>llvmPtrPerms :: Lens' (ValuePerm (LLVMPointerType w)) [LLVMPtrPerm w]
<span class="lineno"> 5895 </span><span class="decl"><span class="nottickedoff">llvmPtrPerms = conjAtomicPerms</span></span>
<span class="lineno"> 5896 </span>
<span class="lineno"> 5897 </span>-- | Lens for the @i@th LLVM pointer permission of a 'ValPerm_Conj'
<span class="lineno"> 5898 </span>llvmPtrPerm :: Int -&gt; Lens' (ValuePerm (LLVMPointerType w)) (LLVMPtrPerm w)
<span class="lineno"> 5899 </span><span class="decl"><span class="nottickedoff">llvmPtrPerm = conjAtomicPerm</span></span>
<span class="lineno"> 5900 </span>
<span class="lineno"> 5901 </span>-- | Add a new 'LLVMPtrPerm' to the end of the list of those contained in the
<span class="lineno"> 5902 </span>-- 'llvmPtrPerms' of a permission
<span class="lineno"> 5903 </span>addLLVMPtrPerm :: LLVMPtrPerm w -&gt; ValuePerm (LLVMPointerType w) -&gt;
<span class="lineno"> 5904 </span>                  ValuePerm (LLVMPointerType w)
<span class="lineno"> 5905 </span><span class="decl"><span class="nottickedoff">addLLVMPtrPerm pp = over llvmPtrPerms (++ [pp])</span></span>
<span class="lineno"> 5906 </span>
<span class="lineno"> 5907 </span>-- | Delete the 'LLVMPtrPerm' at the given index from the list of those
<span class="lineno"> 5908 </span>-- contained in the 'llvmPtrPerms' of a permission
<span class="lineno"> 5909 </span>deleteLLVMPtrPerm :: Int -&gt; ValuePerm (LLVMPointerType w) -&gt;
<span class="lineno"> 5910 </span>                     ValuePerm (LLVMPointerType w)
<span class="lineno"> 5911 </span><span class="decl"><span class="nottickedoff">deleteLLVMPtrPerm i =</span>
<span class="lineno"> 5912 </span><span class="spaces">  </span><span class="nottickedoff">over llvmPtrPerms (\pps -&gt;</span>
<span class="lineno"> 5913 </span><span class="spaces">                      </span><span class="nottickedoff">if i &gt;= length pps then</span>
<span class="lineno"> 5914 </span><span class="spaces">                        </span><span class="nottickedoff">error &quot;deleteLLVMPtrPerm: index out of bounds&quot;</span>
<span class="lineno"> 5915 </span><span class="spaces">                      </span><span class="nottickedoff">else take i pps ++ drop (i+1) pps)</span></span>
<span class="lineno"> 5916 </span>
<span class="lineno"> 5917 </span>-- | Return the index of the last 'LLVMPtrPerm' of a permission
<span class="lineno"> 5918 </span>lastLLVMPtrPermIndex :: ValuePerm (LLVMPointerType w) -&gt; Int
<span class="lineno"> 5919 </span><span class="decl"><span class="nottickedoff">lastLLVMPtrPermIndex p =</span>
<span class="lineno"> 5920 </span><span class="spaces">  </span><span class="nottickedoff">let len = length (p ^. llvmPtrPerms) in</span>
<span class="lineno"> 5921 </span><span class="spaces">  </span><span class="nottickedoff">if len &gt; 0 then len - 1 else error &quot;lastLLVMPtrPerms: no pointer perms!&quot;</span></span>
<span class="lineno"> 5922 </span>
<span class="lineno"> 5923 </span>-- | Create a list of pointer permissions needed in order to deallocate a frame
<span class="lineno"> 5924 </span>-- that has the given frame permissions. It is an error if any of the required
<span class="lineno"> 5925 </span>-- permissions are for LLVM words instead of pointers.
<span class="lineno"> 5926 </span>llvmFrameDeletionPerms :: (1 &lt;= w, KnownNat w) =&gt; LLVMFramePerm w -&gt;
<span class="lineno"> 5927 </span>                          Some DistPerms
<span class="lineno"> 5928 </span><span class="decl"><span class="nottickedoff">llvmFrameDeletionPerms [] = Some DistPermsNil</span>
<span class="lineno"> 5929 </span><span class="spaces"></span><span class="nottickedoff">llvmFrameDeletionPerms ((asLLVMOffset -&gt; Just (x,_off), sz):fperm')</span>
<span class="lineno"> 5930 </span><span class="spaces">  </span><span class="nottickedoff">| Some del_perms &lt;- llvmFrameDeletionPerms fperm' =</span>
<span class="lineno"> 5931 </span><span class="spaces">    </span><span class="nottickedoff">Some $ DistPermsCons del_perms x $ llvmBlockPermOfSize sz</span>
<span class="lineno"> 5932 </span><span class="spaces"></span><span class="nottickedoff">llvmFrameDeletionPerms _ =</span>
<span class="lineno"> 5933 </span><span class="spaces">  </span><span class="nottickedoff">error &quot;llvmFrameDeletionPerms: unexpected LLVM word allocated in frame&quot;</span></span>
<span class="lineno"> 5934 </span>
<span class="lineno"> 5935 </span>-- | Build a 'DistPerms' with just one permission
<span class="lineno"> 5936 </span>distPerms1 :: ExprVar a -&gt; ValuePerm a -&gt; DistPerms (RNil :&gt; a)
<span class="lineno"> 5937 </span><span class="decl"><span class="nottickedoff">distPerms1 x p = DistPermsCons DistPermsNil x p</span></span>
<span class="lineno"> 5938 </span>
<span class="lineno"> 5939 </span>-- | Build a 'DistPerms' with two permissions
<span class="lineno"> 5940 </span>distPerms2 :: ExprVar a1 -&gt; ValuePerm a1 -&gt;
<span class="lineno"> 5941 </span>              ExprVar a2 -&gt; ValuePerm a2 -&gt; DistPerms (RNil :&gt; a1 :&gt; a2)
<span class="lineno"> 5942 </span><span class="decl"><span class="nottickedoff">distPerms2 x1 p1 x2 p2 = DistPermsCons (distPerms1 x1 p1) x2 p2</span></span>
<span class="lineno"> 5943 </span>
<span class="lineno"> 5944 </span>-- | Build a 'DistPerms' with three permissions
<span class="lineno"> 5945 </span>distPerms3 :: ExprVar a1 -&gt; ValuePerm a1 -&gt; ExprVar a2 -&gt; ValuePerm a2 -&gt;
<span class="lineno"> 5946 </span>              ExprVar a3 -&gt; ValuePerm a3 -&gt; DistPerms (RNil :&gt; a1 :&gt; a2 :&gt; a3)
<span class="lineno"> 5947 </span><span class="decl"><span class="nottickedoff">distPerms3 x1 p1 x2 p2 x3 p3 = DistPermsCons (distPerms2 x1 p1 x2 p2) x3 p3</span></span>
<span class="lineno"> 5948 </span>
<span class="lineno"> 5949 </span>-- | Get the first permission in a 'DistPerms'
<span class="lineno"> 5950 </span>distPermsHeadPerm :: DistPerms (ps :&gt; a) -&gt; ValuePerm a
<span class="lineno"> 5951 </span><span class="decl"><span class="nottickedoff">distPermsHeadPerm (DistPermsCons _ _ p) = p</span></span>
<span class="lineno"> 5952 </span>
<span class="lineno"> 5953 </span>-- | Drop the last permission in a 'DistPerms'
<span class="lineno"> 5954 </span>distPermsSnoc :: DistPerms (ps :&gt; a) -&gt; DistPerms ps
<span class="lineno"> 5955 </span><span class="decl"><span class="nottickedoff">distPermsSnoc (DistPermsCons ps _ _) = ps</span></span>
<span class="lineno"> 5956 </span>
<span class="lineno"> 5957 </span>-- | Map a function on permissions across a 'DistPerms'
<span class="lineno"> 5958 </span>mapDistPerms :: (forall a. ValuePerm a -&gt; ValuePerm a) -&gt;
<span class="lineno"> 5959 </span>                DistPerms ps -&gt; DistPerms ps
<span class="lineno"> 5960 </span><span class="decl"><span class="nottickedoff">mapDistPerms _ DistPermsNil = DistPermsNil</span>
<span class="lineno"> 5961 </span><span class="spaces"></span><span class="nottickedoff">mapDistPerms f (DistPermsCons perms x p) =</span>
<span class="lineno"> 5962 </span><span class="spaces">  </span><span class="nottickedoff">DistPermsCons (mapDistPerms f perms) x (f p)</span></span>
<span class="lineno"> 5963 </span>
<span class="lineno"> 5964 </span>
<span class="lineno"> 5965 </span>-- | Create a sequence of @true@ permissions
<span class="lineno"> 5966 </span>trueValuePerms :: RAssign any ps -&gt; ValuePerms ps
<span class="lineno"> 5967 </span><span class="decl"><span class="nottickedoff">trueValuePerms MNil = ValPerms_Nil</span>
<span class="lineno"> 5968 </span><span class="spaces"></span><span class="nottickedoff">trueValuePerms (ps :&gt;: _) = ValPerms_Cons (trueValuePerms ps) ValPerm_True</span></span>
<span class="lineno"> 5969 </span>
<span class="lineno"> 5970 </span>-- | Create a list of @eq(xi)@ permissions from a list of variables @x1,x2,...@
<span class="lineno"> 5971 </span>eqValuePerms :: RAssign Name ps -&gt; ValuePerms ps
<span class="lineno"> 5972 </span><span class="decl"><span class="nottickedoff">eqValuePerms MNil = ValPerms_Nil</span>
<span class="lineno"> 5973 </span><span class="spaces"></span><span class="nottickedoff">eqValuePerms (xs :&gt;: x) =</span>
<span class="lineno"> 5974 </span><span class="spaces">  </span><span class="nottickedoff">ValPerms_Cons (eqValuePerms xs) (ValPerm_Eq (PExpr_Var x))</span></span>
<span class="lineno"> 5975 </span>
<span class="lineno"> 5976 </span>-- | Append two lists of permissions
<span class="lineno"> 5977 </span>appendValuePerms :: ValuePerms ps1 -&gt; ValuePerms ps2 -&gt; ValuePerms (ps1 :++: ps2)
<span class="lineno"> 5978 </span><span class="decl"><span class="nottickedoff">appendValuePerms ps1 ValPerms_Nil = ps1</span>
<span class="lineno"> 5979 </span><span class="spaces"></span><span class="nottickedoff">appendValuePerms ps1 (ValPerms_Cons ps2 p) =</span>
<span class="lineno"> 5980 </span><span class="spaces">  </span><span class="nottickedoff">ValPerms_Cons (appendValuePerms ps1 ps2) p</span></span>
<span class="lineno"> 5981 </span>
<span class="lineno"> 5982 </span>distPermsToProxies :: DistPerms ps -&gt; RAssign Proxy ps
<span class="lineno"> 5983 </span><span class="decl"><span class="nottickedoff">distPermsToProxies (DistPermsNil) = MNil</span>
<span class="lineno"> 5984 </span><span class="spaces"></span><span class="nottickedoff">distPermsToProxies (DistPermsCons ps _ _) = distPermsToProxies ps :&gt;: Proxy</span></span>
<span class="lineno"> 5985 </span>
<span class="lineno"> 5986 </span>mbDistPermsToProxies :: Mb ctx (DistPerms ps) -&gt; RAssign Proxy ps
<span class="lineno"> 5987 </span><span class="decl"><span class="nottickedoff">mbDistPermsToProxies mb_ps = case mbMatch mb_ps of</span>
<span class="lineno"> 5988 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| DistPermsNil |] -&gt; MNil</span>
<span class="lineno"> 5989 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| DistPermsCons ps _ _ |] -&gt;</span>
<span class="lineno"> 5990 </span><span class="spaces">    </span><span class="nottickedoff">mbDistPermsToProxies ps :&gt;: Proxy</span></span>
<span class="lineno"> 5991 </span>
<span class="lineno"> 5992 </span>-- | Extract the variables in a 'DistPerms'
<span class="lineno"> 5993 </span>distPermsVars :: DistPerms ps -&gt; RAssign Name ps
<span class="lineno"> 5994 </span><span class="decl"><span class="nottickedoff">distPermsVars DistPermsNil = MNil</span>
<span class="lineno"> 5995 </span><span class="spaces"></span><span class="nottickedoff">distPermsVars (DistPermsCons ps x _) = distPermsVars ps :&gt;: x</span></span>
<span class="lineno"> 5996 </span>
<span class="lineno"> 5997 </span>-- | Extract the non-bound variables in a 'DistPerms' in context
<span class="lineno"> 5998 </span>mbDistPermsVars :: Mb ctx (DistPerms ps) -&gt; [Some ExprVar]
<span class="lineno"> 5999 </span><span class="decl"><span class="nottickedoff">mbDistPermsVars =</span>
<span class="lineno"> 6000 </span><span class="spaces">  </span><span class="nottickedoff">concat . RL.mapToList (\case</span>
<span class="lineno"> 6001 </span><span class="spaces">                            </span><span class="nottickedoff">Compose [nuP| VarAndPerm mb_n _ |]</span>
<span class="lineno"> 6002 </span><span class="spaces">                              </span><span class="nottickedoff">| Right n &lt;- mbNameBoundP mb_n -&gt; [Some n]</span>
<span class="lineno"> 6003 </span><span class="spaces">                            </span><span class="nottickedoff">_ -&gt; []) . mbRAssign</span></span>
<span class="lineno"> 6004 </span>
<span class="lineno"> 6005 </span>-- | Append two lists of distinguished permissions
<span class="lineno"> 6006 </span>appendDistPerms :: DistPerms ps1 -&gt; DistPerms ps2 -&gt; DistPerms (ps1 :++: ps2)
<span class="lineno"> 6007 </span><span class="decl"><span class="nottickedoff">appendDistPerms ps1 DistPermsNil = ps1</span>
<span class="lineno"> 6008 </span><span class="spaces"></span><span class="nottickedoff">appendDistPerms ps1 (DistPermsCons ps2 x p) =</span>
<span class="lineno"> 6009 </span><span class="spaces">  </span><span class="nottickedoff">DistPermsCons (appendDistPerms ps1 ps2) x p</span></span>
<span class="lineno"> 6010 </span>
<span class="lineno"> 6011 </span>-- | Filter a list of distinguished permissions using a predicate
<span class="lineno"> 6012 </span>filterDistPerms :: (forall a. Name a -&gt; ValuePerm a -&gt; Bool) -&gt;
<span class="lineno"> 6013 </span>                   DistPerms ps -&gt; Some DistPerms
<span class="lineno"> 6014 </span><span class="decl"><span class="nottickedoff">filterDistPerms _ DistPermsNil = Some DistPermsNil</span>
<span class="lineno"> 6015 </span><span class="spaces"></span><span class="nottickedoff">filterDistPerms pred (DistPermsCons ps x p)</span>
<span class="lineno"> 6016 </span><span class="spaces">  </span><span class="nottickedoff">| pred x p</span>
<span class="lineno"> 6017 </span><span class="spaces">  </span><span class="nottickedoff">, Some ps' &lt;- filterDistPerms pred ps = Some (DistPermsCons ps' x p)</span>
<span class="lineno"> 6018 </span><span class="spaces"></span><span class="nottickedoff">filterDistPerms pred (DistPermsCons ps _ _) = filterDistPerms pred ps</span></span>
<span class="lineno"> 6019 </span>
<span class="lineno"> 6020 </span>-- | Build a list of distinguished permissions from a list of variables
<span class="lineno"> 6021 </span>buildDistPerms :: (forall a. Name a -&gt; ValuePerm a) -&gt; RAssign Name ps -&gt;
<span class="lineno"> 6022 </span>                  DistPerms ps
<span class="lineno"> 6023 </span><span class="decl"><span class="nottickedoff">buildDistPerms _ MNil = DistPermsNil</span>
<span class="lineno"> 6024 </span><span class="spaces"></span><span class="nottickedoff">buildDistPerms f (ns :&gt;: n) = DistPermsCons (buildDistPerms f ns) n (f n)</span></span>
<span class="lineno"> 6025 </span>
<span class="lineno"> 6026 </span>-- | Split a list of distinguished permissions into two
<span class="lineno"> 6027 </span>splitDistPerms :: f ps1 -&gt; RAssign g ps2 -&gt; DistPerms (ps1 :++: ps2) -&gt;
<span class="lineno"> 6028 </span>                  (DistPerms ps1, DistPerms ps2)
<span class="lineno"> 6029 </span><span class="decl"><span class="nottickedoff">splitDistPerms _ = helper where</span>
<span class="lineno"> 6030 </span><span class="spaces">  </span><span class="nottickedoff">helper :: RAssign g ps2 -&gt; DistPerms (ps1 :++: ps2) -&gt;</span>
<span class="lineno"> 6031 </span><span class="spaces">            </span><span class="nottickedoff">(DistPerms ps1, DistPerms ps2)</span>
<span class="lineno"> 6032 </span><span class="spaces">  </span><span class="nottickedoff">helper MNil perms = (perms, DistPermsNil)</span>
<span class="lineno"> 6033 </span><span class="spaces">  </span><span class="nottickedoff">helper (prxs :&gt;: _) (DistPermsCons ps x p) =</span>
<span class="lineno"> 6034 </span><span class="spaces">    </span><span class="nottickedoff">let (perms1, perms2) = helper prxs ps in</span>
<span class="lineno"> 6035 </span><span class="spaces">    </span><span class="nottickedoff">(perms1, DistPermsCons perms2 x p)</span></span>
<span class="lineno"> 6036 </span>
<span class="lineno"> 6037 </span>-- | Split a list of value permissions in bindings into two
<span class="lineno"> 6038 </span>splitMbValuePerms :: f ps1 -&gt; RAssign g ps2 -&gt;
<span class="lineno"> 6039 </span>                     Mb vars (ValuePerms (ps1 :++: ps2)) -&gt;
<span class="lineno"> 6040 </span>                     (Mb vars (ValuePerms ps1), Mb vars (ValuePerms ps2))
<span class="lineno"> 6041 </span><span class="decl"><span class="nottickedoff">splitMbValuePerms _ MNil mb_perms =</span>
<span class="lineno"> 6042 </span><span class="spaces">  </span><span class="nottickedoff">(mb_perms, fmap (const ValPerms_Nil) mb_perms)</span>
<span class="lineno"> 6043 </span><span class="spaces"></span><span class="nottickedoff">splitMbValuePerms prx (ps2 :&gt;: _) (mbMatch -&gt; [nuMP| ValPerms_Cons mb_perms p |]) =</span>
<span class="lineno"> 6044 </span><span class="spaces">  </span><span class="nottickedoff">let (ret1, ret2) = splitMbValuePerms prx ps2 mb_perms in</span>
<span class="lineno"> 6045 </span><span class="spaces">  </span><span class="nottickedoff">(ret1, mbMap2 ValPerms_Cons ret2 p)</span></span>
<span class="lineno"> 6046 </span>
<span class="lineno"> 6047 </span>-- | Lens for the top permission in a 'DistPerms' stack
<span class="lineno"> 6048 </span>distPermsHead :: ExprVar a -&gt; Lens' (DistPerms (ps :&gt; a)) (ValuePerm a)
<span class="lineno"> 6049 </span><span class="decl"><span class="nottickedoff">distPermsHead x =</span>
<span class="lineno"> 6050 </span><span class="spaces">  </span><span class="nottickedoff">lens (\(DistPermsCons _ y p) -&gt;</span>
<span class="lineno"> 6051 </span><span class="spaces">         </span><span class="nottickedoff">if x == y then p else error &quot;distPermsHead: incorrect variable name!&quot;)</span>
<span class="lineno"> 6052 </span><span class="spaces">  </span><span class="nottickedoff">(\(DistPermsCons pstk y _) p -&gt;</span>
<span class="lineno"> 6053 </span><span class="spaces">    </span><span class="nottickedoff">if x == y then DistPermsCons pstk y p else</span>
<span class="lineno"> 6054 </span><span class="spaces">      </span><span class="nottickedoff">error &quot;distPermsHead: incorrect variable name!&quot;)</span></span>
<span class="lineno"> 6055 </span>
<span class="lineno"> 6056 </span>-- | The lens for the tail of a 'DistPerms' stack
<span class="lineno"> 6057 </span>distPermsTail :: Lens' (DistPerms (ps :&gt; a)) (DistPerms ps)
<span class="lineno"> 6058 </span><span class="decl"><span class="nottickedoff">distPermsTail =</span>
<span class="lineno"> 6059 </span><span class="spaces">  </span><span class="nottickedoff">lens (\(DistPermsCons pstk _ _) -&gt; pstk)</span>
<span class="lineno"> 6060 </span><span class="spaces">  </span><span class="nottickedoff">(\(DistPermsCons _ x p) pstk -&gt; DistPermsCons pstk x p)</span></span>
<span class="lineno"> 6061 </span>
<span class="lineno"> 6062 </span>-- | The lens for the nth permission in a 'DistPerms' stack
<span class="lineno"> 6063 </span>nthVarPerm :: Member ps a -&gt; ExprVar a -&gt; Lens' (DistPerms ps) (ValuePerm a)
<span class="lineno"> 6064 </span><span class="decl"><span class="nottickedoff">nthVarPerm Member_Base x = distPermsHead x</span>
<span class="lineno"> 6065 </span><span class="spaces"></span><span class="nottickedoff">nthVarPerm (Member_Step memb') x = distPermsTail . nthVarPerm memb' x</span></span>
<span class="lineno"> 6066 </span>
<span class="lineno"> 6067 </span>-- | Test if a permission can be copied, i.e., whether @p -o p*p@. This is true
<span class="lineno"> 6068 </span>-- iff @p@ does not contain any 'Write' modalities, any frame permissions, or
<span class="lineno"> 6069 </span>-- any lifetime ownership permissions. Note that this must be true for all
<span class="lineno"> 6070 </span>-- substitutions of free (permission or expression) variables, so free variables
<span class="lineno"> 6071 </span>-- can make a permission not copyable as well.
<span class="lineno"> 6072 </span>permIsCopyable :: ValuePerm a -&gt; Bool
<span class="lineno"> 6073 </span><span class="decl"><span class="nottickedoff">permIsCopyable (ValPerm_Eq _) = True</span>
<span class="lineno"> 6074 </span><span class="spaces"></span><span class="nottickedoff">permIsCopyable (ValPerm_Or p1 p2) = permIsCopyable p1 &amp;&amp; permIsCopyable p2</span>
<span class="lineno"> 6075 </span><span class="spaces"></span><span class="nottickedoff">permIsCopyable (ValPerm_Exists mb_p) = mbLift $ fmap permIsCopyable mb_p</span>
<span class="lineno"> 6076 </span><span class="spaces"></span><span class="nottickedoff">permIsCopyable (ValPerm_Named npn args _offset) =</span>
<span class="lineno"> 6077 </span><span class="spaces">  </span><span class="nottickedoff">-- FIXME: this is wrong. For transparent perms, should make this just unfold</span>
<span class="lineno"> 6078 </span><span class="spaces">  </span><span class="nottickedoff">-- the definition; for opaque perms, look at arguments. For recursive perms,</span>
<span class="lineno"> 6079 </span><span class="spaces">  </span><span class="nottickedoff">-- unfold and assume the recursive call is copyable, then see if the unfolded</span>
<span class="lineno"> 6080 </span><span class="spaces">  </span><span class="nottickedoff">-- version is still copyable</span>
<span class="lineno"> 6081 </span><span class="spaces">  </span><span class="nottickedoff">namedPermArgsAreCopyable (namedPermNameArgs npn) args</span>
<span class="lineno"> 6082 </span><span class="spaces"></span><span class="nottickedoff">permIsCopyable (ValPerm_Var _ _) = False</span>
<span class="lineno"> 6083 </span><span class="spaces"></span><span class="nottickedoff">permIsCopyable (ValPerm_Conj ps) = all atomicPermIsCopyable ps</span>
<span class="lineno"> 6084 </span><span class="spaces"></span><span class="nottickedoff">permIsCopyable ValPerm_False = True</span></span>
<span class="lineno"> 6085 </span>
<span class="lineno"> 6086 </span>-- | The same as 'permIsCopyable' except for atomic permissions
<span class="lineno"> 6087 </span>atomicPermIsCopyable :: AtomicPerm a -&gt; Bool
<span class="lineno"> 6088 </span><span class="decl"><span class="nottickedoff">atomicPermIsCopyable (Perm_LLVMField</span>
<span class="lineno"> 6089 </span><span class="spaces">                      </span><span class="nottickedoff">(LLVMFieldPerm { llvmFieldRW = PExpr_Read,</span>
<span class="lineno"> 6090 </span><span class="spaces">                                       </span><span class="nottickedoff">llvmFieldContents = p })) =</span>
<span class="lineno"> 6091 </span><span class="spaces">  </span><span class="nottickedoff">permIsCopyable p</span>
<span class="lineno"> 6092 </span><span class="spaces"></span><span class="nottickedoff">atomicPermIsCopyable (Perm_LLVMField _) = False</span>
<span class="lineno"> 6093 </span><span class="spaces"></span><span class="nottickedoff">atomicPermIsCopyable (Perm_LLVMArray (LLVMArrayPerm {..})) =</span>
<span class="lineno"> 6094 </span><span class="spaces">  </span><span class="nottickedoff">llvmArrayRW == PExpr_Read &amp;&amp; shapeIsCopyable llvmArrayRW llvmArrayCellShape</span>
<span class="lineno"> 6095 </span><span class="spaces"></span><span class="nottickedoff">atomicPermIsCopyable (Perm_LLVMBlock (LLVMBlockPerm {..})) =</span>
<span class="lineno"> 6096 </span><span class="spaces">  </span><span class="nottickedoff">llvmBlockRW == PExpr_Read &amp;&amp; shapeIsCopyable llvmBlockRW llvmBlockShape</span>
<span class="lineno"> 6097 </span><span class="spaces"></span><span class="nottickedoff">atomicPermIsCopyable (Perm_LLVMFree _) = True</span>
<span class="lineno"> 6098 </span><span class="spaces"></span><span class="nottickedoff">atomicPermIsCopyable (Perm_LLVMFunPtr _ _) = True</span>
<span class="lineno"> 6099 </span><span class="spaces"></span><span class="nottickedoff">atomicPermIsCopyable Perm_IsLLVMPtr = True</span>
<span class="lineno"> 6100 </span><span class="spaces"></span><span class="nottickedoff">atomicPermIsCopyable (Perm_LLVMBlockShape sh) = shapeIsCopyable PExpr_Write sh</span>
<span class="lineno"> 6101 </span><span class="spaces"></span><span class="nottickedoff">atomicPermIsCopyable (Perm_LLVMFrame _) = False</span>
<span class="lineno"> 6102 </span><span class="spaces"></span><span class="nottickedoff">atomicPermIsCopyable (Perm_LOwned _ _ _ _ _) = False</span>
<span class="lineno"> 6103 </span><span class="spaces"></span><span class="nottickedoff">atomicPermIsCopyable (Perm_LOwnedSimple _ _) = False</span>
<span class="lineno"> 6104 </span><span class="spaces"></span><span class="nottickedoff">atomicPermIsCopyable (Perm_LCurrent _) = True</span>
<span class="lineno"> 6105 </span><span class="spaces"></span><span class="nottickedoff">atomicPermIsCopyable Perm_LFinished = True</span>
<span class="lineno"> 6106 </span><span class="spaces"></span><span class="nottickedoff">atomicPermIsCopyable (Perm_Struct ps) = and $ RL.mapToList permIsCopyable ps</span>
<span class="lineno"> 6107 </span><span class="spaces"></span><span class="nottickedoff">atomicPermIsCopyable (Perm_Fun _) = True</span>
<span class="lineno"> 6108 </span><span class="spaces"></span><span class="nottickedoff">atomicPermIsCopyable (Perm_BVProp _) = True</span>
<span class="lineno"> 6109 </span><span class="spaces"></span><span class="nottickedoff">atomicPermIsCopyable Perm_Any = True</span>
<span class="lineno"> 6110 </span><span class="spaces"></span><span class="nottickedoff">atomicPermIsCopyable (Perm_NamedConj n args _) =</span>
<span class="lineno"> 6111 </span><span class="spaces">  </span><span class="nottickedoff">namedPermArgsAreCopyable (namedPermNameArgs n) args</span></span>
<span class="lineno"> 6112 </span>
<span class="lineno"> 6113 </span>-- | 'permIsCopyable' for the arguments of a named permission
<span class="lineno"> 6114 </span>namedPermArgIsCopyable :: TypeRepr a -&gt; PermExpr a -&gt; Bool
<span class="lineno"> 6115 </span><span class="decl"><span class="nottickedoff">namedPermArgIsCopyable RWModalityRepr PExpr_Read = True</span>
<span class="lineno"> 6116 </span><span class="spaces"></span><span class="nottickedoff">namedPermArgIsCopyable RWModalityRepr _ = False</span>
<span class="lineno"> 6117 </span><span class="spaces"></span><span class="nottickedoff">namedPermArgIsCopyable (ValuePermRepr _) (PExpr_ValPerm p) = permIsCopyable p</span>
<span class="lineno"> 6118 </span><span class="spaces"></span><span class="nottickedoff">namedPermArgIsCopyable (ValuePermRepr _) (PExpr_Var _) = False</span>
<span class="lineno"> 6119 </span><span class="spaces"></span><span class="nottickedoff">namedPermArgIsCopyable _ _ = True</span></span>
<span class="lineno"> 6120 </span>
<span class="lineno"> 6121 </span>-- | 'permIsCopyable' for an argument of a named permission
<span class="lineno"> 6122 </span>namedPermArgsAreCopyable :: CruCtx args -&gt; PermExprs args -&gt; Bool
<span class="lineno"> 6123 </span><span class="decl"><span class="nottickedoff">namedPermArgsAreCopyable CruCtxNil PExprs_Nil = True</span>
<span class="lineno"> 6124 </span><span class="spaces"></span><span class="nottickedoff">namedPermArgsAreCopyable (CruCtxCons tps tp) (PExprs_Cons args arg) =</span>
<span class="lineno"> 6125 </span><span class="spaces">  </span><span class="nottickedoff">namedPermArgsAreCopyable tps args &amp;&amp; namedPermArgIsCopyable tp arg</span></span>
<span class="lineno"> 6126 </span>
<span class="lineno"> 6127 </span>-- | Test if an LLVM shape corresponds to a copyable permission relative to the
<span class="lineno"> 6128 </span>-- given read/write modality
<span class="lineno"> 6129 </span>shapeIsCopyable :: PermExpr RWModalityType -&gt; PermExpr (LLVMShapeType w) -&gt; Bool
<span class="lineno"> 6130 </span><span class="decl"><span class="nottickedoff">shapeIsCopyable _ (PExpr_Var _) = False</span>
<span class="lineno"> 6131 </span><span class="spaces"></span><span class="nottickedoff">shapeIsCopyable _ PExpr_EmptyShape = True</span>
<span class="lineno"> 6132 </span><span class="spaces"></span><span class="nottickedoff">shapeIsCopyable rw (PExpr_NamedShape maybe_rw' _ nmsh args) =</span>
<span class="lineno"> 6133 </span><span class="spaces">  </span><span class="nottickedoff">case namedShapeBody nmsh of</span>
<span class="lineno"> 6134 </span><span class="spaces">    </span><span class="nottickedoff">DefinedShapeBody _ -&gt;</span>
<span class="lineno"> 6135 </span><span class="spaces">      </span><span class="nottickedoff">let rw' = maybe rw id maybe_rw' in</span>
<span class="lineno"> 6136 </span><span class="spaces">      </span><span class="nottickedoff">shapeIsCopyable rw' $ unfoldNamedShape nmsh args</span>
<span class="lineno"> 6137 </span><span class="spaces">    </span><span class="nottickedoff">-- NOTE: we are assuming that opaque shapes are copyable iff their args are</span>
<span class="lineno"> 6138 </span><span class="spaces">    </span><span class="nottickedoff">OpaqueShapeBody _ _ _ -&gt;</span>
<span class="lineno"> 6139 </span><span class="spaces">      </span><span class="nottickedoff">namedPermArgsAreCopyable (namedShapeArgs nmsh) args</span>
<span class="lineno"> 6140 </span><span class="spaces">    </span><span class="nottickedoff">-- HACK: the real computation we want to perform is to assume nmsh is copyable</span>
<span class="lineno"> 6141 </span><span class="spaces">    </span><span class="nottickedoff">-- and prove it is under that assumption; to accomplish this, we substitute</span>
<span class="lineno"> 6142 </span><span class="spaces">    </span><span class="nottickedoff">-- the empty shape for the recursive shape</span>
<span class="lineno"> 6143 </span><span class="spaces">    </span><span class="nottickedoff">RecShapeBody mb_sh _ _ -&gt;</span>
<span class="lineno"> 6144 </span><span class="spaces">      </span><span class="nottickedoff">shapeIsCopyable rw $ subst (substOfExprs (args :&gt;: PExpr_EmptyShape)) mb_sh</span>
<span class="lineno"> 6145 </span><span class="spaces"></span><span class="nottickedoff">shapeIsCopyable _ (PExpr_EqShape _ _) = True</span>
<span class="lineno"> 6146 </span><span class="spaces"></span><span class="nottickedoff">shapeIsCopyable rw (PExpr_PtrShape maybe_rw' _ sh) =</span>
<span class="lineno"> 6147 </span><span class="spaces">  </span><span class="nottickedoff">let rw' = maybe rw id maybe_rw' in</span>
<span class="lineno"> 6148 </span><span class="spaces">  </span><span class="nottickedoff">rw' == PExpr_Read &amp;&amp; shapeIsCopyable rw' sh</span>
<span class="lineno"> 6149 </span><span class="spaces"></span><span class="nottickedoff">shapeIsCopyable _ (PExpr_FieldShape (LLVMFieldShape p)) = permIsCopyable p</span>
<span class="lineno"> 6150 </span><span class="spaces"></span><span class="nottickedoff">shapeIsCopyable rw (PExpr_ArrayShape _ _ sh) = shapeIsCopyable rw sh</span>
<span class="lineno"> 6151 </span><span class="spaces"></span><span class="nottickedoff">shapeIsCopyable rw (PExpr_TupShape sh) = shapeIsCopyable rw sh</span>
<span class="lineno"> 6152 </span><span class="spaces"></span><span class="nottickedoff">shapeIsCopyable rw (PExpr_SeqShape sh1 sh2) =</span>
<span class="lineno"> 6153 </span><span class="spaces">  </span><span class="nottickedoff">shapeIsCopyable rw sh1 &amp;&amp; shapeIsCopyable rw sh2</span>
<span class="lineno"> 6154 </span><span class="spaces"></span><span class="nottickedoff">shapeIsCopyable rw (PExpr_OrShape sh1 sh2) =</span>
<span class="lineno"> 6155 </span><span class="spaces">  </span><span class="nottickedoff">shapeIsCopyable rw sh1 &amp;&amp; shapeIsCopyable rw sh2</span>
<span class="lineno"> 6156 </span><span class="spaces"></span><span class="nottickedoff">shapeIsCopyable rw (PExpr_ExShape mb_sh) =</span>
<span class="lineno"> 6157 </span><span class="spaces">  </span><span class="nottickedoff">mbLift $ fmap (shapeIsCopyable rw) mb_sh</span>
<span class="lineno"> 6158 </span><span class="spaces"></span><span class="nottickedoff">shapeIsCopyable _ PExpr_FalseShape = True</span></span>
<span class="lineno"> 6159 </span>
<span class="lineno"> 6160 </span>
<span class="lineno"> 6161 </span>-- | Get the lifetime children of a lifetime permission, returning the empty
<span class="lineno"> 6162 </span>-- list of children for a non-@lowned@ permission
<span class="lineno"> 6163 </span>lownedPermChildren :: ValuePerm LifetimeType -&gt; [PermExpr LifetimeType]
<span class="lineno"> 6164 </span><span class="decl"><span class="nottickedoff">lownedPermChildren (ValPerm_LOwned ls _ _ _ _) = ls</span>
<span class="lineno"> 6165 </span><span class="spaces"></span><span class="nottickedoff">lownedPermChildren _ = []</span></span>
<span class="lineno"> 6166 </span>
<span class="lineno"> 6167 </span>-- | Topologically sort a list of lifetimes with their ownership permissions so
<span class="lineno"> 6168 </span>-- that child lifetimes come before their parents
<span class="lineno"> 6169 </span>sortLOwnedPerms :: [(ExprVar LifetimeType, ValuePerm LifetimeType)] -&gt;
<span class="lineno"> 6170 </span>                   [(ExprVar LifetimeType, ValuePerm LifetimeType)]
<span class="lineno"> 6171 </span><span class="decl"><span class="nottickedoff">sortLOwnedPerms ls_ps =</span>
<span class="lineno"> 6172 </span><span class="spaces">  </span><span class="nottickedoff">evalState (concat &lt;$&gt; mapM visit ls_ps) NameSet.empty where</span>
<span class="lineno"> 6173 </span><span class="spaces">  </span><span class="nottickedoff">visit :: (ExprVar LifetimeType, ValuePerm LifetimeType) -&gt;</span>
<span class="lineno"> 6174 </span><span class="spaces">           </span><span class="nottickedoff">State (NameSet CrucibleType) [(ExprVar LifetimeType,</span>
<span class="lineno"> 6175 </span><span class="spaces">                                          </span><span class="nottickedoff">ValuePerm LifetimeType)]</span>
<span class="lineno"> 6176 </span><span class="spaces">  </span><span class="nottickedoff">visit (l, p) =</span>
<span class="lineno"> 6177 </span><span class="spaces">    </span><span class="nottickedoff">(NameSet.member l &lt;$&gt; get) &gt;&gt;= \case</span>
<span class="lineno"> 6178 </span><span class="spaces">    </span><span class="nottickedoff">True -&gt; return []</span>
<span class="lineno"> 6179 </span><span class="spaces">    </span><span class="nottickedoff">False -&gt;</span>
<span class="lineno"> 6180 </span><span class="spaces">      </span><span class="nottickedoff">do</span>
<span class="lineno"> 6181 </span><span class="spaces">        </span><span class="nottickedoff">-- Mark l as visited</span>
<span class="lineno"> 6182 </span><span class="spaces">        </span><span class="nottickedoff">modify (NameSet.insert l)</span>
<span class="lineno"> 6183 </span><span class="spaces">        </span><span class="nottickedoff">-- Find all children of (l,p) with a permission in the initial ls_ps</span>
<span class="lineno"> 6184 </span><span class="spaces">        </span><span class="nottickedoff">let ls_ps' =</span>
<span class="lineno"> 6185 </span><span class="spaces">              </span><span class="nottickedoff">mapMaybe (\case</span>
<span class="lineno"> 6186 </span><span class="spaces">                           </span><span class="nottickedoff">PExpr_Var l' -&gt; (l',) &lt;$&gt; lookup l' ls_ps</span>
<span class="lineno"> 6187 </span><span class="spaces">                           </span><span class="nottickedoff">_ -&gt; Nothing)</span>
<span class="lineno"> 6188 </span><span class="spaces">              </span><span class="nottickedoff">(lownedPermChildren p)</span>
<span class="lineno"> 6189 </span><span class="spaces">        </span><span class="nottickedoff">-- Visit all children of (l,p) and return any of them and their</span>
<span class="lineno"> 6190 </span><span class="spaces">        </span><span class="nottickedoff">-- recursive children that have not been visited yet</span>
<span class="lineno"> 6191 </span><span class="spaces">        </span><span class="nottickedoff">rec_ret &lt;- concat &lt;$&gt; mapM visit ls_ps'</span>
<span class="lineno"> 6192 </span><span class="spaces">        </span><span class="nottickedoff">-- Add (l,p) after all of its children</span>
<span class="lineno"> 6193 </span><span class="spaces">        </span><span class="nottickedoff">return (rec_ret ++ [(l,p)])</span></span>
<span class="lineno"> 6194 </span>
<span class="lineno"> 6195 </span>-- | Test if a list of permissions that might be in a lifetime ownership
<span class="lineno"> 6196 </span>-- permission (so not a lifetime permission) could help prove a permission on an
<span class="lineno"> 6197 </span>-- expression in a binding
<span class="lineno"> 6198 </span>lownedPermsCouldProve1 :: CruCtx ctx -&gt; ExprPerms ps_l -&gt;
<span class="lineno"> 6199 </span>                          Mb ctx (ExprAndPerm a) -&gt; Bool
<span class="lineno"> 6200 </span><span class="decl"><span class="nottickedoff">lownedPermsCouldProve1 ctx ps_l (mbMapCl $(mkClosed [| exprPermVarAndPerm |]) -&gt;</span>
<span class="lineno"> 6201 </span><span class="spaces">                                 </span><span class="nottickedoff">[nuP| Just (VarAndPerm mb_x mb_p) |])</span>
<span class="lineno"> 6202 </span><span class="spaces">  </span><span class="nottickedoff">| Right x &lt;- mbNameBoundP mb_x =</span>
<span class="lineno"> 6203 </span><span class="spaces">    </span><span class="nottickedoff">mbRangeFTsCouldCoverPart (concatMap getOffsets $ exprPermsForVar x ps_l) $</span>
<span class="lineno"> 6204 </span><span class="spaces">    </span><span class="nottickedoff">mbGetOffsets ctx mb_p</span>
<span class="lineno"> 6205 </span><span class="spaces"></span><span class="nottickedoff">lownedPermsCouldProve1 _ _ _ = False</span></span>
<span class="lineno"> 6206 </span>
<span class="lineno"> 6207 </span>-- | Test if a list of permissions that might be in a lifetime ownership
<span class="lineno"> 6208 </span>-- permission (so not a lifetime permission) could help prove any of a list of
<span class="lineno"> 6209 </span>-- permissions on expressions in a binding
<span class="lineno"> 6210 </span>lownedPermsCouldProve :: CruCtx ctx -&gt; ExprPerms ps_l -&gt;
<span class="lineno"> 6211 </span>                         Mb ctx (ExprPerms ps_r) -&gt; Bool
<span class="lineno"> 6212 </span><span class="decl"><span class="nottickedoff">lownedPermsCouldProve ctx lops =</span>
<span class="lineno"> 6213 </span><span class="spaces">  </span><span class="nottickedoff">or . RL.mapToList (lownedPermsCouldProve1 ctx lops . getCompose) . mbRAssign</span></span>
<span class="lineno"> 6214 </span>
<span class="lineno"> 6215 </span>-- | Find all lifetimes with ownership permissions in an 'ExprPerms'
<span class="lineno"> 6216 </span>lownedsInExprPerms :: ExprPerms ps -&gt; [ExprVar LifetimeType]
<span class="lineno"> 6217 </span><span class="decl"><span class="nottickedoff">lownedsInExprPerms =</span>
<span class="lineno"> 6218 </span><span class="spaces">  </span><span class="nottickedoff">catMaybes . RL.mapToList</span>
<span class="lineno"> 6219 </span><span class="spaces">  </span><span class="nottickedoff">(\case</span>
<span class="lineno"> 6220 </span><span class="spaces">      </span><span class="nottickedoff">ExprAndPerm (PExpr_Var l) (ValPerm_Conj ps)</span>
<span class="lineno"> 6221 </span><span class="spaces">        </span><span class="nottickedoff">| Refl:_ &lt;- mapMaybe isLifetimeOwnershipPerm ps -&gt; Just l</span>
<span class="lineno"> 6222 </span><span class="spaces">      </span><span class="nottickedoff">_ -&gt; Nothing)</span></span>
<span class="lineno"> 6223 </span>
<span class="lineno"> 6224 </span>-- | Find all lifetimes with ownership permissions in an 'ExprPerms' in binding
<span class="lineno"> 6225 </span>lownedsInMbExprPerms :: Mb (ctx :: RList CrucibleType) (ExprPerms ps) -&gt;
<span class="lineno"> 6226 </span>                        [ExprVar LifetimeType]
<span class="lineno"> 6227 </span><span class="decl"><span class="nottickedoff">lownedsInMbExprPerms mb_ps =</span>
<span class="lineno"> 6228 </span><span class="spaces">  </span><span class="nottickedoff">mapMaybe (\case</span>
<span class="lineno"> 6229 </span><span class="spaces">               </span><span class="nottickedoff">(mbNameBoundP -&gt; Right l) -&gt; Just l</span>
<span class="lineno"> 6230 </span><span class="spaces">               </span><span class="nottickedoff">_ -&gt; Nothing) $</span>
<span class="lineno"> 6231 </span><span class="spaces">  </span><span class="nottickedoff">mbList $ mbMapCl $(mkClosed [| lownedsInExprPerms |]) mb_ps</span></span>
<span class="lineno"> 6232 </span>
<span class="lineno"> 6233 </span>-- | Find all lifetimes with ownership permissions in a 'DistPerms' in binding
<span class="lineno"> 6234 </span>lownedsInMbDistPerms :: Mb ctx (DistPerms ps) -&gt; [ExprVar LifetimeType]
<span class="lineno"> 6235 </span><span class="decl"><span class="nottickedoff">lownedsInMbDistPerms =</span>
<span class="lineno"> 6236 </span><span class="spaces">  </span><span class="nottickedoff">catMaybes . RL.mapToList</span>
<span class="lineno"> 6237 </span><span class="spaces">  </span><span class="nottickedoff">(\case</span>
<span class="lineno"> 6238 </span><span class="spaces">      </span><span class="nottickedoff">Compose [nuP| VarAndPerm mb_l (ValPerm_Conj1 mb_p) |]</span>
<span class="lineno"> 6239 </span><span class="spaces">        </span><span class="nottickedoff">| Just Refl</span>
<span class="lineno"> 6240 </span><span class="spaces">          </span><span class="nottickedoff">&lt;- mbLift $ mbMapCl $(mkClosed [| isLifetimeOwnershipPerm |]) mb_p</span>
<span class="lineno"> 6241 </span><span class="spaces">        </span><span class="nottickedoff">, Right l &lt;- mbNameBoundP mb_l -&gt; Just l</span>
<span class="lineno"> 6242 </span><span class="spaces">      </span><span class="nottickedoff">_ -&gt; Nothing)</span>
<span class="lineno"> 6243 </span><span class="spaces">  </span><span class="nottickedoff">. mbRAssign</span></span>
<span class="lineno"> 6244 </span>
<span class="lineno"> 6245 </span>{-
<span class="lineno"> 6246 </span>-- | Convert a 'FunPerm' in a name-binding to a 'FunPerm' that takes those bound
<span class="lineno"> 6247 </span>-- names as additional ghost arguments with the supplied input permissions and
<span class="lineno"> 6248 </span>-- no output permissions
<span class="lineno"> 6249 </span>mbFunPerm :: CruCtx ctx -&gt; Mb ctx (ValuePerms ctx) -&gt;
<span class="lineno"> 6250 </span>             Mb ctx (FunPerm ghosts args gouts ret) -&gt;
<span class="lineno"> 6251 </span>             FunPerm (ctx :++: ghosts) args gouts ret
<span class="lineno"> 6252 </span>mbFunPerm ctx mb_ps (mbMatch -&gt;
<span class="lineno"> 6253 </span>                     [nuMP| FunPerm mb_ghosts mb_args
<span class="lineno"> 6254 </span>                          mb_gouts mb_ret ps_in ps_out |]) =
<span class="lineno"> 6255 </span>  let ghosts = mbLift mb_ghosts
<span class="lineno"> 6256 </span>      args = mbLift mb_args
<span class="lineno"> 6257 </span>      ctx_perms = trueValuePerms $ cruCtxToTypes ctx
<span class="lineno"> 6258 </span>      args_prxs = cruCtxProxies args
<span class="lineno"> 6259 </span>      ghosts_prxs = cruCtxProxies ghosts
<span class="lineno"> 6260 </span>      gouts_prxs = cruCtxProxies gouts
<span class="lineno"> 6261 </span>      prxs_in = RL.append ghosts_prxs args_prxs
<span class="lineno"> 6262 </span>      prxs_out =
<span class="lineno"> 6263 </span>        RL.append ghosts_prxs $ RL.append args_prxs gouts_prxs :&gt;: Proxy in
<span class="lineno"> 6264 </span>  case RL.appendAssoc ctx ghosts arg_types of
<span class="lineno"> 6265 </span>    Refl -&gt;
<span class="lineno"> 6266 </span>      FunPerm (appendCruCtx ctx ghosts) args (mbLift mb_gouts) (mbLift mb_ret)
<span class="lineno"> 6267 </span>      (mbCombine prxs_in $
<span class="lineno"> 6268 </span>       mbMap2 (\ps mb_ps_in -&gt; fmap (RL.append ps) mb_ps_in) mb_ps ps_in)
<span class="lineno"> 6269 </span>      (fmap (RL.append ctx_perms) $
<span class="lineno"> 6270 </span>       mbCombine prxs_out ps_out)
<span class="lineno"> 6271 </span>-}
<span class="lineno"> 6272 </span>
<span class="lineno"> 6273 </span>-- | Substitute ghost and regular arguments into a function permission to get
<span class="lineno"> 6274 </span>-- its input permissions for those arguments, where ghost arguments are given
<span class="lineno"> 6275 </span>-- both as variables and expressions to which those variables are instantiated.
<span class="lineno"> 6276 </span>-- For a 'FunPerm' of the form @(gctx). xs:ps -o xs:ps'@, return
<span class="lineno"> 6277 </span>--
<span class="lineno"> 6278 </span>-- &gt; [gs/gctx]xs : [gexprs/gctx]ps, g1:eq(gexpr1), ..., gm:eq(gexprm)
<span class="lineno"> 6279 </span>funPermDistIns :: FunPerm ghosts args gouts ret -&gt; RAssign Name ghosts -&gt;
<span class="lineno"> 6280 </span>                  PermExprs ghosts -&gt; RAssign Name args -&gt;
<span class="lineno"> 6281 </span>                  DistPerms ((ghosts :++: args) :++: ghosts)
<span class="lineno"> 6282 </span><span class="decl"><span class="nottickedoff">funPermDistIns fun_perm ghosts gexprs args =</span>
<span class="lineno"> 6283 </span><span class="spaces">  </span><span class="nottickedoff">appendDistPerms</span>
<span class="lineno"> 6284 </span><span class="spaces">  </span><span class="nottickedoff">(valuePermsToDistPerms (RL.append ghosts args) $</span>
<span class="lineno"> 6285 </span><span class="spaces">   </span><span class="nottickedoff">subst (appendSubsts (substOfExprs gexprs) (substOfVars args)) $</span>
<span class="lineno"> 6286 </span><span class="spaces">   </span><span class="nottickedoff">funPermIns fun_perm)</span>
<span class="lineno"> 6287 </span><span class="spaces">  </span><span class="nottickedoff">(eqDistPerms ghosts gexprs)</span></span>
<span class="lineno"> 6288 </span>
<span class="lineno"> 6289 </span>-- | Substitute ghost and regular arguments into a function permission to get
<span class="lineno"> 6290 </span>-- its input permissions for those arguments, where ghost arguments are given
<span class="lineno"> 6291 </span>-- both as variables and expressions to which those variables are instantiated.
<span class="lineno"> 6292 </span>-- For a 'FunPerm' of the form @(gctx). xs:ps -o xs:ps'@, return
<span class="lineno"> 6293 </span>--
<span class="lineno"> 6294 </span>-- &gt; [gs/gctx]xs : [gexprs/gctx]ps'
<span class="lineno"> 6295 </span>funPermDistOuts :: FunPerm ghosts args gouts ret -&gt; RAssign Name ghosts -&gt;
<span class="lineno"> 6296 </span>                   PermExprs ghosts -&gt; RAssign Name args -&gt;
<span class="lineno"> 6297 </span>                   RAssign Name (gouts :&gt; ret) -&gt;
<span class="lineno"> 6298 </span>                   DistPerms ((ghosts :++: args) :++: gouts :&gt; ret)
<span class="lineno"> 6299 </span><span class="decl"><span class="nottickedoff">funPermDistOuts fun_perm ghosts gexprs args gouts_ret =</span>
<span class="lineno"> 6300 </span><span class="spaces">  </span><span class="nottickedoff">valuePermsToDistPerms (RL.append (RL.append ghosts args) gouts_ret) $</span>
<span class="lineno"> 6301 </span><span class="spaces">  </span><span class="nottickedoff">subst (appendSubsts</span>
<span class="lineno"> 6302 </span><span class="spaces">         </span><span class="nottickedoff">(appendSubsts (substOfExprs gexprs) (substOfVars args))</span>
<span class="lineno"> 6303 </span><span class="spaces">         </span><span class="nottickedoff">(substOfVars gouts_ret)) $</span>
<span class="lineno"> 6304 </span><span class="spaces">  </span><span class="nottickedoff">funPermOuts fun_perm</span></span>
<span class="lineno"> 6305 </span>
<span class="lineno"> 6306 </span>-- | Unfold a recursive permission given a 'RecPerm' for it
<span class="lineno"> 6307 </span>unfoldRecPerm :: RecPerm b reach args a -&gt; PermExprs args -&gt; PermOffset a -&gt;
<span class="lineno"> 6308 </span>                 ValuePerm a
<span class="lineno"> 6309 </span><span class="decl"><span class="nottickedoff">unfoldRecPerm rp args off =</span>
<span class="lineno"> 6310 </span><span class="spaces">  </span><span class="nottickedoff">let p = ValPerm_Named (recPermName rp) args NoPermOffset in</span>
<span class="lineno"> 6311 </span><span class="spaces">  </span><span class="nottickedoff">offsetPerm off $ subst (substOfExprs (args :&gt;: PExpr_ValPerm p)) $</span>
<span class="lineno"> 6312 </span><span class="spaces">  </span><span class="nottickedoff">recPermBody rp</span></span>
<span class="lineno"> 6313 </span>
<span class="lineno"> 6314 </span>-- | Unfold a defined permission given arguments
<span class="lineno"> 6315 </span>unfoldDefinedPerm :: DefinedPerm b args a -&gt; PermExprs args -&gt;
<span class="lineno"> 6316 </span>                     PermOffset a -&gt; ValuePerm a
<span class="lineno"> 6317 </span><span class="decl"><span class="nottickedoff">unfoldDefinedPerm dp args off =</span>
<span class="lineno"> 6318 </span><span class="spaces">  </span><span class="nottickedoff">offsetPerm off $ subst (substOfExprs args) (definedPermDef dp)</span></span>
<span class="lineno"> 6319 </span>
<span class="lineno"> 6320 </span>-- | Unfold a named permission as long as it is unfoldable
<span class="lineno"> 6321 </span>unfoldPerm :: NameSortCanFold ns ~ 'True =&gt; NamedPerm ns args a -&gt;
<span class="lineno"> 6322 </span>              PermExprs args -&gt; PermOffset a -&gt; ValuePerm a
<span class="lineno"> 6323 </span><span class="decl"><span class="nottickedoff">unfoldPerm (NamedPerm_Defined dp) = unfoldDefinedPerm dp</span>
<span class="lineno"> 6324 </span><span class="spaces"></span><span class="nottickedoff">unfoldPerm (NamedPerm_Rec rp) = unfoldRecPerm rp</span></span>
<span class="lineno"> 6325 </span>
<span class="lineno"> 6326 </span>-- | Unfold a unfoldable conjunctive named permission to a list of conjuncts
<span class="lineno"> 6327 </span>unfoldConjPerm :: NameSortIsConj ns ~ 'True =&gt; NameSortCanFold ns ~ 'True =&gt;
<span class="lineno"> 6328 </span>                  NamedPerm ns args a -&gt; PermExprs args -&gt; PermOffset a -&gt;
<span class="lineno"> 6329 </span>                  [AtomicPerm a]
<span class="lineno"> 6330 </span><span class="decl"><span class="nottickedoff">unfoldConjPerm npn args off</span>
<span class="lineno"> 6331 </span><span class="spaces">  </span><span class="nottickedoff">| ValPerm_Conj conjs &lt;- unfoldPerm npn args off = conjs</span>
<span class="lineno"> 6332 </span><span class="spaces"></span><span class="nottickedoff">unfoldConjPerm npn args off</span>
<span class="lineno"> 6333 </span><span class="spaces">  </span><span class="nottickedoff">| ValPerm_Named npn' args' off' &lt;- unfoldPerm npn args off</span>
<span class="lineno"> 6334 </span><span class="spaces">  </span><span class="nottickedoff">, TrueRepr &lt;- nameIsConjRepr npn' =</span>
<span class="lineno"> 6335 </span><span class="spaces">    </span><span class="nottickedoff">[Perm_NamedConj npn' args' off']</span>
<span class="lineno"> 6336 </span><span class="spaces"></span><span class="nottickedoff">unfoldConjPerm _ _ _ =</span>
<span class="lineno"> 6337 </span><span class="spaces">  </span><span class="nottickedoff">panic &quot;unfoldConjPerm&quot; []</span></span>
<span class="lineno"> 6338 </span>
<span class="lineno"> 6339 </span>-- | Test if two expressions are definitely unequal
<span class="lineno"> 6340 </span>exprsUnequal :: PermExpr a -&gt; PermExpr a -&gt; Bool
<span class="lineno"> 6341 </span><span class="decl"><span class="nottickedoff">exprsUnequal (PExpr_Var _) _ = False</span>
<span class="lineno"> 6342 </span><span class="spaces"></span><span class="nottickedoff">exprsUnequal (PExpr_Bool b1) (PExpr_Bool b2) = b1 /= b2</span>
<span class="lineno"> 6343 </span><span class="spaces"></span><span class="nottickedoff">exprsUnequal (PExpr_Nat n1) (PExpr_Nat n2) = n1 /= n2</span>
<span class="lineno"> 6344 </span><span class="spaces"></span><span class="nottickedoff">exprsUnequal (PExpr_String str1) (PExpr_String str2) = str1 /= str2</span>
<span class="lineno"> 6345 </span><span class="spaces"></span><span class="nottickedoff">exprsUnequal e1@(PExpr_BV _ _) e2 = not $ bvCouldEqual e1 e2</span>
<span class="lineno"> 6346 </span><span class="spaces"></span><span class="nottickedoff">{- FIXME: we need to prove the types are equal on both sides for this case:</span>
<span class="lineno"> 6347 </span><span class="spaces"></span><span class="nottickedoff">exprsUnequal (PExpr_Struct es1) (PExpr_Struct es2) =</span>
<span class="lineno"> 6348 </span><span class="spaces">  </span><span class="nottickedoff">any $ mapToList2 exprsUnequal es1 es2</span>
<span class="lineno"> 6349 </span><span class="spaces"></span><span class="nottickedoff">-}</span>
<span class="lineno"> 6350 </span><span class="spaces"></span><span class="nottickedoff">exprsUnequal _ _ =</span>
<span class="lineno"> 6351 </span><span class="spaces">  </span><span class="nottickedoff">-- FIXME: maybe we want more cases for shapes and even function handles,</span>
<span class="lineno"> 6352 </span><span class="spaces">  </span><span class="nottickedoff">-- though those shouldn't matter for the current uses of exprsUnequal</span>
<span class="lineno"> 6353 </span><span class="spaces">  </span><span class="nottickedoff">False</span></span>
<span class="lineno"> 6354 </span>
<span class="lineno"> 6355 </span>-- | Generic function to get free variables
<span class="lineno"> 6356 </span>class FreeVars a where
<span class="lineno"> 6357 </span>  freeVars :: a -&gt; NameSet CrucibleType
<span class="lineno"> 6358 </span>
<span class="lineno"> 6359 </span>-- | Get the free variables of an expression as an 'RAssign'
<span class="lineno"> 6360 </span>freeVarsRAssign :: FreeVars a =&gt; a -&gt; Some (RAssign ExprVar)
<span class="lineno"> 6361 </span><span class="decl"><span class="nottickedoff">freeVarsRAssign =</span>
<span class="lineno"> 6362 </span><span class="spaces">  </span><span class="nottickedoff">foldl (\(Some ns) (SomeName n) -&gt; Some (ns :&gt;: n)) (Some MNil) . toList . freeVars</span></span>
<span class="lineno"> 6363 </span>
<span class="lineno"> 6364 </span>-- | Get the bound variables of an expression or permission
<span class="lineno"> 6365 </span>boundVars :: (NuMatching a, FreeVars a) =&gt; Mb (ctx :: RList CrucibleType) a -&gt;
<span class="lineno"> 6366 </span>             [Some @CrucibleType (Member ctx)]
<span class="lineno"> 6367 </span><span class="decl"><span class="nottickedoff">boundVars mb_a =</span>
<span class="lineno"> 6368 </span><span class="spaces">  </span><span class="nottickedoff">mapMaybe (\case</span>
<span class="lineno"> 6369 </span><span class="spaces">               </span><span class="nottickedoff">[nuP| SomeName mb_n |]</span>
<span class="lineno"> 6370 </span><span class="spaces">                 </span><span class="nottickedoff">| Left memb &lt;- mbNameBoundP mb_n -&gt; Just (Some memb)</span>
<span class="lineno"> 6371 </span><span class="spaces">               </span><span class="nottickedoff">_ -&gt; Nothing) $</span>
<span class="lineno"> 6372 </span><span class="spaces">  </span><span class="nottickedoff">mbList $ mbMapCl $(mkClosed [| toList . freeVars |]) mb_a</span></span>
<span class="lineno"> 6373 </span>
<span class="lineno"> 6374 </span>instance FreeVars a =&gt; FreeVars (Maybe a) where
<span class="lineno"> 6375 </span>  <span class="decl"><span class="nottickedoff">freeVars = maybe NameSet.empty freeVars</span></span>
<span class="lineno"> 6376 </span>
<span class="lineno"> 6377 </span>instance FreeVars a =&gt; FreeVars [a] where
<span class="lineno"> 6378 </span>  <span class="decl"><span class="nottickedoff">freeVars = foldr (NameSet.union . freeVars) NameSet.empty</span></span>
<span class="lineno"> 6379 </span>
<span class="lineno"> 6380 </span>instance (FreeVars a, FreeVars b) =&gt; FreeVars (a,b) where
<span class="lineno"> 6381 </span>  <span class="decl"><span class="nottickedoff">freeVars (a,b) = NameSet.union (freeVars a) (freeVars b)</span></span>
<span class="lineno"> 6382 </span>
<span class="lineno"> 6383 </span>instance FreeVars a =&gt; FreeVars (Mb ctx a) where
<span class="lineno"> 6384 </span>  <span class="decl"><span class="nottickedoff">freeVars = NameSet.liftNameSet . fmap freeVars</span></span>
<span class="lineno"> 6385 </span>
<span class="lineno"> 6386 </span>instance FreeVars (PermExpr a) where
<span class="lineno"> 6387 </span>  <span class="decl"><span class="nottickedoff">freeVars (PExpr_Var x) = NameSet.singleton x</span>
<span class="lineno"> 6388 </span><span class="spaces">  </span><span class="nottickedoff">freeVars PExpr_Unit = NameSet.empty</span>
<span class="lineno"> 6389 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (PExpr_Bool _) = NameSet.empty</span>
<span class="lineno"> 6390 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (PExpr_Nat _) = NameSet.empty</span>
<span class="lineno"> 6391 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (PExpr_String _) = NameSet.empty</span>
<span class="lineno"> 6392 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (PExpr_BV factors _) = freeVars factors</span>
<span class="lineno"> 6393 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (PExpr_Struct elems) = freeVars elems</span>
<span class="lineno"> 6394 </span><span class="spaces">  </span><span class="nottickedoff">freeVars PExpr_Always = NameSet.empty</span>
<span class="lineno"> 6395 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (PExpr_LLVMWord e) = freeVars e</span>
<span class="lineno"> 6396 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (PExpr_LLVMOffset ptr off) =</span>
<span class="lineno"> 6397 </span><span class="spaces">    </span><span class="nottickedoff">NameSet.insert ptr (freeVars off)</span>
<span class="lineno"> 6398 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (PExpr_Fun _) = NameSet.empty</span>
<span class="lineno"> 6399 </span><span class="spaces">  </span><span class="nottickedoff">freeVars PExpr_PermListNil = NameSet.empty</span>
<span class="lineno"> 6400 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (PExpr_PermListCons _ e p l) =</span>
<span class="lineno"> 6401 </span><span class="spaces">    </span><span class="nottickedoff">NameSet.unions [freeVars e, freeVars p, freeVars l]</span>
<span class="lineno"> 6402 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (PExpr_RWModality _) = NameSet.empty</span>
<span class="lineno"> 6403 </span><span class="spaces">  </span><span class="nottickedoff">freeVars PExpr_EmptyShape = NameSet.empty</span>
<span class="lineno"> 6404 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (PExpr_NamedShape rw l nmsh args) =</span>
<span class="lineno"> 6405 </span><span class="spaces">    </span><span class="nottickedoff">NameSet.unions [freeVars rw, freeVars l, freeVars nmsh, freeVars args]</span>
<span class="lineno"> 6406 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (PExpr_EqShape len b) = NameSet.union (freeVars len) (freeVars b)</span>
<span class="lineno"> 6407 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (PExpr_PtrShape maybe_rw maybe_l sh) =</span>
<span class="lineno"> 6408 </span><span class="spaces">    </span><span class="nottickedoff">NameSet.unions [freeVars maybe_rw, freeVars maybe_l, freeVars sh]</span>
<span class="lineno"> 6409 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (PExpr_FieldShape fld) = freeVars fld</span>
<span class="lineno"> 6410 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (PExpr_ArrayShape len _ sh) =</span>
<span class="lineno"> 6411 </span><span class="spaces">    </span><span class="nottickedoff">NameSet.union (freeVars len) (freeVars sh)</span>
<span class="lineno"> 6412 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (PExpr_TupShape sh) = freeVars sh</span>
<span class="lineno"> 6413 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (PExpr_SeqShape sh1 sh2) =</span>
<span class="lineno"> 6414 </span><span class="spaces">    </span><span class="nottickedoff">NameSet.union (freeVars sh1) (freeVars sh2)</span>
<span class="lineno"> 6415 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (PExpr_OrShape sh1 sh2) =</span>
<span class="lineno"> 6416 </span><span class="spaces">    </span><span class="nottickedoff">NameSet.union (freeVars sh1) (freeVars sh2)</span>
<span class="lineno"> 6417 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (PExpr_ExShape mb_sh) = NameSet.liftNameSet $ fmap freeVars mb_sh</span>
<span class="lineno"> 6418 </span><span class="spaces">  </span><span class="nottickedoff">freeVars PExpr_FalseShape = NameSet.empty</span>
<span class="lineno"> 6419 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (PExpr_ValPerm p) = freeVars p</span></span>
<span class="lineno"> 6420 </span>
<span class="lineno"> 6421 </span>instance FreeVars (BVFactor w) where
<span class="lineno"> 6422 </span>  <span class="decl"><span class="nottickedoff">freeVars (BVFactor _ x) = NameSet.singleton x</span></span>
<span class="lineno"> 6423 </span>
<span class="lineno"> 6424 </span>instance FreeVars (PermExprs as) where
<span class="lineno"> 6425 </span>  <span class="decl"><span class="nottickedoff">freeVars PExprs_Nil = NameSet.empty</span>
<span class="lineno"> 6426 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (PExprs_Cons es e) = NameSet.union (freeVars es) (freeVars e)</span></span>
<span class="lineno"> 6427 </span>
<span class="lineno"> 6428 </span>instance FreeVars (LLVMFieldShape w) where
<span class="lineno"> 6429 </span>  <span class="decl"><span class="nottickedoff">freeVars (LLVMFieldShape p) = freeVars p</span></span>
<span class="lineno"> 6430 </span>
<span class="lineno"> 6431 </span>instance FreeVars (BVRange w) where
<span class="lineno"> 6432 </span>  <span class="decl"><span class="nottickedoff">freeVars (BVRange off len) = NameSet.union (freeVars off) (freeVars len)</span></span>
<span class="lineno"> 6433 </span>
<span class="lineno"> 6434 </span>instance FreeVars (BVProp w) where
<span class="lineno"> 6435 </span>  <span class="decl"><span class="nottickedoff">freeVars (BVProp_Eq e1 e2) = NameSet.union (freeVars e1) (freeVars e2)</span>
<span class="lineno"> 6436 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (BVProp_Neq e1 e2) = NameSet.union (freeVars e1) (freeVars e2)</span>
<span class="lineno"> 6437 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (BVProp_ULt e1 e2) = NameSet.union (freeVars e1) (freeVars e2)</span>
<span class="lineno"> 6438 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (BVProp_ULeq e1 e2) = NameSet.union (freeVars e1) (freeVars e2)</span>
<span class="lineno"> 6439 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (BVProp_ULeq_Diff e1 e2 e3) =</span>
<span class="lineno"> 6440 </span><span class="spaces">    </span><span class="nottickedoff">NameSet.unions [freeVars e1, freeVars e2, freeVars e3]</span></span>
<span class="lineno"> 6441 </span>
<span class="lineno"> 6442 </span>instance FreeVars (AtomicPerm tp) where
<span class="lineno"> 6443 </span>  <span class="decl"><span class="nottickedoff">freeVars (Perm_LLVMField fp) = freeVars fp</span>
<span class="lineno"> 6444 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (Perm_LLVMArray ap) = freeVars ap</span>
<span class="lineno"> 6445 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (Perm_LLVMBlock bp) = freeVars bp</span>
<span class="lineno"> 6446 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (Perm_LLVMFree e) = freeVars e</span>
<span class="lineno"> 6447 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (Perm_LLVMFunPtr _ fun_perm) = freeVars fun_perm</span>
<span class="lineno"> 6448 </span><span class="spaces">  </span><span class="nottickedoff">freeVars Perm_IsLLVMPtr = NameSet.empty</span>
<span class="lineno"> 6449 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (Perm_LLVMBlockShape sh) = freeVars sh</span>
<span class="lineno"> 6450 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (Perm_LLVMFrame fperms) = freeVars $ map fst fperms</span>
<span class="lineno"> 6451 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (Perm_LOwned ls _ _ ps_in ps_out) =</span>
<span class="lineno"> 6452 </span><span class="spaces">    </span><span class="nottickedoff">NameSet.unions [freeVars ls, freeVars ps_in, freeVars ps_out]</span>
<span class="lineno"> 6453 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (Perm_LOwnedSimple _ lops) = freeVars lops</span>
<span class="lineno"> 6454 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (Perm_LCurrent l) = freeVars l</span>
<span class="lineno"> 6455 </span><span class="spaces">  </span><span class="nottickedoff">freeVars Perm_LFinished = NameSet.empty</span>
<span class="lineno"> 6456 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (Perm_Struct ps) = NameSet.unions $ RL.mapToList freeVars ps</span>
<span class="lineno"> 6457 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (Perm_Fun fun_perm) = freeVars fun_perm</span>
<span class="lineno"> 6458 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (Perm_BVProp prop) = freeVars prop</span>
<span class="lineno"> 6459 </span><span class="spaces">  </span><span class="nottickedoff">freeVars Perm_Any = NameSet.empty</span>
<span class="lineno"> 6460 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (Perm_NamedConj _ args off) =</span>
<span class="lineno"> 6461 </span><span class="spaces">    </span><span class="nottickedoff">NameSet.union (freeVars args) (freeVars off)</span></span>
<span class="lineno"> 6462 </span>
<span class="lineno"> 6463 </span>instance FreeVars (ValuePerm tp) where
<span class="lineno"> 6464 </span>  <span class="decl"><span class="nottickedoff">freeVars (ValPerm_Eq e) = freeVars e</span>
<span class="lineno"> 6465 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (ValPerm_Or p1 p2) = NameSet.union (freeVars p1) (freeVars p2)</span>
<span class="lineno"> 6466 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (ValPerm_Exists mb_p) =</span>
<span class="lineno"> 6467 </span><span class="spaces">    </span><span class="nottickedoff">NameSet.liftNameSet $ fmap freeVars mb_p</span>
<span class="lineno"> 6468 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (ValPerm_Named _ args off) =</span>
<span class="lineno"> 6469 </span><span class="spaces">    </span><span class="nottickedoff">NameSet.union (freeVars args) (freeVars off)</span>
<span class="lineno"> 6470 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (ValPerm_Var x off) = NameSet.insert x $ freeVars off</span>
<span class="lineno"> 6471 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (ValPerm_Conj ps) = freeVars ps</span>
<span class="lineno"> 6472 </span><span class="spaces">  </span><span class="nottickedoff">freeVars ValPerm_False = NameSet.empty</span></span>
<span class="lineno"> 6473 </span>
<span class="lineno"> 6474 </span>instance FreeVars (ValuePerms tps) where
<span class="lineno"> 6475 </span>  <span class="decl"><span class="nottickedoff">freeVars ValPerms_Nil = NameSet.empty</span>
<span class="lineno"> 6476 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (ValPerms_Cons ps p) = NameSet.union (freeVars ps) (freeVars p)</span></span>
<span class="lineno"> 6477 </span>
<span class="lineno"> 6478 </span>instance FreeVars (DistPerms tps) where
<span class="lineno"> 6479 </span>  <span class="decl"><span class="nottickedoff">freeVars dperms =</span>
<span class="lineno"> 6480 </span><span class="spaces">    </span><span class="nottickedoff">NameSet.unions $</span>
<span class="lineno"> 6481 </span><span class="spaces">    </span><span class="nottickedoff">RL.mapToList (\(VarAndPerm x p) -&gt; NameSet.insert x (freeVars p)) dperms</span></span>
<span class="lineno"> 6482 </span>
<span class="lineno"> 6483 </span>instance FreeVars (ExprPerms tps) where
<span class="lineno"> 6484 </span>  <span class="decl"><span class="nottickedoff">freeVars eps =</span>
<span class="lineno"> 6485 </span><span class="spaces">    </span><span class="nottickedoff">NameSet.unions $</span>
<span class="lineno"> 6486 </span><span class="spaces">    </span><span class="nottickedoff">RL.mapToList (\(ExprAndPerm e p) -&gt; NameSet.union (freeVars e) (freeVars p)) eps</span></span>
<span class="lineno"> 6487 </span>
<span class="lineno"> 6488 </span>instance FreeVars (LLVMFieldPerm w sz) where
<span class="lineno"> 6489 </span>  <span class="decl"><span class="nottickedoff">freeVars (LLVMFieldPerm {..}) =</span>
<span class="lineno"> 6490 </span><span class="spaces">    </span><span class="nottickedoff">NameSet.unions [freeVars llvmFieldRW, freeVars llvmFieldLifetime,</span>
<span class="lineno"> 6491 </span><span class="spaces">                    </span><span class="nottickedoff">freeVars llvmFieldOffset, freeVars llvmFieldContents]</span></span>
<span class="lineno"> 6492 </span>
<span class="lineno"> 6493 </span>instance FreeVars (LLVMArrayPerm w) where
<span class="lineno"> 6494 </span>  <span class="decl"><span class="nottickedoff">freeVars (LLVMArrayPerm {..}) =</span>
<span class="lineno"> 6495 </span><span class="spaces">    </span><span class="nottickedoff">NameSet.unions [freeVars llvmArrayRW,</span>
<span class="lineno"> 6496 </span><span class="spaces">                    </span><span class="nottickedoff">freeVars llvmArrayLifetime,</span>
<span class="lineno"> 6497 </span><span class="spaces">                    </span><span class="nottickedoff">freeVars llvmArrayOffset,</span>
<span class="lineno"> 6498 </span><span class="spaces">                    </span><span class="nottickedoff">freeVars llvmArrayLen,</span>
<span class="lineno"> 6499 </span><span class="spaces">                    </span><span class="nottickedoff">freeVars llvmArrayCellShape,</span>
<span class="lineno"> 6500 </span><span class="spaces">                    </span><span class="nottickedoff">freeVars llvmArrayBorrows]</span></span>
<span class="lineno"> 6501 </span>
<span class="lineno"> 6502 </span>instance FreeVars (LLVMArrayIndex w) where
<span class="lineno"> 6503 </span>  <span class="decl"><span class="nottickedoff">freeVars (LLVMArrayIndex cell _) = freeVars cell</span></span>
<span class="lineno"> 6504 </span>
<span class="lineno"> 6505 </span>instance FreeVars (LLVMArrayBorrow w) where
<span class="lineno"> 6506 </span>  <span class="decl"><span class="nottickedoff">freeVars (FieldBorrow ix) = freeVars ix</span>
<span class="lineno"> 6507 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (RangeBorrow rng) = freeVars rng</span></span>
<span class="lineno"> 6508 </span>
<span class="lineno"> 6509 </span>instance FreeVars (LLVMBlockPerm w) where
<span class="lineno"> 6510 </span>  <span class="decl"><span class="nottickedoff">freeVars (LLVMBlockPerm rw l off len sh) =</span>
<span class="lineno"> 6511 </span><span class="spaces">    </span><span class="nottickedoff">NameSet.unions [freeVars rw, freeVars l, freeVars off,</span>
<span class="lineno"> 6512 </span><span class="spaces">                    </span><span class="nottickedoff">freeVars len, freeVars sh]</span></span>
<span class="lineno"> 6513 </span>
<span class="lineno"> 6514 </span>instance FreeVars (PermOffset tp) where
<span class="lineno"> 6515 </span>  <span class="decl"><span class="nottickedoff">freeVars NoPermOffset = NameSet.empty</span>
<span class="lineno"> 6516 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (LLVMPermOffset e) = freeVars e</span></span>
<span class="lineno"> 6517 </span>
<span class="lineno"> 6518 </span>instance FreeVars (FunPerm ghosts args gouts ret) where
<span class="lineno"> 6519 </span>  <span class="decl"><span class="nottickedoff">freeVars (FunPerm _ _ _ _ perms_in perms_out) =</span>
<span class="lineno"> 6520 </span><span class="spaces">    </span><span class="nottickedoff">NameSet.union</span>
<span class="lineno"> 6521 </span><span class="spaces">    </span><span class="nottickedoff">(NameSet.liftNameSet $ fmap freeVars perms_in)</span>
<span class="lineno"> 6522 </span><span class="spaces">    </span><span class="nottickedoff">(NameSet.liftNameSet $ fmap freeVars perms_out)</span></span>
<span class="lineno"> 6523 </span>
<span class="lineno"> 6524 </span>instance FreeVars (NamedShape b args w) where
<span class="lineno"> 6525 </span>  <span class="decl"><span class="nottickedoff">freeVars (NamedShape _ _ body) = freeVars body</span></span>
<span class="lineno"> 6526 </span>
<span class="lineno"> 6527 </span>instance FreeVars (NamedShapeBody b args w) where
<span class="lineno"> 6528 </span>  <span class="decl"><span class="nottickedoff">freeVars (DefinedShapeBody mb_sh) = freeVars mb_sh</span>
<span class="lineno"> 6529 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (OpaqueShapeBody mb_len _ _) = freeVars mb_len</span>
<span class="lineno"> 6530 </span><span class="spaces">  </span><span class="nottickedoff">freeVars (RecShapeBody mb_sh _ _) = freeVars mb_sh</span></span>
<span class="lineno"> 6531 </span>
<span class="lineno"> 6532 </span>
<span class="lineno"> 6533 </span>-- | Find all equality permissions @eq(e)@ contained in another permission
<span class="lineno"> 6534 </span>class ContainedEqVars a where
<span class="lineno"> 6535 </span>  containedEqVars :: a -&gt; NameSet CrucibleType
<span class="lineno"> 6536 </span>
<span class="lineno"> 6537 </span>instance ContainedEqVars (ValuePerm a) where
<span class="lineno"> 6538 </span>  <span class="decl"><span class="nottickedoff">containedEqVars (ValPerm_Eq e) = freeVars e</span>
<span class="lineno"> 6539 </span><span class="spaces">  </span><span class="nottickedoff">containedEqVars (ValPerm_Or p1 p2) =</span>
<span class="lineno"> 6540 </span><span class="spaces">    </span><span class="nottickedoff">NameSet.union (containedEqVars p1) (containedEqVars p2)</span>
<span class="lineno"> 6541 </span><span class="spaces">  </span><span class="nottickedoff">containedEqVars (ValPerm_Exists mb_p) =</span>
<span class="lineno"> 6542 </span><span class="spaces">    </span><span class="nottickedoff">NameSet.liftNameSet $ fmap containedEqVars mb_p</span>
<span class="lineno"> 6543 </span><span class="spaces">  </span><span class="nottickedoff">containedEqVars (ValPerm_Named _ _ _) =</span>
<span class="lineno"> 6544 </span><span class="spaces">    </span><span class="nottickedoff">-- FIXME: we should probably unfold named permissions here...</span>
<span class="lineno"> 6545 </span><span class="spaces">    </span><span class="nottickedoff">NameSet.empty</span>
<span class="lineno"> 6546 </span><span class="spaces">  </span><span class="nottickedoff">containedEqVars (ValPerm_Var _ _) = NameSet.empty</span>
<span class="lineno"> 6547 </span><span class="spaces">  </span><span class="nottickedoff">containedEqVars (ValPerm_Conj ps) = NameSet.unions $ map containedEqVars ps</span>
<span class="lineno"> 6548 </span><span class="spaces">  </span><span class="nottickedoff">containedEqVars ValPerm_False = NameSet.empty</span></span>
<span class="lineno"> 6549 </span>
<span class="lineno"> 6550 </span>instance ContainedEqVars (AtomicPerm a) where
<span class="lineno"> 6551 </span>  <span class="decl"><span class="nottickedoff">containedEqVars (Perm_LLVMField fp) = containedEqVars (llvmFieldContents fp)</span>
<span class="lineno"> 6552 </span><span class="spaces">  </span><span class="nottickedoff">containedEqVars (Perm_LLVMArray ap) = containedEqVars (llvmArrayCellShape ap)</span>
<span class="lineno"> 6553 </span><span class="spaces">  </span><span class="nottickedoff">containedEqVars (Perm_LLVMBlock bp) = containedEqVars (llvmBlockShape bp)</span>
<span class="lineno"> 6554 </span><span class="spaces">  </span><span class="nottickedoff">containedEqVars (Perm_LLVMBlockShape sh) = containedEqVars sh</span>
<span class="lineno"> 6555 </span><span class="spaces">  </span><span class="nottickedoff">containedEqVars _ = NameSet.empty</span></span>
<span class="lineno"> 6556 </span>
<span class="lineno"> 6557 </span>instance ContainedEqVars (PermExpr (LLVMShapeType w)) where
<span class="lineno"> 6558 </span>  <span class="decl"><span class="nottickedoff">containedEqVars (PExpr_Var _) = NameSet.empty</span>
<span class="lineno"> 6559 </span><span class="spaces">  </span><span class="nottickedoff">containedEqVars PExpr_EmptyShape = NameSet.empty</span>
<span class="lineno"> 6560 </span><span class="spaces">  </span><span class="nottickedoff">containedEqVars (PExpr_NamedShape _ _ nmsh@(NamedShape _ _</span>
<span class="lineno"> 6561 </span><span class="spaces">                                              </span><span class="nottickedoff">(DefinedShapeBody _)) args) =</span>
<span class="lineno"> 6562 </span><span class="spaces">    </span><span class="nottickedoff">containedEqVars (unfoldNamedShape nmsh args)</span>
<span class="lineno"> 6563 </span><span class="spaces">  </span><span class="nottickedoff">containedEqVars (PExpr_NamedShape _ _ (NamedShape _ _</span>
<span class="lineno"> 6564 </span><span class="spaces">                                         </span><span class="nottickedoff">(OpaqueShapeBody _ _ _)) _) =</span>
<span class="lineno"> 6565 </span><span class="spaces">    </span><span class="nottickedoff">NameSet.empty</span>
<span class="lineno"> 6566 </span><span class="spaces">  </span><span class="nottickedoff">containedEqVars (PExpr_NamedShape _ _ (NamedShape _ _</span>
<span class="lineno"> 6567 </span><span class="spaces">                                         </span><span class="nottickedoff">(RecShapeBody mb_sh _ _)) args) =</span>
<span class="lineno"> 6568 </span><span class="spaces">    </span><span class="nottickedoff">-- NOTE: we unfold the shape with the empty shape substituted for recursive</span>
<span class="lineno"> 6569 </span><span class="spaces">    </span><span class="nottickedoff">-- occurrences of the shape name, to avoid an infinite loop</span>
<span class="lineno"> 6570 </span><span class="spaces">    </span><span class="nottickedoff">containedEqVars $ subst (substOfExprs (args :&gt;: PExpr_EmptyShape)) mb_sh</span>
<span class="lineno"> 6571 </span><span class="spaces">  </span><span class="nottickedoff">containedEqVars (PExpr_EqShape _ blk) = freeVars blk</span>
<span class="lineno"> 6572 </span><span class="spaces">  </span><span class="nottickedoff">containedEqVars (PExpr_PtrShape _ _ sh) = containedEqVars sh</span>
<span class="lineno"> 6573 </span><span class="spaces">  </span><span class="nottickedoff">containedEqVars (PExpr_FieldShape (LLVMFieldShape p)) = containedEqVars p</span>
<span class="lineno"> 6574 </span><span class="spaces">  </span><span class="nottickedoff">containedEqVars (PExpr_ArrayShape _ _ sh) = containedEqVars sh</span>
<span class="lineno"> 6575 </span><span class="spaces">  </span><span class="nottickedoff">containedEqVars (PExpr_TupShape sh) = containedEqVars sh</span>
<span class="lineno"> 6576 </span><span class="spaces">  </span><span class="nottickedoff">containedEqVars (PExpr_SeqShape sh1 sh2) =</span>
<span class="lineno"> 6577 </span><span class="spaces">    </span><span class="nottickedoff">NameSet.union (containedEqVars sh1) (containedEqVars sh2)</span>
<span class="lineno"> 6578 </span><span class="spaces">  </span><span class="nottickedoff">containedEqVars (PExpr_OrShape sh1 sh2) =</span>
<span class="lineno"> 6579 </span><span class="spaces">    </span><span class="nottickedoff">NameSet.union (containedEqVars sh1) (containedEqVars sh2)</span>
<span class="lineno"> 6580 </span><span class="spaces">  </span><span class="nottickedoff">containedEqVars (PExpr_ExShape mb_sh) =</span>
<span class="lineno"> 6581 </span><span class="spaces">    </span><span class="nottickedoff">NameSet.liftNameSet $ fmap containedEqVars mb_sh</span>
<span class="lineno"> 6582 </span><span class="spaces">  </span><span class="nottickedoff">containedEqVars PExpr_FalseShape = NameSet.empty</span></span>
<span class="lineno"> 6583 </span>
<span class="lineno"> 6584 </span>
<span class="lineno"> 6585 </span>-- | Test if an expression @e@ is a /determining/ expression, meaning that
<span class="lineno"> 6586 </span>-- proving @x:eq(e)@ will necessarily determine the values of the free variables
<span class="lineno"> 6587 </span>-- of @e@ in the sense of 'determinedVars'.
<span class="lineno"> 6588 </span>isDeterminingExpr :: PermExpr a -&gt; Bool
<span class="lineno"> 6589 </span><span class="decl"><span class="nottickedoff">isDeterminingExpr (PExpr_Var _) = True</span>
<span class="lineno"> 6590 </span><span class="spaces"></span><span class="nottickedoff">isDeterminingExpr (PExpr_LLVMWord e) = isDeterminingExpr e</span>
<span class="lineno"> 6591 </span><span class="spaces"></span><span class="nottickedoff">isDeterminingExpr (PExpr_BV [BVFactor _ _] _) =</span>
<span class="lineno"> 6592 </span><span class="spaces">  </span><span class="nottickedoff">-- A linear expression N*x + M lets you solve for x when it is possible</span>
<span class="lineno"> 6593 </span><span class="spaces">  </span><span class="nottickedoff">True</span>
<span class="lineno"> 6594 </span><span class="spaces"></span><span class="nottickedoff">isDeterminingExpr (PExpr_ValPerm (ValPerm_Eq e)) = isDeterminingExpr e</span>
<span class="lineno"> 6595 </span><span class="spaces"></span><span class="nottickedoff">isDeterminingExpr (PExpr_LLVMOffset _ off) = isDeterminingExpr off</span>
<span class="lineno"> 6596 </span><span class="spaces"></span><span class="nottickedoff">isDeterminingExpr e =</span>
<span class="lineno"> 6597 </span><span class="spaces">  </span><span class="nottickedoff">-- If an expression has no free variables then it vacuously determines all of</span>
<span class="lineno"> 6598 </span><span class="spaces">  </span><span class="nottickedoff">-- its free variables</span>
<span class="lineno"> 6599 </span><span class="spaces">  </span><span class="nottickedoff">NameSet.null $ freeVars e</span></span>
<span class="lineno"> 6600 </span>  -- FIXME: consider adding a case for y &amp;+ e
<span class="lineno"> 6601 </span>
<span class="lineno"> 6602 </span>-- | Generic function to compute the /needed/ variables of a permission, meaning
<span class="lineno"> 6603 </span>-- those whose values must be determined before that permission can be
<span class="lineno"> 6604 </span>-- proved. This includes, e.g., all the offsets and lengths of field and array
<span class="lineno"> 6605 </span>-- permissions.
<span class="lineno"> 6606 </span>class NeededVars a where
<span class="lineno"> 6607 </span>  neededVars :: a -&gt; NameSet CrucibleType
<span class="lineno"> 6608 </span>
<span class="lineno"> 6609 </span>instance NeededVars a =&gt; NeededVars [a] where
<span class="lineno"> 6610 </span>  <span class="decl"><span class="nottickedoff">neededVars as = NameSet.unions $ map neededVars as</span></span>
<span class="lineno"> 6611 </span>
<span class="lineno"> 6612 </span>instance NeededVars (PermExpr a) where
<span class="lineno"> 6613 </span>  -- FIXME: need a better explanation of why this is the right answer...
<span class="lineno"> 6614 </span>  <span class="decl"><span class="nottickedoff">neededVars e = if isDeterminingExpr e then NameSet.empty else freeVars e</span></span>
<span class="lineno"> 6615 </span>
<span class="lineno"> 6616 </span>instance NeededVars (PermExprs args) where
<span class="lineno"> 6617 </span>  <span class="decl"><span class="nottickedoff">neededVars PExprs_Nil = NameSet.empty</span>
<span class="lineno"> 6618 </span><span class="spaces">  </span><span class="nottickedoff">neededVars (PExprs_Cons es e) = NameSet.union (neededVars es) (neededVars e)</span></span>
<span class="lineno"> 6619 </span>
<span class="lineno"> 6620 </span>instance NeededVars (ValuePerm a) where
<span class="lineno"> 6621 </span>  <span class="decl"><span class="nottickedoff">neededVars (ValPerm_Eq e) = neededVars e</span>
<span class="lineno"> 6622 </span><span class="spaces">  </span><span class="nottickedoff">neededVars (ValPerm_Or p1 p2) = NameSet.union (neededVars p1) (neededVars p2)</span>
<span class="lineno"> 6623 </span><span class="spaces">  </span><span class="nottickedoff">neededVars (ValPerm_Exists mb_p) = NameSet.liftNameSet $ fmap neededVars mb_p</span>
<span class="lineno"> 6624 </span><span class="spaces">  </span><span class="nottickedoff">neededVars (ValPerm_Named name args offset)</span>
<span class="lineno"> 6625 </span><span class="spaces">    </span><span class="nottickedoff">| OpaqueSortRepr _ &lt;- namedPermNameSort name =</span>
<span class="lineno"> 6626 </span><span class="spaces">      </span><span class="nottickedoff">NameSet.union (neededVars args) (freeVars offset)</span>
<span class="lineno"> 6627 </span><span class="spaces">  </span><span class="nottickedoff">-- FIXME: for non-opaque named permissions, we currently define the</span>
<span class="lineno"> 6628 </span><span class="spaces">  </span><span class="nottickedoff">-- @neededVars@ as all free variables of @p@, but this is incorrect for</span>
<span class="lineno"> 6629 </span><span class="spaces">  </span><span class="nottickedoff">-- defined or recursive permissions that do determine their variable arguments</span>
<span class="lineno"> 6630 </span><span class="spaces">  </span><span class="nottickedoff">-- when unfolded.</span>
<span class="lineno"> 6631 </span><span class="spaces">  </span><span class="nottickedoff">neededVars p@(ValPerm_Named _ _ _) = freeVars p</span>
<span class="lineno"> 6632 </span><span class="spaces">  </span><span class="nottickedoff">neededVars p@(ValPerm_Var _ _) = freeVars p</span>
<span class="lineno"> 6633 </span><span class="spaces">  </span><span class="nottickedoff">neededVars (ValPerm_Conj ps) = neededVars ps</span>
<span class="lineno"> 6634 </span><span class="spaces">  </span><span class="nottickedoff">neededVars ValPerm_False = NameSet.empty</span></span>
<span class="lineno"> 6635 </span>
<span class="lineno"> 6636 </span>instance NeededVars (AtomicPerm a) where
<span class="lineno"> 6637 </span>  <span class="decl"><span class="nottickedoff">neededVars (Perm_LLVMField fp) = neededVars fp</span>
<span class="lineno"> 6638 </span><span class="spaces">  </span><span class="nottickedoff">neededVars (Perm_LLVMArray ap) = neededVars ap</span>
<span class="lineno"> 6639 </span><span class="spaces">  </span><span class="nottickedoff">neededVars (Perm_LLVMBlock bp) = neededVars bp</span>
<span class="lineno"> 6640 </span><span class="spaces">  </span><span class="nottickedoff">neededVars (Perm_LLVMBlockShape _) = NameSet.empty</span>
<span class="lineno"> 6641 </span><span class="spaces">  </span><span class="nottickedoff">neededVars p@(Perm_LOwned _ _ _ _ _) = freeVars p</span>
<span class="lineno"> 6642 </span><span class="spaces">  </span><span class="nottickedoff">neededVars (Perm_LOwnedSimple _ ps) = neededVars $ RL.map exprAndPermPerm ps</span>
<span class="lineno"> 6643 </span><span class="spaces">  </span><span class="nottickedoff">neededVars p = freeVars p</span></span>
<span class="lineno"> 6644 </span>
<span class="lineno"> 6645 </span>instance NeededVars (LLVMFieldPerm w sz) where
<span class="lineno"> 6646 </span>  <span class="decl"><span class="nottickedoff">neededVars (LLVMFieldPerm {..}) =</span>
<span class="lineno"> 6647 </span><span class="spaces">    </span><span class="nottickedoff">NameSet.unions [freeVars llvmFieldOffset, neededVars llvmFieldRW,</span>
<span class="lineno"> 6648 </span><span class="spaces">                    </span><span class="nottickedoff">neededVars llvmFieldLifetime, neededVars llvmFieldContents]</span></span>
<span class="lineno"> 6649 </span>
<span class="lineno"> 6650 </span>instance NeededVars (LLVMArrayPerm w) where
<span class="lineno"> 6651 </span>  <span class="decl"><span class="nottickedoff">neededVars (LLVMArrayPerm {..}) =</span>
<span class="lineno"> 6652 </span><span class="spaces">    </span><span class="nottickedoff">NameSet.unions [neededVars llvmArrayRW, neededVars llvmArrayLifetime,</span>
<span class="lineno"> 6653 </span><span class="spaces">                    </span><span class="nottickedoff">freeVars llvmArrayOffset, freeVars llvmArrayLen,</span>
<span class="lineno"> 6654 </span><span class="spaces">                    </span><span class="nottickedoff">freeVars llvmArrayBorrows, neededVars llvmArrayCellShape]</span></span>
<span class="lineno"> 6655 </span>
<span class="lineno"> 6656 </span>instance NeededVars (LLVMBlockPerm w) where
<span class="lineno"> 6657 </span>  <span class="decl"><span class="nottickedoff">neededVars (LLVMBlockPerm {..}) =</span>
<span class="lineno"> 6658 </span><span class="spaces">    </span><span class="nottickedoff">NameSet.unions [neededVars llvmBlockRW, neededVars llvmBlockLifetime,</span>
<span class="lineno"> 6659 </span><span class="spaces">                    </span><span class="nottickedoff">freeVars llvmBlockOffset, freeVars llvmBlockLen]</span></span>
<span class="lineno"> 6660 </span>
<span class="lineno"> 6661 </span>instance NeededVars (ValuePerms as) where
<span class="lineno"> 6662 </span>  <span class="decl"><span class="nottickedoff">neededVars =</span>
<span class="lineno"> 6663 </span><span class="spaces">    </span><span class="nottickedoff">foldValuePerms (\vars p -&gt;</span>
<span class="lineno"> 6664 </span><span class="spaces">                     </span><span class="nottickedoff">NameSet.union vars (neededVars p)) NameSet.empty</span></span>
<span class="lineno"> 6665 </span>
<span class="lineno"> 6666 </span>instance NeededVars (DistPerms as) where
<span class="lineno"> 6667 </span>  <span class="decl"><span class="nottickedoff">neededVars =</span>
<span class="lineno"> 6668 </span><span class="spaces">    </span><span class="nottickedoff">foldDistPerms (\vars _ p -&gt;</span>
<span class="lineno"> 6669 </span><span class="spaces">                    </span><span class="nottickedoff">NameSet.union vars (neededVars p)) NameSet.empty</span></span>
<span class="lineno"> 6670 </span>
<span class="lineno"> 6671 </span>
<span class="lineno"> 6672 </span>-- | Change all pointer shapes that are associated with the current lifetime of
<span class="lineno"> 6673 </span>-- that shape (i.e., that are not inside a pointer shape with an explicit
<span class="lineno"> 6674 </span>-- lifetime) to 'PExpr_Read'.
<span class="lineno"> 6675 </span>readOnlyShape :: PermExpr (LLVMShapeType w) -&gt; PermExpr (LLVMShapeType w)
<span class="lineno"> 6676 </span><span class="decl"><span class="nottickedoff">readOnlyShape e@(PExpr_Var _) = e</span>
<span class="lineno"> 6677 </span><span class="spaces"></span><span class="nottickedoff">readOnlyShape PExpr_EmptyShape = PExpr_EmptyShape</span>
<span class="lineno"> 6678 </span><span class="spaces"></span><span class="nottickedoff">readOnlyShape (PExpr_NamedShape _ l nmsh args) =</span>
<span class="lineno"> 6679 </span><span class="spaces">  </span><span class="nottickedoff">PExpr_NamedShape (Just PExpr_Read) l nmsh args</span>
<span class="lineno"> 6680 </span><span class="spaces"></span><span class="nottickedoff">readOnlyShape e@(PExpr_EqShape _ _) = e</span>
<span class="lineno"> 6681 </span><span class="spaces"></span><span class="nottickedoff">readOnlyShape e@(PExpr_PtrShape _ (Just _) _) = e</span>
<span class="lineno"> 6682 </span><span class="spaces"></span><span class="nottickedoff">readOnlyShape (PExpr_PtrShape _ Nothing sh) =</span>
<span class="lineno"> 6683 </span><span class="spaces">  </span><span class="nottickedoff">PExpr_PtrShape (Just PExpr_Read) Nothing $ readOnlyShape sh</span>
<span class="lineno"> 6684 </span><span class="spaces"></span><span class="nottickedoff">readOnlyShape e@(PExpr_FieldShape _) = e</span>
<span class="lineno"> 6685 </span><span class="spaces"></span><span class="nottickedoff">readOnlyShape (PExpr_ArrayShape len stride sh) =</span>
<span class="lineno"> 6686 </span><span class="spaces">  </span><span class="nottickedoff">PExpr_ArrayShape len stride $ readOnlyShape sh</span>
<span class="lineno"> 6687 </span><span class="spaces"></span><span class="nottickedoff">readOnlyShape (PExpr_TupShape sh) = PExpr_TupShape (readOnlyShape sh)</span>
<span class="lineno"> 6688 </span><span class="spaces"></span><span class="nottickedoff">readOnlyShape (PExpr_SeqShape sh1 sh2) =</span>
<span class="lineno"> 6689 </span><span class="spaces">  </span><span class="nottickedoff">PExpr_SeqShape (readOnlyShape sh1) (readOnlyShape sh2)</span>
<span class="lineno"> 6690 </span><span class="spaces"></span><span class="nottickedoff">readOnlyShape (PExpr_OrShape sh1 sh2) =</span>
<span class="lineno"> 6691 </span><span class="spaces">  </span><span class="nottickedoff">PExpr_OrShape (readOnlyShape sh1) (readOnlyShape sh2)</span>
<span class="lineno"> 6692 </span><span class="spaces"></span><span class="nottickedoff">readOnlyShape (PExpr_ExShape mb_sh) =</span>
<span class="lineno"> 6693 </span><span class="spaces">  </span><span class="nottickedoff">PExpr_ExShape $ fmap readOnlyShape mb_sh</span>
<span class="lineno"> 6694 </span><span class="spaces"></span><span class="nottickedoff">readOnlyShape PExpr_FalseShape = PExpr_FalseShape</span></span>
<span class="lineno"> 6695 </span>
<span class="lineno"> 6696 </span>
<span class="lineno"> 6697 </span>----------------------------------------------------------------------
<span class="lineno"> 6698 </span>-- * Generalized Substitution
<span class="lineno"> 6699 </span>----------------------------------------------------------------------
<span class="lineno"> 6700 </span>
<span class="lineno"> 6701 </span>-- FIXME: these two EFQ proofs may no longer be needed...?
<span class="lineno"> 6702 </span>noTypesInExprCtx :: forall (ctx :: RList CrucibleType) (a :: Type) b.
<span class="lineno"> 6703 </span>                    Member ctx a -&gt; b
<span class="lineno"> 6704 </span><span class="decl"><span class="nottickedoff">noTypesInExprCtx (Member_Step ctx) = noTypesInExprCtx ctx</span></span>
<span class="lineno"> 6705 </span>
<span class="lineno"> 6706 </span>noExprsInTypeCtx :: forall (ctx :: RList Type) (a :: CrucibleType) b.
<span class="lineno"> 6707 </span>                    Member ctx a -&gt; b
<span class="lineno"> 6708 </span><span class="decl"><span class="nottickedoff">noExprsInTypeCtx (Member_Step ctx) = noExprsInTypeCtx ctx</span></span>
<span class="lineno"> 6709 </span>-- No case for Member_Base
<span class="lineno"> 6710 </span>
<span class="lineno"> 6711 </span>-- | Defines a substitution type @s@ that supports substituting into expression
<span class="lineno"> 6712 </span>-- and permission variables in a given monad @m@
<span class="lineno"> 6713 </span>class MonadBind m =&gt; SubstVar s m | s -&gt; m where
<span class="lineno"> 6714 </span>  extSubst :: s ctx -&gt; ExprVar a -&gt; s (ctx :&gt; a)
<span class="lineno"> 6715 </span>  substExprVar :: s ctx -&gt; Mb ctx (ExprVar a) -&gt; m (PermExpr a)
<span class="lineno"> 6716 </span>
<span class="lineno"> 6717 </span>substPermVar :: SubstVar s m =&gt; s ctx -&gt; Mb ctx (PermVar a) -&gt; m (ValuePerm a)
<span class="lineno"> 6718 </span><span class="decl"><span class="nottickedoff">substPermVar s mb_x =</span>
<span class="lineno"> 6719 </span><span class="spaces">  </span><span class="nottickedoff">substExprVar s mb_x &gt;&gt;= \e -&gt;</span>
<span class="lineno"> 6720 </span><span class="spaces">  </span><span class="nottickedoff">case e of</span>
<span class="lineno"> 6721 </span><span class="spaces">    </span><span class="nottickedoff">PExpr_Var x -&gt; return $ ValPerm_Var x NoPermOffset</span>
<span class="lineno"> 6722 </span><span class="spaces">    </span><span class="nottickedoff">PExpr_ValPerm p -&gt; return p</span></span>
<span class="lineno"> 6723 </span>
<span class="lineno"> 6724 </span>-- | Extend a substitution with 0 or more variables
<span class="lineno"> 6725 </span>extSubstMulti :: SubstVar s m =&gt; s ctx -&gt; RAssign ExprVar ctx' -&gt;
<span class="lineno"> 6726 </span>                 s (ctx :++: ctx')
<span class="lineno"> 6727 </span><span class="decl"><span class="nottickedoff">extSubstMulti s MNil = s</span>
<span class="lineno"> 6728 </span><span class="spaces"></span><span class="nottickedoff">extSubstMulti s (xs :&gt;: x) = extSubst (extSubstMulti s xs) x</span></span>
<span class="lineno"> 6729 </span>
<span class="lineno"> 6730 </span>-- | Generalized notion of substitution, which says that substitution type @s@
<span class="lineno"> 6731 </span>-- supports substituting into type @a@ in monad @m@
<span class="lineno"> 6732 </span>--
<span class="lineno"> 6733 </span>-- FIXME: the 'Mb' argument should really be a 'MatchedMb', to emphasize that we
<span class="lineno"> 6734 </span>-- expect it to be in fresh pair form
<span class="lineno"> 6735 </span>class SubstVar s m =&gt; Substable s a m where
<span class="lineno"> 6736 </span>  genSubst :: s ctx -&gt; Mb ctx a -&gt; m a
<span class="lineno"> 6737 </span>
<span class="lineno"> 6738 </span>-- | A version of 'Substable' for type functors
<span class="lineno"> 6739 </span>class SubstVar s m =&gt; Substable1 s f m where
<span class="lineno"> 6740 </span>  genSubst1 :: s ctx -&gt; Mb ctx (f a) -&gt; m (f a)
<span class="lineno"> 6741 </span>
<span class="lineno"> 6742 </span>instance SubstVar s m =&gt; Substable s Integer m where
<span class="lineno"> 6743 </span>  <span class="decl"><span class="nottickedoff">genSubst _ mb_i = return $ mbLift mb_i</span></span>
<span class="lineno"> 6744 </span>
<span class="lineno"> 6745 </span>instance (NuMatching a, Substable s a m) =&gt; Substable s [a] m where
<span class="lineno"> 6746 </span>  <span class="decl"><span class="nottickedoff">genSubst s as = mapM (genSubst s) (mbList as)</span></span>
<span class="lineno"> 6747 </span>
<span class="lineno"> 6748 </span>instance (NuMatching a, Substable s a m) =&gt; Substable s (NonEmpty a) m where
<span class="lineno"> 6749 </span>  <span class="decl"><span class="nottickedoff">genSubst s (mbMatch -&gt; [nuMP| x :| xs |]) =</span>
<span class="lineno"> 6750 </span><span class="spaces">    </span><span class="nottickedoff">(:|) &lt;$&gt; genSubst s x &lt;*&gt; genSubst s xs</span></span>
<span class="lineno"> 6751 </span>
<span class="lineno"> 6752 </span>instance (NuMatching a, NuMatching b,
<span class="lineno"> 6753 </span>          Substable s a m, Substable s b m) =&gt; Substable s (a,b) m where
<span class="lineno"> 6754 </span>  <span class="decl"><span class="nottickedoff">genSubst s [nuP| (a,b) |] = (,) &lt;$&gt; genSubst s a &lt;*&gt; genSubst s b</span></span>
<span class="lineno"> 6755 </span>
<span class="lineno"> 6756 </span>instance (NuMatching a, NuMatching b, NuMatching c, Substable s a m,
<span class="lineno"> 6757 </span>          Substable s b m, Substable s c m) =&gt; Substable s (a,b,c) m where
<span class="lineno"> 6758 </span>  <span class="decl"><span class="nottickedoff">genSubst s [nuP| (a,b,c) |] =</span>
<span class="lineno"> 6759 </span><span class="spaces">    </span><span class="nottickedoff">(,,) &lt;$&gt; genSubst s a &lt;*&gt; genSubst s b &lt;*&gt; genSubst s c</span></span>
<span class="lineno"> 6760 </span>
<span class="lineno"> 6761 </span>instance (NuMatching a, NuMatching b, NuMatching c, NuMatching d,
<span class="lineno"> 6762 </span>          Substable s a m, Substable s b m,
<span class="lineno"> 6763 </span>          Substable s c m, Substable s d m) =&gt; Substable s (a,b,c,d) m where
<span class="lineno"> 6764 </span>  <span class="decl"><span class="nottickedoff">genSubst s [nuP| (a,b,c,d) |] =</span>
<span class="lineno"> 6765 </span><span class="spaces">    </span><span class="nottickedoff">(,,,) &lt;$&gt; genSubst s a &lt;*&gt; genSubst s b &lt;*&gt; genSubst s c &lt;*&gt; genSubst s d</span></span>
<span class="lineno"> 6766 </span>
<span class="lineno"> 6767 </span>instance (NuMatching a, Substable s a m) =&gt; Substable s (Maybe a) m where
<span class="lineno"> 6768 </span>  <span class="decl"><span class="nottickedoff">genSubst s mb_x = case mbMatch mb_x of</span>
<span class="lineno"> 6769 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Just a |] -&gt; Just &lt;$&gt; genSubst s a</span>
<span class="lineno"> 6770 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Nothing |] -&gt; return Nothing</span></span>
<span class="lineno"> 6771 </span>
<span class="lineno"> 6772 </span>instance {-# INCOHERENT #-} (Given (RAssign Proxy (ctx :: RList CrucibleType)),
<span class="lineno"> 6773 </span>                             Substable s a m, NuMatching a) =&gt;
<span class="lineno"> 6774 </span>                            Substable s (Mb ctx a) m where
<span class="lineno"> 6775 </span>  <span class="decl"><span class="nottickedoff">genSubst = genSubstMb given</span></span>
<span class="lineno"> 6776 </span>
<span class="lineno"> 6777 </span>instance {-# INCOHERENT #-}
<span class="lineno"> 6778 </span>  (Substable s a m, NuMatching a) =&gt;
<span class="lineno"> 6779 </span>  Substable s (Mb (RNil :: RList CrucibleType) a) m where
<span class="lineno"> 6780 </span>  <span class="decl"><span class="nottickedoff">genSubst = genSubstMb RL.typeCtxProxies</span></span>
<span class="lineno"> 6781 </span>
<span class="lineno"> 6782 </span>instance {-# INCOHERENT #-} (Substable s a m, NuMatching a) =&gt;
<span class="lineno"> 6783 </span>                            Substable s (Binding (c :: CrucibleType) a) m where
<span class="lineno"> 6784 </span>  <span class="decl"><span class="nottickedoff">genSubst = genSubstMb RL.typeCtxProxies</span></span>
<span class="lineno"> 6785 </span>
<span class="lineno"> 6786 </span>genSubstMb ::
<span class="lineno"> 6787 </span>  Substable s a m =&gt;
<span class="lineno"> 6788 </span>  NuMatching a =&gt;
<span class="lineno"> 6789 </span>  RAssign Proxy (ctx :: RList CrucibleType) -&gt;
<span class="lineno"> 6790 </span>  s ctx' -&gt; Mb ctx' (Mb ctx a) -&gt; m (Mb ctx a)
<span class="lineno"> 6791 </span><span class="decl"><span class="nottickedoff">genSubstMb p s mbmb =</span>
<span class="lineno"> 6792 </span><span class="spaces">  </span><span class="nottickedoff">mbM $ nuMulti p $ \ns -&gt; genSubst (extSubstMulti s ns) (mbCombine p mbmb)</span></span>
<span class="lineno"> 6793 </span>
<span class="lineno"> 6794 </span>
<span class="lineno"> 6795 </span>instance {-# INCOHERENT #-} (Given (RAssign Proxy ctx),
<span class="lineno"> 6796 </span>                             Substable s a m, NuMatching a) =&gt;
<span class="lineno"> 6797 </span>                            Substable s (NamedMb ctx a) m where
<span class="lineno"> 6798 </span>   <span class="decl"><span class="nottickedoff">genSubst = genSubstNamedMb given</span></span>
<span class="lineno"> 6799 </span>
<span class="lineno"> 6800 </span>instance {-# INCOHERENT #-} (Substable s a m, NuMatching a) =&gt;
<span class="lineno"> 6801 </span>                            Substable s (NamedMb RNil a) m where
<span class="lineno"> 6802 </span>   <span class="decl"><span class="nottickedoff">genSubst = genSubstNamedMb RL.typeCtxProxies</span></span>
<span class="lineno"> 6803 </span>
<span class="lineno"> 6804 </span>instance {-# INCOHERENT #-} (Substable s a m, NuMatching a) =&gt;
<span class="lineno"> 6805 </span>                            Substable s (NamedBinding c a) m where
<span class="lineno"> 6806 </span>   <span class="decl"><span class="nottickedoff">genSubst = genSubstNamedMb RL.typeCtxProxies</span></span>
<span class="lineno"> 6807 </span>
<span class="lineno"> 6808 </span>genSubstNamedMb ::
<span class="lineno"> 6809 </span>  Substable s a m =&gt;
<span class="lineno"> 6810 </span>  NuMatching a =&gt;
<span class="lineno"> 6811 </span>  RAssign Proxy ctx -&gt;
<span class="lineno"> 6812 </span>  s ctx' -&gt; Mb ctx' (NamedMb ctx a) -&gt; m (NamedMb ctx a)
<span class="lineno"> 6813 </span><span class="decl"><span class="nottickedoff">genSubstNamedMb p s mbmb = mbMNamed (fmap (genSubst s) (mbSink p mbmb))</span></span>
<span class="lineno"> 6814 </span>
<span class="lineno"> 6815 </span>instance SubstVar s m =&gt; Substable s (Member ctx a) m where
<span class="lineno"> 6816 </span>  <span class="decl"><span class="nottickedoff">genSubst _ mb_memb = return $ mbLift mb_memb</span></span>
<span class="lineno"> 6817 </span>
<span class="lineno"> 6818 </span>instance SubstVar s m =&gt; Substable s (TypeRepr a) m where
<span class="lineno"> 6819 </span>  <span class="decl"><span class="nottickedoff">genSubst _ mb_tp = return $ mbLift mb_tp</span></span>
<span class="lineno"> 6820 </span>
<span class="lineno"> 6821 </span>instance SubstVar s m =&gt; Substable s (CruCtx ctx) m where
<span class="lineno"> 6822 </span>  <span class="decl"><span class="nottickedoff">genSubst _ mb_ctx = return $ mbLift mb_ctx</span></span>
<span class="lineno"> 6823 </span>
<span class="lineno"> 6824 </span>instance (NuMatchingAny1 f, Substable1 s f m) =&gt;
<span class="lineno"> 6825 </span>         Substable s (RAssign f ctx) m where
<span class="lineno"> 6826 </span>  <span class="decl"><span class="nottickedoff">genSubst s mb_xs = case mbMatch mb_xs of</span>
<span class="lineno"> 6827 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| MNil |] -&gt; return MNil</span>
<span class="lineno"> 6828 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| xs :&gt;: x |] -&gt; (:&gt;:) &lt;$&gt; genSubst s xs &lt;*&gt; genSubst1 s x</span></span>
<span class="lineno"> 6829 </span>
<span class="lineno"> 6830 </span>instance (NuMatchingAny1 f, Substable1 s f m) =&gt;
<span class="lineno"> 6831 </span>         Substable1 s (RAssign f) m where
<span class="lineno"> 6832 </span>  <span class="decl"><span class="nottickedoff">genSubst1 = genSubst</span></span>
<span class="lineno"> 6833 </span>
<span class="lineno"> 6834 </span>instance (NuMatchingAny1 f, Substable1 s f m) =&gt;
<span class="lineno"> 6835 </span>         Substable s (Assignment f ctx) m where
<span class="lineno"> 6836 </span>  <span class="decl"><span class="nottickedoff">genSubst s mb_assign =</span>
<span class="lineno"> 6837 </span><span class="spaces">    </span><span class="nottickedoff">case mbMatch $ fmap viewAssign mb_assign of</span>
<span class="lineno"> 6838 </span><span class="spaces">      </span><span class="nottickedoff">[nuMP| AssignEmpty |] -&gt; return $ Ctx.empty</span>
<span class="lineno"> 6839 </span><span class="spaces">      </span><span class="nottickedoff">[nuMP| AssignExtend asgn' x |] -&gt;</span>
<span class="lineno"> 6840 </span><span class="spaces">        </span><span class="nottickedoff">Ctx.extend &lt;$&gt; genSubst s asgn' &lt;*&gt; genSubst1 s x</span></span>
<span class="lineno"> 6841 </span>
<span class="lineno"> 6842 </span>instance SubstVar s m =&gt; Substable s (a :~: b) m where
<span class="lineno"> 6843 </span>  <span class="decl"><span class="nottickedoff">genSubst _ = return . mbLift</span></span>
<span class="lineno"> 6844 </span>
<span class="lineno"> 6845 </span>instance SubstVar s m =&gt; Substable1 s ((:~:) a) m where
<span class="lineno"> 6846 </span>  <span class="decl"><span class="nottickedoff">genSubst1 _ = return . mbLift</span></span>
<span class="lineno"> 6847 </span>
<span class="lineno"> 6848 </span>-- | Helper function to substitute into 'BVFactor's
<span class="lineno"> 6849 </span>substBVFactor :: SubstVar s m =&gt; s ctx -&gt; Mb ctx (BVFactor w) -&gt;
<span class="lineno"> 6850 </span>                 m (PermExpr (BVType w))
<span class="lineno"> 6851 </span><span class="decl"><span class="nottickedoff">substBVFactor s (mbMatch -&gt; [nuMP| BVFactor (BV.BV i) x |]) =</span>
<span class="lineno"> 6852 </span><span class="spaces">  </span><span class="nottickedoff">bvMult (mbLift i) &lt;$&gt; substExprVar s x</span></span>
<span class="lineno"> 6853 </span>
<span class="lineno"> 6854 </span>instance SubstVar s m =&gt;
<span class="lineno"> 6855 </span>         Substable s (NatRepr n) m where
<span class="lineno"> 6856 </span>  <span class="decl"><span class="nottickedoff">genSubst _ = return . mbLift</span></span>
<span class="lineno"> 6857 </span>
<span class="lineno"> 6858 </span>instance SubstVar PermVarSubst m =&gt;
<span class="lineno"> 6859 </span>         Substable PermVarSubst (ExprVar a) m where
<span class="lineno"> 6860 </span>  <span class="decl"><span class="nottickedoff">genSubst s mb_x = return $ varSubstVar s mb_x</span></span>
<span class="lineno"> 6861 </span>
<span class="lineno"> 6862 </span>instance SubstVar PermVarSubst m =&gt; Substable1 PermVarSubst ExprVar m where
<span class="lineno"> 6863 </span>  <span class="decl"><span class="nottickedoff">genSubst1 = genSubst</span></span>
<span class="lineno"> 6864 </span>
<span class="lineno"> 6865 </span>instance SubstVar s m =&gt; Substable s (PermExpr a) m where
<span class="lineno"> 6866 </span>  <span class="decl"><span class="nottickedoff">genSubst s mb_expr = case mbMatch mb_expr of</span>
<span class="lineno"> 6867 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_Var x |] -&gt; substExprVar s x</span>
<span class="lineno"> 6868 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_Unit |] -&gt; return $ PExpr_Unit</span>
<span class="lineno"> 6869 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_Bool b |] -&gt; return $ PExpr_Bool $ mbLift b</span>
<span class="lineno"> 6870 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_Nat n |] -&gt; return $ PExpr_Nat $ mbLift n</span>
<span class="lineno"> 6871 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_String str |] -&gt; return $ PExpr_String $ mbLift str</span>
<span class="lineno"> 6872 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_BV factors off |] -&gt;</span>
<span class="lineno"> 6873 </span><span class="spaces">      </span><span class="nottickedoff">foldr bvAdd (PExpr_BV [] (mbLift off)) &lt;$&gt;</span>
<span class="lineno"> 6874 </span><span class="spaces">      </span><span class="nottickedoff">mapM (substBVFactor s) (mbList factors)</span>
<span class="lineno"> 6875 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_Struct args |] -&gt;</span>
<span class="lineno"> 6876 </span><span class="spaces">      </span><span class="nottickedoff">PExpr_Struct &lt;$&gt; genSubst s args</span>
<span class="lineno"> 6877 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_Always |] -&gt; return PExpr_Always</span>
<span class="lineno"> 6878 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_LLVMWord e |] -&gt;</span>
<span class="lineno"> 6879 </span><span class="spaces">      </span><span class="nottickedoff">PExpr_LLVMWord &lt;$&gt; genSubst s e</span>
<span class="lineno"> 6880 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_LLVMOffset x off |] -&gt;</span>
<span class="lineno"> 6881 </span><span class="spaces">      </span><span class="nottickedoff">addLLVMOffset &lt;$&gt; substExprVar s x &lt;*&gt; genSubst s off</span>
<span class="lineno"> 6882 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_Fun fh |] -&gt;</span>
<span class="lineno"> 6883 </span><span class="spaces">      </span><span class="nottickedoff">return $ PExpr_Fun $ mbLift fh</span>
<span class="lineno"> 6884 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_PermListNil |] -&gt;</span>
<span class="lineno"> 6885 </span><span class="spaces">      </span><span class="nottickedoff">return $ PExpr_PermListNil</span>
<span class="lineno"> 6886 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_PermListCons tp e p l |] -&gt;</span>
<span class="lineno"> 6887 </span><span class="spaces">      </span><span class="nottickedoff">PExpr_PermListCons (mbLift tp) &lt;$&gt; genSubst s e &lt;*&gt; genSubst s p</span>
<span class="lineno"> 6888 </span><span class="spaces">                                     </span><span class="nottickedoff">&lt;*&gt; genSubst s l</span>
<span class="lineno"> 6889 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_RWModality rw |] -&gt;</span>
<span class="lineno"> 6890 </span><span class="spaces">      </span><span class="nottickedoff">return $ PExpr_RWModality $ mbLift rw</span>
<span class="lineno"> 6891 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_EmptyShape |] -&gt; return PExpr_EmptyShape</span>
<span class="lineno"> 6892 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_NamedShape rw l nmsh args |] -&gt;</span>
<span class="lineno"> 6893 </span><span class="spaces">      </span><span class="nottickedoff">PExpr_NamedShape &lt;$&gt; genSubst s rw &lt;*&gt; genSubst s l &lt;*&gt; genSubst s nmsh</span>
<span class="lineno"> 6894 </span><span class="spaces">                       </span><span class="nottickedoff">&lt;*&gt; genSubst s args</span>
<span class="lineno"> 6895 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_EqShape len b |] -&gt;</span>
<span class="lineno"> 6896 </span><span class="spaces">      </span><span class="nottickedoff">PExpr_EqShape &lt;$&gt; genSubst s len &lt;*&gt; genSubst s b</span>
<span class="lineno"> 6897 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_PtrShape maybe_rw maybe_l sh |] -&gt;</span>
<span class="lineno"> 6898 </span><span class="spaces">      </span><span class="nottickedoff">PExpr_PtrShape &lt;$&gt; genSubst s maybe_rw &lt;*&gt; genSubst s maybe_l</span>
<span class="lineno"> 6899 </span><span class="spaces">                     </span><span class="nottickedoff">&lt;*&gt; genSubst s sh</span>
<span class="lineno"> 6900 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_FieldShape sh |] -&gt;</span>
<span class="lineno"> 6901 </span><span class="spaces">      </span><span class="nottickedoff">PExpr_FieldShape &lt;$&gt; genSubst s sh</span>
<span class="lineno"> 6902 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_ArrayShape len stride sh |] -&gt;</span>
<span class="lineno"> 6903 </span><span class="spaces">      </span><span class="nottickedoff">PExpr_ArrayShape &lt;$&gt; genSubst s len &lt;*&gt; return (mbLift stride)</span>
<span class="lineno"> 6904 </span><span class="spaces">                       </span><span class="nottickedoff">&lt;*&gt; genSubst s sh</span>
<span class="lineno"> 6905 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_TupShape sh |] -&gt; PExpr_TupShape &lt;$&gt; genSubst s sh</span>
<span class="lineno"> 6906 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_SeqShape sh1 sh2 |] -&gt;</span>
<span class="lineno"> 6907 </span><span class="spaces">      </span><span class="nottickedoff">PExpr_SeqShape &lt;$&gt; genSubst s sh1 &lt;*&gt; genSubst s sh2</span>
<span class="lineno"> 6908 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_OrShape sh1 sh2 |] -&gt;</span>
<span class="lineno"> 6909 </span><span class="spaces">      </span><span class="nottickedoff">PExpr_OrShape &lt;$&gt; genSubst s sh1 &lt;*&gt; genSubst s sh2</span>
<span class="lineno"> 6910 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_ExShape mb_sh |] -&gt;</span>
<span class="lineno"> 6911 </span><span class="spaces">      </span><span class="nottickedoff">PExpr_ExShape &lt;$&gt; genSubstMb RL.typeCtxProxies s mb_sh</span>
<span class="lineno"> 6912 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_FalseShape |] -&gt; return PExpr_FalseShape</span>
<span class="lineno"> 6913 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_ValPerm p |] -&gt;</span>
<span class="lineno"> 6914 </span><span class="spaces">      </span><span class="nottickedoff">PExpr_ValPerm &lt;$&gt; genSubst s p</span></span>
<span class="lineno"> 6915 </span>
<span class="lineno"> 6916 </span>instance SubstVar s m =&gt; Substable1 s PermExpr m where
<span class="lineno"> 6917 </span>  <span class="decl"><span class="nottickedoff">genSubst1 = genSubst</span></span>
<span class="lineno"> 6918 </span>
<span class="lineno"> 6919 </span>instance SubstVar s m =&gt; Substable s (BVRange w) m where
<span class="lineno"> 6920 </span>  <span class="decl"><span class="nottickedoff">genSubst s (mbMatch -&gt; [nuMP| BVRange e1 e2 |]) =</span>
<span class="lineno"> 6921 </span><span class="spaces">    </span><span class="nottickedoff">BVRange &lt;$&gt; genSubst s e1 &lt;*&gt; genSubst s e2</span></span>
<span class="lineno"> 6922 </span>
<span class="lineno"> 6923 </span>instance SubstVar s m =&gt; Substable s (MbRangeForType a) m where
<span class="lineno"> 6924 </span>  <span class="decl"><span class="nottickedoff">genSubst s (mbMatch -&gt; [nuMP| MbRangeForLLVMType vars rw l rng |]) =</span>
<span class="lineno"> 6925 </span><span class="spaces">    </span><span class="nottickedoff">MbRangeForLLVMType (mbLift vars) &lt;$&gt;</span>
<span class="lineno"> 6926 </span><span class="spaces">    </span><span class="nottickedoff">genSubstMb (cruCtxProxies $ mbLift vars) s rw &lt;*&gt;</span>
<span class="lineno"> 6927 </span><span class="spaces">    </span><span class="nottickedoff">genSubstMb (cruCtxProxies $ mbLift vars) s l &lt;*&gt;</span>
<span class="lineno"> 6928 </span><span class="spaces">    </span><span class="nottickedoff">genSubstMb (cruCtxProxies $ mbLift vars) s rng</span></span>
<span class="lineno"> 6929 </span>
<span class="lineno"> 6930 </span>instance SubstVar s m =&gt; Substable s (BVProp w) m where
<span class="lineno"> 6931 </span>  <span class="decl"><span class="nottickedoff">genSubst s mb_prop = case mbMatch mb_prop of</span>
<span class="lineno"> 6932 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVProp_Eq e1 e2 |] -&gt;</span>
<span class="lineno"> 6933 </span><span class="spaces">      </span><span class="nottickedoff">BVProp_Eq &lt;$&gt; genSubst s e1 &lt;*&gt; genSubst s e2</span>
<span class="lineno"> 6934 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVProp_Neq e1 e2 |] -&gt;</span>
<span class="lineno"> 6935 </span><span class="spaces">      </span><span class="nottickedoff">BVProp_Neq &lt;$&gt; genSubst s e1 &lt;*&gt; genSubst s e2</span>
<span class="lineno"> 6936 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVProp_ULt e1 e2 |] -&gt;</span>
<span class="lineno"> 6937 </span><span class="spaces">      </span><span class="nottickedoff">BVProp_ULt &lt;$&gt; genSubst s e1 &lt;*&gt; genSubst s e2</span>
<span class="lineno"> 6938 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVProp_ULeq e1 e2 |] -&gt;</span>
<span class="lineno"> 6939 </span><span class="spaces">      </span><span class="nottickedoff">BVProp_ULeq &lt;$&gt; genSubst s e1 &lt;*&gt; genSubst s e2</span>
<span class="lineno"> 6940 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVProp_ULeq_Diff e1 e2 e3 |] -&gt;</span>
<span class="lineno"> 6941 </span><span class="spaces">      </span><span class="nottickedoff">BVProp_ULeq_Diff &lt;$&gt; genSubst s e1 &lt;*&gt; genSubst s e2 &lt;*&gt; genSubst s e3</span></span>
<span class="lineno"> 6942 </span>
<span class="lineno"> 6943 </span>instance SubstVar s m =&gt; Substable s (AtomicPerm a) m where
<span class="lineno"> 6944 </span>  <span class="decl"><span class="nottickedoff">genSubst s mb_p = case mbMatch mb_p of</span>
<span class="lineno"> 6945 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LLVMField fp |] -&gt; Perm_LLVMField &lt;$&gt; genSubst s fp</span>
<span class="lineno"> 6946 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LLVMArray ap |] -&gt; Perm_LLVMArray &lt;$&gt; genSubst s ap</span>
<span class="lineno"> 6947 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LLVMBlock bp |] -&gt; Perm_LLVMBlock &lt;$&gt; genSubst s bp</span>
<span class="lineno"> 6948 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LLVMFree e |] -&gt; Perm_LLVMFree &lt;$&gt; genSubst s e</span>
<span class="lineno"> 6949 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LLVMFunPtr tp p |] -&gt;</span>
<span class="lineno"> 6950 </span><span class="spaces">      </span><span class="nottickedoff">Perm_LLVMFunPtr (mbLift tp) &lt;$&gt; genSubst s p</span>
<span class="lineno"> 6951 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_IsLLVMPtr |] -&gt; return Perm_IsLLVMPtr</span>
<span class="lineno"> 6952 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LLVMBlockShape sh |] -&gt;</span>
<span class="lineno"> 6953 </span><span class="spaces">      </span><span class="nottickedoff">Perm_LLVMBlockShape &lt;$&gt; genSubst s sh</span>
<span class="lineno"> 6954 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LLVMFrame fp |] -&gt; Perm_LLVMFrame &lt;$&gt; genSubst s fp</span>
<span class="lineno"> 6955 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LOwned ls tps_in tps_out ps_in ps_out |] -&gt;</span>
<span class="lineno"> 6956 </span><span class="spaces">      </span><span class="nottickedoff">Perm_LOwned &lt;$&gt; genSubst s ls &lt;*&gt; return (mbLift tps_in) &lt;*&gt;</span>
<span class="lineno"> 6957 </span><span class="spaces">      </span><span class="nottickedoff">return (mbLift tps_out) &lt;*&gt; genSubst s ps_in &lt;*&gt; genSubst s ps_out</span>
<span class="lineno"> 6958 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LOwnedSimple tps lops |] -&gt;</span>
<span class="lineno"> 6959 </span><span class="spaces">      </span><span class="nottickedoff">Perm_LOwnedSimple (mbLift tps) &lt;$&gt; genSubst s lops</span>
<span class="lineno"> 6960 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LCurrent e |] -&gt; Perm_LCurrent &lt;$&gt; genSubst s e</span>
<span class="lineno"> 6961 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LFinished |] -&gt; return Perm_LFinished</span>
<span class="lineno"> 6962 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_Struct tps |] -&gt; Perm_Struct &lt;$&gt; genSubst s tps</span>
<span class="lineno"> 6963 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_Fun fperm |] -&gt; Perm_Fun &lt;$&gt; genSubst s fperm</span>
<span class="lineno"> 6964 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_BVProp prop |] -&gt; Perm_BVProp &lt;$&gt; genSubst s prop</span>
<span class="lineno"> 6965 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_Any |] -&gt; return Perm_Any</span>
<span class="lineno"> 6966 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_NamedConj n args off |] -&gt;</span>
<span class="lineno"> 6967 </span><span class="spaces">      </span><span class="nottickedoff">Perm_NamedConj (mbLift n) &lt;$&gt; genSubst s args &lt;*&gt; genSubst s off</span></span>
<span class="lineno"> 6968 </span>
<span class="lineno"> 6969 </span>instance SubstVar s m =&gt; Substable s (NamedShape b args w) m where
<span class="lineno"> 6970 </span>  <span class="decl"><span class="nottickedoff">genSubst s (mbMatch -&gt; [nuMP| NamedShape str args body |]) =</span>
<span class="lineno"> 6971 </span><span class="spaces">    </span><span class="nottickedoff">NamedShape (mbLift str) (mbLift args) &lt;$&gt; genSubstNSB (cruCtxProxies (mbLift args)) s body</span></span>
<span class="lineno"> 6972 </span>
<span class="lineno"> 6973 </span>genSubstNSB ::
<span class="lineno"> 6974 </span>  SubstVar s m =&gt;
<span class="lineno"> 6975 </span>  RAssign Proxy args -&gt;
<span class="lineno"> 6976 </span>  s ctx -&gt; Mb ctx (NamedShapeBody b args w) -&gt; m (NamedShapeBody b args w)
<span class="lineno"> 6977 </span><span class="decl"><span class="nottickedoff">genSubstNSB px s mb_body = case mbMatch mb_body of</span>
<span class="lineno"> 6978 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| DefinedShapeBody mb_sh |] -&gt;</span>
<span class="lineno"> 6979 </span><span class="spaces">      </span><span class="nottickedoff">DefinedShapeBody &lt;$&gt; genSubstMb px s mb_sh</span>
<span class="lineno"> 6980 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| OpaqueShapeBody mb_len trans_id desc_id |] -&gt;</span>
<span class="lineno"> 6981 </span><span class="spaces">      </span><span class="nottickedoff">OpaqueShapeBody &lt;$&gt; genSubstMb px s mb_len &lt;*&gt; return (mbLift trans_id)</span>
<span class="lineno"> 6982 </span><span class="spaces">      </span><span class="nottickedoff">&lt;*&gt; return (mbLift desc_id)</span>
<span class="lineno"> 6983 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| RecShapeBody mb_sh trans_id desc_id |] -&gt;</span>
<span class="lineno"> 6984 </span><span class="spaces">      </span><span class="nottickedoff">RecShapeBody &lt;$&gt; genSubstMb (px :&gt;: Proxy) s mb_sh</span>
<span class="lineno"> 6985 </span><span class="spaces">                   </span><span class="nottickedoff">&lt;*&gt; return (mbLift trans_id)</span>
<span class="lineno"> 6986 </span><span class="spaces">                   </span><span class="nottickedoff">&lt;*&gt; return (mbLift desc_id)</span></span>
<span class="lineno"> 6987 </span>
<span class="lineno"> 6988 </span>instance SubstVar s m =&gt; Substable s (NamedPermName ns args a) m where
<span class="lineno"> 6989 </span>  <span class="decl"><span class="nottickedoff">genSubst _ mb_rpn = return $ mbLift mb_rpn</span></span>
<span class="lineno"> 6990 </span>
<span class="lineno"> 6991 </span>instance SubstVar s m =&gt; Substable s (PermOffset a) m where
<span class="lineno"> 6992 </span>  <span class="decl"><span class="nottickedoff">genSubst s mb_off = case mbMatch mb_off of</span>
<span class="lineno"> 6993 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| NoPermOffset |] -&gt; return NoPermOffset</span>
<span class="lineno"> 6994 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| LLVMPermOffset e |] -&gt; mkLLVMPermOffset &lt;$&gt; genSubst s e</span></span>
<span class="lineno"> 6995 </span>
<span class="lineno"> 6996 </span>instance SubstVar s m =&gt; Substable s (NamedPerm ns args a) m where
<span class="lineno"> 6997 </span>  <span class="decl"><span class="nottickedoff">genSubst s mb_np = case mbMatch mb_np of</span>
<span class="lineno"> 6998 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| NamedPerm_Opaque  p |] -&gt; NamedPerm_Opaque  &lt;$&gt; genSubst s p</span>
<span class="lineno"> 6999 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| NamedPerm_Rec     p |] -&gt; NamedPerm_Rec     &lt;$&gt; genSubst s p</span>
<span class="lineno"> 7000 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| NamedPerm_Defined p |] -&gt; NamedPerm_Defined &lt;$&gt; genSubst s p</span></span>
<span class="lineno"> 7001 </span>
<span class="lineno"> 7002 </span>instance SubstVar s m =&gt; Substable s (OpaquePerm ns args a) m where
<span class="lineno"> 7003 </span>  <span class="decl"><span class="nottickedoff">genSubst _ (mbMatch -&gt; [nuMP| OpaquePerm n i1 i2 |]) =</span>
<span class="lineno"> 7004 </span><span class="spaces">    </span><span class="nottickedoff">return $ OpaquePerm (mbLift n) (mbLift i1) (mbLift i2)</span></span>
<span class="lineno"> 7005 </span>
<span class="lineno"> 7006 </span>instance SubstVar s m =&gt; Substable s (RecPerm ns reach args a) m where
<span class="lineno"> 7007 </span>  <span class="decl"><span class="nottickedoff">genSubst s (mbMatch -&gt; [nuMP| RecPerm rpn dt_i d_i reachMeths body |]) =</span>
<span class="lineno"> 7008 </span><span class="spaces">    </span><span class="nottickedoff">let ctx = mbLift (fmap namedPermNameArgs rpn) in</span>
<span class="lineno"> 7009 </span><span class="spaces">    </span><span class="nottickedoff">RecPerm (mbLift rpn) (mbLift dt_i) (mbLift d_i) (mbLift reachMeths) &lt;$&gt;</span>
<span class="lineno"> 7010 </span><span class="spaces">    </span><span class="nottickedoff">genSubstMb (cruCtxProxies ctx :&gt;: Proxy) s body</span></span>
<span class="lineno"> 7011 </span>
<span class="lineno"> 7012 </span>instance SubstVar s m =&gt; Substable s (DefinedPerm ns args a) m where
<span class="lineno"> 7013 </span>  <span class="decl"><span class="nottickedoff">genSubst s (mbMatch -&gt; [nuMP| DefinedPerm n p |]) =</span>
<span class="lineno"> 7014 </span><span class="spaces">    </span><span class="nottickedoff">DefinedPerm (mbLift n) &lt;$&gt; genSubstMb (cruCtxProxies (mbLift (fmap namedPermNameArgs n))) s p</span></span>
<span class="lineno"> 7015 </span>
<span class="lineno"> 7016 </span>instance SubstVar s m =&gt; Substable s (ValuePerm a) m where
<span class="lineno"> 7017 </span>  <span class="decl"><span class="nottickedoff">genSubst s mb_p = case mbMatch mb_p of</span>
<span class="lineno"> 7018 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ValPerm_Eq e |] -&gt; ValPerm_Eq &lt;$&gt; genSubst s e</span>
<span class="lineno"> 7019 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ValPerm_Or p1 p2 |] -&gt;</span>
<span class="lineno"> 7020 </span><span class="spaces">      </span><span class="nottickedoff">ValPerm_Or &lt;$&gt; genSubst s p1 &lt;*&gt; genSubst s p2</span>
<span class="lineno"> 7021 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ValPerm_Exists p |] -&gt;</span>
<span class="lineno"> 7022 </span><span class="spaces">      </span><span class="nottickedoff">-- FIXME: maybe we don't need extSubst at all, but can just use the</span>
<span class="lineno"> 7023 </span><span class="spaces">      </span><span class="nottickedoff">-- Substable instance for Mb ctx a from above</span>
<span class="lineno"> 7024 </span><span class="spaces">      </span><span class="nottickedoff">ValPerm_Exists &lt;$&gt; genSubstMb RL.typeCtxProxies s p</span>
<span class="lineno"> 7025 </span><span class="spaces">      </span><span class="nottickedoff">-- nuM (\x -&gt; genSubst (extSubst s x) $ mbCombine p)</span>
<span class="lineno"> 7026 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ValPerm_Named n args off |] -&gt;</span>
<span class="lineno"> 7027 </span><span class="spaces">      </span><span class="nottickedoff">ValPerm_Named (mbLift n) &lt;$&gt; genSubst s args &lt;*&gt; genSubst s off</span>
<span class="lineno"> 7028 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ValPerm_Var mb_x mb_off |] -&gt;</span>
<span class="lineno"> 7029 </span><span class="spaces">      </span><span class="nottickedoff">offsetPerm &lt;$&gt; genSubst s mb_off &lt;*&gt; substPermVar s mb_x</span>
<span class="lineno"> 7030 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ValPerm_Conj aps |] -&gt;</span>
<span class="lineno"> 7031 </span><span class="spaces">      </span><span class="nottickedoff">ValPerm_Conj &lt;$&gt; mapM (genSubst s) (mbList aps)</span>
<span class="lineno"> 7032 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ValPerm_False |] -&gt;</span>
<span class="lineno"> 7033 </span><span class="spaces">      </span><span class="nottickedoff">pure ValPerm_False</span></span>
<span class="lineno"> 7034 </span>
<span class="lineno"> 7035 </span>instance SubstVar s m =&gt; Substable1 s ValuePerm m where
<span class="lineno"> 7036 </span>  <span class="decl"><span class="nottickedoff">genSubst1 = genSubst</span></span>
<span class="lineno"> 7037 </span>
<span class="lineno"> 7038 </span>{-
<span class="lineno"> 7039 </span>instance SubstVar s m =&gt; Substable s (ValuePerms as) m where
<span class="lineno"> 7040 </span>  genSubst s mb_ps = case mbMatch mb_ps of
<span class="lineno"> 7041 </span>    [nuMP| ValPerms_Nil |] -&gt; return ValPerms_Nil
<span class="lineno"> 7042 </span>    [nuMP| ValPerms_Cons ps p |] -&gt;
<span class="lineno"> 7043 </span>      ValPerms_Cons &lt;$&gt; genSubst s ps &lt;*&gt; genSubst s p
<span class="lineno"> 7044 </span>-}
<span class="lineno"> 7045 </span>
<span class="lineno"> 7046 </span>instance SubstVar s m =&gt; Substable s RWModality m where
<span class="lineno"> 7047 </span>  <span class="decl"><span class="nottickedoff">genSubst _ mb_rw = case mbMatch mb_rw of</span>
<span class="lineno"> 7048 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Write |] -&gt; return Write</span>
<span class="lineno"> 7049 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Read |] -&gt; return Read</span></span>
<span class="lineno"> 7050 </span>
<span class="lineno"> 7051 </span>instance SubstVar s m =&gt; Substable s (LLVMFieldPerm w sz) m where
<span class="lineno"> 7052 </span>  <span class="decl"><span class="nottickedoff">genSubst s (mbMatch -&gt; [nuMP| LLVMFieldPerm rw ls off p |]) =</span>
<span class="lineno"> 7053 </span><span class="spaces">    </span><span class="nottickedoff">LLVMFieldPerm &lt;$&gt; genSubst s rw &lt;*&gt; genSubst s ls &lt;*&gt;</span>
<span class="lineno"> 7054 </span><span class="spaces">                      </span><span class="nottickedoff">genSubst s off &lt;*&gt; genSubst s p</span></span>
<span class="lineno"> 7055 </span>
<span class="lineno"> 7056 </span>instance SubstVar s m =&gt; Substable s (LLVMArrayPerm w) m where
<span class="lineno"> 7057 </span>  <span class="decl"><span class="nottickedoff">genSubst s (mbMatch -&gt; [nuMP| LLVMArrayPerm rw l off len stride sh bs |]) =</span>
<span class="lineno"> 7058 </span><span class="spaces">    </span><span class="nottickedoff">LLVMArrayPerm &lt;$&gt; genSubst s rw &lt;*&gt; genSubst s l &lt;*&gt; genSubst s off</span>
<span class="lineno"> 7059 </span><span class="spaces">    </span><span class="nottickedoff">&lt;*&gt; genSubst s len &lt;*&gt; return (mbLift stride) &lt;*&gt; genSubst s sh</span>
<span class="lineno"> 7060 </span><span class="spaces">    </span><span class="nottickedoff">&lt;*&gt; genSubst s bs</span></span>
<span class="lineno"> 7061 </span>
<span class="lineno"> 7062 </span>instance SubstVar s m =&gt; Substable s (LLVMArrayIndex w) m where
<span class="lineno"> 7063 </span>  <span class="decl"><span class="nottickedoff">genSubst s (mbMatch -&gt; [nuMP| LLVMArrayIndex ix off |]) =</span>
<span class="lineno"> 7064 </span><span class="spaces">    </span><span class="nottickedoff">LLVMArrayIndex &lt;$&gt; genSubst s ix &lt;*&gt; return (mbLift off)</span></span>
<span class="lineno"> 7065 </span>
<span class="lineno"> 7066 </span>instance SubstVar s m =&gt; Substable s (LLVMArrayBorrow w) m where
<span class="lineno"> 7067 </span>  <span class="decl"><span class="nottickedoff">genSubst s mb_borrow = case mbMatch mb_borrow of</span>
<span class="lineno"> 7068 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| FieldBorrow ix |] -&gt; FieldBorrow &lt;$&gt; genSubst s ix</span>
<span class="lineno"> 7069 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| RangeBorrow r |] -&gt; RangeBorrow &lt;$&gt; genSubst s r</span></span>
<span class="lineno"> 7070 </span>
<span class="lineno"> 7071 </span>instance SubstVar s m =&gt; Substable s (LLVMBlockPerm w) m where
<span class="lineno"> 7072 </span>  <span class="decl"><span class="nottickedoff">genSubst s (mbMatch -&gt; [nuMP| LLVMBlockPerm rw l off len sh |]) =</span>
<span class="lineno"> 7073 </span><span class="spaces">    </span><span class="nottickedoff">LLVMBlockPerm &lt;$&gt; genSubst s rw &lt;*&gt; genSubst s l &lt;*&gt; genSubst s off</span>
<span class="lineno"> 7074 </span><span class="spaces">    </span><span class="nottickedoff">&lt;*&gt; genSubst s len &lt;*&gt; genSubst s sh</span></span>
<span class="lineno"> 7075 </span>
<span class="lineno"> 7076 </span>instance SubstVar s m =&gt; Substable s (LLVMFieldShape w) m where
<span class="lineno"> 7077 </span>  <span class="decl"><span class="nottickedoff">genSubst s (mbMatch -&gt; [nuMP| LLVMFieldShape p |]) =</span>
<span class="lineno"> 7078 </span><span class="spaces">    </span><span class="nottickedoff">LLVMFieldShape &lt;$&gt; genSubst s p</span></span>
<span class="lineno"> 7079 </span>
<span class="lineno"> 7080 </span>instance SubstVar s m =&gt; Substable s (ExprAndPerm a) m where
<span class="lineno"> 7081 </span>  <span class="decl"><span class="nottickedoff">genSubst s (mbMatch -&gt; [nuMP| ExprAndPerm e p |]) =</span>
<span class="lineno"> 7082 </span><span class="spaces">    </span><span class="nottickedoff">ExprAndPerm &lt;$&gt; genSubst s e &lt;*&gt; genSubst s p</span></span>
<span class="lineno"> 7083 </span>
<span class="lineno"> 7084 </span>instance SubstVar s m =&gt; Substable1 s ExprAndPerm m where
<span class="lineno"> 7085 </span>  <span class="decl"><span class="nottickedoff">genSubst1 = genSubst</span></span>
<span class="lineno"> 7086 </span>
<span class="lineno"> 7087 </span>instance SubstVar s m =&gt; Substable s (FunPerm ghosts args gouts ret) m where
<span class="lineno"> 7088 </span>  <span class="decl"><span class="nottickedoff">genSubst s (mbMatch -&gt;</span>
<span class="lineno"> 7089 </span><span class="spaces">              </span><span class="nottickedoff">[nuMP| FunPerm mb_ghosts mb_args mb_gouts</span>
<span class="lineno"> 7090 </span><span class="spaces">                   </span><span class="nottickedoff">mb_ret perms_in perms_out |]) =</span>
<span class="lineno"> 7091 </span><span class="spaces">    </span><span class="nottickedoff">let ghosts = mbLift mb_ghosts</span>
<span class="lineno"> 7092 </span><span class="spaces">        </span><span class="nottickedoff">args = mbLift mb_args</span>
<span class="lineno"> 7093 </span><span class="spaces">        </span><span class="nottickedoff">gouts = mbLift mb_gouts</span>
<span class="lineno"> 7094 </span><span class="spaces">        </span><span class="nottickedoff">ret = mbLift mb_ret</span>
<span class="lineno"> 7095 </span><span class="spaces">        </span><span class="nottickedoff">ghosts_args_prxs =</span>
<span class="lineno"> 7096 </span><span class="spaces">          </span><span class="nottickedoff">RL.append (cruCtxProxies ghosts) (cruCtxProxies args)</span>
<span class="lineno"> 7097 </span><span class="spaces">        </span><span class="nottickedoff">ghosts_args_gouts_ret_prxs =</span>
<span class="lineno"> 7098 </span><span class="spaces">          </span><span class="nottickedoff">RL.append ghosts_args_prxs (cruCtxProxies gouts) :&gt;: Proxy in</span>
<span class="lineno"> 7099 </span><span class="spaces">    </span><span class="nottickedoff">FunPerm ghosts args gouts ret</span>
<span class="lineno"> 7100 </span><span class="spaces">    </span><span class="nottickedoff">&lt;$&gt; genSubstMb ghosts_args_prxs s perms_in</span>
<span class="lineno"> 7101 </span><span class="spaces">    </span><span class="nottickedoff">&lt;*&gt; genSubstMb ghosts_args_gouts_ret_prxs s perms_out</span></span>
<span class="lineno"> 7102 </span>
<span class="lineno"> 7103 </span>instance SubstVar PermVarSubst m =&gt;
<span class="lineno"> 7104 </span>         Substable PermVarSubst (LifetimeCurrentPerms ps) m where
<span class="lineno"> 7105 </span>  <span class="decl"><span class="nottickedoff">genSubst s mb_x = case mbMatch mb_x of</span>
<span class="lineno"> 7106 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| AlwaysCurrentPerms |] -&gt; return AlwaysCurrentPerms</span>
<span class="lineno"> 7107 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| LOwnedCurrentPerms l ls tps_in tps_out ps_in ps_out |] -&gt;</span>
<span class="lineno"> 7108 </span><span class="spaces">      </span><span class="nottickedoff">LOwnedCurrentPerms &lt;$&gt; genSubst s l &lt;*&gt; genSubst s ls</span>
<span class="lineno"> 7109 </span><span class="spaces">      </span><span class="nottickedoff">&lt;*&gt; return (mbLift tps_in) &lt;*&gt; return (mbLift tps_out)</span>
<span class="lineno"> 7110 </span><span class="spaces">      </span><span class="nottickedoff">&lt;*&gt; genSubst s ps_in &lt;*&gt; genSubst s ps_out</span>
<span class="lineno"> 7111 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| LOwnedSimpleCurrentPerms l tps ps |] -&gt;</span>
<span class="lineno"> 7112 </span><span class="spaces">      </span><span class="nottickedoff">LOwnedSimpleCurrentPerms &lt;$&gt; genSubst s l</span>
<span class="lineno"> 7113 </span><span class="spaces">      </span><span class="nottickedoff">&lt;*&gt; return (mbLift tps) &lt;*&gt; genSubst s ps</span>
<span class="lineno"> 7114 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| CurrentTransPerms ps l |] -&gt;</span>
<span class="lineno"> 7115 </span><span class="spaces">      </span><span class="nottickedoff">CurrentTransPerms &lt;$&gt; genSubst s ps &lt;*&gt; genSubst s l</span></span>
<span class="lineno"> 7116 </span>
<span class="lineno"> 7117 </span>instance SubstVar PermVarSubst m =&gt;
<span class="lineno"> 7118 </span>         Substable PermVarSubst (VarAndPerm a) m where
<span class="lineno"> 7119 </span>  <span class="decl"><span class="nottickedoff">genSubst s (mbMatch -&gt; [nuMP| VarAndPerm x p |]) =</span>
<span class="lineno"> 7120 </span><span class="spaces">    </span><span class="nottickedoff">VarAndPerm &lt;$&gt; genSubst s x &lt;*&gt; genSubst s p</span></span>
<span class="lineno"> 7121 </span>
<span class="lineno"> 7122 </span>instance SubstVar PermVarSubst m =&gt; Substable1 PermVarSubst VarAndPerm m where
<span class="lineno"> 7123 </span>  <span class="decl"><span class="nottickedoff">genSubst1 = genSubst</span></span>
<span class="lineno"> 7124 </span>
<span class="lineno"> 7125 </span>instance Substable1 s f m =&gt; Substable1 s (Typed f) m where
<span class="lineno"> 7126 </span>  <span class="decl"><span class="nottickedoff">genSubst1 s mb_typed =</span>
<span class="lineno"> 7127 </span><span class="spaces">    </span><span class="nottickedoff">Typed (mbLift $ fmap typedType mb_typed) &lt;$&gt;</span>
<span class="lineno"> 7128 </span><span class="spaces">    </span><span class="nottickedoff">genSubst1 s (fmap typedObj mb_typed)</span></span>
<span class="lineno"> 7129 </span>
<span class="lineno"> 7130 </span>{-
<span class="lineno"> 7131 </span>instance SubstVar PermVarSubst m =&gt;
<span class="lineno"> 7132 </span>         Substable PermVarSubst (DistPerms ps) m where
<span class="lineno"> 7133 </span>  genSubst s mb_dperms = case mbMatch mb_dperms of
<span class="lineno"> 7134 </span>    [nuMP| DistPermsNil |] -&gt; return DistPermsNil
<span class="lineno"> 7135 </span>    [nuMP| DistPermsCons dperms' x p |] -&gt;
<span class="lineno"> 7136 </span>      DistPermsCons &lt;$&gt; genSubst s dperms' &lt;*&gt;
<span class="lineno"> 7137 </span>      return (varSubstVar s x) &lt;*&gt; genSubst s p
<span class="lineno"> 7138 </span>-}
<span class="lineno"> 7139 </span>
<span class="lineno"> 7140 </span>instance SubstVar s m =&gt; Substable s (LifetimeFunctor args a) m where
<span class="lineno"> 7141 </span>  <span class="decl"><span class="nottickedoff">genSubst s mb_x = case mbMatch mb_x of</span>
<span class="lineno"> 7142 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| LTFunctorField off p |] -&gt;</span>
<span class="lineno"> 7143 </span><span class="spaces">      </span><span class="nottickedoff">LTFunctorField &lt;$&gt; genSubst s off &lt;*&gt; genSubst s p</span>
<span class="lineno"> 7144 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| LTFunctorArray off len stride sh bs |] -&gt;</span>
<span class="lineno"> 7145 </span><span class="spaces">      </span><span class="nottickedoff">LTFunctorArray &lt;$&gt; genSubst s off &lt;*&gt; genSubst s len &lt;*&gt;</span>
<span class="lineno"> 7146 </span><span class="spaces">      </span><span class="nottickedoff">return (mbLift stride) &lt;*&gt; genSubst s sh &lt;*&gt; genSubst s bs</span>
<span class="lineno"> 7147 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| LTFunctorBlock off len sh |] -&gt;</span>
<span class="lineno"> 7148 </span><span class="spaces">      </span><span class="nottickedoff">LTFunctorBlock &lt;$&gt; genSubst s off &lt;*&gt; genSubst s len &lt;*&gt; genSubst s sh</span></span>
<span class="lineno"> 7149 </span>
<span class="lineno"> 7150 </span>
<span class="lineno"> 7151 </span>----------------------------------------------------------------------
<span class="lineno"> 7152 </span>-- * Expression Substitutions
<span class="lineno"> 7153 </span>----------------------------------------------------------------------
<span class="lineno"> 7154 </span>
<span class="lineno"> 7155 </span>-- | A substitution assigns a permission expression to each bound name in a
<span class="lineno"> 7156 </span>-- name-binding context
<span class="lineno"> 7157 </span>newtype PermSubst ctx =
<span class="lineno"> 7158 </span>  PermSubst { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unPermSubst</span></span></span> :: RAssign PermExpr ctx }
<span class="lineno"> 7159 </span>
<span class="lineno"> 7160 </span>emptySubst :: PermSubst RNil
<span class="lineno"> 7161 </span><span class="decl"><span class="nottickedoff">emptySubst = PermSubst RL.empty</span></span>
<span class="lineno"> 7162 </span>
<span class="lineno"> 7163 </span>consSubst :: PermSubst ctx -&gt; PermExpr a -&gt; PermSubst (ctx :&gt; a)
<span class="lineno"> 7164 </span><span class="decl"><span class="nottickedoff">consSubst (PermSubst elems) e = PermSubst (elems :&gt;: e)</span></span>
<span class="lineno"> 7165 </span>
<span class="lineno"> 7166 </span>singletonSubst :: PermExpr a -&gt; PermSubst (RNil :&gt; a)
<span class="lineno"> 7167 </span><span class="decl"><span class="nottickedoff">singletonSubst e = PermSubst (RL.empty :&gt;: e)</span></span>
<span class="lineno"> 7168 </span>
<span class="lineno"> 7169 </span>appendSubsts :: PermSubst ctx1 -&gt; PermSubst ctx2 -&gt; PermSubst (ctx1 :++: ctx2)
<span class="lineno"> 7170 </span><span class="decl"><span class="nottickedoff">appendSubsts (PermSubst es1) (PermSubst es2) = PermSubst $ RL.append es1 es2</span></span>
<span class="lineno"> 7171 </span>
<span class="lineno"> 7172 </span>substOfVars :: RAssign ExprVar ctx -&gt; PermSubst ctx
<span class="lineno"> 7173 </span><span class="decl"><span class="nottickedoff">substOfVars = PermSubst . RL.map PExpr_Var</span></span>
<span class="lineno"> 7174 </span>
<span class="lineno"> 7175 </span>substOfExprs :: PermExprs ctx -&gt; PermSubst ctx
<span class="lineno"> 7176 </span><span class="decl"><span class="nottickedoff">substOfExprs = PermSubst</span></span>
<span class="lineno"> 7177 </span>
<span class="lineno"> 7178 </span>-- FIXME: Maybe PermSubst should just be PermExprs?
<span class="lineno"> 7179 </span>exprsOfSubst :: PermSubst ctx -&gt; PermExprs ctx
<span class="lineno"> 7180 </span><span class="decl"><span class="nottickedoff">exprsOfSubst = unPermSubst</span></span>
<span class="lineno"> 7181 </span>
<span class="lineno"> 7182 </span>substLookup :: PermSubst ctx -&gt; Member ctx a -&gt; PermExpr a
<span class="lineno"> 7183 </span><span class="decl"><span class="nottickedoff">substLookup (PermSubst m) memb = RL.get memb m</span></span>
<span class="lineno"> 7184 </span>
<span class="lineno"> 7185 </span>noPermsInCruCtx :: forall (ctx :: RList CrucibleType) (a :: CrucibleType) b.
<span class="lineno"> 7186 </span>                   Member ctx (ValuePerm a) -&gt; b
<span class="lineno"> 7187 </span><span class="decl"><span class="nottickedoff">noPermsInCruCtx (Member_Step ctx) = noPermsInCruCtx ctx</span></span>
<span class="lineno"> 7188 </span>-- No case for Member_Base
<span class="lineno"> 7189 </span>
<span class="lineno"> 7190 </span>instance SubstVar PermSubst Identity where
<span class="lineno"> 7191 </span>  <span class="decl"><span class="nottickedoff">extSubst (PermSubst elems) x = PermSubst $ elems :&gt;: PExpr_Var x</span></span>
<span class="lineno"> 7192 </span>  <span class="decl"><span class="nottickedoff">substExprVar s x =</span>
<span class="lineno"> 7193 </span><span class="spaces">    </span><span class="nottickedoff">case mbNameBoundP x of</span>
<span class="lineno"> 7194 </span><span class="spaces">      </span><span class="nottickedoff">Left memb -&gt; return $ substLookup s memb</span>
<span class="lineno"> 7195 </span><span class="spaces">      </span><span class="nottickedoff">Right y -&gt; return $ PExpr_Var y</span></span>
<span class="lineno"> 7196 </span>  {-
<span class="lineno"> 7197 </span>  substPermVar s mb_x =
<span class="lineno"> 7198 </span>    case mbNameBoundP mb_x of
<span class="lineno"> 7199 </span>      Left memb -&gt; noTypesInExprCtx memb
<span class="lineno"> 7200 </span>      Right x -&gt; return $ ValPerm_Var x -}
<span class="lineno"> 7201 </span>
<span class="lineno"> 7202 </span>-- | Apply a substitution to an object
<span class="lineno"> 7203 </span>subst :: Substable PermSubst a Identity =&gt; PermSubst ctx -&gt; Mb ctx a -&gt; a
<span class="lineno"> 7204 </span><span class="decl"><span class="nottickedoff">subst s mb = runIdentity $ genSubst s mb</span></span>
<span class="lineno"> 7205 </span>
<span class="lineno"> 7206 </span>-- | Substitute a single expression into an object
<span class="lineno"> 7207 </span>subst1 :: Substable PermSubst a Identity =&gt; PermExpr b -&gt; Binding b a -&gt; a
<span class="lineno"> 7208 </span><span class="decl"><span class="nottickedoff">subst1 e = subst (singletonSubst e)</span></span>
<span class="lineno"> 7209 </span>
<span class="lineno"> 7210 </span>
<span class="lineno"> 7211 </span>----------------------------------------------------------------------
<span class="lineno"> 7212 </span>-- * Variable Substitutions
<span class="lineno"> 7213 </span>----------------------------------------------------------------------
<span class="lineno"> 7214 </span>
<span class="lineno"> 7215 </span>-- FIXME HERE: PermVarSubst and other types should just be instances of a
<span class="lineno"> 7216 </span>-- RAssign, except it is annoying to build NuMatching instances for RAssign
<span class="lineno"> 7217 </span>-- because there are different ways one might do it, so we need to use
<span class="lineno"> 7218 </span>-- OVERLAPPING and/or INCOHERENT pragmas for them
<span class="lineno"> 7219 </span>
<span class="lineno"> 7220 </span>emptyVarSubst :: PermVarSubst RNil
<span class="lineno"> 7221 </span><span class="decl"><span class="nottickedoff">emptyVarSubst = PermVarSubst_Nil</span></span>
<span class="lineno"> 7222 </span>
<span class="lineno"> 7223 </span>singletonVarSubst :: ExprVar a -&gt; PermVarSubst (RNil :&gt; a)
<span class="lineno"> 7224 </span><span class="decl"><span class="nottickedoff">singletonVarSubst x = PermVarSubst_Cons emptyVarSubst x</span></span>
<span class="lineno"> 7225 </span>
<span class="lineno"> 7226 </span>consVarSubst :: PermVarSubst ctx -&gt; ExprVar a -&gt; PermVarSubst (ctx :&gt; a)
<span class="lineno"> 7227 </span><span class="decl"><span class="nottickedoff">consVarSubst = PermVarSubst_Cons</span></span>
<span class="lineno"> 7228 </span>
<span class="lineno"> 7229 </span>permVarSubstOfNames :: RAssign Name ctx -&gt; PermVarSubst ctx
<span class="lineno"> 7230 </span><span class="decl"><span class="nottickedoff">permVarSubstOfNames MNil = PermVarSubst_Nil</span>
<span class="lineno"> 7231 </span><span class="spaces"></span><span class="nottickedoff">permVarSubstOfNames (ns :&gt;: n) = PermVarSubst_Cons (permVarSubstOfNames ns) n</span></span>
<span class="lineno"> 7232 </span>
<span class="lineno"> 7233 </span>permVarSubstToNames :: PermVarSubst ctx -&gt; RAssign Name ctx
<span class="lineno"> 7234 </span><span class="decl"><span class="nottickedoff">permVarSubstToNames PermVarSubst_Nil = MNil</span>
<span class="lineno"> 7235 </span><span class="spaces"></span><span class="nottickedoff">permVarSubstToNames (PermVarSubst_Cons s n) = permVarSubstToNames s :&gt;: n</span></span>
<span class="lineno"> 7236 </span>
<span class="lineno"> 7237 </span>varSubstLookup :: PermVarSubst ctx -&gt; Member ctx a -&gt; ExprVar a
<span class="lineno"> 7238 </span><span class="decl"><span class="nottickedoff">varSubstLookup PermVarSubst_Nil m = case m of {}</span>
<span class="lineno"> 7239 </span><span class="spaces"></span><span class="nottickedoff">varSubstLookup (PermVarSubst_Cons _ x) Member_Base = x</span>
<span class="lineno"> 7240 </span><span class="spaces"></span><span class="nottickedoff">varSubstLookup (PermVarSubst_Cons s _) (Member_Step memb) =</span>
<span class="lineno"> 7241 </span><span class="spaces">  </span><span class="nottickedoff">varSubstLookup s memb</span></span>
<span class="lineno"> 7242 </span>
<span class="lineno"> 7243 </span>appendVarSubsts :: PermVarSubst ctx1 -&gt; PermVarSubst ctx2 -&gt;
<span class="lineno"> 7244 </span>                   PermVarSubst (ctx1 :++: ctx2)
<span class="lineno"> 7245 </span><span class="decl"><span class="nottickedoff">appendVarSubsts es1 PermVarSubst_Nil = es1</span>
<span class="lineno"> 7246 </span><span class="spaces"></span><span class="nottickedoff">appendVarSubsts es1 (PermVarSubst_Cons es2 x) =</span>
<span class="lineno"> 7247 </span><span class="spaces">  </span><span class="nottickedoff">PermVarSubst_Cons (appendVarSubsts es1 es2) x</span></span>
<span class="lineno"> 7248 </span>
<span class="lineno"> 7249 </span>-- | Convert a 'PermVarSubst' to a 'PermSubst'
<span class="lineno"> 7250 </span>permVarSubstToSubst :: PermVarSubst ctx -&gt; PermSubst ctx
<span class="lineno"> 7251 </span><span class="decl"><span class="nottickedoff">permVarSubstToSubst s = PermSubst $ RL.map PExpr_Var $ permVarSubstToNames s</span></span>
<span class="lineno"> 7252 </span>
<span class="lineno"> 7253 </span>varSubstVar :: PermVarSubst ctx -&gt; Mb ctx (ExprVar a) -&gt; ExprVar a
<span class="lineno"> 7254 </span><span class="decl"><span class="nottickedoff">varSubstVar s mb_x =</span>
<span class="lineno"> 7255 </span><span class="spaces">  </span><span class="nottickedoff">case mbNameBoundP mb_x of</span>
<span class="lineno"> 7256 </span><span class="spaces">    </span><span class="nottickedoff">Left memb -&gt; varSubstLookup s memb</span>
<span class="lineno"> 7257 </span><span class="spaces">    </span><span class="nottickedoff">Right x -&gt; x</span></span>
<span class="lineno"> 7258 </span>
<span class="lineno"> 7259 </span>instance SubstVar PermVarSubst Identity where
<span class="lineno"> 7260 </span>  <span class="decl"><span class="nottickedoff">extSubst s x = PermVarSubst_Cons s x</span></span>
<span class="lineno"> 7261 </span>  <span class="decl"><span class="nottickedoff">substExprVar s x =</span>
<span class="lineno"> 7262 </span><span class="spaces">    </span><span class="nottickedoff">case mbNameBoundP x of</span>
<span class="lineno"> 7263 </span><span class="spaces">      </span><span class="nottickedoff">Left memb -&gt; return $ PExpr_Var $ varSubstLookup s memb</span>
<span class="lineno"> 7264 </span><span class="spaces">      </span><span class="nottickedoff">Right y -&gt; return $ PExpr_Var y</span></span>
<span class="lineno"> 7265 </span>  {-
<span class="lineno"> 7266 </span>  substPermVar s mb_x =
<span class="lineno"> 7267 </span>    case mbNameBoundP mb_x of
<span class="lineno"> 7268 </span>      Left memb -&gt; noTypesInExprCtx memb
<span class="lineno"> 7269 </span>      Right x -&gt; return $ ValPerm_Var x -}
<span class="lineno"> 7270 </span>
<span class="lineno"> 7271 </span>-- | Wrapper function to apply a renamionmg to an expression type
<span class="lineno"> 7272 </span>varSubst :: Substable PermVarSubst a Identity =&gt; PermVarSubst ctx -&gt;
<span class="lineno"> 7273 </span>            Mb ctx a -&gt; a
<span class="lineno"> 7274 </span><span class="decl"><span class="nottickedoff">varSubst s mb = runIdentity $ genSubst s mb</span></span>
<span class="lineno"> 7275 </span>
<span class="lineno"> 7276 </span>-- | Build a list of all possible 'PermVarSubst's of variables in a 'NameMap'
<span class="lineno"> 7277 </span>-- for variables listed in a 'CruCtx'
<span class="lineno"> 7278 </span>allPermVarSubsts :: NameMap TypeRepr -&gt; CruCtx ctx -&gt; [PermVarSubst ctx]
<span class="lineno"> 7279 </span><span class="decl"><span class="nottickedoff">allPermVarSubsts nmap = helper (NameMap.assocs nmap) where</span>
<span class="lineno"> 7280 </span><span class="spaces">  </span><span class="nottickedoff">helper :: [NameAndElem TypeRepr] -&gt; CruCtx ctx -&gt; [PermVarSubst ctx]</span>
<span class="lineno"> 7281 </span><span class="spaces">  </span><span class="nottickedoff">helper _ CruCtxNil = return emptyVarSubst</span>
<span class="lineno"> 7282 </span><span class="spaces">  </span><span class="nottickedoff">helper ns_ts (CruCtxCons ctx tp) =</span>
<span class="lineno"> 7283 </span><span class="spaces">    </span><span class="nottickedoff">helper ns_ts ctx &gt;&gt;= \sbst -&gt;</span>
<span class="lineno"> 7284 </span><span class="spaces">    </span><span class="nottickedoff">map (consVarSubst sbst) (getVarsOfType ns_ts tp)</span>
<span class="lineno"> 7285 </span><span class="spaces">  </span><span class="nottickedoff">getVarsOfType :: [NameAndElem TypeRepr] -&gt; TypeRepr tp -&gt; [Name tp]</span>
<span class="lineno"> 7286 </span><span class="spaces">  </span><span class="nottickedoff">getVarsOfType [] _ = []</span>
<span class="lineno"> 7287 </span><span class="spaces">  </span><span class="nottickedoff">getVarsOfType (NameAndElem n tp':ns_ts) tp</span>
<span class="lineno"> 7288 </span><span class="spaces">    </span><span class="nottickedoff">| Just Refl &lt;- testEquality tp tp' = n : (getVarsOfType ns_ts tp)</span>
<span class="lineno"> 7289 </span><span class="spaces">  </span><span class="nottickedoff">getVarsOfType (_:ns_ts) tp = getVarsOfType ns_ts tp</span></span>
<span class="lineno"> 7290 </span>
<span class="lineno"> 7291 </span>
<span class="lineno"> 7292 </span>----------------------------------------------------------------------
<span class="lineno"> 7293 </span>-- * Partial Substitutions
<span class="lineno"> 7294 </span>----------------------------------------------------------------------
<span class="lineno"> 7295 </span>
<span class="lineno"> 7296 </span>-- | An element of a partial substitution = maybe an expression
<span class="lineno"> 7297 </span>newtype PSubstElem a = PSubstElem { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unPSubstElem</span></span></span> :: Maybe (PermExpr a) }
<span class="lineno"> 7298 </span>
<span class="lineno"> 7299 </span>-- | Partial substitutions assign expressions to some of the bound names in a
<span class="lineno"> 7300 </span>-- context
<span class="lineno"> 7301 </span>newtype PartialSubst ctx =
<span class="lineno"> 7302 </span>  PartialSubst { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unPartialSubst</span></span></span> :: RAssign PSubstElem ctx }
<span class="lineno"> 7303 </span>
<span class="lineno"> 7304 </span>-- | Build an empty partial substitution for a given set of variables, i.e., the
<span class="lineno"> 7305 </span>-- partial substitution that assigns no expressions to those variables
<span class="lineno"> 7306 </span>emptyPSubst :: RAssign any ctx -&gt; PartialSubst ctx
<span class="lineno"> 7307 </span><span class="decl"><span class="nottickedoff">emptyPSubst = PartialSubst . RL.map (\_ -&gt; PSubstElem Nothing)</span></span>
<span class="lineno"> 7308 </span>
<span class="lineno"> 7309 </span>-- | Build a fully-defined partial substitution from a regular substitution
<span class="lineno"> 7310 </span>psubstOfSubst :: PermSubst ctx -&gt; PartialSubst ctx
<span class="lineno"> 7311 </span><span class="decl"><span class="nottickedoff">psubstOfSubst = PartialSubst . RL.map (PSubstElem . Just) . unPermSubst</span></span>
<span class="lineno"> 7312 </span>
<span class="lineno"> 7313 </span>-- | Return the set of variables that have been assigned values by a partial
<span class="lineno"> 7314 </span>-- substitution inside a binding for all of its variables
<span class="lineno"> 7315 </span>psubstMbDom :: PartialSubst ctx -&gt; Mb ctx (NameSet CrucibleType)
<span class="lineno"> 7316 </span><span class="decl"><span class="nottickedoff">psubstMbDom (PartialSubst elems) =</span>
<span class="lineno"> 7317 </span><span class="spaces">  </span><span class="nottickedoff">nuMulti (RL.map (\_-&gt; Proxy) elems) $ \ns -&gt;</span>
<span class="lineno"> 7318 </span><span class="spaces">  </span><span class="nottickedoff">NameSet.fromList $ catMaybes $ RL.toList $</span>
<span class="lineno"> 7319 </span><span class="spaces">  </span><span class="nottickedoff">RL.map2 (\n (PSubstElem maybe_e) -&gt;</span>
<span class="lineno"> 7320 </span><span class="spaces">            </span><span class="nottickedoff">if isJust maybe_e</span>
<span class="lineno"> 7321 </span><span class="spaces">            </span><span class="nottickedoff">then Constant (Just $ SomeName n)</span>
<span class="lineno"> 7322 </span><span class="spaces">            </span><span class="nottickedoff">else Constant Nothing) ns elems</span></span>
<span class="lineno"> 7323 </span>
<span class="lineno"> 7324 </span>-- | Return the set of variables that have not been assigned values by a partial
<span class="lineno"> 7325 </span>-- substitution inside a binding for all of its variables
<span class="lineno"> 7326 </span>psubstMbUnsetVars :: PartialSubst ctx -&gt; Mb ctx (NameSet CrucibleType)
<span class="lineno"> 7327 </span><span class="decl"><span class="nottickedoff">psubstMbUnsetVars (PartialSubst elems) =</span>
<span class="lineno"> 7328 </span><span class="spaces">  </span><span class="nottickedoff">nuMulti (RL.map (\_ -&gt; Proxy) elems) $ \ns -&gt;</span>
<span class="lineno"> 7329 </span><span class="spaces">  </span><span class="nottickedoff">NameSet.fromList $ catMaybes $ RL.toList $</span>
<span class="lineno"> 7330 </span><span class="spaces">  </span><span class="nottickedoff">RL.map2 (\n (PSubstElem maybe_e) -&gt;</span>
<span class="lineno"> 7331 </span><span class="spaces">            </span><span class="nottickedoff">if maybe_e == Nothing</span>
<span class="lineno"> 7332 </span><span class="spaces">            </span><span class="nottickedoff">then Constant (Just $ SomeName n)</span>
<span class="lineno"> 7333 </span><span class="spaces">            </span><span class="nottickedoff">else Constant Nothing) ns elems</span></span>
<span class="lineno"> 7334 </span>
<span class="lineno"> 7335 </span>-- | Return a list of 'Bool's indicating which of the bound names in context
<span class="lineno"> 7336 </span>-- @ctx@ are unset in the given partial substitution
<span class="lineno"> 7337 </span>psubstUnsetVarsBool :: PartialSubst ctx -&gt; [Bool]
<span class="lineno"> 7338 </span><span class="decl"><span class="nottickedoff">psubstUnsetVarsBool (PartialSubst elems) =</span>
<span class="lineno"> 7339 </span><span class="spaces">  </span><span class="nottickedoff">RL.mapToList (\(PSubstElem maybe_e) -&gt; isNothing maybe_e) elems</span></span>
<span class="lineno"> 7340 </span>
<span class="lineno"> 7341 </span>-- | Set the expression associated with a variable in a partial substitution. It
<span class="lineno"> 7342 </span>-- is an error if it is already set.
<span class="lineno"> 7343 </span>psubstSet :: Member ctx a -&gt; PermExpr a -&gt; PartialSubst ctx -&gt;
<span class="lineno"> 7344 </span>             PartialSubst ctx
<span class="lineno"> 7345 </span><span class="decl"><span class="nottickedoff">psubstSet memb e (PartialSubst elems) =</span>
<span class="lineno"> 7346 </span><span class="spaces">  </span><span class="nottickedoff">PartialSubst $</span>
<span class="lineno"> 7347 </span><span class="spaces">  </span><span class="nottickedoff">RL.modify memb</span>
<span class="lineno"> 7348 </span><span class="spaces">  </span><span class="nottickedoff">(\pse -&gt; case pse of</span>
<span class="lineno"> 7349 </span><span class="spaces">      </span><span class="nottickedoff">PSubstElem Nothing -&gt; PSubstElem $ Just e</span>
<span class="lineno"> 7350 </span><span class="spaces">      </span><span class="nottickedoff">PSubstElem (Just _) -&gt; panic &quot;psubstSet&quot; [&quot;value already set for variable&quot;])</span>
<span class="lineno"> 7351 </span><span class="spaces">  </span><span class="nottickedoff">elems</span></span>
<span class="lineno"> 7352 </span>
<span class="lineno"> 7353 </span>-- | Extend a partial substitution with an unassigned variable
<span class="lineno"> 7354 </span>extPSubst :: PartialSubst ctx -&gt; PartialSubst (ctx :&gt; a)
<span class="lineno"> 7355 </span><span class="decl"><span class="nottickedoff">extPSubst (PartialSubst elems) = PartialSubst $ elems :&gt;: PSubstElem Nothing</span></span>
<span class="lineno"> 7356 </span>
<span class="lineno"> 7357 </span>-- | Shorten a partial substitution
<span class="lineno"> 7358 </span>unextPSubst :: PartialSubst (ctx :&gt; a) -&gt; PartialSubst ctx
<span class="lineno"> 7359 </span><span class="decl"><span class="nottickedoff">unextPSubst (PartialSubst (elems :&gt;: _)) = PartialSubst elems</span></span>
<span class="lineno"> 7360 </span>
<span class="lineno"> 7361 </span>-- | Complete a partial substitution into a total substitution, filling in zero
<span class="lineno"> 7362 </span>-- values using 'zeroOfType' if necessary
<span class="lineno"> 7363 </span>completePSubst :: CruCtx vars -&gt; PartialSubst vars -&gt; PermSubst vars
<span class="lineno"> 7364 </span><span class="decl"><span class="nottickedoff">completePSubst ctx (PartialSubst pselems) = PermSubst $ helper ctx pselems where</span>
<span class="lineno"> 7365 </span><span class="spaces">  </span><span class="nottickedoff">helper :: CruCtx vars -&gt; RAssign PSubstElem vars -&gt; RAssign PermExpr vars</span>
<span class="lineno"> 7366 </span><span class="spaces">  </span><span class="nottickedoff">helper _ MNil = MNil</span>
<span class="lineno"> 7367 </span><span class="spaces">  </span><span class="nottickedoff">helper (CruCtxCons ctx' tp) (pselems' :&gt;: pse) =</span>
<span class="lineno"> 7368 </span><span class="spaces">    </span><span class="nottickedoff">helper ctx' pselems' :&gt;:</span>
<span class="lineno"> 7369 </span><span class="spaces">    </span><span class="nottickedoff">(fromMaybe (zeroOfType tp) (unPSubstElem pse))</span></span>
<span class="lineno"> 7370 </span>
<span class="lineno"> 7371 </span>-- | Look up an optional expression in a partial substitution
<span class="lineno"> 7372 </span>psubstLookup :: PartialSubst ctx -&gt; Member ctx a -&gt; Maybe (PermExpr a)
<span class="lineno"> 7373 </span><span class="decl"><span class="nottickedoff">psubstLookup (PartialSubst m) memb = unPSubstElem $ RL.get memb m</span></span>
<span class="lineno"> 7374 </span>
<span class="lineno"> 7375 </span>-- | Get 'Proxy's for the domain of a 'PartialSubst'
<span class="lineno"> 7376 </span>psubstProxies :: PartialSubst ctx -&gt; RAssign Proxy ctx
<span class="lineno"> 7377 </span><span class="decl"><span class="nottickedoff">psubstProxies (PartialSubst m) = RL.map (const Proxy) m</span></span>
<span class="lineno"> 7378 </span>
<span class="lineno"> 7379 </span>-- | Append two partial substitutions
<span class="lineno"> 7380 </span>psubstAppend :: PartialSubst ctx1 -&gt; PartialSubst ctx2 -&gt;
<span class="lineno"> 7381 </span>                PartialSubst (ctx1 :++: ctx2)
<span class="lineno"> 7382 </span><span class="decl"><span class="nottickedoff">psubstAppend (PartialSubst elems1) (PartialSubst elems2) =</span>
<span class="lineno"> 7383 </span><span class="spaces">  </span><span class="nottickedoff">PartialSubst $ RL.append elems1 elems2</span></span>
<span class="lineno"> 7384 </span>
<span class="lineno"> 7385 </span>instance SubstVar PartialSubst Maybe where
<span class="lineno"> 7386 </span>  <span class="decl"><span class="nottickedoff">extSubst (PartialSubst elems) x =</span>
<span class="lineno"> 7387 </span><span class="spaces">    </span><span class="nottickedoff">PartialSubst $ elems :&gt;: PSubstElem (Just $ PExpr_Var x)</span></span>
<span class="lineno"> 7388 </span>  <span class="decl"><span class="nottickedoff">substExprVar s x =</span>
<span class="lineno"> 7389 </span><span class="spaces">    </span><span class="nottickedoff">case mbNameBoundP x of</span>
<span class="lineno"> 7390 </span><span class="spaces">      </span><span class="nottickedoff">Left memb -&gt; psubstLookup s memb</span>
<span class="lineno"> 7391 </span><span class="spaces">      </span><span class="nottickedoff">Right y -&gt; return $ PExpr_Var y</span></span>
<span class="lineno"> 7392 </span>  {-
<span class="lineno"> 7393 </span>  substPermVar s mb_x =
<span class="lineno"> 7394 </span>    case mbNameBoundP mb_x of
<span class="lineno"> 7395 </span>      Left memb -&gt; noTypesInExprCtx memb
<span class="lineno"> 7396 </span>      Right x -&gt; return $ ValPerm_Var x -}
<span class="lineno"> 7397 </span>
<span class="lineno"> 7398 </span>-- | Wrapper function to apply a partial substitution to an expression type
<span class="lineno"> 7399 </span>partialSubst :: Substable PartialSubst a Maybe =&gt; PartialSubst ctx -&gt;
<span class="lineno"> 7400 </span>                Mb ctx a -&gt; Maybe a
<span class="lineno"> 7401 </span><span class="decl"><span class="nottickedoff">partialSubst = genSubst</span></span>
<span class="lineno"> 7402 </span>
<span class="lineno"> 7403 </span>-- | Apply a partial substitution, raising an error (with the given string) if
<span class="lineno"> 7404 </span>-- this fails
<span class="lineno"> 7405 </span>partialSubstForce :: Substable PartialSubst a Maybe =&gt; PartialSubst ctx -&gt;
<span class="lineno"> 7406 </span>                     Mb ctx a -&gt; String -&gt; a
<span class="lineno"> 7407 </span><span class="decl"><span class="nottickedoff">partialSubstForce s mb msg = fromMaybe (error msg) $ partialSubst s mb</span></span>
<span class="lineno"> 7408 </span>
<span class="lineno"> 7409 </span>-- | Try to lift an expression out of a multi-binding by substituting with the
<span class="lineno"> 7410 </span>-- empty partial substitution
<span class="lineno"> 7411 </span>tryLift :: Substable PartialSubst a Maybe =&gt;
<span class="lineno"> 7412 </span>           Mb (ctx :: RList CrucibleType) a -&gt; Maybe a
<span class="lineno"> 7413 </span><span class="decl"><span class="nottickedoff">tryLift mb_a = partialSubst (emptyPSubst $ mbToProxy mb_a) mb_a</span></span>
<span class="lineno"> 7414 </span>
<span class="lineno"> 7415 </span>
<span class="lineno"> 7416 </span>----------------------------------------------------------------------
<span class="lineno"> 7417 </span>-- * Additional functions involving partial substitutions
<span class="lineno"> 7418 </span>----------------------------------------------------------------------
<span class="lineno"> 7419 </span>
<span class="lineno"> 7420 </span>-- | If there is exactly one 'BVFactor' in a list of 'BVFactor's which is
<span class="lineno"> 7421 </span>-- an unset variable, return the value of its 'BV', the witness that it
<span class="lineno"> 7422 </span>-- is bound, and the result of adding together the remaining factors
<span class="lineno"> 7423 </span>getUnsetBVFactor :: (1 &lt;= w, KnownNat w) =&gt; PartialSubst vars -&gt;
<span class="lineno"> 7424 </span>                    Mb vars [BVFactor w] -&gt;
<span class="lineno"> 7425 </span>                    Maybe (Integer, Member vars (BVType w), PermExpr (BVType w))
<span class="lineno"> 7426 </span><span class="decl"><span class="nottickedoff">getUnsetBVFactor psubst (mbList -&gt; mb_factors) =</span>
<span class="lineno"> 7427 </span><span class="spaces">  </span><span class="nottickedoff">case partitionEithers $ mbFactorNameBoundP psubst &lt;$&gt; mb_factors of</span>
<span class="lineno"> 7428 </span><span class="spaces">    </span><span class="nottickedoff">([(n, memb)], xs) -&gt; Just (n, memb, foldl' bvAdd (bvInt 0) xs)</span>
<span class="lineno"> 7429 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; Nothing</span></span>
<span class="lineno"> 7430 </span>
<span class="lineno"> 7431 </span>-- | If a 'BVFactor' in a binding is an unset variable, return the value
<span class="lineno"> 7432 </span>-- of its 'BV' and the witness that it is bound. Otherwise, return the
<span class="lineno"> 7433 </span>-- constant of the factor multiplied by the variable's value if it is
<span class="lineno"> 7434 </span>-- a set variable, or the constant of the factor multiplied by the
<span class="lineno"> 7435 </span>-- variable, if it is an unbound variable
<span class="lineno"> 7436 </span>mbFactorNameBoundP :: PartialSubst vars -&gt;
<span class="lineno"> 7437 </span>                      Mb vars (BVFactor w) -&gt;
<span class="lineno"> 7438 </span>                      Either (Integer, Member vars (BVType w))
<span class="lineno"> 7439 </span>                             (PermExpr (BVType w))
<span class="lineno"> 7440 </span><span class="decl"><span class="nottickedoff">mbFactorNameBoundP psubst (mbMatch -&gt; [nuMP| BVFactor (BV.BV mb_n) mb_z |]) =</span>
<span class="lineno"> 7441 </span><span class="spaces">  </span><span class="nottickedoff">let n = mbLift mb_n in</span>
<span class="lineno"> 7442 </span><span class="spaces">  </span><span class="nottickedoff">case mbNameBoundP mb_z of</span>
<span class="lineno"> 7443 </span><span class="spaces">    </span><span class="nottickedoff">Left memb -&gt; case psubstLookup psubst memb of</span>
<span class="lineno"> 7444 </span><span class="spaces">                   </span><span class="nottickedoff">Nothing -&gt; Left (n, memb)</span>
<span class="lineno"> 7445 </span><span class="spaces">                   </span><span class="nottickedoff">Just e' -&gt; Right (bvMultBV (BV.mkBV knownNat n) e')</span>
<span class="lineno"> 7446 </span><span class="spaces">    </span><span class="nottickedoff">Right z -&gt; Right (bvFactorExpr (BV.mkBV knownNat n) z)</span></span>
<span class="lineno"> 7447 </span>
<span class="lineno"> 7448 </span>
<span class="lineno"> 7449 </span>----------------------------------------------------------------------
<span class="lineno"> 7450 </span>-- * Abstracting Out Variables
<span class="lineno"> 7451 </span>----------------------------------------------------------------------
<span class="lineno"> 7452 </span>
<span class="lineno"> 7453 </span>mbMbApply :: Mb (ctx1 :: RList k1) (Mb (ctx2 :: RList k2) (a -&gt; b)) -&gt;
<span class="lineno"> 7454 </span>             Mb ctx1 (Mb ctx2 a) -&gt; Mb ctx1 (Mb ctx2 b)
<span class="lineno"> 7455 </span><span class="decl"><span class="nottickedoff">mbMbApply = mbApply . (fmap mbApply)</span></span>
<span class="lineno"> 7456 </span>
<span class="lineno"> 7457 </span>clMbMbApplyM :: Monad m =&gt;
<span class="lineno"> 7458 </span>                m (Closed (Mb (ctx1 :: RList k1)
<span class="lineno"> 7459 </span>                           (Mb (ctx2 :: RList k2) (a -&gt; b)))) -&gt;
<span class="lineno"> 7460 </span>                m (Closed (Mb ctx1 (Mb ctx2 a))) -&gt;
<span class="lineno"> 7461 </span>                m (Closed (Mb ctx1 (Mb ctx2 b)))
<span class="lineno"> 7462 </span><span class="decl"><span class="nottickedoff">clMbMbApplyM fm am =</span>
<span class="lineno"> 7463 </span><span class="spaces">  </span><span class="nottickedoff">(\f a -&gt; $(mkClosed [| mbMbApply |]) `clApply` f `clApply` a) &lt;$&gt; fm &lt;*&gt; am</span></span>
<span class="lineno"> 7464 </span>
<span class="lineno"> 7465 </span>absVarsReturnH :: Monad m =&gt; RAssign f1 (ctx1 :: RList k1) -&gt;
<span class="lineno"> 7466 </span>                  RAssign f2 (ctx2 :: RList k2) -&gt;
<span class="lineno"> 7467 </span>                  Closed a -&gt; m (Closed (Mb ctx1 (Mb ctx2 a)))
<span class="lineno"> 7468 </span><span class="decl"><span class="nottickedoff">absVarsReturnH fs1 fs2 cl_a =</span>
<span class="lineno"> 7469 </span><span class="spaces">  </span><span class="nottickedoff">return ( $(mkClosed [| \prxs1 prxs2 a -&gt;</span>
<span class="lineno"> 7470 </span><span class="spaces">                        </span><span class="nottickedoff">nuMulti prxs1 (const $ nuMulti prxs2 $ const a) |])</span>
<span class="lineno"> 7471 </span><span class="spaces">           </span><span class="nottickedoff">`clApply` closedProxies fs1 `clApply` closedProxies fs2</span>
<span class="lineno"> 7472 </span><span class="spaces">           </span><span class="nottickedoff">`clApply` cl_a)</span></span>
<span class="lineno"> 7473 </span>
<span class="lineno"> 7474 </span>-- | Map an 'RAssign' to a 'Closed' 'RAssign' of 'Proxy' objects
<span class="lineno"> 7475 </span>closedProxies :: RAssign f args -&gt; Closed (RAssign Proxy args)
<span class="lineno"> 7476 </span><span class="decl"><span class="nottickedoff">closedProxies = toClosed . mapRAssign (const Proxy)</span></span>
<span class="lineno"> 7477 </span>
<span class="lineno"> 7478 </span>-- | Class for types that support abstracting out all permission and expression
<span class="lineno"> 7479 </span>-- variables. If the abstraction succeeds, we get a closed element of the type
<span class="lineno"> 7480 </span>-- inside a binding for those permission and expression variables that are free
<span class="lineno"> 7481 </span>-- in the original input.
<span class="lineno"> 7482 </span>--
<span class="lineno"> 7483 </span>-- NOTE: if a variable occurs more than once, we associate it with the left-most
<span class="lineno"> 7484 </span>-- occurrence, i.e., the earliest binding
<span class="lineno"> 7485 </span>class AbstractVars a where
<span class="lineno"> 7486 </span>  abstractPEVars :: RAssign Name (pctx :: RList Type) -&gt;
<span class="lineno"> 7487 </span>                    RAssign Name (ectx :: RList CrucibleType) -&gt; a -&gt;
<span class="lineno"> 7488 </span>                    Maybe (Closed (Mb pctx (Mb ectx a)))
<span class="lineno"> 7489 </span>
<span class="lineno"> 7490 </span>-- | Call 'abstractPEVars' with only variables that have 'CrucibleType's
<span class="lineno"> 7491 </span>abstractVars :: AbstractVars a =&gt;
<span class="lineno"> 7492 </span>                RAssign Name (ctx :: RList CrucibleType) -&gt; a -&gt;
<span class="lineno"> 7493 </span>                Maybe (Closed (Mb ctx a))
<span class="lineno"> 7494 </span><span class="decl"><span class="nottickedoff">abstractVars ns a =</span>
<span class="lineno"> 7495 </span><span class="spaces">  </span><span class="nottickedoff">fmap (clApply $(mkClosed [| elimEmptyMb |])) $ abstractPEVars MNil ns a</span></span>
<span class="lineno"> 7496 </span>
<span class="lineno"> 7497 </span>-- | An expression or other object which the variables have been abstracted out
<span class="lineno"> 7498 </span>-- of, along with those variables that were abstracted out of it
<span class="lineno"> 7499 </span>data AbsObj a = forall ctx. AbsObj (RAssign ExprVar ctx) (Closed (Mb ctx a))
<span class="lineno"> 7500 </span>
<span class="lineno"> 7501 </span>-- | Find all free variables of an expresssion and abstract them out. Note that
<span class="lineno"> 7502 </span>-- this should always succeed, if 'freeVars' is implemented correctly.
<span class="lineno"> 7503 </span>abstractFreeVars :: (AbstractVars a, FreeVars a) =&gt; a -&gt; AbsObj a
<span class="lineno"> 7504 </span><span class="decl"><span class="nottickedoff">abstractFreeVars a</span>
<span class="lineno"> 7505 </span><span class="spaces">  </span><span class="nottickedoff">| Some ns &lt;- freeVarsRAssign a</span>
<span class="lineno"> 7506 </span><span class="spaces">  </span><span class="nottickedoff">, Just cl_mb_a &lt;- abstractVars ns a = AbsObj ns cl_mb_a</span>
<span class="lineno"> 7507 </span><span class="spaces"></span><span class="nottickedoff">abstractFreeVars _ = panic &quot;abstractFreeVars&quot; []</span></span>
<span class="lineno"> 7508 </span>
<span class="lineno"> 7509 </span>
<span class="lineno"> 7510 </span>-- | Try to close an expression by calling 'abstractPEVars' with an empty list
<span class="lineno"> 7511 </span>-- of expression variables
<span class="lineno"> 7512 </span>tryClose :: AbstractVars a =&gt; a -&gt; Maybe (Closed a)
<span class="lineno"> 7513 </span><span class="decl"><span class="nottickedoff">tryClose a =</span>
<span class="lineno"> 7514 </span><span class="spaces">  </span><span class="nottickedoff">fmap (clApply $(mkClosed [| elimEmptyMb . elimEmptyMb |])) $</span>
<span class="lineno"> 7515 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars MNil MNil a</span></span>
<span class="lineno"> 7516 </span>
<span class="lineno"> 7517 </span>instance AbstractVars (Name (a :: CrucibleType)) where
<span class="lineno"> 7518 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 (n :: Name a)</span>
<span class="lineno"> 7519 </span><span class="spaces">    </span><span class="nottickedoff">| Just memb &lt;- memberElem n ns2</span>
<span class="lineno"> 7520 </span><span class="spaces">    </span><span class="nottickedoff">= return ( $(mkClosed</span>
<span class="lineno"> 7521 </span><span class="spaces">                 </span><span class="nottickedoff">[| \prxs1 prxs2 memb' -&gt;</span>
<span class="lineno"> 7522 </span><span class="spaces">                   </span><span class="nottickedoff">nuMulti prxs1 (const $ nuMulti prxs2 (RL.get memb')) |])</span>
<span class="lineno"> 7523 </span><span class="spaces">               </span><span class="nottickedoff">`clApply` closedProxies ns1 `clApply` closedProxies ns2</span>
<span class="lineno"> 7524 </span><span class="spaces">               </span><span class="nottickedoff">`clApply` toClosed memb)</span>
<span class="lineno"> 7525 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars _ _ _ = Nothing</span></span>
<span class="lineno"> 7526 </span>
<span class="lineno"> 7527 </span>instance AbstractVars (Name (a :: Type)) where
<span class="lineno"> 7528 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 (n :: Name a)</span>
<span class="lineno"> 7529 </span><span class="spaces">    </span><span class="nottickedoff">| Just memb &lt;- memberElem n ns1</span>
<span class="lineno"> 7530 </span><span class="spaces">    </span><span class="nottickedoff">= return ( $(mkClosed</span>
<span class="lineno"> 7531 </span><span class="spaces">                 </span><span class="nottickedoff">[| \prxs1 prxs2 memb' -&gt;</span>
<span class="lineno"> 7532 </span><span class="spaces">                   </span><span class="nottickedoff">nuMulti prxs1 $ \ns -&gt;</span>
<span class="lineno"> 7533 </span><span class="spaces">                   </span><span class="nottickedoff">nuMulti prxs2 (const $ RL.get memb' ns) |])</span>
<span class="lineno"> 7534 </span><span class="spaces">               </span><span class="nottickedoff">`clApply` closedProxies ns1 `clApply` closedProxies ns2</span>
<span class="lineno"> 7535 </span><span class="spaces">               </span><span class="nottickedoff">`clApply` toClosed memb)</span>
<span class="lineno"> 7536 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars _ _ _ = Nothing</span></span>
<span class="lineno"> 7537 </span>
<span class="lineno"> 7538 </span>instance AbstractVars a =&gt; AbstractVars (Mb (ctx :: RList CrucibleType) a) where
<span class="lineno"> 7539 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 mb =</span>
<span class="lineno"> 7540 </span><span class="spaces">    </span><span class="nottickedoff">mbLift $</span>
<span class="lineno"> 7541 </span><span class="spaces">    </span><span class="nottickedoff">nuMultiWithElim1</span>
<span class="lineno"> 7542 </span><span class="spaces">    </span><span class="nottickedoff">(\ns a -&gt;</span>
<span class="lineno"> 7543 </span><span class="spaces">      </span><span class="nottickedoff">clApply ( $(mkClosed [| \prxs -&gt; fmap (mbSeparate prxs) |])</span>
<span class="lineno"> 7544 </span><span class="spaces">                </span><span class="nottickedoff">`clApply` closedProxies ns) &lt;$&gt;</span>
<span class="lineno"> 7545 </span><span class="spaces">      </span><span class="nottickedoff">abstractPEVars ns1 (append ns2 ns) a)</span>
<span class="lineno"> 7546 </span><span class="spaces">    </span><span class="nottickedoff">mb</span></span>
<span class="lineno"> 7547 </span>
<span class="lineno"> 7548 </span>instance AbstractVars a =&gt; AbstractVars (Mb (ctx :: RList Type) a) where
<span class="lineno"> 7549 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 mb =</span>
<span class="lineno"> 7550 </span><span class="spaces">    </span><span class="nottickedoff">mbLift $</span>
<span class="lineno"> 7551 </span><span class="spaces">    </span><span class="nottickedoff">nuMultiWithElim1</span>
<span class="lineno"> 7552 </span><span class="spaces">    </span><span class="nottickedoff">(\ns a -&gt;</span>
<span class="lineno"> 7553 </span><span class="spaces">      </span><span class="nottickedoff">clApply ( $(mkClosed [| \prxs2 prxs -&gt; fmap (mbSwap prxs2) . mbSeparate prxs |])</span>
<span class="lineno"> 7554 </span><span class="spaces">                </span><span class="nottickedoff">`clApply` closedProxies ns2</span>
<span class="lineno"> 7555 </span><span class="spaces">                </span><span class="nottickedoff">`clApply` closedProxies ns) &lt;$&gt;</span>
<span class="lineno"> 7556 </span><span class="spaces">      </span><span class="nottickedoff">abstractPEVars (append ns1 ns) ns2 a)</span>
<span class="lineno"> 7557 </span><span class="spaces">    </span><span class="nottickedoff">mb</span></span>
<span class="lineno"> 7558 </span>
<span class="lineno"> 7559 </span>instance AbstractVars (RAssign Name (ctx :: RList CrucibleType)) where
<span class="lineno"> 7560 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 MNil = absVarsReturnH ns1 ns2 $(mkClosed [| MNil |])</span>
<span class="lineno"> 7561 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (ns :&gt;: n) =</span>
<span class="lineno"> 7562 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| (:&gt;:) |])</span>
<span class="lineno"> 7563 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 ns</span>
<span class="lineno"> 7564 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 n</span></span>
<span class="lineno"> 7565 </span>
<span class="lineno"> 7566 </span>instance AbstractVars Integer where
<span class="lineno"> 7567 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 i = absVarsReturnH ns1 ns2 (toClosed i)</span></span>
<span class="lineno"> 7568 </span>
<span class="lineno"> 7569 </span>instance AbstractVars (BV w) where
<span class="lineno"> 7570 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 bv = absVarsReturnH ns1 ns2 (toClosed bv)</span></span>
<span class="lineno"> 7571 </span>
<span class="lineno"> 7572 </span>instance AbstractVars Bytes where
<span class="lineno"> 7573 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 bytes = absVarsReturnH ns1 ns2 (toClosed bytes)</span></span>
<span class="lineno"> 7574 </span>
<span class="lineno"> 7575 </span>instance AbstractVars Natural where
<span class="lineno"> 7576 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 n = absVarsReturnH ns1 ns2 (toClosed n)</span></span>
<span class="lineno"> 7577 </span>
<span class="lineno"> 7578 </span>instance AbstractVars Char where
<span class="lineno"> 7579 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 c = absVarsReturnH ns1 ns2 (toClosed c)</span></span>
<span class="lineno"> 7580 </span>
<span class="lineno"> 7581 </span>instance AbstractVars Bool where
<span class="lineno"> 7582 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 b = absVarsReturnH ns1 ns2 (toClosed b)</span></span>
<span class="lineno"> 7583 </span>
<span class="lineno"> 7584 </span>instance AbstractVars (Member ctx a) where
<span class="lineno"> 7585 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 memb = absVarsReturnH ns1 ns2 (toClosed memb)</span></span>
<span class="lineno"> 7586 </span>
<span class="lineno"> 7587 </span>instance AbstractVars a =&gt; AbstractVars (Maybe a) where
<span class="lineno"> 7588 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 Nothing =</span>
<span class="lineno"> 7589 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| Nothing |])</span>
<span class="lineno"> 7590 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (Just a) =</span>
<span class="lineno"> 7591 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| Just |])</span>
<span class="lineno"> 7592 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 a</span></span>
<span class="lineno"> 7593 </span>
<span class="lineno"> 7594 </span>instance AbstractVars a =&gt; AbstractVars [a] where
<span class="lineno"> 7595 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 [] =</span>
<span class="lineno"> 7596 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| [] |])</span>
<span class="lineno"> 7597 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (a:as) =</span>
<span class="lineno"> 7598 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| (:) |])</span>
<span class="lineno"> 7599 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 a</span>
<span class="lineno"> 7600 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 as</span></span>
<span class="lineno"> 7601 </span>
<span class="lineno"> 7602 </span>instance (AbstractVars a, AbstractVars b) =&gt; AbstractVars (a,b) where
<span class="lineno"> 7603 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 (a,b) =</span>
<span class="lineno"> 7604 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| (,) |])</span>
<span class="lineno"> 7605 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 a</span>
<span class="lineno"> 7606 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 b</span></span>
<span class="lineno"> 7607 </span>
<span class="lineno"> 7608 </span>instance AbstractVars (PermExpr a) where
<span class="lineno"> 7609 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 (PExpr_Var x) =</span>
<span class="lineno"> 7610 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| PExpr_Var |])</span>
<span class="lineno"> 7611 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 x</span>
<span class="lineno"> 7612 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 PExpr_Unit =</span>
<span class="lineno"> 7613 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| PExpr_Unit |])</span>
<span class="lineno"> 7614 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (PExpr_Bool b) =</span>
<span class="lineno"> 7615 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| PExpr_Bool |])</span>
<span class="lineno"> 7616 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 b</span>
<span class="lineno"> 7617 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (PExpr_Nat i) =</span>
<span class="lineno"> 7618 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| PExpr_Nat |])</span>
<span class="lineno"> 7619 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 i</span>
<span class="lineno"> 7620 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (PExpr_String str) =</span>
<span class="lineno"> 7621 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 ($(mkClosed [| PExpr_String |])</span>
<span class="lineno"> 7622 </span><span class="spaces">                            </span><span class="nottickedoff">`clApply` toClosed str)</span>
<span class="lineno"> 7623 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (PExpr_BV factors k) =</span>
<span class="lineno"> 7624 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| PExpr_BV |])</span>
<span class="lineno"> 7625 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 factors</span>
<span class="lineno"> 7626 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 k</span>
<span class="lineno"> 7627 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (PExpr_Struct es) =</span>
<span class="lineno"> 7628 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| PExpr_Struct |])</span>
<span class="lineno"> 7629 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 es</span>
<span class="lineno"> 7630 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 PExpr_Always =</span>
<span class="lineno"> 7631 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| PExpr_Always |])</span>
<span class="lineno"> 7632 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (PExpr_LLVMWord e) =</span>
<span class="lineno"> 7633 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| PExpr_LLVMWord |])</span>
<span class="lineno"> 7634 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 e</span>
<span class="lineno"> 7635 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (PExpr_LLVMOffset x e) =</span>
<span class="lineno"> 7636 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| PExpr_LLVMOffset |])</span>
<span class="lineno"> 7637 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 x</span>
<span class="lineno"> 7638 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 e</span>
<span class="lineno"> 7639 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (PExpr_Fun fh) =</span>
<span class="lineno"> 7640 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 ($(mkClosed [| PExpr_Fun |]) `clApply` toClosed fh)</span>
<span class="lineno"> 7641 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 PExpr_PermListNil =</span>
<span class="lineno"> 7642 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 ($(mkClosed [| PExpr_PermListNil |]))</span>
<span class="lineno"> 7643 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (PExpr_PermListCons tp e p l) =</span>
<span class="lineno"> 7644 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 ($(mkClosed [| PExpr_PermListCons |])</span>
<span class="lineno"> 7645 </span><span class="spaces">                           </span><span class="nottickedoff">`clApply` toClosed tp)</span>
<span class="lineno"> 7646 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 e</span>
<span class="lineno"> 7647 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 p</span>
<span class="lineno"> 7648 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 l</span>
<span class="lineno"> 7649 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (PExpr_RWModality rw) =</span>
<span class="lineno"> 7650 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 ($(mkClosed [| PExpr_RWModality |])</span>
<span class="lineno"> 7651 </span><span class="spaces">                            </span><span class="nottickedoff">`clApply` toClosed rw)</span>
<span class="lineno"> 7652 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 PExpr_EmptyShape =</span>
<span class="lineno"> 7653 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| PExpr_EmptyShape |])</span>
<span class="lineno"> 7654 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (PExpr_NamedShape rw l nmsh args) =</span>
<span class="lineno"> 7655 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| PExpr_NamedShape |])</span>
<span class="lineno"> 7656 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 rw</span>
<span class="lineno"> 7657 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 l</span>
<span class="lineno"> 7658 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 nmsh</span>
<span class="lineno"> 7659 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 args</span>
<span class="lineno"> 7660 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (PExpr_EqShape len b) =</span>
<span class="lineno"> 7661 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 ($(mkClosed [| PExpr_EqShape |]))</span>
<span class="lineno"> 7662 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 len</span>
<span class="lineno"> 7663 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 b</span>
<span class="lineno"> 7664 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (PExpr_PtrShape maybe_rw maybe_l sh) =</span>
<span class="lineno"> 7665 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 ($(mkClosed [| PExpr_PtrShape |]))</span>
<span class="lineno"> 7666 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 maybe_rw</span>
<span class="lineno"> 7667 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 maybe_l</span>
<span class="lineno"> 7668 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 sh</span>
<span class="lineno"> 7669 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (PExpr_FieldShape fsh) =</span>
<span class="lineno"> 7670 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 ($(mkClosed [| PExpr_FieldShape |]))</span>
<span class="lineno"> 7671 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 fsh</span>
<span class="lineno"> 7672 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (PExpr_ArrayShape len stride sh) =</span>
<span class="lineno"> 7673 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 ($(mkClosed [| flip PExpr_ArrayShape |])</span>
<span class="lineno"> 7674 </span><span class="spaces">                           </span><span class="nottickedoff">`clApply` toClosed stride)</span>
<span class="lineno"> 7675 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 len</span>
<span class="lineno"> 7676 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 sh</span>
<span class="lineno"> 7677 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (PExpr_TupShape sh) =</span>
<span class="lineno"> 7678 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| PExpr_TupShape |])</span>
<span class="lineno"> 7679 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 sh</span>
<span class="lineno"> 7680 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (PExpr_SeqShape sh1 sh2) =</span>
<span class="lineno"> 7681 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| PExpr_SeqShape |])</span>
<span class="lineno"> 7682 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 sh1</span>
<span class="lineno"> 7683 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 sh2</span>
<span class="lineno"> 7684 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (PExpr_OrShape sh1 sh2) =</span>
<span class="lineno"> 7685 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| PExpr_OrShape |])</span>
<span class="lineno"> 7686 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 sh1</span>
<span class="lineno"> 7687 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 sh2</span>
<span class="lineno"> 7688 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (PExpr_ExShape mb_sh) =</span>
<span class="lineno"> 7689 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| PExpr_ExShape |])</span>
<span class="lineno"> 7690 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 mb_sh</span>
<span class="lineno"> 7691 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 PExpr_FalseShape =</span>
<span class="lineno"> 7692 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| PExpr_FalseShape |])</span>
<span class="lineno"> 7693 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (PExpr_ValPerm p) =</span>
<span class="lineno"> 7694 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 ($(mkClosed [| PExpr_ValPerm |]))</span>
<span class="lineno"> 7695 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 p</span></span>
<span class="lineno"> 7696 </span>
<span class="lineno"> 7697 </span>instance AbstractVars (PermExprs as) where
<span class="lineno"> 7698 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 PExprs_Nil =</span>
<span class="lineno"> 7699 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| PExprs_Nil |])</span>
<span class="lineno"> 7700 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (PExprs_Cons es e) =</span>
<span class="lineno"> 7701 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| PExprs_Cons |])</span>
<span class="lineno"> 7702 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 es</span>
<span class="lineno"> 7703 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 e</span></span>
<span class="lineno"> 7704 </span>
<span class="lineno"> 7705 </span>instance AbstractVars (BVFactor w) where
<span class="lineno"> 7706 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 (BVFactor i x) =</span>
<span class="lineno"> 7707 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| BVFactor |])</span>
<span class="lineno"> 7708 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 i</span>
<span class="lineno"> 7709 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 x</span></span>
<span class="lineno"> 7710 </span>
<span class="lineno"> 7711 </span>instance AbstractVars (BVRange w) where
<span class="lineno"> 7712 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 (BVRange e1 e2) =</span>
<span class="lineno"> 7713 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| BVRange |])</span>
<span class="lineno"> 7714 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 e1</span>
<span class="lineno"> 7715 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 e2</span></span>
<span class="lineno"> 7716 </span>
<span class="lineno"> 7717 </span>instance AbstractVars (BVProp w) where
<span class="lineno"> 7718 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 (BVProp_Eq e1 e2) =</span>
<span class="lineno"> 7719 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| BVProp_Eq |])</span>
<span class="lineno"> 7720 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 e1</span>
<span class="lineno"> 7721 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 e2</span>
<span class="lineno"> 7722 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (BVProp_Neq e1 e2) =</span>
<span class="lineno"> 7723 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| BVProp_Neq |])</span>
<span class="lineno"> 7724 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 e1</span>
<span class="lineno"> 7725 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 e2</span>
<span class="lineno"> 7726 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (BVProp_ULt e1 e2) =</span>
<span class="lineno"> 7727 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| BVProp_ULt |])</span>
<span class="lineno"> 7728 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 e1</span>
<span class="lineno"> 7729 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 e2</span>
<span class="lineno"> 7730 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (BVProp_ULeq e1 e2) =</span>
<span class="lineno"> 7731 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| BVProp_ULeq |])</span>
<span class="lineno"> 7732 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 e1</span>
<span class="lineno"> 7733 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 e2</span>
<span class="lineno"> 7734 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (BVProp_ULeq_Diff e1 e2 e3) =</span>
<span class="lineno"> 7735 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| BVProp_ULeq_Diff |])</span>
<span class="lineno"> 7736 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 e1</span>
<span class="lineno"> 7737 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 e2</span>
<span class="lineno"> 7738 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 e3</span></span>
<span class="lineno"> 7739 </span>
<span class="lineno"> 7740 </span>instance AbstractVars (AtomicPerm a) where
<span class="lineno"> 7741 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 (Perm_LLVMField fp) =</span>
<span class="lineno"> 7742 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| Perm_LLVMField |])</span>
<span class="lineno"> 7743 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 fp</span>
<span class="lineno"> 7744 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (Perm_LLVMArray ap) =</span>
<span class="lineno"> 7745 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| Perm_LLVMArray |])</span>
<span class="lineno"> 7746 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 ap</span>
<span class="lineno"> 7747 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (Perm_LLVMBlock bp) =</span>
<span class="lineno"> 7748 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| Perm_LLVMBlock |])</span>
<span class="lineno"> 7749 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 bp</span>
<span class="lineno"> 7750 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (Perm_LLVMFree e) =</span>
<span class="lineno"> 7751 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| Perm_LLVMFree |])</span>
<span class="lineno"> 7752 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 e</span>
<span class="lineno"> 7753 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (Perm_LLVMFunPtr tp p) =</span>
<span class="lineno"> 7754 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2</span>
<span class="lineno"> 7755 </span><span class="spaces">    </span><span class="nottickedoff">($(mkClosed [| Perm_LLVMFunPtr |]) `clApply` toClosed tp)</span>
<span class="lineno"> 7756 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 p</span>
<span class="lineno"> 7757 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 Perm_IsLLVMPtr =</span>
<span class="lineno"> 7758 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| Perm_IsLLVMPtr |])</span>
<span class="lineno"> 7759 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (Perm_LLVMBlockShape sh) =</span>
<span class="lineno"> 7760 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| Perm_LLVMBlockShape |])</span>
<span class="lineno"> 7761 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 sh</span>
<span class="lineno"> 7762 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (Perm_LLVMFrame fp) =</span>
<span class="lineno"> 7763 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| Perm_LLVMFrame |])</span>
<span class="lineno"> 7764 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 fp</span>
<span class="lineno"> 7765 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (Perm_LOwned ls tps_in tps_out ps_in ps_out) =</span>
<span class="lineno"> 7766 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| Perm_LOwned |])</span>
<span class="lineno"> 7767 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 ls</span>
<span class="lineno"> 7768 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` (absVarsReturnH ns1 ns2 $ toClosed tps_in)</span>
<span class="lineno"> 7769 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` (absVarsReturnH ns1 ns2 $ toClosed tps_out)</span>
<span class="lineno"> 7770 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 ps_in</span>
<span class="lineno"> 7771 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 ps_out</span>
<span class="lineno"> 7772 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (Perm_LOwnedSimple tps lops) =</span>
<span class="lineno"> 7773 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 ($(mkClosed [| Perm_LOwnedSimple |])</span>
<span class="lineno"> 7774 </span><span class="spaces">                            </span><span class="nottickedoff">`clApply` toClosed tps)</span>
<span class="lineno"> 7775 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 lops</span>
<span class="lineno"> 7776 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (Perm_LCurrent e) =</span>
<span class="lineno"> 7777 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| Perm_LCurrent |])</span>
<span class="lineno"> 7778 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 e</span>
<span class="lineno"> 7779 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 Perm_LFinished =</span>
<span class="lineno"> 7780 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| Perm_LFinished |])</span>
<span class="lineno"> 7781 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (Perm_Struct ps) =</span>
<span class="lineno"> 7782 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| Perm_Struct |])</span>
<span class="lineno"> 7783 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 ps</span>
<span class="lineno"> 7784 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (Perm_Fun fperm) =</span>
<span class="lineno"> 7785 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| Perm_Fun |])</span>
<span class="lineno"> 7786 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 fperm</span>
<span class="lineno"> 7787 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (Perm_BVProp prop) =</span>
<span class="lineno"> 7788 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| Perm_BVProp |])</span>
<span class="lineno"> 7789 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 prop</span>
<span class="lineno"> 7790 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 Perm_Any =</span>
<span class="lineno"> 7791 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| Perm_Any |])</span>
<span class="lineno"> 7792 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (Perm_NamedConj n args off) =</span>
<span class="lineno"> 7793 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| Perm_NamedConj |])</span>
<span class="lineno"> 7794 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 n</span>
<span class="lineno"> 7795 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 args</span>
<span class="lineno"> 7796 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 off</span></span>
<span class="lineno"> 7797 </span>
<span class="lineno"> 7798 </span>instance AbstractVars (ValuePerm a) where
<span class="lineno"> 7799 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 (ValPerm_Var x off) =</span>
<span class="lineno"> 7800 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| ValPerm_Var |])</span>
<span class="lineno"> 7801 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 x</span>
<span class="lineno"> 7802 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 off</span>
<span class="lineno"> 7803 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (ValPerm_Eq e) =</span>
<span class="lineno"> 7804 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| ValPerm_Eq |])</span>
<span class="lineno"> 7805 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 e</span>
<span class="lineno"> 7806 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (ValPerm_Or p1 p2) =</span>
<span class="lineno"> 7807 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| ValPerm_Or |])</span>
<span class="lineno"> 7808 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 p1</span>
<span class="lineno"> 7809 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 p2</span>
<span class="lineno"> 7810 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (ValPerm_Exists p) =</span>
<span class="lineno"> 7811 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| ValPerm_Exists |])</span>
<span class="lineno"> 7812 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 p</span>
<span class="lineno"> 7813 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (ValPerm_Named n args off) =</span>
<span class="lineno"> 7814 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| ValPerm_Named |])</span>
<span class="lineno"> 7815 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 n</span>
<span class="lineno"> 7816 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 args</span>
<span class="lineno"> 7817 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 off</span>
<span class="lineno"> 7818 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (ValPerm_Conj ps) =</span>
<span class="lineno"> 7819 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| ValPerm_Conj |])</span>
<span class="lineno"> 7820 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 ps</span>
<span class="lineno"> 7821 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 ValPerm_False =</span>
<span class="lineno"> 7822 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| ValPerm_False |])</span></span>
<span class="lineno"> 7823 </span>
<span class="lineno"> 7824 </span>instance AbstractVars (ValuePerms as) where
<span class="lineno"> 7825 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 ValPerms_Nil =</span>
<span class="lineno"> 7826 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| ValPerms_Nil |])</span>
<span class="lineno"> 7827 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (ValPerms_Cons ps p) =</span>
<span class="lineno"> 7828 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| ValPerms_Cons |])</span>
<span class="lineno"> 7829 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 ps</span>
<span class="lineno"> 7830 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 p</span></span>
<span class="lineno"> 7831 </span>
<span class="lineno"> 7832 </span>instance AbstractVars RWModality where
<span class="lineno"> 7833 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 Write =</span>
<span class="lineno"> 7834 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| Write |])</span>
<span class="lineno"> 7835 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 Read =</span>
<span class="lineno"> 7836 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| Read |])</span></span>
<span class="lineno"> 7837 </span>
<span class="lineno"> 7838 </span>instance AbstractVars (LLVMFieldPerm w sz) where
<span class="lineno"> 7839 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 (LLVMFieldPerm rw ls off p) =</span>
<span class="lineno"> 7840 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| LLVMFieldPerm |])</span>
<span class="lineno"> 7841 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 rw</span>
<span class="lineno"> 7842 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 ls</span>
<span class="lineno"> 7843 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 off</span>
<span class="lineno"> 7844 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 p</span></span>
<span class="lineno"> 7845 </span>
<span class="lineno"> 7846 </span>instance AbstractVars (LLVMArrayPerm w) where
<span class="lineno"> 7847 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 (LLVMArrayPerm rw l off len str flds bs) =</span>
<span class="lineno"> 7848 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| LLVMArrayPerm |])</span>
<span class="lineno"> 7849 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 rw</span>
<span class="lineno"> 7850 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 l</span>
<span class="lineno"> 7851 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 off</span>
<span class="lineno"> 7852 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 len</span>
<span class="lineno"> 7853 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 str</span>
<span class="lineno"> 7854 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 flds</span>
<span class="lineno"> 7855 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 bs</span></span>
<span class="lineno"> 7856 </span>
<span class="lineno"> 7857 </span>instance AbstractVars (LLVMArrayIndex w) where
<span class="lineno"> 7858 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 (LLVMArrayIndex ix off) =</span>
<span class="lineno"> 7859 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| LLVMArrayIndex |])</span>
<span class="lineno"> 7860 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 ix</span>
<span class="lineno"> 7861 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 off</span></span>
<span class="lineno"> 7862 </span>
<span class="lineno"> 7863 </span>instance AbstractVars (PermOffset a) where
<span class="lineno"> 7864 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 NoPermOffset =</span>
<span class="lineno"> 7865 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| NoPermOffset |])</span>
<span class="lineno"> 7866 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (LLVMPermOffset off) =</span>
<span class="lineno"> 7867 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| LLVMPermOffset |])</span>
<span class="lineno"> 7868 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 off</span></span>
<span class="lineno"> 7869 </span>
<span class="lineno"> 7870 </span>instance AbstractVars (LLVMArrayBorrow w) where
<span class="lineno"> 7871 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 (FieldBorrow ix) =</span>
<span class="lineno"> 7872 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| FieldBorrow |])</span>
<span class="lineno"> 7873 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 ix</span>
<span class="lineno"> 7874 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (RangeBorrow r) =</span>
<span class="lineno"> 7875 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| RangeBorrow |])</span>
<span class="lineno"> 7876 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 r</span></span>
<span class="lineno"> 7877 </span>
<span class="lineno"> 7878 </span>instance AbstractVars (LLVMFieldShape w) where
<span class="lineno"> 7879 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 (LLVMFieldShape p) =</span>
<span class="lineno"> 7880 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| LLVMFieldShape |])</span>
<span class="lineno"> 7881 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 p</span></span>
<span class="lineno"> 7882 </span>
<span class="lineno"> 7883 </span>instance AbstractVars (LLVMBlockPerm w) where
<span class="lineno"> 7884 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 (LLVMBlockPerm rw l off len sh) =</span>
<span class="lineno"> 7885 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| LLVMBlockPerm |])</span>
<span class="lineno"> 7886 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 rw</span>
<span class="lineno"> 7887 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 l</span>
<span class="lineno"> 7888 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 off</span>
<span class="lineno"> 7889 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 len</span>
<span class="lineno"> 7890 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 sh</span></span>
<span class="lineno"> 7891 </span>
<span class="lineno"> 7892 </span>instance AbstractVars (DistPerms ps) where
<span class="lineno"> 7893 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 DistPermsNil =</span>
<span class="lineno"> 7894 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| DistPermsNil |])</span>
<span class="lineno"> 7895 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (DistPermsCons perms x p) =</span>
<span class="lineno"> 7896 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| DistPermsCons |])</span>
<span class="lineno"> 7897 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 perms</span>
<span class="lineno"> 7898 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 x `clMbMbApplyM` abstractPEVars ns1 ns2 p</span></span>
<span class="lineno"> 7899 </span>
<span class="lineno"> 7900 </span>instance AbstractVars (ExprAndPerm a) where
<span class="lineno"> 7901 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 (ExprAndPerm e p) =</span>
<span class="lineno"> 7902 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| ExprAndPerm |])</span>
<span class="lineno"> 7903 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 e</span>
<span class="lineno"> 7904 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 p</span></span>
<span class="lineno"> 7905 </span>
<span class="lineno"> 7906 </span>instance AbstractVars (ExprPerms a) where
<span class="lineno"> 7907 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 MNil =</span>
<span class="lineno"> 7908 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| MNil |])</span>
<span class="lineno"> 7909 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (ps :&gt;: p) =</span>
<span class="lineno"> 7910 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| (:&gt;:) |])</span>
<span class="lineno"> 7911 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 ps</span>
<span class="lineno"> 7912 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 p</span></span>
<span class="lineno"> 7913 </span>
<span class="lineno"> 7914 </span>instance AbstractVars (FunPerm ghosts args gouts ret) where
<span class="lineno"> 7915 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 (FunPerm ghosts args gouts ret perms_in perms_out) =</span>
<span class="lineno"> 7916 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2</span>
<span class="lineno"> 7917 </span><span class="spaces">    </span><span class="nottickedoff">($(mkClosed [| FunPerm |])</span>
<span class="lineno"> 7918 </span><span class="spaces">     </span><span class="nottickedoff">`clApply` toClosed ghosts `clApply` toClosed args</span>
<span class="lineno"> 7919 </span><span class="spaces">     </span><span class="nottickedoff">`clApply` toClosed gouts `clApply` toClosed ret)</span>
<span class="lineno"> 7920 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 perms_in</span>
<span class="lineno"> 7921 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 perms_out</span></span>
<span class="lineno"> 7922 </span>
<span class="lineno"> 7923 </span>instance AbstractVars (NamedShape b args w) where
<span class="lineno"> 7924 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 (NamedShape nm args body) =</span>
<span class="lineno"> 7925 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 ($(mkClosed [| NamedShape |])</span>
<span class="lineno"> 7926 </span><span class="spaces">                             </span><span class="nottickedoff">`clApply` toClosed nm `clApply` toClosed args)</span>
<span class="lineno"> 7927 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 body</span></span>
<span class="lineno"> 7928 </span>
<span class="lineno"> 7929 </span>instance AbstractVars (NamedShapeBody b args w) where
<span class="lineno"> 7930 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 (DefinedShapeBody mb_sh) =</span>
<span class="lineno"> 7931 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 $(mkClosed [| DefinedShapeBody |])</span>
<span class="lineno"> 7932 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 mb_sh</span>
<span class="lineno"> 7933 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (OpaqueShapeBody mb_len trans_id desc_id) =</span>
<span class="lineno"> 7934 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 ($(mkClosed [| \i1 i2 l -&gt; OpaqueShapeBody l i1 i2 |])</span>
<span class="lineno"> 7935 </span><span class="spaces">                            </span><span class="nottickedoff">`clApply` toClosed trans_id</span>
<span class="lineno"> 7936 </span><span class="spaces">                            </span><span class="nottickedoff">`clApply` toClosed desc_id)</span>
<span class="lineno"> 7937 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 mb_len</span>
<span class="lineno"> 7938 </span><span class="spaces">  </span><span class="nottickedoff">abstractPEVars ns1 ns2 (RecShapeBody mb_sh trans_id desc_id) =</span>
<span class="lineno"> 7939 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2 ($(mkClosed</span>
<span class="lineno"> 7940 </span><span class="spaces">                              </span><span class="nottickedoff">[| \i1 i2 l -&gt; RecShapeBody l i1 i2 |])</span>
<span class="lineno"> 7941 </span><span class="spaces">                            </span><span class="nottickedoff">`clApply` toClosed trans_id</span>
<span class="lineno"> 7942 </span><span class="spaces">                            </span><span class="nottickedoff">`clApply` toClosed desc_id)</span>
<span class="lineno"> 7943 </span><span class="spaces">    </span><span class="nottickedoff">`clMbMbApplyM` abstractPEVars ns1 ns2 mb_sh</span></span>
<span class="lineno"> 7944 </span>
<span class="lineno"> 7945 </span>instance AbstractVars (NamedPermName ns args a) where
<span class="lineno"> 7946 </span>  <span class="decl"><span class="nottickedoff">abstractPEVars ns1 ns2 (NamedPermName n tp args ns reachConstr) =</span>
<span class="lineno"> 7947 </span><span class="spaces">    </span><span class="nottickedoff">absVarsReturnH ns1 ns2</span>
<span class="lineno"> 7948 </span><span class="spaces">    </span><span class="nottickedoff">($(mkClosed [| NamedPermName |])</span>
<span class="lineno"> 7949 </span><span class="spaces">     </span><span class="nottickedoff">`clApply` toClosed n `clApply` toClosed tp `clApply` toClosed args</span>
<span class="lineno"> 7950 </span><span class="spaces">     </span><span class="nottickedoff">`clApply` toClosed ns`clApply` toClosed reachConstr)</span></span>
<span class="lineno"> 7951 </span>
<span class="lineno"> 7952 </span>
<span class="lineno"> 7953 </span>----------------------------------------------------------------------
<span class="lineno"> 7954 </span>-- * Abstracting out named shapes
<span class="lineno"> 7955 </span>----------------------------------------------------------------------
<span class="lineno"> 7956 </span>
<span class="lineno"> 7957 </span>-- | An existentially quantified LLVM shape with a name, but that is considered
<span class="lineno"> 7958 </span>-- \&quot;partial\&quot; because it has not been added to the environment yet
<span class="lineno"> 7959 </span>data SomePartialNamedShape w where
<span class="lineno"> 7960 </span>  NonRecShape :: String -&gt; CruCtx args -&gt; Mb args (PermExpr (LLVMShapeType w))
<span class="lineno"> 7961 </span>              -&gt; SomePartialNamedShape w
<span class="lineno"> 7962 </span>  RecShape :: String -&gt; CruCtx args
<span class="lineno"> 7963 </span>           -&gt; Mb (args :&gt; LLVMShapeType w) (PermExpr (LLVMShapeType w))
<span class="lineno"> 7964 </span>           -&gt; SomePartialNamedShape w
<span class="lineno"> 7965 </span>
<span class="lineno"> 7966 </span>-- | An existentially quantified LLVM shape applied to some arguments
<span class="lineno"> 7967 </span>data SomeNamedShapeApp w where
<span class="lineno"> 7968 </span>  SomeNamedShapeApp :: String -&gt; CruCtx args -&gt; PermExprs args -&gt;
<span class="lineno"> 7969 </span>                       NatRepr w -&gt; SomeNamedShapeApp w
<span class="lineno"> 7970 </span>
<span class="lineno"> 7971 </span>class AbstractNamedShape w a where
<span class="lineno"> 7972 </span>  abstractNSM :: a -&gt; ReaderT (SomeNamedShapeApp w) Maybe
<span class="lineno"> 7973 </span>                              (Binding (LLVMShapeType w) a)
<span class="lineno"> 7974 </span>
<span class="lineno"> 7975 </span>abstractNS :: (KnownNat w, AbstractNamedShape w a) =&gt;
<span class="lineno"> 7976 </span>              String -&gt; CruCtx args -&gt; PermExprs args -&gt;
<span class="lineno"> 7977 </span>              a -&gt; Maybe (Binding (LLVMShapeType w) a)
<span class="lineno"> 7978 </span><span class="decl"><span class="nottickedoff">abstractNS nsh args_ctx args x = runReaderT (abstractNSM x) nshApp</span>
<span class="lineno"> 7979 </span><span class="spaces">  </span><span class="nottickedoff">where nshApp = SomeNamedShapeApp nsh args_ctx args knownNat</span></span>
<span class="lineno"> 7980 </span>
<span class="lineno"> 7981 </span>pureBindingM :: Monad m =&gt; b -&gt; m (Binding a b)
<span class="lineno"> 7982 </span><span class="decl"><span class="nottickedoff">pureBindingM = pure . nu . const</span></span>
<span class="lineno"> 7983 </span>
<span class="lineno"> 7984 </span>instance (NuMatching a, AbstractNamedShape w a) =&gt;
<span class="lineno"> 7985 </span>         AbstractNamedShape w (Mb ctx a) where
<span class="lineno"> 7986 </span>  <span class="decl"><span class="nottickedoff">abstractNSM = fmap (mbSwap RL.typeCtxProxies) . mbM . fmap abstractNSM</span></span>
<span class="lineno"> 7987 </span>
<span class="lineno"> 7988 </span>instance AbstractNamedShape w Integer where
<span class="lineno"> 7989 </span>  <span class="decl"><span class="nottickedoff">abstractNSM = pureBindingM</span></span>
<span class="lineno"> 7990 </span>
<span class="lineno"> 7991 </span>instance AbstractNamedShape w a =&gt; AbstractNamedShape w (Maybe a) where
<span class="lineno"> 7992 </span>  <span class="decl"><span class="nottickedoff">abstractNSM (Just x) = fmap Just &lt;$&gt; abstractNSM x</span>
<span class="lineno"> 7993 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM Nothing = pureBindingM Nothing</span></span>
<span class="lineno"> 7994 </span>
<span class="lineno"> 7995 </span>instance AbstractNamedShape w a =&gt; AbstractNamedShape w [a] where
<span class="lineno"> 7996 </span>  <span class="decl"><span class="nottickedoff">abstractNSM [] = pureBindingM []</span>
<span class="lineno"> 7997 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (x:xs) = mbMap2 (:) &lt;$&gt; abstractNSM x &lt;*&gt; abstractNSM xs</span></span>
<span class="lineno"> 7998 </span>
<span class="lineno"> 7999 </span>instance (AbstractNamedShape w a, AbstractNamedShape w b) =&gt;
<span class="lineno"> 8000 </span>         AbstractNamedShape w (a, b) where
<span class="lineno"> 8001 </span>  <span class="decl"><span class="nottickedoff">abstractNSM (x,y) = mbMap2 (,) &lt;$&gt; abstractNSM x &lt;*&gt; abstractNSM y</span></span>
<span class="lineno"> 8002 </span>
<span class="lineno"> 8003 </span>instance AbstractNamedShape w (PermExpr a) where
<span class="lineno"> 8004 </span>  <span class="decl"><span class="nottickedoff">abstractNSM (PExpr_Var x) = pureBindingM (PExpr_Var x)</span>
<span class="lineno"> 8005 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM PExpr_Unit = pureBindingM PExpr_Unit</span>
<span class="lineno"> 8006 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (PExpr_Bool b) = pureBindingM (PExpr_Bool b)</span>
<span class="lineno"> 8007 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (PExpr_Nat n) = pureBindingM (PExpr_Nat n)</span>
<span class="lineno"> 8008 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (PExpr_String s) = pureBindingM (PExpr_String s)</span>
<span class="lineno"> 8009 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (PExpr_BV fs c) = pureBindingM (PExpr_BV fs c)</span>
<span class="lineno"> 8010 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (PExpr_Struct es) = fmap PExpr_Struct &lt;$&gt; abstractNSM es</span>
<span class="lineno"> 8011 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM PExpr_Always = pureBindingM PExpr_Always</span>
<span class="lineno"> 8012 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (PExpr_LLVMWord e) = fmap PExpr_LLVMWord &lt;$&gt; abstractNSM e</span>
<span class="lineno"> 8013 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (PExpr_LLVMOffset x e) = fmap (PExpr_LLVMOffset x) &lt;$&gt; abstractNSM e</span>
<span class="lineno"> 8014 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (PExpr_Fun fh) = pureBindingM (PExpr_Fun fh)</span>
<span class="lineno"> 8015 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM PExpr_PermListNil = pureBindingM PExpr_PermListNil</span>
<span class="lineno"> 8016 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (PExpr_PermListCons tp e p l) =</span>
<span class="lineno"> 8017 </span><span class="spaces">    </span><span class="nottickedoff">mbMap3 (PExpr_PermListCons tp) &lt;$&gt; abstractNSM e &lt;*&gt; abstractNSM p &lt;*&gt; abstractNSM l</span>
<span class="lineno"> 8018 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (PExpr_RWModality rw) = pureBindingM (PExpr_RWModality rw)</span>
<span class="lineno"> 8019 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM PExpr_EmptyShape = pureBindingM PExpr_EmptyShape</span>
<span class="lineno"> 8020 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM e@(PExpr_NamedShape maybe_rw maybe_l nmsh args) =</span>
<span class="lineno"> 8021 </span><span class="spaces">    </span><span class="nottickedoff">do SomeNamedShapeApp nm_abs args_ctx_abs args_abs w_abs &lt;- ask</span>
<span class="lineno"> 8022 </span><span class="spaces">       </span><span class="nottickedoff">case namedShapeName nmsh == nm_abs of</span>
<span class="lineno"> 8023 </span><span class="spaces">         </span><span class="nottickedoff">True | Just Refl &lt;- testEquality (namedShapeArgs nmsh) args_ctx_abs</span>
<span class="lineno"> 8024 </span><span class="spaces">              </span><span class="nottickedoff">, True &lt;- args == args_abs</span>
<span class="lineno"> 8025 </span><span class="spaces">              </span><span class="nottickedoff">, Nothing &lt;- maybe_rw, Nothing &lt;- maybe_l</span>
<span class="lineno"> 8026 </span><span class="spaces">              </span><span class="nottickedoff">, Just Refl &lt;- testEquality w_abs (shapeLLVMTypeWidth e)</span>
<span class="lineno"> 8027 </span><span class="spaces">              </span><span class="nottickedoff">-&gt; pure $ nu PExpr_Var</span>
<span class="lineno"> 8028 </span><span class="spaces">         </span><span class="nottickedoff">True -&gt; fail &quot;named shape not applied to its arguments&quot;</span>
<span class="lineno"> 8029 </span><span class="spaces">         </span><span class="nottickedoff">False -&gt; pureBindingM (PExpr_NamedShape maybe_rw maybe_l nmsh args)</span>
<span class="lineno"> 8030 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (PExpr_EqShape len b) =</span>
<span class="lineno"> 8031 </span><span class="spaces">    </span><span class="nottickedoff">mbMap2 PExpr_EqShape &lt;$&gt; abstractNSM len &lt;*&gt; abstractNSM b</span>
<span class="lineno"> 8032 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (PExpr_PtrShape rw l sh) =</span>
<span class="lineno"> 8033 </span><span class="spaces">    </span><span class="nottickedoff">mbMap3 PExpr_PtrShape &lt;$&gt; abstractNSM rw &lt;*&gt; abstractNSM l &lt;*&gt; abstractNSM sh</span>
<span class="lineno"> 8034 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (PExpr_FieldShape fsh) = fmap PExpr_FieldShape &lt;$&gt; abstractNSM fsh</span>
<span class="lineno"> 8035 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (PExpr_ArrayShape len s sh) =</span>
<span class="lineno"> 8036 </span><span class="spaces">    </span><span class="nottickedoff">mbMap3 PExpr_ArrayShape &lt;$&gt; abstractNSM len &lt;*&gt; pureBindingM s &lt;*&gt; abstractNSM sh</span>
<span class="lineno"> 8037 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (PExpr_TupShape sh) = fmap PExpr_TupShape &lt;$&gt; abstractNSM sh</span>
<span class="lineno"> 8038 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (PExpr_SeqShape sh1 sh2) =</span>
<span class="lineno"> 8039 </span><span class="spaces">    </span><span class="nottickedoff">mbMap2 PExpr_SeqShape &lt;$&gt; abstractNSM sh1 &lt;*&gt; abstractNSM sh2</span>
<span class="lineno"> 8040 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (PExpr_OrShape sh1 sh2) =</span>
<span class="lineno"> 8041 </span><span class="spaces">    </span><span class="nottickedoff">mbMap2 PExpr_OrShape &lt;$&gt; abstractNSM sh1 &lt;*&gt; abstractNSM sh2</span>
<span class="lineno"> 8042 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (PExpr_ExShape mb_sh) = fmap PExpr_ExShape &lt;$&gt; abstractNSM mb_sh</span>
<span class="lineno"> 8043 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM PExpr_FalseShape = pureBindingM PExpr_FalseShape</span>
<span class="lineno"> 8044 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (PExpr_ValPerm p) = fmap PExpr_ValPerm &lt;$&gt; abstractNSM p</span></span>
<span class="lineno"> 8045 </span>
<span class="lineno"> 8046 </span>instance AbstractNamedShape w (PermExprs as) where
<span class="lineno"> 8047 </span>  <span class="decl"><span class="nottickedoff">abstractNSM PExprs_Nil = pureBindingM PExprs_Nil</span>
<span class="lineno"> 8048 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (PExprs_Cons es e) =</span>
<span class="lineno"> 8049 </span><span class="spaces">    </span><span class="nottickedoff">mbMap2 PExprs_Cons &lt;$&gt; abstractNSM es &lt;*&gt; abstractNSM e</span></span>
<span class="lineno"> 8050 </span>
<span class="lineno"> 8051 </span>instance AbstractNamedShape w' (LLVMFieldShape w) where
<span class="lineno"> 8052 </span>  <span class="decl"><span class="nottickedoff">abstractNSM (LLVMFieldShape p) = fmap LLVMFieldShape &lt;$&gt; abstractNSM p</span></span>
<span class="lineno"> 8053 </span>
<span class="lineno"> 8054 </span>instance AbstractNamedShape w (ValuePerm a) where
<span class="lineno"> 8055 </span>  <span class="decl"><span class="nottickedoff">abstractNSM (ValPerm_Eq e) = fmap ValPerm_Eq &lt;$&gt; abstractNSM e</span>
<span class="lineno"> 8056 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (ValPerm_Or p1 p2) =</span>
<span class="lineno"> 8057 </span><span class="spaces">    </span><span class="nottickedoff">mbMap2 ValPerm_Or &lt;$&gt; abstractNSM p1 &lt;*&gt; abstractNSM p2</span>
<span class="lineno"> 8058 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (ValPerm_Exists p) = fmap ValPerm_Exists &lt;$&gt; abstractNSM p</span>
<span class="lineno"> 8059 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (ValPerm_Named n args off) =</span>
<span class="lineno"> 8060 </span><span class="spaces">    </span><span class="nottickedoff">mbMap2 (ValPerm_Named n) &lt;$&gt; abstractNSM args &lt;*&gt; abstractNSM off</span>
<span class="lineno"> 8061 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (ValPerm_Var x off) =</span>
<span class="lineno"> 8062 </span><span class="spaces">    </span><span class="nottickedoff">fmap (ValPerm_Var x) &lt;$&gt; abstractNSM off</span>
<span class="lineno"> 8063 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (ValPerm_Conj aps) = fmap ValPerm_Conj &lt;$&gt; abstractNSM aps</span>
<span class="lineno"> 8064 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM ValPerm_False = (pure . pure) ValPerm_False</span></span>
<span class="lineno"> 8065 </span>
<span class="lineno"> 8066 </span>instance AbstractNamedShape w (PermOffset a) where
<span class="lineno"> 8067 </span>  <span class="decl"><span class="nottickedoff">abstractNSM NoPermOffset = pureBindingM NoPermOffset</span>
<span class="lineno"> 8068 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (LLVMPermOffset e) = fmap LLVMPermOffset &lt;$&gt; abstractNSM e</span></span>
<span class="lineno"> 8069 </span>
<span class="lineno"> 8070 </span>instance AbstractNamedShape w (AtomicPerm a) where
<span class="lineno"> 8071 </span>  <span class="decl"><span class="nottickedoff">abstractNSM (Perm_LLVMField fp) = fmap Perm_LLVMField &lt;$&gt; abstractNSM fp</span>
<span class="lineno"> 8072 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (Perm_LLVMArray ap) = fmap Perm_LLVMArray &lt;$&gt; abstractNSM ap</span>
<span class="lineno"> 8073 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (Perm_LLVMBlock bp) = fmap Perm_LLVMBlock &lt;$&gt; abstractNSM bp</span>
<span class="lineno"> 8074 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (Perm_LLVMFree e) = fmap Perm_LLVMFree &lt;$&gt; abstractNSM e</span>
<span class="lineno"> 8075 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (Perm_LLVMFunPtr tp p) = fmap (Perm_LLVMFunPtr tp) &lt;$&gt; abstractNSM p</span>
<span class="lineno"> 8076 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (Perm_LLVMBlockShape sh) = fmap Perm_LLVMBlockShape &lt;$&gt; abstractNSM sh</span>
<span class="lineno"> 8077 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM Perm_IsLLVMPtr = pureBindingM Perm_IsLLVMPtr</span>
<span class="lineno"> 8078 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (Perm_NamedConj n args off) =</span>
<span class="lineno"> 8079 </span><span class="spaces">    </span><span class="nottickedoff">mbMap2 (Perm_NamedConj n) &lt;$&gt; abstractNSM args &lt;*&gt; abstractNSM off</span>
<span class="lineno"> 8080 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (Perm_LLVMFrame fp) = fmap Perm_LLVMFrame &lt;$&gt; abstractNSM fp</span>
<span class="lineno"> 8081 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (Perm_LOwned ls tps_in tps_out ps_in ps_out) =</span>
<span class="lineno"> 8082 </span><span class="spaces">    </span><span class="nottickedoff">mbMap3 (\ls' -&gt; Perm_LOwned ls' tps_in tps_out) &lt;$&gt;</span>
<span class="lineno"> 8083 </span><span class="spaces">    </span><span class="nottickedoff">abstractNSM ls &lt;*&gt; abstractNSM ps_in &lt;*&gt; abstractNSM ps_out</span>
<span class="lineno"> 8084 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (Perm_LOwnedSimple tps lops) =</span>
<span class="lineno"> 8085 </span><span class="spaces">    </span><span class="nottickedoff">fmap (Perm_LOwnedSimple tps) &lt;$&gt; abstractNSM lops</span>
<span class="lineno"> 8086 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (Perm_LCurrent e) = fmap Perm_LCurrent &lt;$&gt; abstractNSM e</span>
<span class="lineno"> 8087 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM Perm_LFinished = pureBindingM Perm_LFinished</span>
<span class="lineno"> 8088 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (Perm_Struct ps) = fmap Perm_Struct &lt;$&gt; abstractNSM ps</span>
<span class="lineno"> 8089 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (Perm_Fun fp) = fmap Perm_Fun &lt;$&gt; abstractNSM fp</span>
<span class="lineno"> 8090 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (Perm_BVProp prop) = pureBindingM (Perm_BVProp prop)</span>
<span class="lineno"> 8091 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM Perm_Any = pureBindingM Perm_Any</span></span>
<span class="lineno"> 8092 </span>
<span class="lineno"> 8093 </span>instance AbstractNamedShape w' (LLVMFieldPerm w sz) where
<span class="lineno"> 8094 </span>  <span class="decl"><span class="nottickedoff">abstractNSM (LLVMFieldPerm rw l off p) =</span>
<span class="lineno"> 8095 </span><span class="spaces">    </span><span class="nottickedoff">mbMap4 LLVMFieldPerm &lt;$&gt; abstractNSM rw &lt;*&gt; abstractNSM l</span>
<span class="lineno"> 8096 </span><span class="spaces">                         </span><span class="nottickedoff">&lt;*&gt; abstractNSM off &lt;*&gt; abstractNSM p</span></span>
<span class="lineno"> 8097 </span>
<span class="lineno"> 8098 </span>-- | FIXME: move this to Hobbits?
<span class="lineno"> 8099 </span>mbApplyM :: Applicative m =&gt; m (Mb ctx (a -&gt; b)) -&gt; m (Mb ctx a) -&gt; m (Mb ctx b)
<span class="lineno"> 8100 </span><span class="decl"><span class="nottickedoff">mbApplyM f x = mbApply &lt;$&gt; f &lt;*&gt; x</span></span>
<span class="lineno"> 8101 </span>
<span class="lineno"> 8102 </span>instance AbstractNamedShape w' (LLVMArrayPerm w) where
<span class="lineno"> 8103 </span>  <span class="decl"><span class="nottickedoff">abstractNSM (LLVMArrayPerm rw l off len stride sh bs) =</span>
<span class="lineno"> 8104 </span><span class="spaces">    </span><span class="nottickedoff">pureBindingM LLVMArrayPerm `mbApplyM` abstractNSM rw</span>
<span class="lineno"> 8105 </span><span class="spaces">    </span><span class="nottickedoff">`mbApplyM` abstractNSM l `mbApplyM` abstractNSM off</span>
<span class="lineno"> 8106 </span><span class="spaces">    </span><span class="nottickedoff">`mbApplyM` abstractNSM len `mbApplyM` pureBindingM stride</span>
<span class="lineno"> 8107 </span><span class="spaces">    </span><span class="nottickedoff">`mbApplyM` abstractNSM sh `mbApplyM` abstractNSM bs</span></span>
<span class="lineno"> 8108 </span>
<span class="lineno"> 8109 </span>instance AbstractNamedShape w' (LLVMArrayBorrow w) where
<span class="lineno"> 8110 </span>  <span class="decl"><span class="nottickedoff">abstractNSM (FieldBorrow ix) = fmap FieldBorrow &lt;$&gt; abstractNSM ix</span>
<span class="lineno"> 8111 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (RangeBorrow rng) = pureBindingM (RangeBorrow rng)</span></span>
<span class="lineno"> 8112 </span>
<span class="lineno"> 8113 </span>instance AbstractNamedShape w' (LLVMBlockPerm w) where
<span class="lineno"> 8114 </span>  <span class="decl"><span class="nottickedoff">abstractNSM (LLVMBlockPerm rw l off len sh) =</span>
<span class="lineno"> 8115 </span><span class="spaces">    </span><span class="nottickedoff">mbMap5 LLVMBlockPerm &lt;$&gt; abstractNSM rw &lt;*&gt; abstractNSM l</span>
<span class="lineno"> 8116 </span><span class="spaces">                         </span><span class="nottickedoff">&lt;*&gt; abstractNSM off &lt;*&gt; abstractNSM len</span>
<span class="lineno"> 8117 </span><span class="spaces">                         </span><span class="nottickedoff">&lt;*&gt; abstractNSM sh</span></span>
<span class="lineno"> 8118 </span>
<span class="lineno"> 8119 </span>instance AbstractNamedShape w (ExprPerms ps) where
<span class="lineno"> 8120 </span>  <span class="decl"><span class="nottickedoff">abstractNSM MNil = pureBindingM MNil</span>
<span class="lineno"> 8121 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (p :&gt;: ps) = mbMap2 (:&gt;:) &lt;$&gt; abstractNSM p &lt;*&gt; abstractNSM ps</span></span>
<span class="lineno"> 8122 </span>
<span class="lineno"> 8123 </span>instance AbstractNamedShape w (ExprAndPerm a) where
<span class="lineno"> 8124 </span>  <span class="decl"><span class="nottickedoff">abstractNSM (ExprAndPerm e p) =</span>
<span class="lineno"> 8125 </span><span class="spaces">    </span><span class="nottickedoff">mbMap2 ExprAndPerm &lt;$&gt; abstractNSM e &lt;*&gt; abstractNSM p</span></span>
<span class="lineno"> 8126 </span>
<span class="lineno"> 8127 </span>instance AbstractNamedShape w (ValuePerms as) where
<span class="lineno"> 8128 </span>  <span class="decl"><span class="nottickedoff">abstractNSM ValPerms_Nil = pureBindingM ValPerms_Nil</span>
<span class="lineno"> 8129 </span><span class="spaces">  </span><span class="nottickedoff">abstractNSM (ValPerms_Cons ps p) =</span>
<span class="lineno"> 8130 </span><span class="spaces">    </span><span class="nottickedoff">mbMap2 ValPerms_Cons &lt;$&gt; abstractNSM ps &lt;*&gt; abstractNSM p</span></span>
<span class="lineno"> 8131 </span>
<span class="lineno"> 8132 </span>instance AbstractNamedShape w (FunPerm ghosts args gouts ret) where
<span class="lineno"> 8133 </span>  <span class="decl"><span class="nottickedoff">abstractNSM (FunPerm ghosts args gouts ret perms_in perms_out) =</span>
<span class="lineno"> 8134 </span><span class="spaces">    </span><span class="nottickedoff">mbMap2 (FunPerm ghosts args gouts ret) &lt;$&gt; abstractNSM perms_in</span>
<span class="lineno"> 8135 </span><span class="spaces">                                           </span><span class="nottickedoff">&lt;*&gt; abstractNSM perms_out</span></span>
<span class="lineno"> 8136 </span>
<span class="lineno"> 8137 </span>
<span class="lineno"> 8138 </span>instance Liftable RWModality where
<span class="lineno"> 8139 </span>  <span class="decl"><span class="nottickedoff">mbLift mb_rw = case mbMatch mb_rw of</span>
<span class="lineno"> 8140 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Write |] -&gt; Write</span>
<span class="lineno"> 8141 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Read |] -&gt; Read</span></span>
<span class="lineno"> 8142 </span>
<span class="lineno"> 8143 </span>instance Closable RWModality where
<span class="lineno"> 8144 </span>  <span class="decl"><span class="nottickedoff">toClosed Write = $(mkClosed [| Write |])</span>
<span class="lineno"> 8145 </span><span class="spaces">  </span><span class="nottickedoff">toClosed Read = $(mkClosed [| Read |])</span></span>
<span class="lineno"> 8146 </span>
<span class="lineno"> 8147 </span>instance Closable (NameSortRepr ns) where
<span class="lineno"> 8148 </span>  <span class="decl"><span class="nottickedoff">toClosed (DefinedSortRepr b) =</span>
<span class="lineno"> 8149 </span><span class="spaces">    </span><span class="nottickedoff">$(mkClosed [| DefinedSortRepr |]) `clApply` toClosed b</span>
<span class="lineno"> 8150 </span><span class="spaces">  </span><span class="nottickedoff">toClosed (OpaqueSortRepr b) =</span>
<span class="lineno"> 8151 </span><span class="spaces">    </span><span class="nottickedoff">$(mkClosed [| OpaqueSortRepr |]) `clApply` toClosed b</span>
<span class="lineno"> 8152 </span><span class="spaces">  </span><span class="nottickedoff">toClosed (RecursiveSortRepr b reach) =</span>
<span class="lineno"> 8153 </span><span class="spaces">    </span><span class="nottickedoff">$(mkClosed [| RecursiveSortRepr |])</span>
<span class="lineno"> 8154 </span><span class="spaces">    </span><span class="nottickedoff">`clApply` toClosed b `clApply` toClosed reach</span></span>
<span class="lineno"> 8155 </span>
<span class="lineno"> 8156 </span>instance Liftable (NameSortRepr ns) where
<span class="lineno"> 8157 </span>  <span class="decl"><span class="nottickedoff">mbLift = unClosed . mbLift . fmap toClosed</span></span>
<span class="lineno"> 8158 </span>
<span class="lineno"> 8159 </span>instance Closable (NameReachConstr ns args a) where
<span class="lineno"> 8160 </span>  <span class="decl"><span class="nottickedoff">toClosed NameReachConstr = $(mkClosed [| NameReachConstr |])</span>
<span class="lineno"> 8161 </span><span class="spaces">  </span><span class="nottickedoff">toClosed NameNonReachConstr = $(mkClosed [| NameNonReachConstr |])</span></span>
<span class="lineno"> 8162 </span>
<span class="lineno"> 8163 </span>instance Liftable (NameReachConstr ns args a) where
<span class="lineno"> 8164 </span>  <span class="decl"><span class="nottickedoff">mbLift = unClosed . mbLift . fmap toClosed</span></span>
<span class="lineno"> 8165 </span>
<span class="lineno"> 8166 </span>instance Liftable (NamedPermName ns args a) where
<span class="lineno"> 8167 </span>  <span class="decl"><span class="nottickedoff">mbLift (mbMatch -&gt; [nuMP| NamedPermName n tp args ns r |]) =</span>
<span class="lineno"> 8168 </span><span class="spaces">    </span><span class="nottickedoff">NamedPermName (mbLift n) (mbLift tp) (mbLift args) (mbLift ns) (mbLift r)</span></span>
<span class="lineno"> 8169 </span>
<span class="lineno"> 8170 </span>instance Liftable SomeNamedPermName where
<span class="lineno"> 8171 </span>  <span class="decl"><span class="nottickedoff">mbLift (mbMatch -&gt; [nuMP| SomeNamedPermName rpn |]) =</span>
<span class="lineno"> 8172 </span><span class="spaces">    </span><span class="nottickedoff">SomeNamedPermName $ mbLift rpn</span></span>
<span class="lineno"> 8173 </span>
<span class="lineno"> 8174 </span>instance Liftable (ReachMethods args a reach) where
<span class="lineno"> 8175 </span>  <span class="decl"><span class="nottickedoff">mbLift mb_x = case mbMatch mb_x of</span>
<span class="lineno"> 8176 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ReachMethods transIdent |] -&gt;</span>
<span class="lineno"> 8177 </span><span class="spaces">      </span><span class="nottickedoff">ReachMethods (mbLift transIdent)</span>
<span class="lineno"> 8178 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| NoReachMethods |] -&gt; NoReachMethods</span></span>
<span class="lineno"> 8179 </span>
<span class="lineno"> 8180 </span>
<span class="lineno"> 8181 </span>----------------------------------------------------------------------
<span class="lineno"> 8182 </span>-- * Permission Environments
<span class="lineno"> 8183 </span>----------------------------------------------------------------------
<span class="lineno"> 8184 </span>
<span class="lineno"> 8185 </span>-- | Get the 'BlockHintSort' for a 'BlockHint'
<span class="lineno"> 8186 </span>blockHintSort :: BlockHint blocks init ret args -&gt; BlockHintSort args
<span class="lineno"> 8187 </span><span class="decl"><span class="nottickedoff">blockHintSort (BlockHint _ _ _ sort) = sort</span></span>
<span class="lineno"> 8188 </span>
<span class="lineno"> 8189 </span>-- | Test if a 'BlockHintSort' is a block entry hint
<span class="lineno"> 8190 </span>isBlockEntryHint :: BlockHintSort args -&gt; Bool
<span class="lineno"> 8191 </span><span class="decl"><span class="nottickedoff">isBlockEntryHint (BlockEntryHintSort _ _  _) = True</span>
<span class="lineno"> 8192 </span><span class="spaces"></span><span class="nottickedoff">isBlockEntryHint _ = False</span></span>
<span class="lineno"> 8193 </span>
<span class="lineno"> 8194 </span>-- | Test if a 'BlockHintSort' is a generalization hint
<span class="lineno"> 8195 </span>isGenPermsHint :: BlockHintSort args -&gt; Bool
<span class="lineno"> 8196 </span><span class="decl"><span class="nottickedoff">isGenPermsHint GenPermsHintSort = True</span>
<span class="lineno"> 8197 </span><span class="spaces"></span><span class="nottickedoff">isGenPermsHint _ = False</span></span>
<span class="lineno"> 8198 </span>
<span class="lineno"> 8199 </span>-- | Test if a 'BlockHintSort' is a generalization hint
<span class="lineno"> 8200 </span>isJoinPointHint :: BlockHintSort args -&gt; Bool
<span class="lineno"> 8201 </span><span class="decl"><span class="nottickedoff">isJoinPointHint JoinPointHintSort = True</span>
<span class="lineno"> 8202 </span><span class="spaces"></span><span class="nottickedoff">isJoinPointHint _ = False</span></span>
<span class="lineno"> 8203 </span>
<span class="lineno"> 8204 </span>-- FIXME: all the per-block hints
<span class="lineno"> 8205 </span>
<span class="lineno"> 8206 </span>-- | The empty 'PermEnv'
<span class="lineno"> 8207 </span>emptyPermEnv :: PermEnv
<span class="lineno"> 8208 </span><span class="decl"><span class="nottickedoff">emptyPermEnv = PermEnv [] [] [] [] [] defaultSpecMEventType</span></span>
<span class="lineno"> 8209 </span>
<span class="lineno"> 8210 </span>-- | Add a 'NamedPerm' to a permission environment
<span class="lineno"> 8211 </span>permEnvAddNamedPerm :: PermEnv -&gt; NamedPerm ns args a -&gt; PermEnv
<span class="lineno"> 8212 </span><span class="decl"><span class="nottickedoff">permEnvAddNamedPerm env np =</span>
<span class="lineno"> 8213 </span><span class="spaces">  </span><span class="nottickedoff">env { permEnvNamedPerms = SomeNamedPerm np : permEnvNamedPerms env }</span></span>
<span class="lineno"> 8214 </span>
<span class="lineno"> 8215 </span>-- | Add a 'NamedShape' to a permission environment
<span class="lineno"> 8216 </span>permEnvAddNamedShape :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 8217 </span>                        PermEnv -&gt; NamedShape b args w -&gt; PermEnv
<span class="lineno"> 8218 </span><span class="decl"><span class="nottickedoff">permEnvAddNamedShape env ns =</span>
<span class="lineno"> 8219 </span><span class="spaces">  </span><span class="nottickedoff">env { permEnvNamedShapes = SomeNamedShape ns : permEnvNamedShapes env }</span></span>
<span class="lineno"> 8220 </span>
<span class="lineno"> 8221 </span>-- | Add an opaque named permission to a 'PermEnv'
<span class="lineno"> 8222 </span>permEnvAddOpaquePerm :: PermEnv -&gt; String -&gt; CruCtx args -&gt; TypeRepr a -&gt;
<span class="lineno"> 8223 </span>                        Ident -&gt; Ident -&gt; PermEnv
<span class="lineno"> 8224 </span><span class="decl"><span class="nottickedoff">permEnvAddOpaquePerm env str args tp trans_id d_id =</span>
<span class="lineno"> 8225 </span><span class="spaces">  </span><span class="nottickedoff">let n = NamedPermName str tp args (OpaqueSortRepr</span>
<span class="lineno"> 8226 </span><span class="spaces">                                     </span><span class="nottickedoff">TrueRepr) NameNonReachConstr in</span>
<span class="lineno"> 8227 </span><span class="spaces">  </span><span class="nottickedoff">permEnvAddNamedPerm env $ NamedPerm_Opaque $ OpaquePerm n trans_id d_id</span></span>
<span class="lineno"> 8228 </span>
<span class="lineno"> 8229 </span>-- | Add a recursive named permission to a 'PermEnv', given a 'String' name for
<span class="lineno"> 8230 </span>-- the permission, its argument types and permission type, identifiers for its
<span class="lineno"> 8231 </span>-- 'recPermTransType' and 'recPermTransDesc' fields, its body, and optional
<span class="lineno"> 8232 </span>-- reachability constraints and methods. The last two of these can depend on the
<span class="lineno"> 8233 </span>-- @b@ flag computed for the body, and the last can take in the name being
<span class="lineno"> 8234 </span>-- created and a temporary 'PermEnv' with this name added in order to construct
<span class="lineno"> 8235 </span>-- the 'ReachMethods', which can be constructed in an arbitrary monad.
<span class="lineno"> 8236 </span>permEnvAddRecPermM :: Monad m =&gt; PermEnv -&gt; String -&gt; CruCtx args -&gt;
<span class="lineno"> 8237 </span>                      TypeRepr a -&gt; Ident -&gt; Ident -&gt;
<span class="lineno"> 8238 </span>                      Mb (args :&gt; ValuePermType a) (ValuePerm a) -&gt;
<span class="lineno"> 8239 </span>                      (forall b. NameReachConstr (RecursiveSort b reach) args a) -&gt;
<span class="lineno"> 8240 </span>                      (forall b. NamedPermName (RecursiveSort b reach) args a -&gt;
<span class="lineno"> 8241 </span>                       PermEnv -&gt; m (ReachMethods args a reach)) -&gt;
<span class="lineno"> 8242 </span>                      m PermEnv
<span class="lineno"> 8243 </span><span class="decl"><span class="nottickedoff">permEnvAddRecPermM env nm args tp trans_ident d_ident body reachC reachMethsF</span>
<span class="lineno"> 8244 </span><span class="spaces">  </span><span class="nottickedoff">| Some b &lt;- someBool $ mbLift $ fmap isConjPerm body =</span>
<span class="lineno"> 8245 </span><span class="spaces">    </span><span class="nottickedoff">do let reach = nameReachConstrBool reachC</span>
<span class="lineno"> 8246 </span><span class="spaces">       </span><span class="nottickedoff">let npn = NamedPermName nm tp args (RecursiveSortRepr b reach) reachC</span>
<span class="lineno"> 8247 </span><span class="spaces">       </span><span class="nottickedoff">let tmp_env =</span>
<span class="lineno"> 8248 </span><span class="spaces">             </span><span class="nottickedoff">permEnvAddNamedPerm env $ NamedPerm_Rec $</span>
<span class="lineno"> 8249 </span><span class="spaces">             </span><span class="nottickedoff">RecPerm npn trans_ident d_ident</span>
<span class="lineno"> 8250 </span><span class="spaces">             </span><span class="nottickedoff">(error &quot;Using reachability methods for recursive perm before it is defined!&quot;)</span>
<span class="lineno"> 8251 </span><span class="spaces">             </span><span class="nottickedoff">body</span>
<span class="lineno"> 8252 </span><span class="spaces">       </span><span class="nottickedoff">reachMeths &lt;- reachMethsF npn tmp_env</span>
<span class="lineno"> 8253 </span><span class="spaces">       </span><span class="nottickedoff">return $ </span>
<span class="lineno"> 8254 </span><span class="spaces">         </span><span class="nottickedoff">permEnvAddNamedPerm env $ NamedPerm_Rec $</span>
<span class="lineno"> 8255 </span><span class="spaces">         </span><span class="nottickedoff">RecPerm npn trans_ident d_ident reachMeths body</span></span>
<span class="lineno"> 8256 </span>
<span class="lineno"> 8257 </span>-- | Add a defined named permission to a 'PermEnv'
<span class="lineno"> 8258 </span>permEnvAddDefinedPerm :: PermEnv -&gt; String -&gt; CruCtx args -&gt; TypeRepr a -&gt;
<span class="lineno"> 8259 </span>                         Mb args (ValuePerm a) -&gt; PermEnv
<span class="lineno"> 8260 </span><span class="decl"><span class="nottickedoff">permEnvAddDefinedPerm env str args tp p =</span>
<span class="lineno"> 8261 </span><span class="spaces">  </span><span class="nottickedoff">case someBool $ mbLift $ fmap isConjPerm p of</span>
<span class="lineno"> 8262 </span><span class="spaces">    </span><span class="nottickedoff">Some b -&gt;</span>
<span class="lineno"> 8263 </span><span class="spaces">      </span><span class="nottickedoff">let n = NamedPermName str tp args (DefinedSortRepr b) NameNonReachConstr</span>
<span class="lineno"> 8264 </span><span class="spaces">          </span><span class="nottickedoff">np = NamedPerm_Defined (DefinedPerm n p) in</span>
<span class="lineno"> 8265 </span><span class="spaces">      </span><span class="nottickedoff">env { permEnvNamedPerms = SomeNamedPerm np : permEnvNamedPerms env }</span></span>
<span class="lineno"> 8266 </span>
<span class="lineno"> 8267 </span>-- | Add a defined LLVM shape to a permission environment
<span class="lineno"> 8268 </span>permEnvAddDefinedShape :: (1 &lt;= w, KnownNat w) =&gt; PermEnv -&gt; String -&gt;
<span class="lineno"> 8269 </span>                          CruCtx args -&gt; Mb args (PermExpr (LLVMShapeType w)) -&gt;
<span class="lineno"> 8270 </span>                          PermEnv
<span class="lineno"> 8271 </span><span class="decl"><span class="nottickedoff">permEnvAddDefinedShape env nm args mb_sh =</span>
<span class="lineno"> 8272 </span><span class="spaces">  </span><span class="nottickedoff">env { permEnvNamedShapes =</span>
<span class="lineno"> 8273 </span><span class="spaces">          </span><span class="nottickedoff">SomeNamedShape (NamedShape nm args $</span>
<span class="lineno"> 8274 </span><span class="spaces">                          </span><span class="nottickedoff">DefinedShapeBody mb_sh) : permEnvNamedShapes env }</span></span>
<span class="lineno"> 8275 </span>
<span class="lineno"> 8276 </span>-- | Add an opaque LLVM shape to a permission environment
<span class="lineno"> 8277 </span>permEnvAddOpaqueShape :: (1 &lt;= w, KnownNat w) =&gt; PermEnv -&gt; String -&gt;
<span class="lineno"> 8278 </span>                         CruCtx args -&gt; Mb args (PermExpr (BVType w)) -&gt;
<span class="lineno"> 8279 </span>                         Ident -&gt; Ident -&gt; PermEnv
<span class="lineno"> 8280 </span><span class="decl"><span class="nottickedoff">permEnvAddOpaqueShape env nm args mb_len tp_id d_id =</span>
<span class="lineno"> 8281 </span><span class="spaces">  </span><span class="nottickedoff">env { permEnvNamedShapes =</span>
<span class="lineno"> 8282 </span><span class="spaces">          </span><span class="nottickedoff">SomeNamedShape (NamedShape nm args $</span>
<span class="lineno"> 8283 </span><span class="spaces">                          </span><span class="nottickedoff">OpaqueShapeBody mb_len tp_id d_id)</span>
<span class="lineno"> 8284 </span><span class="spaces">          </span><span class="nottickedoff">: permEnvNamedShapes env }</span></span>
<span class="lineno"> 8285 </span>
<span class="lineno"> 8286 </span>-- | Add a global symbol with a function permission along with its translation
<span class="lineno"> 8287 </span>-- to a spec function to a 'PermEnv'
<span class="lineno"> 8288 </span>permEnvAddGlobalSymFun :: (1 &lt;= w, KnownNat w) =&gt; PermEnv -&gt; GlobalSymbol -&gt;
<span class="lineno"> 8289 </span>                          f w -&gt; FunPerm ghosts args gouts ret -&gt;
<span class="lineno"> 8290 </span>                          OpenTerm -&gt; PermEnv
<span class="lineno"> 8291 </span><span class="decl"><span class="nottickedoff">permEnvAddGlobalSymFun env sym (w :: f w) fun_perm t =</span>
<span class="lineno"> 8292 </span><span class="spaces">  </span><span class="nottickedoff">let p = ValPerm_Conj1 $ mkPermLLVMFunPtr w fun_perm in</span>
<span class="lineno"> 8293 </span><span class="spaces">  </span><span class="nottickedoff">env { permEnvGlobalSyms =</span>
<span class="lineno"> 8294 </span><span class="spaces">          </span><span class="nottickedoff">PermEnvGlobalEntry sym p (GlobalTrans [t])</span>
<span class="lineno"> 8295 </span><span class="spaces">          </span><span class="nottickedoff">: permEnvGlobalSyms env }</span></span>
<span class="lineno"> 8296 </span>
<span class="lineno"> 8297 </span>-- | Add a global symbol with 0 or more function permissions to a 'PermEnv'
<span class="lineno"> 8298 </span>permEnvAddGlobalSymFunMulti :: (1 &lt;= w, KnownNat w) =&gt; PermEnv -&gt;
<span class="lineno"> 8299 </span>                               GlobalSymbol -&gt; f w -&gt;
<span class="lineno"> 8300 </span>                               [(SomeFunPerm args ret, OpenTerm)] -&gt; PermEnv
<span class="lineno"> 8301 </span><span class="decl"><span class="nottickedoff">permEnvAddGlobalSymFunMulti env sym (w :: f w) ps_ts =</span>
<span class="lineno"> 8302 </span><span class="spaces">  </span><span class="nottickedoff">let p = ValPerm_Conj1 $ mkPermLLVMFunPtrs w $ map fst ps_ts in</span>
<span class="lineno"> 8303 </span><span class="spaces">  </span><span class="nottickedoff">env { permEnvGlobalSyms =</span>
<span class="lineno"> 8304 </span><span class="spaces">          </span><span class="nottickedoff">PermEnvGlobalEntry sym p (GlobalTrans $ map snd ps_ts)</span>
<span class="lineno"> 8305 </span><span class="spaces">          </span><span class="nottickedoff">: permEnvGlobalSyms env }</span></span>
<span class="lineno"> 8306 </span>
<span class="lineno"> 8307 </span>-- | Add some 'PermEnvGlobalEntry's to a 'PermEnv'
<span class="lineno"> 8308 </span>permEnvAddGlobalSyms :: PermEnv -&gt; [PermEnvGlobalEntry] -&gt; PermEnv
<span class="lineno"> 8309 </span><span class="decl"><span class="nottickedoff">permEnvAddGlobalSyms env entries = env { permEnvGlobalSyms =</span>
<span class="lineno"> 8310 </span><span class="spaces">                                           </span><span class="nottickedoff">entries ++ permEnvGlobalSyms env }</span></span>
<span class="lineno"> 8311 </span>
<span class="lineno"> 8312 </span>-- | Add a 'Hint' to a 'PermEnv'
<span class="lineno"> 8313 </span>permEnvAddHint :: PermEnv -&gt; Hint -&gt; PermEnv
<span class="lineno"> 8314 </span><span class="decl"><span class="nottickedoff">permEnvAddHint env hint = env { permEnvHints = hint : permEnvHints env }</span></span>
<span class="lineno"> 8315 </span>
<span class="lineno"> 8316 </span>-- | Look up a 'FnHandle' by name in a 'PermEnv'
<span class="lineno"> 8317 </span>lookupFunHandle :: PermEnv -&gt; String -&gt; Maybe SomeHandle
<span class="lineno"> 8318 </span><span class="decl"><span class="nottickedoff">lookupFunHandle env str =</span>
<span class="lineno"> 8319 </span><span class="spaces">  </span><span class="nottickedoff">case find (\(PermEnvFunEntry h _ _) -&gt;</span>
<span class="lineno"> 8320 </span><span class="spaces">              </span><span class="nottickedoff">handleName h == fromString str) (permEnvFunPerms env) of</span>
<span class="lineno"> 8321 </span><span class="spaces">    </span><span class="nottickedoff">Just (PermEnvFunEntry h _ _) -&gt; Just (SomeHandle h)</span>
<span class="lineno"> 8322 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; Nothing</span></span>
<span class="lineno"> 8323 </span>
<span class="lineno"> 8324 </span>-- | Look up the function permission and SAW translation for a 'FnHandle'
<span class="lineno"> 8325 </span>lookupFunPerm :: PermEnv -&gt; FnHandle cargs ret -&gt;
<span class="lineno"> 8326 </span>                 Maybe (SomeFunPerm (CtxToRList cargs) ret, Ident)
<span class="lineno"> 8327 </span><span class="decl"><span class="nottickedoff">lookupFunPerm env = helper (permEnvFunPerms env) where</span>
<span class="lineno"> 8328 </span><span class="spaces">  </span><span class="nottickedoff">helper :: [PermEnvFunEntry] -&gt; FnHandle cargs ret -&gt;</span>
<span class="lineno"> 8329 </span><span class="spaces">            </span><span class="nottickedoff">Maybe (SomeFunPerm (CtxToRList cargs) ret, Ident)</span>
<span class="lineno"> 8330 </span><span class="spaces">  </span><span class="nottickedoff">helper [] _ = Nothing</span>
<span class="lineno"> 8331 </span><span class="spaces">  </span><span class="nottickedoff">helper ((PermEnvFunEntry h' fun_perm ident):_) h</span>
<span class="lineno"> 8332 </span><span class="spaces">    </span><span class="nottickedoff">| Just Refl &lt;- testEquality (handleType h') (handleType h)</span>
<span class="lineno"> 8333 </span><span class="spaces">    </span><span class="nottickedoff">, h' == h</span>
<span class="lineno"> 8334 </span><span class="spaces">    </span><span class="nottickedoff">= Just (SomeFunPerm fun_perm, ident)</span>
<span class="lineno"> 8335 </span><span class="spaces">  </span><span class="nottickedoff">helper (_:entries) h = helper entries h</span></span>
<span class="lineno"> 8336 </span>
<span class="lineno"> 8337 </span>-- | Look up a 'NamedPermName' by name in a 'PermEnv'
<span class="lineno"> 8338 </span>lookupNamedPermName :: PermEnv -&gt; String -&gt; Maybe SomeNamedPermName
<span class="lineno"> 8339 </span><span class="decl"><span class="nottickedoff">lookupNamedPermName env str =</span>
<span class="lineno"> 8340 </span><span class="spaces">  </span><span class="nottickedoff">case find (\(SomeNamedPerm np) -&gt;</span>
<span class="lineno"> 8341 </span><span class="spaces">              </span><span class="nottickedoff">namedPermNameName (namedPermName np) == str) (permEnvNamedPerms env) of</span>
<span class="lineno"> 8342 </span><span class="spaces">    </span><span class="nottickedoff">Just (SomeNamedPerm np) -&gt; Just (SomeNamedPermName (namedPermName np))</span>
<span class="lineno"> 8343 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; Nothing</span></span>
<span class="lineno"> 8344 </span>
<span class="lineno"> 8345 </span>-- | Look up a conjunctive 'NamedPermName' by name in a 'PermEnv'
<span class="lineno"> 8346 </span>lookupNamedConjPermName :: PermEnv -&gt; String -&gt; Maybe SomeNamedConjPermName
<span class="lineno"> 8347 </span><span class="decl"><span class="nottickedoff">lookupNamedConjPermName env str =</span>
<span class="lineno"> 8348 </span><span class="spaces">  </span><span class="nottickedoff">case find (\(SomeNamedPerm np) -&gt;</span>
<span class="lineno"> 8349 </span><span class="spaces">              </span><span class="nottickedoff">namedPermNameName (namedPermName np) == str)</span>
<span class="lineno"> 8350 </span><span class="spaces">       </span><span class="nottickedoff">(permEnvNamedPerms env) of</span>
<span class="lineno"> 8351 </span><span class="spaces">    </span><span class="nottickedoff">Just (SomeNamedPerm np)</span>
<span class="lineno"> 8352 </span><span class="spaces">      </span><span class="nottickedoff">| TrueRepr &lt;- nameIsConjRepr $ namedPermName np -&gt;</span>
<span class="lineno"> 8353 </span><span class="spaces">        </span><span class="nottickedoff">Just (SomeNamedConjPermName (namedPermName np))</span>
<span class="lineno"> 8354 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; Nothing</span></span>
<span class="lineno"> 8355 </span>
<span class="lineno"> 8356 </span>-- | Look up the 'NamedPerm' for a 'NamedPermName' in a 'PermEnv'
<span class="lineno"> 8357 </span>lookupNamedPerm :: PermEnv -&gt; NamedPermName ns args a -&gt;
<span class="lineno"> 8358 </span>                   Maybe (NamedPerm ns args a)
<span class="lineno"> 8359 </span><span class="decl"><span class="nottickedoff">lookupNamedPerm env = helper (permEnvNamedPerms env) where</span>
<span class="lineno"> 8360 </span><span class="spaces">  </span><span class="nottickedoff">helper :: [SomeNamedPerm] -&gt; NamedPermName ns args a -&gt;</span>
<span class="lineno"> 8361 </span><span class="spaces">            </span><span class="nottickedoff">Maybe (NamedPerm ns args a)</span>
<span class="lineno"> 8362 </span><span class="spaces">  </span><span class="nottickedoff">helper [] _ = Nothing</span>
<span class="lineno"> 8363 </span><span class="spaces">  </span><span class="nottickedoff">helper (SomeNamedPerm rp:_) rpn</span>
<span class="lineno"> 8364 </span><span class="spaces">    </span><span class="nottickedoff">| Just (Refl, Refl, Refl) &lt;- testNamedPermNameEq (namedPermName rp) rpn</span>
<span class="lineno"> 8365 </span><span class="spaces">    </span><span class="nottickedoff">= Just rp</span>
<span class="lineno"> 8366 </span><span class="spaces">  </span><span class="nottickedoff">helper (_:rps) rpn = helper rps rpn</span></span>
<span class="lineno"> 8367 </span>
<span class="lineno"> 8368 </span>-- | Look up the 'NamedPerm' for a 'NamedPermName' in a 'PermEnv' or raise an
<span class="lineno"> 8369 </span>-- error if it does not exist
<span class="lineno"> 8370 </span>requireNamedPerm :: PermEnv -&gt; NamedPermName ns args a -&gt; NamedPerm ns args a
<span class="lineno"> 8371 </span><span class="decl"><span class="nottickedoff">requireNamedPerm env npn</span>
<span class="lineno"> 8372 </span><span class="spaces">  </span><span class="nottickedoff">| Just np &lt;- lookupNamedPerm env npn = np</span>
<span class="lineno"> 8373 </span><span class="spaces"></span><span class="nottickedoff">requireNamedPerm _ npn =</span>
<span class="lineno"> 8374 </span><span class="spaces">  </span><span class="nottickedoff">panic &quot;requireNamedPerm&quot; [&quot;named perm does not exist: &quot;</span>
<span class="lineno"> 8375 </span><span class="spaces">                            </span><span class="nottickedoff">++ namedPermNameName npn]</span></span>
<span class="lineno"> 8376 </span>
<span class="lineno"> 8377 </span>-- | Look up an LLVM shape by name in a 'PermEnv' and cast it to a given width
<span class="lineno"> 8378 </span>lookupNamedShape :: PermEnv -&gt; String -&gt; Maybe SomeNamedShape
<span class="lineno"> 8379 </span><span class="decl"><span class="nottickedoff">lookupNamedShape env nm =</span>
<span class="lineno"> 8380 </span><span class="spaces">  </span><span class="nottickedoff">find (\case SomeNamedShape nmsh -&gt;</span>
<span class="lineno"> 8381 </span><span class="spaces">                </span><span class="nottickedoff">nm == namedShapeName nmsh) (permEnvNamedShapes env)</span></span>
<span class="lineno"> 8382 </span>
<span class="lineno"> 8383 </span>-- | Look up the permissions and translation for a 'GlobalSymbol' at a
<span class="lineno"> 8384 </span>-- particular machine word width
<span class="lineno"> 8385 </span>lookupGlobalSymbol :: PermEnv -&gt; GlobalSymbol -&gt; NatRepr w -&gt;
<span class="lineno"> 8386 </span>                      Maybe (ValuePerm (LLVMPointerType w), GlobalTrans)
<span class="lineno"> 8387 </span><span class="decl"><span class="nottickedoff">lookupGlobalSymbol env = helper (permEnvGlobalSyms env) where</span>
<span class="lineno"> 8388 </span><span class="spaces">  </span><span class="nottickedoff">helper :: [PermEnvGlobalEntry] -&gt; GlobalSymbol -&gt; NatRepr w -&gt;</span>
<span class="lineno"> 8389 </span><span class="spaces">            </span><span class="nottickedoff">Maybe (ValuePerm (LLVMPointerType w), GlobalTrans)</span>
<span class="lineno"> 8390 </span><span class="spaces">  </span><span class="nottickedoff">helper  (PermEnvGlobalEntry sym'</span>
<span class="lineno"> 8391 </span><span class="spaces">            </span><span class="nottickedoff">(p :: ValuePerm (LLVMPointerType w')) tr:_) sym w</span>
<span class="lineno"> 8392 </span><span class="spaces">    </span><span class="nottickedoff">| sym' == sym</span>
<span class="lineno"> 8393 </span><span class="spaces">    </span><span class="nottickedoff">, Just Refl &lt;- testEquality w (knownNat :: NatRepr w') =</span>
<span class="lineno"> 8394 </span><span class="spaces">      </span><span class="nottickedoff">Just (p, tr)</span>
<span class="lineno"> 8395 </span><span class="spaces">  </span><span class="nottickedoff">helper (_:entries) sym w = helper entries sym w</span>
<span class="lineno"> 8396 </span><span class="spaces">  </span><span class="nottickedoff">helper [] _ _ = Nothing</span></span>
<span class="lineno"> 8397 </span>
<span class="lineno"> 8398 </span>-- | Look up all hints associated with a 'BlockID' in a function
<span class="lineno"> 8399 </span>lookupBlockHints :: PermEnv -&gt; FnHandle init ret -&gt; Assignment CtxRepr blocks -&gt;
<span class="lineno"> 8400 </span>                    BlockID blocks args -&gt; [BlockHintSort args]
<span class="lineno"> 8401 </span><span class="decl"><span class="nottickedoff">lookupBlockHints env h blocks blkID =</span>
<span class="lineno"> 8402 </span><span class="spaces">  </span><span class="nottickedoff">mapMaybe (\hint -&gt; case hint of</span>
<span class="lineno"> 8403 </span><span class="spaces">               </span><span class="nottickedoff">Hint_Block (BlockHint h' blocks' blkID' sort)</span>
<span class="lineno"> 8404 </span><span class="spaces">                 </span><span class="nottickedoff">| Just Refl &lt;- testEquality (handleID h') (handleID h)</span>
<span class="lineno"> 8405 </span><span class="spaces">                 </span><span class="nottickedoff">, Just Refl &lt;- testEquality blocks' blocks</span>
<span class="lineno"> 8406 </span><span class="spaces">                 </span><span class="nottickedoff">, Just Refl &lt;- testEquality blkID blkID' -&gt;</span>
<span class="lineno"> 8407 </span><span class="spaces">                   </span><span class="nottickedoff">return sort</span>
<span class="lineno"> 8408 </span><span class="spaces">               </span><span class="nottickedoff">_ -&gt; Nothing) $</span>
<span class="lineno"> 8409 </span><span class="spaces">  </span><span class="nottickedoff">permEnvHints env</span></span>
<span class="lineno"> 8410 </span>
<span class="lineno"> 8411 </span>-- | Look up all hints with sort 'BlockEntryHintSort' for a given function
<span class="lineno"> 8412 </span>lookupBlockEntryHints :: PermEnv -&gt; FnHandle init ret -&gt;
<span class="lineno"> 8413 </span>                         Assignment CtxRepr blocks -&gt;
<span class="lineno"> 8414 </span>                         [Some (BlockHint blocks init ret)]
<span class="lineno"> 8415 </span><span class="decl"><span class="nottickedoff">lookupBlockEntryHints env h blocks =</span>
<span class="lineno"> 8416 </span><span class="spaces">  </span><span class="nottickedoff">mapMaybe (\hint -&gt; case hint of</span>
<span class="lineno"> 8417 </span><span class="spaces">               </span><span class="nottickedoff">Hint_Block blk_hint@(BlockHint h' blocks' _blkID'</span>
<span class="lineno"> 8418 </span><span class="spaces">                                    </span><span class="nottickedoff">(BlockEntryHintSort _ _ _))</span>
<span class="lineno"> 8419 </span><span class="spaces">                 </span><span class="nottickedoff">| Just Refl &lt;- testEquality (handleID h') (handleID h)</span>
<span class="lineno"> 8420 </span><span class="spaces">                 </span><span class="nottickedoff">, Just Refl &lt;- testEquality blocks' blocks -&gt;</span>
<span class="lineno"> 8421 </span><span class="spaces">                   </span><span class="nottickedoff">return $ Some blk_hint</span>
<span class="lineno"> 8422 </span><span class="spaces">               </span><span class="nottickedoff">_ -&gt; Nothing) $</span>
<span class="lineno"> 8423 </span><span class="spaces">  </span><span class="nottickedoff">permEnvHints env</span></span>
<span class="lineno"> 8424 </span>
<span class="lineno"> 8425 </span>-- | Test if a 'BlockID' in a 'CFG' has a hint with sort 'GenPermsHintSort'
<span class="lineno"> 8426 </span>lookupBlockGenPermsHint :: PermEnv -&gt; FnHandle init ret -&gt;
<span class="lineno"> 8427 </span>                           Assignment CtxRepr blocks -&gt; BlockID blocks args -&gt;
<span class="lineno"> 8428 </span>                           Bool
<span class="lineno"> 8429 </span><span class="decl"><span class="nottickedoff">lookupBlockGenPermsHint env h blocks blkID =</span>
<span class="lineno"> 8430 </span><span class="spaces">  </span><span class="nottickedoff">any (\case GenPermsHintSort -&gt; True</span>
<span class="lineno"> 8431 </span><span class="spaces">             </span><span class="nottickedoff">_ -&gt; False) $</span>
<span class="lineno"> 8432 </span><span class="spaces">  </span><span class="nottickedoff">lookupBlockHints env h blocks blkID</span></span>
<span class="lineno"> 8433 </span>
<span class="lineno"> 8434 </span>-- | Test if a 'BlockID' in a 'CFG' has a hint with sort 'JoinPointHintSort'
<span class="lineno"> 8435 </span>lookupBlockJoinPointHint :: PermEnv -&gt; FnHandle init ret -&gt;
<span class="lineno"> 8436 </span>                            Assignment CtxRepr blocks -&gt; BlockID blocks args -&gt;
<span class="lineno"> 8437 </span>                            Bool
<span class="lineno"> 8438 </span><span class="decl"><span class="nottickedoff">lookupBlockJoinPointHint env h blocks blkID =</span>
<span class="lineno"> 8439 </span><span class="spaces">  </span><span class="nottickedoff">any (\case JoinPointHintSort -&gt; True</span>
<span class="lineno"> 8440 </span><span class="spaces">             </span><span class="nottickedoff">_ -&gt; False) $</span>
<span class="lineno"> 8441 </span><span class="spaces">  </span><span class="nottickedoff">lookupBlockHints env h blocks blkID</span></span>
<span class="lineno"> 8442 </span>
<span class="lineno"> 8443 </span>
<span class="lineno"> 8444 </span>----------------------------------------------------------------------
<span class="lineno"> 8445 </span>-- * Permission Sets
<span class="lineno"> 8446 </span>----------------------------------------------------------------------
<span class="lineno"> 8447 </span>
<span class="lineno"> 8448 </span>-- FIXME: revisit all the operations in this section and remove those that we no
<span class="lineno"> 8449 </span>-- longer need
<span class="lineno"> 8450 </span>
<span class="lineno"> 8451 </span>-- | A permission set associates permissions with expression variables, and also
<span class="lineno"> 8452 </span>-- has a stack of \&quot;distinguished permissions\&quot; that are used for intro rules
<span class="lineno"> 8453 </span>data PermSet ps = PermSet { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_varPermMap</span></span></span> :: NameMap ValuePerm,
<span class="lineno"> 8454 </span>                            <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_distPerms</span></span></span> :: DistPerms ps }
<span class="lineno"> 8455 </span>
<span class="lineno"> 8456 </span><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">makeLenses ''PermSet</span></span></span></span></span>
<span class="lineno"> 8457 </span>
<span class="lineno"> 8458 </span>-- | Get all variables that have permissions set in a 'PermSet'
<span class="lineno"> 8459 </span>permSetVars :: PermSet ps -&gt; [SomeName CrucibleType]
<span class="lineno"> 8460 </span><span class="decl"><span class="nottickedoff">permSetVars =</span>
<span class="lineno"> 8461 </span><span class="spaces">  </span><span class="nottickedoff">map (\case (NameAndElem n _) -&gt;</span>
<span class="lineno"> 8462 </span><span class="spaces">               </span><span class="nottickedoff">SomeName n) . NameMap.assocs . view varPermMap</span></span>
<span class="lineno"> 8463 </span>
<span class="lineno"> 8464 </span>-- | Build a 'PermSet' with only distinguished permissions
<span class="lineno"> 8465 </span>distPermSet :: DistPerms ps -&gt; PermSet ps
<span class="lineno"> 8466 </span><span class="decl"><span class="nottickedoff">distPermSet perms = PermSet NameMap.empty perms</span></span>
<span class="lineno"> 8467 </span>
<span class="lineno"> 8468 </span>-- | The lens for the permissions associated with a given variable
<span class="lineno"> 8469 </span>varPerm :: ExprVar a -&gt; Lens' (PermSet ps) (ValuePerm a)
<span class="lineno"> 8470 </span><span class="decl"><span class="nottickedoff">varPerm x =</span>
<span class="lineno"> 8471 </span><span class="spaces">  </span><span class="nottickedoff">lens</span>
<span class="lineno"> 8472 </span><span class="spaces">  </span><span class="nottickedoff">(\(PermSet nmap _) -&gt;</span>
<span class="lineno"> 8473 </span><span class="spaces">    </span><span class="nottickedoff">case NameMap.lookup x nmap of</span>
<span class="lineno"> 8474 </span><span class="spaces">      </span><span class="nottickedoff">Just p -&gt; p</span>
<span class="lineno"> 8475 </span><span class="spaces">      </span><span class="nottickedoff">Nothing -&gt; ValPerm_True)</span>
<span class="lineno"> 8476 </span><span class="spaces">  </span><span class="nottickedoff">(\(PermSet nmap ps) p -&gt; PermSet (NameMap.insert x p nmap) ps)</span></span>
<span class="lineno"> 8477 </span>
<span class="lineno"> 8478 </span>-- | Set the primary permission for a variable, assuming it is currently the
<span class="lineno"> 8479 </span>-- trivial permission @true@
<span class="lineno"> 8480 </span>setVarPerm :: ExprVar a -&gt; ValuePerm a -&gt; PermSet ps -&gt; PermSet ps
<span class="lineno"> 8481 </span><span class="decl"><span class="nottickedoff">setVarPerm x p =</span>
<span class="lineno"> 8482 </span><span class="spaces">  </span><span class="nottickedoff">over (varPerm x) $ \p' -&gt;</span>
<span class="lineno"> 8483 </span><span class="spaces">  </span><span class="nottickedoff">case p' of</span>
<span class="lineno"> 8484 </span><span class="spaces">    </span><span class="nottickedoff">ValPerm_True -&gt; p</span>
<span class="lineno"> 8485 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; panic &quot;setVarPerm&quot; [&quot;permission for variable already set!&quot;]</span></span>
<span class="lineno"> 8486 </span>
<span class="lineno"> 8487 </span>-- | Get a permission list for multiple variables
<span class="lineno"> 8488 </span>varPermsMulti :: RAssign Name ns -&gt; PermSet ps -&gt; DistPerms ns
<span class="lineno"> 8489 </span><span class="decl"><span class="nottickedoff">varPermsMulti MNil _ = DistPermsNil</span>
<span class="lineno"> 8490 </span><span class="spaces"></span><span class="nottickedoff">varPermsMulti (ns :&gt;: n) ps =</span>
<span class="lineno"> 8491 </span><span class="spaces">  </span><span class="nottickedoff">DistPermsCons (varPermsMulti ns ps) n (ps ^. varPerm n)</span></span>
<span class="lineno"> 8492 </span>
<span class="lineno"> 8493 </span>-- | Get a permission list for all variable permissions
<span class="lineno"> 8494 </span>permSetAllVarPerms :: PermSet ps -&gt; Some DistPerms
<span class="lineno"> 8495 </span><span class="decl"><span class="nottickedoff">permSetAllVarPerms perm_set =</span>
<span class="lineno"> 8496 </span><span class="spaces">  </span><span class="nottickedoff">foldr (\(NameAndElem x p) (Some perms) -&gt; Some (DistPermsCons perms x p))</span>
<span class="lineno"> 8497 </span><span class="spaces">  </span><span class="nottickedoff">(Some DistPermsNil) (NameMap.assocs $ _varPermMap perm_set)</span></span>
<span class="lineno"> 8498 </span>
<span class="lineno"> 8499 </span>-- | A determined vars clause says that the variable on the right-hand side is
<span class="lineno"> 8500 </span>-- determined (as in the description of 'determinedVars') if all those on the
<span class="lineno"> 8501 </span>-- left-hand side are. Note that this is an if and not an iff, as there may be
<span class="lineno"> 8502 </span>-- other ways to mark that RHS variable determined.
<span class="lineno"> 8503 </span>data DetVarsClause =
<span class="lineno"> 8504 </span>  DetVarsClause (NameSet CrucibleType) (SomeName CrucibleType)
<span class="lineno"> 8505 </span>
<span class="lineno"> 8506 </span>-- | Union a 'NameSet' to the left-hand side of a 'DetVarsClause'
<span class="lineno"> 8507 </span>detVarsClauseAddLHS :: NameSet CrucibleType -&gt; DetVarsClause -&gt; DetVarsClause
<span class="lineno"> 8508 </span><span class="decl"><span class="nottickedoff">detVarsClauseAddLHS names (DetVarsClause lhs rhs) =</span>
<span class="lineno"> 8509 </span><span class="spaces">  </span><span class="nottickedoff">DetVarsClause (NameSet.union lhs names) rhs</span></span>
<span class="lineno"> 8510 </span>
<span class="lineno"> 8511 </span>-- | Add a single variable to the left-hand side of a 'DetVarsClause'
<span class="lineno"> 8512 </span>detVarsClauseAddLHSVar :: ExprVar a -&gt; DetVarsClause -&gt; DetVarsClause
<span class="lineno"> 8513 </span><span class="decl"><span class="nottickedoff">detVarsClauseAddLHSVar n (DetVarsClause lhs rhs) =</span>
<span class="lineno"> 8514 </span><span class="spaces">  </span><span class="nottickedoff">DetVarsClause (NameSet.insert n lhs) rhs</span></span>
<span class="lineno"> 8515 </span>
<span class="lineno"> 8516 </span>newtype SeenDetVarsClauses :: CrucibleType -&gt; Type where
<span class="lineno"> 8517 </span>  SeenDetVarsClauses :: [DetVarsClause] -&gt; SeenDetVarsClauses tp
<span class="lineno"> 8518 </span>
<span class="lineno"> 8519 </span>-- | Generic function to compute the 'DetVarsClause's for a permission
<span class="lineno"> 8520 </span>class GetDetVarsClauses a where
<span class="lineno"> 8521 </span>  getDetVarsClauses ::
<span class="lineno"> 8522 </span>    a -&gt; ReaderT (PermSet ps) (State (NameMap SeenDetVarsClauses))
<span class="lineno"> 8523 </span>                              [DetVarsClause]
<span class="lineno"> 8524 </span>
<span class="lineno"> 8525 </span>instance GetDetVarsClauses a =&gt; GetDetVarsClauses [a] where
<span class="lineno"> 8526 </span>  <span class="decl"><span class="nottickedoff">getDetVarsClauses l = concat &lt;$&gt; mapM getDetVarsClauses l</span></span>
<span class="lineno"> 8527 </span>
<span class="lineno"> 8528 </span>instance GetDetVarsClauses (ExprVar a) where
<span class="lineno"> 8529 </span>  -- If x has not been visited yet, then return a clause stating that x is
<span class="lineno"> 8530 </span>  -- determined and add all variables that are potentially determined by the
<span class="lineno"> 8531 </span>  -- current permissions on x
<span class="lineno"> 8532 </span>  <span class="decl"><span class="nottickedoff">getDetVarsClauses x =</span>
<span class="lineno"> 8533 </span><span class="spaces">    </span><span class="nottickedoff">do seen_vars &lt;- get</span>
<span class="lineno"> 8534 </span><span class="spaces">       </span><span class="nottickedoff">perms &lt;- ask</span>
<span class="lineno"> 8535 </span><span class="spaces">       </span><span class="nottickedoff">perm_clauses &lt;- case NameMap.lookup x seen_vars of</span>
<span class="lineno"> 8536 </span><span class="spaces">         </span><span class="nottickedoff">Just (SeenDetVarsClauses perm_clauses) -&gt; return perm_clauses</span>
<span class="lineno"> 8537 </span><span class="spaces">         </span><span class="nottickedoff">Nothing -&gt; do perm_clauses &lt;- getDetVarsClauses (perms ^. varPerm x)</span>
<span class="lineno"> 8538 </span><span class="spaces">                       </span><span class="nottickedoff">modify (NameMap.insert x (SeenDetVarsClauses perm_clauses))</span>
<span class="lineno"> 8539 </span><span class="spaces">                       </span><span class="nottickedoff">return perm_clauses</span>
<span class="lineno"> 8540 </span><span class="spaces">       </span><span class="nottickedoff">return (DetVarsClause NameSet.empty (SomeName x) :</span>
<span class="lineno"> 8541 </span><span class="spaces">               </span><span class="nottickedoff">map (detVarsClauseAddLHSVar x) perm_clauses)</span></span>
<span class="lineno"> 8542 </span>
<span class="lineno"> 8543 </span>instance GetDetVarsClauses (PermExpr a) where
<span class="lineno"> 8544 </span>  <span class="decl"><span class="nottickedoff">getDetVarsClauses e</span>
<span class="lineno"> 8545 </span><span class="spaces">    </span><span class="nottickedoff">| isDeterminingExpr e =</span>
<span class="lineno"> 8546 </span><span class="spaces">      </span><span class="nottickedoff">concat &lt;$&gt; mapM (\(SomeName n) -&gt;</span>
<span class="lineno"> 8547 </span><span class="spaces">                        </span><span class="nottickedoff">getDetVarsClauses n) (NameSet.toList $ freeVars e)</span>
<span class="lineno"> 8548 </span><span class="spaces">  </span><span class="nottickedoff">getDetVarsClauses _ = return []</span></span>
<span class="lineno"> 8549 </span>
<span class="lineno"> 8550 </span>
<span class="lineno"> 8551 </span>instance GetDetVarsClauses (PermExprs as) where
<span class="lineno"> 8552 </span>  <span class="decl"><span class="nottickedoff">getDetVarsClauses PExprs_Nil = return []</span>
<span class="lineno"> 8553 </span><span class="spaces">  </span><span class="nottickedoff">getDetVarsClauses (PExprs_Cons es e) =</span>
<span class="lineno"> 8554 </span><span class="spaces">    </span><span class="nottickedoff">(++) &lt;$&gt; getDetVarsClauses es &lt;*&gt; getDetVarsClauses e</span></span>
<span class="lineno"> 8555 </span>
<span class="lineno"> 8556 </span>instance GetDetVarsClauses (ValuePerm a) where
<span class="lineno"> 8557 </span>  <span class="decl"><span class="nottickedoff">getDetVarsClauses (ValPerm_Eq e) = getDetVarsClauses e</span>
<span class="lineno"> 8558 </span><span class="spaces">  </span><span class="nottickedoff">getDetVarsClauses (ValPerm_Conj ps) = concat &lt;$&gt; mapM getDetVarsClauses ps</span>
<span class="lineno"> 8559 </span><span class="spaces">  </span><span class="nottickedoff">-- FIXME: For named perms, we currently require the offset to have no free</span>
<span class="lineno"> 8560 </span><span class="spaces">  </span><span class="nottickedoff">-- vars, as a simplification, but this could maybe be loosened...?</span>
<span class="lineno"> 8561 </span><span class="spaces">  </span><span class="nottickedoff">getDetVarsClauses (ValPerm_Named _ args off)</span>
<span class="lineno"> 8562 </span><span class="spaces">    </span><span class="nottickedoff">| NameSet.null (freeVars off) = getDetVarsClauses args</span>
<span class="lineno"> 8563 </span><span class="spaces">  </span><span class="nottickedoff">getDetVarsClauses _ = return []</span></span>
<span class="lineno"> 8564 </span>
<span class="lineno"> 8565 </span>instance GetDetVarsClauses (ValuePerms as) where
<span class="lineno"> 8566 </span>  <span class="decl"><span class="nottickedoff">getDetVarsClauses ValPerms_Nil = return []</span>
<span class="lineno"> 8567 </span><span class="spaces">  </span><span class="nottickedoff">getDetVarsClauses (ValPerms_Cons ps p) =</span>
<span class="lineno"> 8568 </span><span class="spaces">    </span><span class="nottickedoff">(++) &lt;$&gt; getDetVarsClauses ps &lt;*&gt; getDetVarsClauses p</span></span>
<span class="lineno"> 8569 </span>
<span class="lineno"> 8570 </span>instance GetDetVarsClauses (AtomicPerm a) where
<span class="lineno"> 8571 </span>  <span class="decl"><span class="nottickedoff">getDetVarsClauses (Perm_LLVMField fp) = getDetVarsClauses fp</span>
<span class="lineno"> 8572 </span><span class="spaces">  </span><span class="nottickedoff">getDetVarsClauses (Perm_LLVMArray ap) = getDetVarsClauses ap</span>
<span class="lineno"> 8573 </span><span class="spaces">  </span><span class="nottickedoff">getDetVarsClauses (Perm_LLVMBlock bp) = getDetVarsClauses bp</span>
<span class="lineno"> 8574 </span><span class="spaces">  </span><span class="nottickedoff">getDetVarsClauses (Perm_LLVMBlockShape sh) = getDetVarsClauses sh</span>
<span class="lineno"> 8575 </span><span class="spaces">  </span><span class="nottickedoff">getDetVarsClauses (Perm_LLVMFrame frame_perm) =</span>
<span class="lineno"> 8576 </span><span class="spaces">    </span><span class="nottickedoff">concat &lt;$&gt; mapM (getDetVarsClauses . fst) frame_perm</span>
<span class="lineno"> 8577 </span><span class="spaces">  </span><span class="nottickedoff">getDetVarsClauses (Perm_LOwned _ _ _ _ _) = return []</span>
<span class="lineno"> 8578 </span><span class="spaces">  </span><span class="nottickedoff">getDetVarsClauses (Perm_LOwnedSimple _ lops) =</span>
<span class="lineno"> 8579 </span><span class="spaces">    </span><span class="nottickedoff">getDetVarsClauses $ RL.map exprAndPermPerm lops</span>
<span class="lineno"> 8580 </span><span class="spaces">  </span><span class="nottickedoff">getDetVarsClauses _ = return []</span></span>
<span class="lineno"> 8581 </span>
<span class="lineno"> 8582 </span>instance (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno"> 8583 </span>         GetDetVarsClauses (LLVMFieldPerm w sz) where
<span class="lineno"> 8584 </span>  <span class="decl"><span class="nottickedoff">getDetVarsClauses (LLVMFieldPerm {..}) =</span>
<span class="lineno"> 8585 </span><span class="spaces">    </span><span class="nottickedoff">map (detVarsClauseAddLHS (freeVars llvmFieldOffset)) &lt;$&gt; concat &lt;$&gt;</span>
<span class="lineno"> 8586 </span><span class="spaces">    </span><span class="nottickedoff">sequence [getDetVarsClauses llvmFieldRW,</span>
<span class="lineno"> 8587 </span><span class="spaces">              </span><span class="nottickedoff">getDetVarsClauses llvmFieldLifetime,</span>
<span class="lineno"> 8588 </span><span class="spaces">              </span><span class="nottickedoff">getDetVarsClauses llvmFieldContents]</span></span>
<span class="lineno"> 8589 </span>
<span class="lineno"> 8590 </span>instance (1 &lt;= w, KnownNat w) =&gt; GetDetVarsClauses (LLVMArrayPerm w) where
<span class="lineno"> 8591 </span>  <span class="decl"><span class="nottickedoff">getDetVarsClauses (LLVMArrayPerm {..}) =</span>
<span class="lineno"> 8592 </span><span class="spaces">    </span><span class="nottickedoff">map (detVarsClauseAddLHS $</span>
<span class="lineno"> 8593 </span><span class="spaces">         </span><span class="nottickedoff">NameSet.unions [freeVars llvmArrayOffset, freeVars llvmArrayLen,</span>
<span class="lineno"> 8594 </span><span class="spaces">                         </span><span class="nottickedoff">freeVars llvmArrayBorrows]) &lt;$&gt; concat &lt;$&gt;</span>
<span class="lineno"> 8595 </span><span class="spaces">    </span><span class="nottickedoff">sequence [getDetVarsClauses llvmArrayRW,</span>
<span class="lineno"> 8596 </span><span class="spaces">              </span><span class="nottickedoff">getDetVarsClauses llvmArrayLifetime,</span>
<span class="lineno"> 8597 </span><span class="spaces">              </span><span class="nottickedoff">getDetVarsClauses llvmArrayCellShape]</span></span>
<span class="lineno"> 8598 </span>
<span class="lineno"> 8599 </span>instance (1 &lt;= w, KnownNat w) =&gt; GetDetVarsClauses (LLVMBlockPerm w) where
<span class="lineno"> 8600 </span>  <span class="decl"><span class="nottickedoff">getDetVarsClauses (LLVMBlockPerm {..}) =</span>
<span class="lineno"> 8601 </span><span class="spaces">    </span><span class="nottickedoff">map (detVarsClauseAddLHS $</span>
<span class="lineno"> 8602 </span><span class="spaces">         </span><span class="nottickedoff">NameSet.unions [freeVars llvmBlockOffset, freeVars llvmBlockLen]) &lt;$&gt;</span>
<span class="lineno"> 8603 </span><span class="spaces">    </span><span class="nottickedoff">concat &lt;$&gt; sequence [getDetVarsClauses llvmBlockRW,</span>
<span class="lineno"> 8604 </span><span class="spaces">                         </span><span class="nottickedoff">getDetVarsClauses llvmBlockLifetime,</span>
<span class="lineno"> 8605 </span><span class="spaces">                         </span><span class="nottickedoff">getShapeDetVarsClauses llvmBlockShape]</span></span>
<span class="lineno"> 8606 </span>
<span class="lineno"> 8607 </span>instance GetDetVarsClauses (LLVMFieldShape w) where
<span class="lineno"> 8608 </span>  <span class="decl"><span class="nottickedoff">getDetVarsClauses (LLVMFieldShape p) = getDetVarsClauses p</span></span>
<span class="lineno"> 8609 </span>
<span class="lineno"> 8610 </span>-- | Compute the 'DetVarsClause's for a block permission with the given shape
<span class="lineno"> 8611 </span>getShapeDetVarsClauses ::
<span class="lineno"> 8612 </span>  (1 &lt;= w, KnownNat w) =&gt; PermExpr (LLVMShapeType w) -&gt;
<span class="lineno"> 8613 </span>  ReaderT (PermSet ps) (State (NameMap SeenDetVarsClauses)) [DetVarsClause]
<span class="lineno"> 8614 </span><span class="decl"><span class="nottickedoff">getShapeDetVarsClauses (PExpr_Var x) =</span>
<span class="lineno"> 8615 </span><span class="spaces">  </span><span class="nottickedoff">getDetVarsClauses x</span>
<span class="lineno"> 8616 </span><span class="spaces"></span><span class="nottickedoff">getShapeDetVarsClauses (PExpr_NamedShape _ _ _ args) =</span>
<span class="lineno"> 8617 </span><span class="spaces">  </span><span class="nottickedoff">-- FIXME: maybe also include the variables determined by the modalities?</span>
<span class="lineno"> 8618 </span><span class="spaces">  </span><span class="nottickedoff">getDetVarsClauses args</span>
<span class="lineno"> 8619 </span><span class="spaces"></span><span class="nottickedoff">getShapeDetVarsClauses (PExpr_EqShape len e) =</span>
<span class="lineno"> 8620 </span><span class="spaces">  </span><span class="nottickedoff">map (detVarsClauseAddLHS (freeVars len)) &lt;$&gt; getDetVarsClauses e</span>
<span class="lineno"> 8621 </span><span class="spaces"></span><span class="nottickedoff">getShapeDetVarsClauses (PExpr_PtrShape _ _ sh) =</span>
<span class="lineno"> 8622 </span><span class="spaces">  </span><span class="nottickedoff">-- FIXME: maybe also include the variables determined by the modalities?</span>
<span class="lineno"> 8623 </span><span class="spaces">  </span><span class="nottickedoff">getShapeDetVarsClauses sh</span>
<span class="lineno"> 8624 </span><span class="spaces"></span><span class="nottickedoff">getShapeDetVarsClauses (PExpr_FieldShape fldsh) = getDetVarsClauses fldsh</span>
<span class="lineno"> 8625 </span><span class="spaces"></span><span class="nottickedoff">getShapeDetVarsClauses (PExpr_ArrayShape len _ sh) =</span>
<span class="lineno"> 8626 </span><span class="spaces">  </span><span class="nottickedoff">map (detVarsClauseAddLHS (freeVars len)) &lt;$&gt; getDetVarsClauses sh</span>
<span class="lineno"> 8627 </span><span class="spaces"></span><span class="nottickedoff">getShapeDetVarsClauses (PExpr_TupShape sh) = getShapeDetVarsClauses sh</span>
<span class="lineno"> 8628 </span><span class="spaces"></span><span class="nottickedoff">getShapeDetVarsClauses (PExpr_SeqShape sh1 sh2)</span>
<span class="lineno"> 8629 </span><span class="spaces">  </span><span class="nottickedoff">| isJust $ llvmShapeLength sh1 =</span>
<span class="lineno"> 8630 </span><span class="spaces">    </span><span class="nottickedoff">(++) &lt;$&gt; getDetVarsClauses sh1 &lt;*&gt; getDetVarsClauses sh2</span>
<span class="lineno"> 8631 </span><span class="spaces"></span><span class="nottickedoff">getShapeDetVarsClauses _ = return []</span></span>
<span class="lineno"> 8632 </span>
<span class="lineno"> 8633 </span>
<span class="lineno"> 8634 </span>-- | Compute all the variables whose values are /determined/ by the permissions
<span class="lineno"> 8635 </span>-- on the given input variables, other than those variables themselves. The
<span class="lineno"> 8636 </span>-- intuitive idea is that permission @x:p@ determines the value of @y@ iff there
<span class="lineno"> 8637 </span>-- is always a uniquely determined value of @y@ for any proof of @exists y.x:p@.
<span class="lineno"> 8638 </span>determinedVars :: PermSet ps -&gt; RAssign ExprVar ns -&gt; [SomeName CrucibleType]
<span class="lineno"> 8639 </span><span class="decl"><span class="nottickedoff">determinedVars top_perms vars =</span>
<span class="lineno"> 8640 </span><span class="spaces">  </span><span class="nottickedoff">let vars_map = NameMap.fromList $</span>
<span class="lineno"> 8641 </span><span class="spaces">        </span><span class="nottickedoff">mapToList (\v -&gt; NameAndElem v (SeenDetVarsClauses [])) vars</span>
<span class="lineno"> 8642 </span><span class="spaces">      </span><span class="nottickedoff">vars_set = NameSet.fromList $ mapToList SomeName vars</span>
<span class="lineno"> 8643 </span><span class="spaces">      </span><span class="nottickedoff">multigraph =</span>
<span class="lineno"> 8644 </span><span class="spaces">        </span><span class="nottickedoff">evalState (runReaderT (getDetVarsClauses (distPermsToValuePerms $</span>
<span class="lineno"> 8645 </span><span class="spaces">                                                  </span><span class="nottickedoff">varPermsMulti vars top_perms))</span>
<span class="lineno"> 8646 </span><span class="spaces">                   </span><span class="nottickedoff">top_perms)</span>
<span class="lineno"> 8647 </span><span class="spaces">        </span><span class="nottickedoff">vars_map in</span>
<span class="lineno"> 8648 </span><span class="spaces">  </span><span class="nottickedoff">evalState (determinedVarsForGraph multigraph) vars_set</span>
<span class="lineno"> 8649 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno"> 8650 </span><span class="spaces">    </span><span class="nottickedoff">-- Find all variables that are not already marked as determined in our</span>
<span class="lineno"> 8651 </span><span class="spaces">    </span><span class="nottickedoff">-- NameSet state but that are determined given the current determined</span>
<span class="lineno"> 8652 </span><span class="spaces">    </span><span class="nottickedoff">-- variables, mark these variables as determined, and then repeat, returning</span>
<span class="lineno"> 8653 </span><span class="spaces">    </span><span class="nottickedoff">-- all variables that are found in order</span>
<span class="lineno"> 8654 </span><span class="spaces">    </span><span class="nottickedoff">determinedVarsForGraph :: [DetVarsClause] -&gt;</span>
<span class="lineno"> 8655 </span><span class="spaces">                              </span><span class="nottickedoff">State (NameSet CrucibleType)</span>
<span class="lineno"> 8656 </span><span class="spaces">                                    </span><span class="nottickedoff">[SomeName CrucibleType]</span>
<span class="lineno"> 8657 </span><span class="spaces">    </span><span class="nottickedoff">determinedVarsForGraph graph =</span>
<span class="lineno"> 8658 </span><span class="spaces">      </span><span class="nottickedoff">do det_vars &lt;- concat &lt;$&gt; mapM determinedVarsForClause graph</span>
<span class="lineno"> 8659 </span><span class="spaces">         </span><span class="nottickedoff">if det_vars == [] then return [] else</span>
<span class="lineno"> 8660 </span><span class="spaces">           </span><span class="nottickedoff">(det_vars ++) &lt;$&gt; determinedVarsForGraph graph</span>
<span class="lineno"> 8661 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8662 </span><span class="spaces">    </span><span class="nottickedoff">-- If the LHS of a clause has become determined but its RHS is not, return</span>
<span class="lineno"> 8663 </span><span class="spaces">    </span><span class="nottickedoff">-- its RHS, otherwise return nothing</span>
<span class="lineno"> 8664 </span><span class="spaces">    </span><span class="nottickedoff">determinedVarsForClause :: DetVarsClause -&gt;</span>
<span class="lineno"> 8665 </span><span class="spaces">                               </span><span class="nottickedoff">State (NameSet CrucibleType)</span>
<span class="lineno"> 8666 </span><span class="spaces">                                     </span><span class="nottickedoff">[SomeName CrucibleType]</span>
<span class="lineno"> 8667 </span><span class="spaces">    </span><span class="nottickedoff">determinedVarsForClause (DetVarsClause lhs_vars (SomeName rhs_var)) =</span>
<span class="lineno"> 8668 </span><span class="spaces">      </span><span class="nottickedoff">do det_vars &lt;- get</span>
<span class="lineno"> 8669 </span><span class="spaces">         </span><span class="nottickedoff">if not (NameSet.member rhs_var det_vars) &amp;&amp;</span>
<span class="lineno"> 8670 </span><span class="spaces">            </span><span class="nottickedoff">nameSetIsSubsetOf lhs_vars det_vars</span>
<span class="lineno"> 8671 </span><span class="spaces">           </span><span class="nottickedoff">then modify (NameSet.insert rhs_var) &gt;&gt; return [SomeName rhs_var]</span>
<span class="lineno"> 8672 </span><span class="spaces">           </span><span class="nottickedoff">else return []</span></span>
<span class="lineno"> 8673 </span>
<span class="lineno"> 8674 </span>-- | Compute the transitive free variables of the permissions on some input list
<span class="lineno"> 8675 </span>-- @ns@ of variables, which includes all variables @ns1@ that are free in the
<span class="lineno"> 8676 </span>-- permissions associated with @ns@, all the variables @ns2@ free in the
<span class="lineno"> 8677 </span>-- permissions of @ns1@, etc. Every variable in the returned list is guaranteed
<span class="lineno"> 8678 </span>-- to be listed /after/ (i.e., to the right of where) it is used.
<span class="lineno"> 8679 </span>varPermsTransFreeVars :: RAssign ExprVar ns -&gt; PermSet ps -&gt;
<span class="lineno"> 8680 </span>                         Some (RAssign ExprVar)
<span class="lineno"> 8681 </span><span class="decl"><span class="nottickedoff">varPermsTransFreeVars =</span>
<span class="lineno"> 8682 </span><span class="spaces">  </span><span class="nottickedoff">helper NameSet.empty . mapToList SomeName</span>
<span class="lineno"> 8683 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno"> 8684 </span><span class="spaces">    </span><span class="nottickedoff">helper :: NameSet CrucibleType -&gt; [SomeName CrucibleType] -&gt; PermSet ps -&gt;</span>
<span class="lineno"> 8685 </span><span class="spaces">              </span><span class="nottickedoff">Some (RAssign ExprVar)</span>
<span class="lineno"> 8686 </span><span class="spaces">    </span><span class="nottickedoff">helper seen_vars ns perms =</span>
<span class="lineno"> 8687 </span><span class="spaces">      </span><span class="nottickedoff">let seen_vars' =</span>
<span class="lineno"> 8688 </span><span class="spaces">            </span><span class="nottickedoff">foldr (\(SomeName n) -&gt; NameSet.insert n) seen_vars ns</span>
<span class="lineno"> 8689 </span><span class="spaces">          </span><span class="nottickedoff">free_vars =</span>
<span class="lineno"> 8690 </span><span class="spaces">            </span><span class="nottickedoff">NameSet.unions $</span>
<span class="lineno"> 8691 </span><span class="spaces">            </span><span class="nottickedoff">map (\(SomeName n) -&gt; freeVars (perms ^. varPerm n)) ns</span>
<span class="lineno"> 8692 </span><span class="spaces">          </span><span class="nottickedoff">new_vars = NameSet.difference free_vars seen_vars' in</span>
<span class="lineno"> 8693 </span><span class="spaces">      </span><span class="nottickedoff">case toList new_vars of</span>
<span class="lineno"> 8694 </span><span class="spaces">        </span><span class="nottickedoff">[] -&gt; Some MNil</span>
<span class="lineno"> 8695 </span><span class="spaces">        </span><span class="nottickedoff">new_ns -&gt;</span>
<span class="lineno"> 8696 </span><span class="spaces">          </span><span class="nottickedoff">case (namesListToNames new_ns, helper seen_vars' new_ns perms) of</span>
<span class="lineno"> 8697 </span><span class="spaces">            </span><span class="nottickedoff">(SomeRAssign ns', Some rest) -&gt;</span>
<span class="lineno"> 8698 </span><span class="spaces">              </span><span class="nottickedoff">Some $ append ns' rest</span></span>
<span class="lineno"> 8699 </span>
<span class="lineno"> 8700 </span>
<span class="lineno"> 8701 </span>-- | Initialize the primary permission of a variable to the given permission if
<span class="lineno"> 8702 </span>-- the variable is not yet set
<span class="lineno"> 8703 </span>initVarPermWith :: ExprVar a -&gt; ValuePerm a -&gt; PermSet ps -&gt; PermSet ps
<span class="lineno"> 8704 </span><span class="decl"><span class="nottickedoff">initVarPermWith x p =</span>
<span class="lineno"> 8705 </span><span class="spaces">  </span><span class="nottickedoff">over varPermMap $ \nmap -&gt;</span>
<span class="lineno"> 8706 </span><span class="spaces">  </span><span class="nottickedoff">if NameMap.member x nmap then nmap else NameMap.insert x p nmap</span></span>
<span class="lineno"> 8707 </span>
<span class="lineno"> 8708 </span>-- | Initialize the primary permission of a variable to @true@ if it is not set
<span class="lineno"> 8709 </span>initVarPerm :: ExprVar a -&gt; PermSet ps -&gt; PermSet ps
<span class="lineno"> 8710 </span><span class="decl"><span class="nottickedoff">initVarPerm x =</span>
<span class="lineno"> 8711 </span><span class="spaces">  </span><span class="nottickedoff">initVarPermWith x ValPerm_True</span></span>
<span class="lineno"> 8712 </span>
<span class="lineno"> 8713 </span>-- | Set the primary permissions for a sequence of variables to @true@
<span class="lineno"> 8714 </span>initVarPerms :: RAssign Name (as :: RList CrucibleType) -&gt; PermSet ps -&gt;
<span class="lineno"> 8715 </span>                PermSet ps
<span class="lineno"> 8716 </span><span class="decl"><span class="nottickedoff">initVarPerms MNil perms = perms</span>
<span class="lineno"> 8717 </span><span class="spaces"></span><span class="nottickedoff">initVarPerms (ns :&gt;: n) perms = initVarPerms ns $ initVarPerm n perms</span></span>
<span class="lineno"> 8718 </span>
<span class="lineno"> 8719 </span>-- | The lens for a particular distinguished perm, checking that it is indeed
<span class="lineno"> 8720 </span>-- associated with the given variable
<span class="lineno"> 8721 </span>distPerm :: Member ps a -&gt; ExprVar a -&gt; Lens' (PermSet ps) (ValuePerm a)
<span class="lineno"> 8722 </span><span class="decl"><span class="nottickedoff">distPerm memb x = distPerms . nthVarPerm memb x</span></span>
<span class="lineno"> 8723 </span>
<span class="lineno"> 8724 </span>-- | The lens for the distinguished perm at the top of the stack, checking that
<span class="lineno"> 8725 </span>-- it has the given variable
<span class="lineno"> 8726 </span>topDistPerm :: ExprVar a -&gt; Lens' (PermSet (ps :&gt; a)) (ValuePerm a)
<span class="lineno"> 8727 </span><span class="decl"><span class="nottickedoff">topDistPerm x = distPerms . distPermsHead x</span></span>
<span class="lineno"> 8728 </span>
<span class="lineno"> 8729 </span>-- | Modify the distinguished permission stack of a 'PermSet'
<span class="lineno"> 8730 </span>modifyDistPerms :: (DistPerms ps1 -&gt; DistPerms ps2) -&gt;
<span class="lineno"> 8731 </span>                   PermSet ps1 -&gt; PermSet ps2
<span class="lineno"> 8732 </span><span class="decl"><span class="nottickedoff">modifyDistPerms f (PermSet perms dperms) = PermSet perms $ f dperms</span></span>
<span class="lineno"> 8733 </span>
<span class="lineno"> 8734 </span>-- | Get all the permissions in the permission set as a sequence of
<span class="lineno"> 8735 </span>-- distinguished permissions
<span class="lineno"> 8736 </span>getAllPerms :: PermSet ps -&gt; Some DistPerms
<span class="lineno"> 8737 </span><span class="decl"><span class="nottickedoff">getAllPerms perms = helper (NameMap.assocs $ perms ^. varPermMap) where</span>
<span class="lineno"> 8738 </span><span class="spaces">  </span><span class="nottickedoff">helper :: [NameAndElem ValuePerm] -&gt; Some DistPerms</span>
<span class="lineno"> 8739 </span><span class="spaces">  </span><span class="nottickedoff">helper [] = Some DistPermsNil</span>
<span class="lineno"> 8740 </span><span class="spaces">  </span><span class="nottickedoff">helper (NameAndElem x p : xps) =</span>
<span class="lineno"> 8741 </span><span class="spaces">    </span><span class="nottickedoff">case helper xps of</span>
<span class="lineno"> 8742 </span><span class="spaces">      </span><span class="nottickedoff">Some ps -&gt; Some $ DistPermsCons ps x p</span></span>
<span class="lineno"> 8743 </span>
<span class="lineno"> 8744 </span>-- | Delete permission @x:p@ from the permission set, assuming @x@ has precisely
<span class="lineno"> 8745 </span>-- permissions @p@, replacing it with @x:true@
<span class="lineno"> 8746 </span>deletePerm :: ExprVar a -&gt; ValuePerm a -&gt; PermSet ps -&gt; PermSet ps
<span class="lineno"> 8747 </span><span class="decl"><span class="nottickedoff">deletePerm x p =</span>
<span class="lineno"> 8748 </span><span class="spaces">  </span><span class="nottickedoff">over (varPerm x) $ \p' -&gt;</span>
<span class="lineno"> 8749 </span><span class="spaces">  </span><span class="nottickedoff">if p' == p then ValPerm_True else panic &quot;deletePerm&quot; []</span></span>
<span class="lineno"> 8750 </span>
<span class="lineno"> 8751 </span>-- | Push a new distinguished permission onto the top of the stack
<span class="lineno"> 8752 </span>pushPerm :: ExprVar a -&gt; ValuePerm a -&gt; PermSet ps -&gt; PermSet (ps :&gt; a)
<span class="lineno"> 8753 </span><span class="decl"><span class="nottickedoff">pushPerm x p (PermSet nmap ps) = PermSet nmap (DistPermsCons ps x p)</span></span>
<span class="lineno"> 8754 </span>
<span class="lineno"> 8755 </span>-- | Pop the top distinguished permission off of the stack
<span class="lineno"> 8756 </span>popPerm :: ExprVar a -&gt; PermSet (ps :&gt; a) -&gt; (PermSet ps, ValuePerm a)
<span class="lineno"> 8757 </span><span class="decl"><span class="nottickedoff">popPerm x (PermSet nmap pstk) =</span>
<span class="lineno"> 8758 </span><span class="spaces">  </span><span class="nottickedoff">(PermSet nmap (pstk ^. distPermsTail), pstk ^. distPermsHead x)</span></span>
<span class="lineno"> 8759 </span>
<span class="lineno"> 8760 </span>-- | Drop the top distinguished permission on the stack
<span class="lineno"> 8761 </span>dropPerm :: ExprVar a -&gt; PermSet (ps :&gt; a) -&gt; PermSet ps
<span class="lineno"> 8762 </span><span class="decl"><span class="nottickedoff">dropPerm x = fst . popPerm x</span></span>

</pre>
</body>
</html>
