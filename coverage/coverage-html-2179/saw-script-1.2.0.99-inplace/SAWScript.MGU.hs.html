<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- |
<span class="lineno">    2 </span>Module      : SAWScript.MGU
<span class="lineno">    3 </span>Description : SAW-Script type checking.
<span class="lineno">    4 </span>License     : BSD3
<span class="lineno">    5 </span>Maintainer  : diatchki
<span class="lineno">    6 </span>Stability   : provisional
<span class="lineno">    7 </span>-}
<span class="lineno">    8 </span>
<span class="lineno">    9 </span>{-# LANGUAGE CPP #-}
<span class="lineno">   10 </span>{-# LANGUAGE GeneralizedNewtypeDeriving #-}
<span class="lineno">   11 </span>{-# LANGUAGE PatternGuards #-}
<span class="lineno">   12 </span>{-# LANGUAGE TypeOperators #-}
<span class="lineno">   13 </span>{-# LANGUAGE ViewPatterns #-}
<span class="lineno">   14 </span>{-# LANGUAGE TupleSections #-}
<span class="lineno">   15 </span>-- See Note [-Wincomplete-uni-patterns and irrefutable patterns]
<span class="lineno">   16 </span>{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}
<span class="lineno">   17 </span>
<span class="lineno">   18 </span>module SAWScript.MGU
<span class="lineno">   19 </span>       ( checkDecl
<span class="lineno">   20 </span>       , checkStmt
<span class="lineno">   21 </span>       , instantiate
<span class="lineno">   22 </span>       ) where
<span class="lineno">   23 </span>
<span class="lineno">   24 </span>#if !MIN_VERSION_base(4,8,0)
<span class="lineno">   25 </span>import Control.Applicative
<span class="lineno">   26 </span>#endif
<span class="lineno">   27 </span>
<span class="lineno">   28 </span>import Control.Monad (zipWithM)
<span class="lineno">   29 </span>import Control.Monad.Reader (MonadReader(..), ReaderT(..), asks)
<span class="lineno">   30 </span>import Control.Monad.State (MonadState(..), StateT, gets, modify, runState)
<span class="lineno">   31 </span>import Control.Monad.Identity (Identity)
<span class="lineno">   32 </span>import Data.List (intercalate, genericTake)
<span class="lineno">   33 </span>import Data.Map (Map)
<span class="lineno">   34 </span>import Data.Either (partitionEithers)
<span class="lineno">   35 </span>import qualified Data.Map as M
<span class="lineno">   36 </span>--import qualified Data.Set as S
<span class="lineno">   37 </span>
<span class="lineno">   38 </span>import qualified Prettyprinter as PP
<span class="lineno">   39 </span>
<span class="lineno">   40 </span>import SAWScript.AST
<span class="lineno">   41 </span>import SAWScript.Panic (panic)
<span class="lineno">   42 </span>import SAWScript.Position (Inference(..), Pos(..), Positioned(..), choosePos)
<span class="lineno">   43 </span>
<span class="lineno">   44 </span>-- should probably move this to AST
<span class="lineno">   45 </span>tUnit :: Pos -&gt; Type
<span class="lineno">   46 </span><span class="decl"><span class="nottickedoff">tUnit pos = tTuple pos []</span></span>
<span class="lineno">   47 </span>
<span class="lineno">   48 </span>
<span class="lineno">   49 </span>-- short names for the environment types we use
<span class="lineno">   50 </span>type VarEnv = Map LName Schema
<span class="lineno">   51 </span>type TyEnv = Map Name NamedType 
<span class="lineno">   52 </span>
<span class="lineno">   53 </span>
<span class="lineno">   54 </span>------------------------------------------------------------
<span class="lineno">   55 </span>-- UnifyVars, NamedVars {{{
<span class="lineno">   56 </span>
<span class="lineno">   57 </span>--
<span class="lineno">   58 </span>-- unifyVars is a type-class-polymorphic function for extracting
<span class="lineno">   59 </span>-- unification vars from a type or type schema. It returns a set of
<span class="lineno">   60 </span>-- TypeIndex (TypeIndex is just Integer) manifested as a map from
<span class="lineno">   61 </span>-- those TypeIndexes to their positions/provenance.
<span class="lineno">   62 </span>--
<span class="lineno">   63 </span>
<span class="lineno">   64 </span>class UnifyVars t where
<span class="lineno">   65 </span>  unifyVars :: t -&gt; M.Map TypeIndex Pos
<span class="lineno">   66 </span>
<span class="lineno">   67 </span>instance (Ord k, UnifyVars a) =&gt; UnifyVars (M.Map k a) where
<span class="lineno">   68 </span>  <span class="decl"><span class="nottickedoff">unifyVars = unifyVars . M.elems</span></span>
<span class="lineno">   69 </span>
<span class="lineno">   70 </span>instance (UnifyVars a) =&gt; UnifyVars [a] where
<span class="lineno">   71 </span>  <span class="decl"><span class="istickedoff">unifyVars = M.unionsWith <span class="nottickedoff">choosePos</span> . map unifyVars</span></span>
<span class="lineno">   72 </span>
<span class="lineno">   73 </span>instance UnifyVars Type where
<span class="lineno">   74 </span>  <span class="decl"><span class="istickedoff">unifyVars t = case t of</span>
<span class="lineno">   75 </span><span class="spaces">    </span><span class="istickedoff">TyCon _ _ ts      -&gt; unifyVars ts</span>
<span class="lineno">   76 </span><span class="spaces">    </span><span class="istickedoff">TyRecord _ tm     -&gt; <span class="nottickedoff">unifyVars tm</span></span>
<span class="lineno">   77 </span><span class="spaces">    </span><span class="istickedoff">TyVar _ _         -&gt; M.empty</span>
<span class="lineno">   78 </span><span class="spaces">    </span><span class="istickedoff">TyUnifyVar pos i  -&gt; M.singleton i <span class="nottickedoff">pos</span></span></span>
<span class="lineno">   79 </span>
<span class="lineno">   80 </span>instance UnifyVars Schema where
<span class="lineno">   81 </span>  <span class="decl"><span class="istickedoff">unifyVars (Forall _ t) = unifyVars t</span></span>
<span class="lineno">   82 </span>
<span class="lineno">   83 </span>--
<span class="lineno">   84 </span>-- namedVars is a type-class-polymorphic function for extracting named
<span class="lineno">   85 </span>-- type variables from a type or type schema. It returns a set of Name
<span class="lineno">   86 </span>-- (Name is just String) manifested as a map from those Names to their
<span class="lineno">   87 </span>-- positions/provenance.
<span class="lineno">   88 </span>--
<span class="lineno">   89 </span>
<span class="lineno">   90 </span>class NamedVars t where
<span class="lineno">   91 </span>  namedVars :: t -&gt; M.Map Name Pos
<span class="lineno">   92 </span>
<span class="lineno">   93 </span>instance (Ord k, NamedVars a) =&gt; NamedVars (M.Map k a) where
<span class="lineno">   94 </span>  <span class="decl"><span class="nottickedoff">namedVars = namedVars . M.elems</span></span>
<span class="lineno">   95 </span>
<span class="lineno">   96 </span>instance (NamedVars a) =&gt; NamedVars [a] where
<span class="lineno">   97 </span>  <span class="decl"><span class="istickedoff">namedVars = M.unionsWith <span class="nottickedoff">choosePos</span> . map namedVars</span></span>
<span class="lineno">   98 </span>
<span class="lineno">   99 </span>instance NamedVars Type where
<span class="lineno">  100 </span>  <span class="decl"><span class="istickedoff">namedVars t = case t of</span>
<span class="lineno">  101 </span><span class="spaces">    </span><span class="istickedoff">TyCon _ _ ts      -&gt; namedVars ts</span>
<span class="lineno">  102 </span><span class="spaces">    </span><span class="istickedoff">TyRecord _ tm     -&gt; <span class="nottickedoff">namedVars tm</span></span>
<span class="lineno">  103 </span><span class="spaces">    </span><span class="istickedoff">TyVar pos n       -&gt; M.singleton n <span class="nottickedoff">pos</span></span>
<span class="lineno">  104 </span><span class="spaces">    </span><span class="istickedoff">TyUnifyVar _ _    -&gt; M.empty</span></span>
<span class="lineno">  105 </span>
<span class="lineno">  106 </span>instance NamedVars Schema where
<span class="lineno">  107 </span>  <span class="decl"><span class="istickedoff">namedVars (Forall ns t) = namedVars t M.\\ M.fromList ns'</span>
<span class="lineno">  108 </span><span class="spaces">    </span><span class="istickedoff">where ns' = map (\(pos, n) -&gt; (n, <span class="nottickedoff">pos</span>)) ns</span></span>
<span class="lineno">  109 </span>
<span class="lineno">  110 </span>-- }}}
<span class="lineno">  111 </span>
<span class="lineno">  112 </span>
<span class="lineno">  113 </span>------------------------------------------------------------
<span class="lineno">  114 </span>-- Substitutions {{{
<span class="lineno">  115 </span>
<span class="lineno">  116 </span>-- Subst is the type of a substitution map for unification vars.
<span class="lineno">  117 </span>newtype Subst = Subst { <span class="istickedoff"><span class="decl"><span class="istickedoff">unSubst</span></span></span> :: M.Map TypeIndex Type } deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  118 </span>
<span class="lineno">  119 </span>-- Merge two substitution maps.
<span class="lineno">  120 </span>--
<span class="lineno">  121 </span>-- XXX: this knows that in the uses below the right substitution (m1)
<span class="lineno">  122 </span>-- is the older/preexisting one. That probably shouldn't be silently
<span class="lineno">  123 </span>-- baked in.
<span class="lineno">  124 </span>--
<span class="lineno">  125 </span>-- We apply the left substitution (m2) into the types in the right
<span class="lineno">  126 </span>-- substitution (m1). That is, any new substitutions are applied into
<span class="lineno">  127 </span>-- the existing ones. I expect this in pursuit of an invariant where
<span class="lineno">  128 </span>-- any unification variables existing in the right-hand sides of the
<span class="lineno">  129 </span>-- substitution aren't themselves defined by the substitution, so we
<span class="lineno">  130 </span>-- don't have to recurse into the right-hand sides later when applying
<span class="lineno">  131 </span>-- the substitution.
<span class="lineno">  132 </span>--
<span class="lineno">  133 </span>-- XXX: However, this assumes that whatever is on the left-hand side
<span class="lineno">  134 </span>-- doesn't already violate this invariant. We can check this with
<span class="lineno">  135 </span>-- reasonable accuracy since we have right here all the ways to create
<span class="lineno">  136 </span>-- a Subst (and we can check that there aren't any others hidden
<span class="lineno">  137 </span>-- below)... and we find that while emptySubst is obviously ok, and
<span class="lineno">  138 </span>-- singletonSubst is ok (an attempt to create a singleton substitution
<span class="lineno">  139 </span>-- that refers to itself will fail the occurs check right before
<span class="lineno">  140 </span>-- calling singletonSubst), there doesn't seem to be any such
<span class="lineno">  141 </span>-- assurance for substFromList. I'm not sure if this is actually a
<span class="lineno">  142 </span>-- problem or not but it should probably be looked into at some point.
<span class="lineno">  143 </span>--
<span class="lineno">  144 </span>-- XXX: we should probably crosscheck the key space of the maps. Note
<span class="lineno">  145 </span>-- that the ordering of the M.union args means that if there are
<span class="lineno">  146 </span>-- duplicated keys we prefer the right substitution (m1), namely the
<span class="lineno">  147 </span>-- preexisting one. Given that this choice seems to be explicit, it
<span class="lineno">  148 </span>-- must have been for a reason, but I'm not sure what that reason
<span class="lineno">  149 </span>-- would be. Ordinarily in this kind of typechecker you might update a
<span class="lineno">  150 </span>-- substitution you've already made, but only when replacing a weak
<span class="lineno">  151 </span>-- substitution (one unification var for another, like a1 -&gt; a2) with
<span class="lineno">  152 </span>-- a strong one (involving a real type, like a1 -&gt; Int)... but if so
<span class="lineno">  153 </span>-- it would always be the _new_ substitution you'd want to keep.
<span class="lineno">  154 </span>-- However, in this particular code we always apply the existing
<span class="lineno">  155 </span>-- substitution before doing further unification, so once we have any
<span class="lineno">  156 </span>-- substitution for a given unification var we shouldn't get another.
<span class="lineno">  157 </span>-- (Unless I guess if the intended invariant above is violated, but if
<span class="lineno">  158 </span>-- that happens we should probably panic, not chug along.)
<span class="lineno">  159 </span>--
<span class="lineno">  160 </span>-- XXX: also it isn't clear that anything below guarantees that we
<span class="lineno">  161 </span>-- won't just derive multiple inconsistent substitutions (e.g. from
<span class="lineno">  162 </span>-- disjoint subexpressions) and combine them incoherently. This should
<span class="lineno">  163 </span>-- really be looked into further.
<span class="lineno">  164 </span>--
<span class="lineno">  165 </span>-- XXX: and _furthermore_ it's not clear that we can't get cyclic
<span class="lineno">  166 </span>-- substitutions. If we already have a substitution a1 -&gt; a2, and we
<span class="lineno">  167 </span>-- add a2 -&gt; a1, we'll resolve the existing substitution to a1 -&gt; a1
<span class="lineno">  168 </span>-- rather than going directly into an infinite loop. That's not
<span class="lineno">  169 </span>-- necessarily preferable though. Normally in this kind of typechecker
<span class="lineno">  170 </span>-- one also wants some kind of acyclicity-oriented invariant, like
<span class="lineno">  171 </span>-- aN resolves to aM only if N &gt; M (otherwise you substitute the other
<span class="lineno">  172 </span>-- way) but we don't do anything like that.
<span class="lineno">  173 </span>--
<span class="lineno">  174 </span>-- When all the above issues get clarified we should consider coming
<span class="lineno">  175 </span>-- up with a different name that indicates that this operation isn't
<span class="lineno">  176 </span>-- commutative. Unless it actually can be.
<span class="lineno">  177 </span>mergeSubst :: Subst -&gt; Subst -&gt; Subst
<span class="lineno">  178 </span><span class="decl"><span class="istickedoff">mergeSubst s2@(Subst m2) (Subst m1) = Subst $ m1' `M.union` m2</span>
<span class="lineno">  179 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  180 </span><span class="spaces">  </span><span class="istickedoff">m1' = fmap (appSubst s2) m1</span></span>
<span class="lineno">  181 </span>
<span class="lineno">  182 </span>emptySubst :: Subst
<span class="lineno">  183 </span><span class="decl"><span class="istickedoff">emptySubst = Subst M.empty</span></span>
<span class="lineno">  184 </span>
<span class="lineno">  185 </span>singletonSubst :: TypeIndex -&gt; Type -&gt; Subst
<span class="lineno">  186 </span><span class="decl"><span class="istickedoff">singletonSubst tv t = Subst $ M.singleton tv t</span></span>
<span class="lineno">  187 </span>
<span class="lineno">  188 </span>substFromList :: [(TypeIndex, Type)] -&gt; Subst
<span class="lineno">  189 </span><span class="decl"><span class="istickedoff">substFromList entries = Subst $ M.fromList entries</span></span>
<span class="lineno">  190 </span>
<span class="lineno">  191 </span>--
<span class="lineno">  192 </span>-- appSubst is a type-class-polymorphic function for applying a
<span class="lineno">  193 </span>-- substitution (of numbered unification vars) to AST elements.
<span class="lineno">  194 </span>--
<span class="lineno">  195 </span>
<span class="lineno">  196 </span>class AppSubst t where
<span class="lineno">  197 </span>  appSubst :: Subst -&gt; t -&gt; t
<span class="lineno">  198 </span>
<span class="lineno">  199 </span>instance (AppSubst t) =&gt; AppSubst (Maybe t) where
<span class="lineno">  200 </span>  <span class="decl"><span class="istickedoff">appSubst s = fmap $ appSubst s</span></span>
<span class="lineno">  201 </span>
<span class="lineno">  202 </span>instance (AppSubst t) =&gt; AppSubst [t] where
<span class="lineno">  203 </span>  <span class="decl"><span class="istickedoff">appSubst s = map $ appSubst s</span></span>
<span class="lineno">  204 </span>
<span class="lineno">  205 </span>instance (Ord k, AppSubst a) =&gt; AppSubst (M.Map k a) where
<span class="lineno">  206 </span>  <span class="decl"><span class="nottickedoff">appSubst s = fmap (appSubst s)</span></span>
<span class="lineno">  207 </span>
<span class="lineno">  208 </span>instance AppSubst Expr where
<span class="lineno">  209 </span>  <span class="decl"><span class="istickedoff">appSubst s expr = case expr of</span>
<span class="lineno">  210 </span><span class="spaces">    </span><span class="istickedoff">TSig pos e t           -&gt; <span class="nottickedoff">TSig pos (appSubst s e) (appSubst s t)</span></span>
<span class="lineno">  211 </span><span class="spaces">    </span><span class="istickedoff">Bool _ _               -&gt; <span class="nottickedoff">expr</span></span>
<span class="lineno">  212 </span><span class="spaces">    </span><span class="istickedoff">String _ _             -&gt; expr</span>
<span class="lineno">  213 </span><span class="spaces">    </span><span class="istickedoff">Int _ _                -&gt; expr</span>
<span class="lineno">  214 </span><span class="spaces">    </span><span class="istickedoff">Code _                 -&gt; expr</span>
<span class="lineno">  215 </span><span class="spaces">    </span><span class="istickedoff">CType _                -&gt; expr</span>
<span class="lineno">  216 </span><span class="spaces">    </span><span class="istickedoff">Array pos es           -&gt; Array <span class="nottickedoff">pos</span> (appSubst <span class="nottickedoff">s</span> es)</span>
<span class="lineno">  217 </span><span class="spaces">    </span><span class="istickedoff">Block pos bs           -&gt; Block <span class="nottickedoff">pos</span> (appSubst <span class="nottickedoff">s</span> bs)</span>
<span class="lineno">  218 </span><span class="spaces">    </span><span class="istickedoff">Tuple pos es           -&gt; Tuple <span class="nottickedoff">pos</span> (appSubst <span class="nottickedoff">s</span> es)</span>
<span class="lineno">  219 </span><span class="spaces">    </span><span class="istickedoff">Record pos fs          -&gt; <span class="nottickedoff">Record pos (appSubst s fs)</span></span>
<span class="lineno">  220 </span><span class="spaces">    </span><span class="istickedoff">Index pos ar ix        -&gt; <span class="nottickedoff">Index pos (appSubst s ar) (appSubst s ix)</span></span>
<span class="lineno">  221 </span><span class="spaces">    </span><span class="istickedoff">Lookup pos rec fld     -&gt; <span class="nottickedoff">Lookup pos (appSubst s rec) fld</span></span>
<span class="lineno">  222 </span><span class="spaces">    </span><span class="istickedoff">TLookup pos tpl idx    -&gt; <span class="nottickedoff">TLookup pos (appSubst s tpl) idx</span></span>
<span class="lineno">  223 </span><span class="spaces">    </span><span class="istickedoff">Var _                  -&gt; expr</span>
<span class="lineno">  224 </span><span class="spaces">    </span><span class="istickedoff">Function pos pat body  -&gt; Function <span class="nottickedoff">pos</span> (appSubst <span class="nottickedoff">s</span> pat) (appSubst <span class="nottickedoff">s</span> body)</span>
<span class="lineno">  225 </span><span class="spaces">    </span><span class="istickedoff">Application pos f v    -&gt; Application <span class="nottickedoff">pos</span> (appSubst <span class="nottickedoff">s</span> f) (appSubst <span class="nottickedoff">s</span> v)</span>
<span class="lineno">  226 </span><span class="spaces">    </span><span class="istickedoff">Let pos dg e           -&gt; <span class="nottickedoff">Let pos (appSubst s dg) (appSubst s e)</span></span>
<span class="lineno">  227 </span><span class="spaces">    </span><span class="istickedoff">IfThenElse pos e e2 e3 -&gt; IfThenElse <span class="nottickedoff">pos</span> (appSubst <span class="nottickedoff">s</span> e) (appSubst <span class="nottickedoff">s</span> e2) (appSubst <span class="nottickedoff">s</span> e3)</span></span>
<span class="lineno">  228 </span>
<span class="lineno">  229 </span>instance AppSubst Pattern where
<span class="lineno">  230 </span>  <span class="decl"><span class="istickedoff">appSubst s pat = case pat of</span>
<span class="lineno">  231 </span><span class="spaces">    </span><span class="istickedoff">PWild pos mt  -&gt; PWild <span class="nottickedoff">pos</span> (appSubst s mt)</span>
<span class="lineno">  232 </span><span class="spaces">    </span><span class="istickedoff">PVar pos x mt -&gt; PVar <span class="nottickedoff">pos</span> x (appSubst s mt)</span>
<span class="lineno">  233 </span><span class="spaces">    </span><span class="istickedoff">PTuple pos ps -&gt; PTuple <span class="nottickedoff">pos</span> (appSubst <span class="nottickedoff">s</span> ps)</span></span>
<span class="lineno">  234 </span>
<span class="lineno">  235 </span>instance AppSubst Stmt where
<span class="lineno">  236 </span>  <span class="decl"><span class="istickedoff">appSubst s bst = case bst of</span>
<span class="lineno">  237 </span><span class="spaces">    </span><span class="istickedoff">StmtBind pos pat e       -&gt; StmtBind pos (appSubst s pat) (appSubst <span class="nottickedoff">s</span> e)</span>
<span class="lineno">  238 </span><span class="spaces">    </span><span class="istickedoff">StmtLet pos dg           -&gt; StmtLet <span class="nottickedoff">pos</span> (appSubst <span class="nottickedoff">s</span> dg)</span>
<span class="lineno">  239 </span><span class="spaces">    </span><span class="istickedoff">StmtCode pos str         -&gt; StmtCode <span class="nottickedoff">pos</span> str</span>
<span class="lineno">  240 </span><span class="spaces">    </span><span class="istickedoff">StmtImport pos imp       -&gt; StmtImport <span class="nottickedoff">pos</span> imp</span>
<span class="lineno">  241 </span><span class="spaces">    </span><span class="istickedoff">StmtTypedef pos name ty  -&gt; StmtTypedef <span class="nottickedoff">pos</span> name (appSubst <span class="nottickedoff">s</span> ty)</span></span>
<span class="lineno">  242 </span>
<span class="lineno">  243 </span>instance AppSubst DeclGroup where
<span class="lineno">  244 </span>  <span class="decl"><span class="istickedoff">appSubst s (Recursive ds) = <span class="nottickedoff">Recursive (appSubst s ds)</span></span>
<span class="lineno">  245 </span><span class="spaces">  </span><span class="istickedoff">appSubst s (NonRecursive d) = NonRecursive (appSubst <span class="nottickedoff">s</span> d)</span></span>
<span class="lineno">  246 </span>
<span class="lineno">  247 </span>instance AppSubst Decl where
<span class="lineno">  248 </span>  <span class="decl"><span class="istickedoff">appSubst s (Decl pos p mt e) = Decl <span class="nottickedoff">pos</span> (appSubst <span class="nottickedoff">s</span> p) (appSubst <span class="nottickedoff">s</span> mt) (appSubst <span class="nottickedoff">s</span> e)</span></span>
<span class="lineno">  249 </span>
<span class="lineno">  250 </span>instance AppSubst Type where
<span class="lineno">  251 </span>  <span class="decl"><span class="istickedoff">appSubst s t = case t of</span>
<span class="lineno">  252 </span><span class="spaces">    </span><span class="istickedoff">TyCon pos tc ts     -&gt; TyCon pos tc (appSubst s ts)</span>
<span class="lineno">  253 </span><span class="spaces">    </span><span class="istickedoff">TyRecord pos fs     -&gt; <span class="nottickedoff">TyRecord pos (appSubst s fs)</span></span>
<span class="lineno">  254 </span><span class="spaces">    </span><span class="istickedoff">TyVar _ _           -&gt; t</span>
<span class="lineno">  255 </span><span class="spaces">    </span><span class="istickedoff">TyUnifyVar _ i      -&gt; case M.lookup i (unSubst s) of</span>
<span class="lineno">  256 </span><span class="spaces">                             </span><span class="istickedoff">Just t' -&gt; t'</span>
<span class="lineno">  257 </span><span class="spaces">                             </span><span class="istickedoff">Nothing -&gt; t</span></span>
<span class="lineno">  258 </span>
<span class="lineno">  259 </span>instance AppSubst Schema where
<span class="lineno">  260 </span>  <span class="decl"><span class="istickedoff">appSubst s (Forall ns t) = Forall ns (appSubst s t)</span></span>
<span class="lineno">  261 </span>
<span class="lineno">  262 </span>-- }}}
<span class="lineno">  263 </span>
<span class="lineno">  264 </span>
<span class="lineno">  265 </span>------------------------------------------------------------
<span class="lineno">  266 </span>-- Instantiate {{{
<span class="lineno">  267 </span>
<span class="lineno">  268 </span>--
<span class="lineno">  269 </span>-- instantiate is a typeclass-polymorphic function for substituting
<span class="lineno">  270 </span>-- named type variables (such as those declared with typedef) in a
<span class="lineno">  271 </span>-- Type.
<span class="lineno">  272 </span>--
<span class="lineno">  273 </span>-- Note: instantiate is exposed from this module and reused by the
<span class="lineno">  274 </span>-- interpreter as part of its handling of typedefs during execution.
<span class="lineno">  275 </span>-- XXX: Should probably come up with a clearer name. &quot;instantiate&quot;
<span class="lineno">  276 </span>-- could mean just about anything...
<span class="lineno">  277 </span>--
<span class="lineno">  278 </span>
<span class="lineno">  279 </span>class Instantiate t where
<span class="lineno">  280 </span>  -- | @instantiate m x@ applies the map @m@ to type variables in @x@.
<span class="lineno">  281 </span>  instantiate :: TyEnv -&gt; t -&gt; t
<span class="lineno">  282 </span>
<span class="lineno">  283 </span>instance (Instantiate a) =&gt; Instantiate (Maybe a) where
<span class="lineno">  284 </span>  <span class="decl"><span class="nottickedoff">instantiate tyenv = fmap (instantiate tyenv)</span></span>
<span class="lineno">  285 </span>
<span class="lineno">  286 </span>instance (Instantiate a) =&gt; Instantiate [a] where
<span class="lineno">  287 </span>  <span class="decl"><span class="istickedoff">instantiate tyenv = map (instantiate tyenv)</span></span>
<span class="lineno">  288 </span>
<span class="lineno">  289 </span>instance Instantiate Type where
<span class="lineno">  290 </span>  <span class="decl"><span class="istickedoff">instantiate tyenv ty = case ty of</span>
<span class="lineno">  291 </span><span class="spaces">    </span><span class="istickedoff">TyCon pos tc ts     -&gt; TyCon pos tc (instantiate tyenv ts)</span>
<span class="lineno">  292 </span><span class="spaces">    </span><span class="istickedoff">TyRecord pos fs     -&gt; <span class="nottickedoff">TyRecord pos (fmap (instantiate tyenv) fs)</span></span>
<span class="lineno">  293 </span><span class="spaces">    </span><span class="istickedoff">TyUnifyVar _ _      -&gt; ty</span>
<span class="lineno">  294 </span><span class="spaces">    </span><span class="istickedoff">TyVar _ n           -&gt;</span>
<span class="lineno">  295 </span><span class="spaces">        </span><span class="istickedoff">case M.lookup n tyenv of</span>
<span class="lineno">  296 </span><span class="spaces">            </span><span class="istickedoff">Nothing -&gt; ty</span>
<span class="lineno">  297 </span><span class="spaces">            </span><span class="istickedoff">Just AbstractType -&gt; ty</span>
<span class="lineno">  298 </span><span class="spaces">            </span><span class="istickedoff">Just (ConcreteType ty') -&gt; ty'</span></span>
<span class="lineno">  299 </span>
<span class="lineno">  300 </span>-- }}}
<span class="lineno">  301 </span>
<span class="lineno">  302 </span>
<span class="lineno">  303 </span>------------------------------------------------------------
<span class="lineno">  304 </span>-- Kinds {{{
<span class="lineno">  305 </span>
<span class="lineno">  306 </span>--
<span class="lineno">  307 </span>-- For the time being we can handle kinds using the number of expected
<span class="lineno">  308 </span>-- type arguments. That is, Kind 0 is *. Apart from tuples the only
<span class="lineno">  309 </span>-- things we have are of kinds *, * -&gt; *, and * -&gt; * -&gt; *, but we do
<span class="lineno">  310 </span>-- have tuples of arbitrary arity.
<span class="lineno">  311 </span>--
<span class="lineno">  312 </span>-- If we ever want additional structure (e.g. distinguishing the
<span class="lineno">  313 </span>-- monad/context types from other types) we can extend this
<span class="lineno">  314 </span>-- representation easily enough.
<span class="lineno">  315 </span>--
<span class="lineno">  316 </span>
<span class="lineno">  317 </span>newtype Kind = Kind { <span class="istickedoff"><span class="decl"><span class="istickedoff">kindNumArgs</span></span></span> :: Int }
<span class="lineno">  318 </span>  deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff">Eq</span></span></span></span>
<span class="lineno">  319 </span>
<span class="lineno">  320 </span>kindStar :: Kind
<span class="lineno">  321 </span><span class="decl"><span class="istickedoff">kindStar = Kind 0</span></span>
<span class="lineno">  322 </span>
<span class="lineno">  323 </span>-- these aren't currently used
<span class="lineno">  324 </span>--kindStarToStar :: Kind
<span class="lineno">  325 </span>--kindStarToStar = Kind 1
<span class="lineno">  326 </span>--
<span class="lineno">  327 </span>--kindStarToStarToStar :: Kind
<span class="lineno">  328 </span>--kindStarToStarToStar = Kind 2
<span class="lineno">  329 </span>
<span class="lineno">  330 </span>instance PrettyPrint Kind where
<span class="lineno">  331 </span>  <span class="decl"><span class="nottickedoff">pretty _ (Kind n) =</span>
<span class="lineno">  332 </span><span class="spaces">     </span><span class="nottickedoff">PP.viaShow $ intercalate &quot; -&gt; &quot; $ take (n + 1) $ repeat &quot;*&quot;</span></span>
<span class="lineno">  333 </span>
<span class="lineno">  334 </span>
<span class="lineno">  335 </span>-- }}}
<span class="lineno">  336 </span>
<span class="lineno">  337 </span>
<span class="lineno">  338 </span>------------------------------------------------------------
<span class="lineno">  339 </span>-- Pass context {{{
<span class="lineno">  340 </span>
<span class="lineno">  341 </span>--
<span class="lineno">  342 </span>-- The monad for this pass is &quot;TI&quot;, which is composed of a &quot;readonly&quot;
<span class="lineno">  343 </span>-- part (which is not constant or readonly, but where changes are
<span class="lineno">  344 </span>-- scoped by the recursive structure of the code) and a read-write
<span class="lineno">  345 </span>-- part that accumulates as we move through the code.
<span class="lineno">  346 </span>--
<span class="lineno">  347 </span>-- XXX: the &quot;readonly&quot; part is used to implement scoping, which is
<span class="lineno">  348 </span>-- fine in theory, but in practice because we have declarations that
<span class="lineno">  349 </span>-- update the environment, the recursive structure of the code does
<span class="lineno">  350 </span>-- not naturally match the scoping. The result is that the recursive
<span class="lineno">  351 </span>-- structure of the code has been twisted around to make it work;
<span class="lineno">  352 </span>-- that isn't desirable and the organization should probably be
<span class="lineno">  353 </span>-- revised.
<span class="lineno">  354 </span>--
<span class="lineno">  355 </span>-- Anyhow, the elements of the context are split across RO and RW
<span class="lineno">  356 </span>-- below.
<span class="lineno">  357 </span>--
<span class="lineno">  358 </span>
<span class="lineno">  359 </span>newtype TI a = TI { <span class="istickedoff"><span class="decl"><span class="istickedoff">unTI</span></span></span> :: ReaderT RO (StateT RW Identity) a }
<span class="lineno">  360 </span>                        deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Functor</span></span></span></span>,<span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Applicative</span></span></span></span></span></span></span></span></span></span>,<span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Monad</span></span></span></span></span></span>,<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">MonadReader RO</span></span></span></span></span></span>)
<span class="lineno">  361 </span>
<span class="lineno">  362 </span>-- | The &quot;readonly&quot; portion
<span class="lineno">  363 </span>data RO = RO
<span class="lineno">  364 </span>  {
<span class="lineno">  365 </span>    -- | The variable typing environment (variable name to type scheme)
<span class="lineno">  366 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">varEnv</span></span></span> :: VarEnv,
<span class="lineno">  367 </span>
<span class="lineno">  368 </span>    -- | The type environment: named type variables, which are either
<span class="lineno">  369 </span>    --   typedefs (map to ConcreteType) or abstract types (AbstractType)
<span class="lineno">  370 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">tyEnv</span></span></span> :: TyEnv
<span class="lineno">  371 </span>  }
<span class="lineno">  372 </span>
<span class="lineno">  373 </span>-- | The read-write portion
<span class="lineno">  374 </span>data RW = RW
<span class="lineno">  375 </span>  {
<span class="lineno">  376 </span>    -- | The next fresh unification var number
<span class="lineno">  377 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">nextTypeIndex</span></span></span> :: TypeIndex,
<span class="lineno">  378 </span>
<span class="lineno">  379 </span>    -- | The unification var substitution we're accumulating
<span class="lineno">  380 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">subst</span></span></span> :: Subst,
<span class="lineno">  381 </span>
<span class="lineno">  382 </span>    -- | Any type errors and warnings we've generated so far
<span class="lineno">  383 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">errors</span></span></span> :: [(Pos, String)],
<span class="lineno">  384 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">warnings</span></span></span> :: [(Pos, String)]
<span class="lineno">  385 </span>  }
<span class="lineno">  386 </span>
<span class="lineno">  387 </span>emptyRW :: RW
<span class="lineno">  388 </span><span class="decl"><span class="istickedoff">emptyRW = RW</span>
<span class="lineno">  389 </span><span class="spaces">  </span><span class="istickedoff">{ nextTypeIndex = 0</span>
<span class="lineno">  390 </span><span class="spaces">  </span><span class="istickedoff">, subst = emptySubst</span>
<span class="lineno">  391 </span><span class="spaces">  </span><span class="istickedoff">, errors = []</span>
<span class="lineno">  392 </span><span class="spaces">  </span><span class="istickedoff">, warnings = []</span>
<span class="lineno">  393 </span><span class="spaces">  </span><span class="istickedoff">}</span></span>
<span class="lineno">  394 </span>
<span class="lineno">  395 </span>-- Get a fresh unification var number.
<span class="lineno">  396 </span>getFreshTypeIndex :: TI TypeIndex
<span class="lineno">  397 </span><span class="decl"><span class="istickedoff">getFreshTypeIndex = do</span>
<span class="lineno">  398 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- TI get</span>
<span class="lineno">  399 </span><span class="spaces">  </span><span class="istickedoff">TI $ put $ rw { nextTypeIndex = nextTypeIndex rw + 1 }</span>
<span class="lineno">  400 </span><span class="spaces">  </span><span class="istickedoff">return $ nextTypeIndex rw</span></span>
<span class="lineno">  401 </span>
<span class="lineno">  402 </span>-- Construct a fresh type variable.
<span class="lineno">  403 </span>--
<span class="lineno">  404 </span>-- Collect the position that prompted us to make it; for example, if
<span class="lineno">  405 </span>-- we're the element type of an empty list we get the position of the
<span class="lineno">  406 </span>-- []. We haven't inferred anything, so use the InfFresh position.
<span class="lineno">  407 </span>-- This will cause the position of anything more substantive that gets
<span class="lineno">  408 </span>-- unified with it to be preferred. If no such thing happens though
<span class="lineno">  409 </span>-- this will be the position that gets attached to the quantifier
<span class="lineno">  410 </span>-- binding in generalize.
<span class="lineno">  411 </span>getFreshTyVar :: Pos -&gt; TI Type
<span class="lineno">  412 </span><span class="decl"><span class="istickedoff">getFreshTyVar pos = TyUnifyVar <span class="nottickedoff">(PosInferred InfFresh pos)</span> &lt;$&gt; getFreshTypeIndex</span></span>
<span class="lineno">  413 </span>
<span class="lineno">  414 </span>-- Construct a new type variable to use as a placeholder after an
<span class="lineno">  415 </span>-- error occurs. For now this is the same as other fresh type
<span class="lineno">  416 </span>-- variables, but I've split it out in case we want to distinguish it
<span class="lineno">  417 </span>-- in the future.
<span class="lineno">  418 </span>getErrorTyVar :: Pos -&gt; TI Type
<span class="lineno">  419 </span><span class="decl"><span class="istickedoff">getErrorTyVar pos = getFreshTyVar <span class="nottickedoff">pos</span></span></span>
<span class="lineno">  420 </span>
<span class="lineno">  421 </span>-- Add an error message.
<span class="lineno">  422 </span>recordError :: Pos -&gt; String -&gt; TI ()
<span class="lineno">  423 </span><span class="decl"><span class="istickedoff">recordError pos err = do</span>
<span class="lineno">  424 </span><span class="spaces">  </span><span class="istickedoff">TI $ modify $ \rw -&gt; rw { errors = (pos, err) : errors rw }</span></span>
<span class="lineno">  425 </span>
<span class="lineno">  426 </span>-- Add a warning message.
<span class="lineno">  427 </span>recordWarning :: Pos -&gt; String -&gt; TI ()
<span class="lineno">  428 </span><span class="decl"><span class="istickedoff">recordWarning pos msg = do</span>
<span class="lineno">  429 </span><span class="spaces">  </span><span class="istickedoff">TI $ modify $ \rw -&gt; rw { warnings = (pos, msg) : warnings rw }</span></span>
<span class="lineno">  430 </span>
<span class="lineno">  431 </span>-- Apply the current substitution with appSubst.
<span class="lineno">  432 </span>applyCurrentSubst :: AppSubst t =&gt; t -&gt; TI t
<span class="lineno">  433 </span><span class="decl"><span class="istickedoff">applyCurrentSubst t = do</span>
<span class="lineno">  434 </span><span class="spaces">  </span><span class="istickedoff">s &lt;- TI $ gets subst</span>
<span class="lineno">  435 </span><span class="spaces">  </span><span class="istickedoff">return $ appSubst s t</span></span>
<span class="lineno">  436 </span>
<span class="lineno">  437 </span>-- Apply the current typedef collection with instantiate.
<span class="lineno">  438 </span>resolveCurrentTypedefs :: Instantiate t =&gt; t -&gt; TI t
<span class="lineno">  439 </span><span class="decl"><span class="istickedoff">resolveCurrentTypedefs t = do</span>
<span class="lineno">  440 </span><span class="spaces">  </span><span class="istickedoff">s &lt;- TI $ asks tyEnv</span>
<span class="lineno">  441 </span><span class="spaces">  </span><span class="istickedoff">return $ instantiate s t</span></span>
<span class="lineno">  442 </span>
<span class="lineno">  443 </span>-- Get the unification vars that are used in the current variable typing
<span class="lineno">  444 </span>-- environment.
<span class="lineno">  445 </span>--
<span class="lineno">  446 </span>-- FIXME: This function may miss type variables that occur in the type
<span class="lineno">  447 </span>-- of a binding that has been shadowed by another value with the same
<span class="lineno">  448 </span>-- name. This could potentially cause a run-time type error if the
<span class="lineno">  449 </span>-- type of a local function gets generalized too much. We can probably
<span class="lineno">  450 </span>-- wait to fix it until someone finds a sawscript program that breaks.
<span class="lineno">  451 </span>unifyVarsInEnv :: TI (M.Map TypeIndex Pos)
<span class="lineno">  452 </span><span class="decl"><span class="istickedoff">unifyVarsInEnv = do</span>
<span class="lineno">  453 </span><span class="spaces">  </span><span class="istickedoff">env &lt;- TI $ asks varEnv</span>
<span class="lineno">  454 </span><span class="spaces">  </span><span class="istickedoff">let ss = M.elems env</span>
<span class="lineno">  455 </span><span class="spaces">  </span><span class="istickedoff">ss' &lt;- mapM applyCurrentSubst ss</span>
<span class="lineno">  456 </span><span class="spaces">  </span><span class="istickedoff">return $ unifyVars ss'</span></span>
<span class="lineno">  457 </span>
<span class="lineno">  458 </span>-- Get the named typedef vars that occur in the current variable typing
<span class="lineno">  459 </span>-- environment.
<span class="lineno">  460 </span>namedVarsInEnv :: TI (M.Map Name Pos)
<span class="lineno">  461 </span><span class="decl"><span class="istickedoff">namedVarsInEnv = do</span>
<span class="lineno">  462 </span><span class="spaces">  </span><span class="istickedoff">env &lt;- TI $ asks varEnv</span>
<span class="lineno">  463 </span><span class="spaces">  </span><span class="istickedoff">let ss = M.elems env</span>
<span class="lineno">  464 </span><span class="spaces">  </span><span class="istickedoff">ss' &lt;- mapM applyCurrentSubst ss</span>
<span class="lineno">  465 </span><span class="spaces">  </span><span class="istickedoff">return $ namedVars ss'</span></span>
<span class="lineno">  466 </span>
<span class="lineno">  467 </span>-- Get the position and name of the first binding in a pattern,
<span class="lineno">  468 </span>-- for use as context info when printing messages. If there's a
<span class="lineno">  469 </span>-- real variable, prefer that (Right cases); otherwise take the
<span class="lineno">  470 </span>-- position of the first wildcard or empty tuple (Left cases).
<span class="lineno">  471 </span>patternLName :: Pattern -&gt; LName
<span class="lineno">  472 </span><span class="decl"><span class="istickedoff">patternLName pat0 =</span>
<span class="lineno">  473 </span><span class="spaces">  </span><span class="istickedoff">case visit pat0 of</span>
<span class="lineno">  474 </span><span class="spaces">    </span><span class="istickedoff">Left pos -&gt; <span class="nottickedoff">Located &quot;_&quot; &quot;_&quot; pos</span></span>
<span class="lineno">  475 </span><span class="spaces">    </span><span class="istickedoff">Right n -&gt; n</span>
<span class="lineno">  476 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  477 </span><span class="spaces">    </span><span class="istickedoff">visit pat =</span>
<span class="lineno">  478 </span><span class="spaces">      </span><span class="istickedoff">case pat of</span>
<span class="lineno">  479 </span><span class="spaces">        </span><span class="istickedoff">PWild pos _ -&gt; <span class="nottickedoff">Left pos</span></span>
<span class="lineno">  480 </span><span class="spaces">        </span><span class="istickedoff">PVar _ n _ -&gt; Right n</span>
<span class="lineno">  481 </span><span class="spaces">        </span><span class="istickedoff">PTuple pos [] -&gt; <span class="nottickedoff">Left pos</span></span>
<span class="lineno">  482 </span><span class="spaces">        </span><span class="istickedoff">PTuple allpos ps -&gt;</span>
<span class="lineno">  483 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">case partitionEithers $ map visit ps of</span></span>
<span class="lineno">  484 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">(_, n : _) -&gt; Right n</span></span>
<span class="lineno">  485 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">(pos : _, _) -&gt; Left pos</span></span>
<span class="lineno">  486 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; Left allpos</span></span></span>
<span class="lineno">  487 </span>
<span class="lineno">  488 </span>-- Get all the bindings in a pattern.
<span class="lineno">  489 </span>patternBindings :: Pattern -&gt; [(Located Name, Maybe Type)]
<span class="lineno">  490 </span><span class="decl"><span class="istickedoff">patternBindings pat =</span>
<span class="lineno">  491 </span><span class="spaces">  </span><span class="istickedoff">case pat of</span>
<span class="lineno">  492 </span><span class="spaces">    </span><span class="istickedoff">PWild _ _mt -&gt; []</span>
<span class="lineno">  493 </span><span class="spaces">    </span><span class="istickedoff">PVar _ x mt -&gt; [(x, mt)]</span>
<span class="lineno">  494 </span><span class="spaces">    </span><span class="istickedoff">PTuple _ ps -&gt; concatMap patternBindings ps</span></span>
<span class="lineno">  495 </span>
<span class="lineno">  496 </span>-- }}}
<span class="lineno">  497 </span>
<span class="lineno">  498 </span>
<span class="lineno">  499 </span>------------------------------------------------------------
<span class="lineno">  500 </span>-- Unification {{{
<span class="lineno">  501 </span>
<span class="lineno">  502 </span>--
<span class="lineno">  503 </span>-- Error reporting.
<span class="lineno">  504 </span>--
<span class="lineno">  505 </span>-- When we find a mismatch, we have potentially recursed arbitrarily
<span class="lineno">  506 </span>-- deeply into the original type. We need to print the specific types
<span class="lineno">  507 </span>-- we trip on (this is important if they are e.g. elements in a large
<span class="lineno">  508 </span>-- system of nested records and typles) but we also want to print the
<span class="lineno">  509 </span>-- rest of the original context as well.
<span class="lineno">  510 </span>--
<span class="lineno">  511 </span>-- Therefore, we start with an initial descriptive message plus (in
<span class="lineno">  512 </span>-- most cases) a pair of expected and found types. Once we fail, we
<span class="lineno">  513 </span>-- add more expected/found type pairs on the way out of the recursion,
<span class="lineno">  514 </span>-- so we print every layer of the type.
<span class="lineno">  515 </span>--
<span class="lineno">  516 </span>-- As a special case, we keep only the outermost of a series of nested
<span class="lineno">  517 </span>-- function types, and drop the nested ones. Because functions are
<span class="lineno">  518 </span>-- curried, this prints the complete function signature once and skips
<span class="lineno">  519 </span>-- the incremental types completed by consuming each argument. (These
<span class="lineno">  520 </span>-- add little information and can also confuse casual users.)
<span class="lineno">  521 </span>--
<span class="lineno">  522 </span>-- The FailMGU type tracks this material. It contains three elements:
<span class="lineno">  523 </span>--    * the initial message
<span class="lineno">  524 </span>--    * the list of pairs of expected/found messages
<span class="lineno">  525 </span>--    * the current function-type expected/found message, if any
<span class="lineno">  526 </span>--
<span class="lineno">  527 </span>-- Empty strings are inserted between pairs to make the output more
<span class="lineno">  528 </span>-- readable.
<span class="lineno">  529 </span>--
<span class="lineno">  530 </span>-- Note that we print the messages on the fly rather than accumulating
<span class="lineno">  531 </span>-- a list of type pairs and printing them at the end. (That may have
<span class="lineno">  532 </span>-- been a mistake; we'll see.)
<span class="lineno">  533 </span>--
<span class="lineno">  534 </span>-- The last element (current function-type expected/found message) is
<span class="lineno">  535 </span>-- always either a list of two message strings or empty. Function types
<span class="lineno">  536 </span>-- we see go in it (replacing anything already there, so we keep only
<span class="lineno">  537 </span>-- the outermost of a series) and are shifted out of it when we see
<span class="lineno">  538 </span>-- something else. It could be a Maybe (String, String), but the code
<span class="lineno">  539 </span>-- is noticeably more convenient the way it is.
<span class="lineno">  540 </span>--
<span class="lineno">  541 </span>-- The initial message is kept separate so that the expected/found
<span class="lineno">  542 </span>-- list can readily be built in either order. It's not clear if it's
<span class="lineno">  543 </span>-- better to print the outermost or innermost mismatches first.
<span class="lineno">  544 </span>--
<span class="lineno">  545 </span>-- Further notes on the message formatting:
<span class="lineno">  546 </span>--
<span class="lineno">  547 </span>-- Print the expected and found types on their own lines. They can be
<span class="lineno">  548 </span>-- large; if they are the resulting lines can still be fairly
<span class="lineno">  549 </span>-- illegible, but at least the user doesn't have to hunt for &quot;found&quot;
<span class="lineno">  550 </span>-- in the middle of a multi-line print.
<span class="lineno">  551 </span>--
<span class="lineno">  552 </span>-- Pad the prefix of the prints so that the types line up; this is
<span class="lineno">  553 </span>-- helpful for longer types that still fit on one output line.
<span class="lineno">  554 </span>--
<span class="lineno">  555 </span>-- We'll indent each line with four spaces. What we send back gets
<span class="lineno">  556 </span>-- printed underneath a message that's already (at least in some
<span class="lineno">  557 </span>-- cases) indented by two spaces. It's important to make it clear that
<span class="lineno">  558 </span>-- all the stuff we generate is part of that message and not, for
<span class="lineno">  559 </span>-- example, an additional separate error. The indenting happens below.
<span class="lineno">  560 </span>--
<span class="lineno">  561 </span>-- Note that although we append to the end of the expected/found list,
<span class="lineno">  562 </span>-- we don't stick the start line in that list, because I keep going
<span class="lineno">  563 </span>-- back and forth on whether the larger types should be printed first
<span class="lineno">  564 </span>-- (prepending in failMGUadd) or last (appending). If we commit to
<span class="lineno">  565 </span>-- appending we don't need to keep the start line separate.
<span class="lineno">  566 </span>--
<span class="lineno">  567 </span>
<span class="lineno">  568 </span>data FailMGU = FailMGU
<span class="lineno">  569 </span>                    [String]    -- initial error message (often multiple lines)
<span class="lineno">  570 </span>                    [String]    -- list of found/expected message pairs
<span class="lineno">  571 </span>                    [String]    -- current found/expected function pair if any
<span class="lineno">  572 </span>
<span class="lineno">  573 </span>-- common code for printing expected/found types
<span class="lineno">  574 </span>showTypes :: Type -&gt; Type -&gt; [String]
<span class="lineno">  575 </span><span class="decl"><span class="istickedoff">showTypes ty1 ty2 =</span>
<span class="lineno">  576 </span><span class="spaces">  </span><span class="istickedoff">let expected = &quot;Expected: &quot; ++ pShow ty1</span>
<span class="lineno">  577 </span><span class="spaces">      </span><span class="istickedoff">found    = &quot;Found:    &quot; ++ pShow ty2</span>
<span class="lineno">  578 </span><span class="spaces">  </span><span class="istickedoff">in</span>
<span class="lineno">  579 </span><span class="spaces">  </span><span class="istickedoff">[expected, found, &quot;&quot;]</span></span>
<span class="lineno">  580 </span>
<span class="lineno">  581 </span>-- logic for showing details of a type
<span class="lineno">  582 </span>showTypeDetails :: Type -&gt; String
<span class="lineno">  583 </span><span class="decl"><span class="istickedoff">showTypeDetails ty =</span>
<span class="lineno">  584 </span><span class="spaces">  </span><span class="istickedoff">let pr pos what =</span>
<span class="lineno">  585 </span><span class="spaces">        </span><span class="istickedoff">show pos ++ &quot;: The type &quot; ++ pShow ty ++ &quot; arises from &quot; ++ what</span>
<span class="lineno">  586 </span><span class="spaces">  </span><span class="istickedoff">in</span>
<span class="lineno">  587 </span><span class="spaces">  </span><span class="istickedoff">case getPos ty of</span>
<span class="lineno">  588 </span><span class="spaces">    </span><span class="istickedoff">PosInferred InfFresh pos -&gt; <span class="nottickedoff">pr pos &quot;fresh type variable introduced here&quot;</span></span>
<span class="lineno">  589 </span><span class="spaces">    </span><span class="istickedoff">PosInferred InfTerm pos -&gt; pr pos &quot;the type of this term&quot;</span>
<span class="lineno">  590 </span><span class="spaces">    </span><span class="istickedoff">PosInferred InfContext pos -&gt; <span class="nottickedoff">pr pos &quot;the context of the term&quot;</span></span>
<span class="lineno">  591 </span><span class="spaces">    </span><span class="istickedoff">pos -&gt; pr pos &quot;this type annotation&quot;</span></span>
<span class="lineno">  592 </span>
<span class="lineno">  593 </span>-- fail with expected/found types
<span class="lineno">  594 </span>failMGU :: String -&gt; Type -&gt; Type -&gt; Either FailMGU a
<span class="lineno">  595 </span><span class="decl"><span class="istickedoff">failMGU start ty1 ty2 = Left (FailMGU start' (&quot;&quot; : showTypes ty1 ty2) [])</span>
<span class="lineno">  596 </span><span class="spaces">  </span><span class="istickedoff">where start' = [start, showTypeDetails ty1, showTypeDetails ty2]</span></span>
<span class="lineno">  597 </span>
<span class="lineno">  598 </span>-- fail with no types
<span class="lineno">  599 </span>failMGU' :: String -&gt; Either FailMGU a
<span class="lineno">  600 </span><span class="decl"><span class="nottickedoff">failMGU' start = Left (FailMGU [start] [] [])</span></span>
<span class="lineno">  601 </span>
<span class="lineno">  602 </span>-- add another expected/found type pair to the failure
<span class="lineno">  603 </span>-- (pull in the last function-type lines if any)
<span class="lineno">  604 </span>failMGUAdd :: FailMGU -&gt; Type -&gt; Type -&gt; FailMGU
<span class="lineno">  605 </span><span class="decl"><span class="istickedoff">failMGUAdd (FailMGU start eflines lastfunlines) ty1 ty2 =</span>
<span class="lineno">  606 </span><span class="spaces">  </span><span class="istickedoff">FailMGU start (eflines ++ lastfunlines ++ showTypes ty1 ty2) []</span></span>
<span class="lineno">  607 </span>
<span class="lineno">  608 </span>-- add another pair that's a function type
<span class="lineno">  609 </span>-- (overwrite any previous function type lines)
<span class="lineno">  610 </span>failMGUAddFun :: FailMGU -&gt; Type -&gt; Type -&gt; FailMGU
<span class="lineno">  611 </span><span class="decl"><span class="nottickedoff">failMGUAddFun (FailMGU start eflines _) ty1 ty2 =</span>
<span class="lineno">  612 </span><span class="spaces">  </span><span class="nottickedoff">FailMGU start eflines (showTypes ty1 ty2)</span></span>
<span class="lineno">  613 </span>
<span class="lineno">  614 </span>-- print the failure as a string list
<span class="lineno">  615 </span>ppFailMGU :: FailMGU -&gt; [String]
<span class="lineno">  616 </span><span class="decl"><span class="istickedoff">ppFailMGU (FailMGU start eflines lastfunlines) =</span>
<span class="lineno">  617 </span><span class="spaces">  </span><span class="istickedoff">start ++ eflines ++ lastfunlines</span></span>
<span class="lineno">  618 </span>
<span class="lineno">  619 </span>-- We've found a substitution for unification var i.
<span class="lineno">  620 </span>--
<span class="lineno">  621 </span>-- Create the substitution, but first check that this doesn't result
<span class="lineno">  622 </span>-- in an invalid type.
<span class="lineno">  623 </span>--
<span class="lineno">  624 </span>-- Does not handle the case where t _is_ TyUnifyVar i; the caller
<span class="lineno">  625 </span>-- handles that.
<span class="lineno">  626 </span>--
<span class="lineno">  627 </span>-- XXX: we can resolve TyUnifyVar i to TyUnifyVar j here, which is
<span class="lineno">  628 </span>-- fine as far as it goes but there doesn't seem to be any logic to
<span class="lineno">  629 </span>-- prohibit also resolving TyUnifyVar j to TyUnifyVar i and creating
<span class="lineno">  630 </span>-- cycles.
<span class="lineno">  631 </span>resolveUnificationVar :: Pos -&gt; TypeIndex -&gt; Type -&gt; Either FailMGU Subst
<span class="lineno">  632 </span><span class="decl"><span class="istickedoff">resolveUnificationVar pos i t =</span>
<span class="lineno">  633 </span><span class="spaces">  </span><span class="istickedoff">case M.lookup i $ unifyVars t of</span>
<span class="lineno">  634 </span><span class="spaces">     </span><span class="istickedoff">Just otherpos -&gt;</span>
<span class="lineno">  635 </span><span class="spaces">       </span><span class="istickedoff">-- FIXME/XXX: this error message is better than the one that was here before</span>
<span class="lineno">  636 </span><span class="spaces">       </span><span class="istickedoff">-- but still lacks a certain something</span>
<span class="lineno">  637 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">failMGU' $ &quot;Occurs check failure: the type at &quot; ++ show otherpos ++</span></span>
<span class="lineno">  638 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">&quot; appears within the type at &quot; ++ show pos</span></span>
<span class="lineno">  639 </span><span class="spaces">     </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  640 </span><span class="spaces">       </span><span class="istickedoff">return (singletonSubst i t)</span></span>
<span class="lineno">  641 </span>
<span class="lineno">  642 </span>-- Guts of unification.
<span class="lineno">  643 </span>--
<span class="lineno">  644 </span>-- &quot;mgu&quot; stands for &quot;most general unifier&quot;.
<span class="lineno">  645 </span>--
<span class="lineno">  646 </span>-- Given two types, produce either a failure report or a substitution
<span class="lineno">  647 </span>-- (to add to the cumulative substitution we build up) that makes them
<span class="lineno">  648 </span>-- the same.
<span class="lineno">  649 </span>mgu :: Type -&gt; Type -&gt; Either FailMGU Subst
<span class="lineno">  650 </span><span class="decl"><span class="istickedoff">mgu t1 t2 = case (t1, t2) of</span>
<span class="lineno">  651 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  652 </span><span class="spaces">  </span><span class="istickedoff">(TyUnifyVar _ i, TyUnifyVar _ j) | <span class="tickonlyfalse">i == j</span> -&gt;</span>
<span class="lineno">  653 </span><span class="spaces">      </span><span class="istickedoff">-- same unification var, nothing to do</span>
<span class="lineno">  654 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">return emptySubst</span></span>
<span class="lineno">  655 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  656 </span><span class="spaces">  </span><span class="istickedoff">(TyUnifyVar pos i, _) -&gt;</span>
<span class="lineno">  657 </span><span class="spaces">      </span><span class="istickedoff">-- one side is a unification var, resolve it</span>
<span class="lineno">  658 </span><span class="spaces">      </span><span class="istickedoff">resolveUnificationVar <span class="nottickedoff">pos</span> i t2</span>
<span class="lineno">  659 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  660 </span><span class="spaces">  </span><span class="istickedoff">(_, TyUnifyVar pos i) -&gt;</span>
<span class="lineno">  661 </span><span class="spaces">      </span><span class="istickedoff">-- one side is a unification var, resolve it</span>
<span class="lineno">  662 </span><span class="spaces">      </span><span class="istickedoff">resolveUnificationVar <span class="nottickedoff">pos</span> i t1</span>
<span class="lineno">  663 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  664 </span><span class="spaces">  </span><span class="istickedoff">(TyRecord _ ts1, TyRecord _ ts2)</span>
<span class="lineno">  665 </span><span class="spaces">    </span><span class="istickedoff">| <span class="nottickedoff">M.keys ts1 /= M.keys ts2</span> -&gt;</span>
<span class="lineno">  666 </span><span class="spaces">      </span><span class="istickedoff">-- records with different keys</span>
<span class="lineno">  667 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">failMGU &quot;Record field names mismatch.&quot; t1 t2</span></span>
<span class="lineno">  668 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  669 </span><span class="spaces">    </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> -&gt;</span>
<span class="lineno">  670 </span><span class="spaces">      </span><span class="istickedoff">-- records with the same field names, try unifying the field types</span>
<span class="lineno">  671 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">case mgus (M.elems ts1) (M.elems ts2) of</span></span>
<span class="lineno">  672 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">Right result -&gt; Right result</span></span>
<span class="lineno">  673 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">Left msgs -&gt; Left $ failMGUAdd msgs t1 t2</span></span>
<span class="lineno">  674 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  675 </span><span class="spaces">  </span><span class="istickedoff">(TyCon _ tc1 ts1, TyCon _ tc2 ts2)</span>
<span class="lineno">  676 </span><span class="spaces">    </span><span class="istickedoff">| tc1 == tc2 -&gt;</span>
<span class="lineno">  677 </span><span class="spaces">      </span><span class="istickedoff">-- same type constructor, unify the args</span>
<span class="lineno">  678 </span><span class="spaces">      </span><span class="istickedoff">case mgus ts1 ts2 of</span>
<span class="lineno">  679 </span><span class="spaces">        </span><span class="istickedoff">Right result -&gt; Right result</span>
<span class="lineno">  680 </span><span class="spaces">        </span><span class="istickedoff">Left msgs -&gt;</span>
<span class="lineno">  681 </span><span class="spaces">          </span><span class="istickedoff">-- oops, didn't work. handle functions specially for</span>
<span class="lineno">  682 </span><span class="spaces">          </span><span class="istickedoff">-- nicer error reporting</span>
<span class="lineno">  683 </span><span class="spaces">          </span><span class="istickedoff">case tc1 of</span>
<span class="lineno">  684 </span><span class="spaces">            </span><span class="istickedoff">FunCon -&gt; <span class="nottickedoff">Left $ failMGUAddFun msgs t1 t2</span></span>
<span class="lineno">  685 </span><span class="spaces">            </span><span class="istickedoff">_ -&gt; Left $ failMGUAdd msgs t1 t2</span>
<span class="lineno">  686 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  687 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt;</span>
<span class="lineno">  688 </span><span class="spaces">      </span><span class="istickedoff">-- Wrong type constructors</span>
<span class="lineno">  689 </span><span class="spaces">      </span><span class="istickedoff">case tc1 of</span>
<span class="lineno">  690 </span><span class="spaces">        </span><span class="istickedoff">FunCon -&gt;</span>
<span class="lineno">  691 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">failMGU (&quot;Term is not a function. (Maybe a function is applied &quot; ++</span></span>
<span class="lineno">  692 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">&quot;to too many arguments?)&quot;) t1 t2</span></span>
<span class="lineno">  693 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  694 </span><span class="spaces">          </span><span class="istickedoff">failMGU (&quot;Mismatch of type constructors. Expected: &quot; ++ pShow tc1 ++</span>
<span class="lineno">  695 </span><span class="spaces">                   </span><span class="istickedoff">&quot; but got &quot; ++ pShow tc2) t1 t2</span>
<span class="lineno">  696 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  697 </span><span class="spaces">  </span><span class="istickedoff">(TyVar _ a, TyVar _ b) | <span class="tickonlytrue">a == b</span> -&gt;</span>
<span class="lineno">  698 </span><span class="spaces">      </span><span class="istickedoff">-- Same named variable</span>
<span class="lineno">  699 </span><span class="spaces">      </span><span class="istickedoff">return emptySubst</span>
<span class="lineno">  700 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  701 </span><span class="spaces">  </span><span class="istickedoff">(_, _) -&gt;</span>
<span class="lineno">  702 </span><span class="spaces">      </span><span class="istickedoff">-- Did not work</span>
<span class="lineno">  703 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">failMGU &quot;Mismatch of types.&quot; t1 t2</span></span></span>
<span class="lineno">  704 </span>
<span class="lineno">  705 </span>-- Run mgu on two lists of types.
<span class="lineno">  706 </span>mgus :: [Type] -&gt; [Type] -&gt; Either FailMGU Subst
<span class="lineno">  707 </span><span class="decl"><span class="istickedoff">mgus t1s t2s = case (t1s, t2s) of</span>
<span class="lineno">  708 </span><span class="spaces">    </span><span class="istickedoff">([], []) -&gt;</span>
<span class="lineno">  709 </span><span class="spaces">        </span><span class="istickedoff">return emptySubst</span>
<span class="lineno">  710 </span><span class="spaces">    </span><span class="istickedoff">(t1 : t1s', t2 : t2s') -&gt; do</span>
<span class="lineno">  711 </span><span class="spaces">        </span><span class="istickedoff">-- unify the first types</span>
<span class="lineno">  712 </span><span class="spaces">        </span><span class="istickedoff">s &lt;- mgu t1 t2</span>
<span class="lineno">  713 </span><span class="spaces">        </span><span class="istickedoff">-- apply that substitution and then recurse</span>
<span class="lineno">  714 </span><span class="spaces">        </span><span class="istickedoff">s' &lt;- mgus (map (appSubst s) t1s') (map (appSubst s) t2s')</span>
<span class="lineno">  715 </span><span class="spaces">        </span><span class="istickedoff">return (mergeSubst s' s)</span>
<span class="lineno">  716 </span><span class="spaces">    </span><span class="istickedoff">(_, _) -&gt;</span>
<span class="lineno">  717 </span><span class="spaces">      </span><span class="istickedoff">-- XXX this is no good, it will always print one of the lengths as 0!</span>
<span class="lineno">  718 </span><span class="spaces">      </span><span class="istickedoff">-- (also, note that this is only reachable for type constructor args</span>
<span class="lineno">  719 </span><span class="spaces">      </span><span class="istickedoff">-- and not function args)</span>
<span class="lineno">  720 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">failMGU' $ &quot;Wrong number of arguments. Expected &quot; ++ show (length t1s) ++</span></span>
<span class="lineno">  721 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">&quot; but got &quot; ++ show (length t2s)</span></span></span>
<span class="lineno">  722 </span>
<span class="lineno">  723 </span>--
<span class="lineno">  724 </span>-- Unify two types.
<span class="lineno">  725 </span>--
<span class="lineno">  726 </span>
<span class="lineno">  727 </span>-- When typechecking an expression the first type argument (t1) should
<span class="lineno">  728 </span>-- be the type expected from the context, and the second (t2) should
<span class="lineno">  729 </span>-- be the type found in the expression appearing in that context. For
<span class="lineno">  730 </span>-- example, when checking the second argument of a function application
<span class="lineno">  731 </span>-- (Application _pos e1 e2) checking e1 gives rise to an expected type
<span class="lineno">  732 </span>-- for e2, so when unifying that with the result of checking e2 the
<span class="lineno">  733 </span>-- t1 argument should be the expected type arising from e1, the t2
<span class="lineno">  734 </span>-- argument should be the type returned by checking e2, and the position
<span class="lineno">  735 </span>-- argument should be the position of e2 (not the position of the
<span class="lineno">  736 </span>-- enclosing apply node). If it doesn't work, the message generated
<span class="lineno">  737 </span>-- will be of the form &quot;pos: found t2, expected t1&quot;.
<span class="lineno">  738 </span>--
<span class="lineno">  739 </span>-- Other cases should pass the arguments analogously. As of this
<span class="lineno">  740 </span>-- writing some are definitely backwards.
<span class="lineno">  741 </span>--
<span class="lineno">  742 </span>-- Further notes on error messages:
<span class="lineno">  743 </span>--
<span class="lineno">  744 </span>-- The error message returned by mgu already prints the types at some
<span class="lineno">  745 </span>-- length, so we don't need to print any of that again.
<span class="lineno">  746 </span>--
<span class="lineno">  747 </span>-- Indent all but the first line by four spaces because the first line
<span class="lineno">  748 </span>-- ends up indented by two when it ultimately gets printed (or at
<span class="lineno">  749 </span>-- least sometimes it does) and we want the grouping to be clearly
<span class="lineno">  750 </span>-- recognizable.
<span class="lineno">  751 </span>--
<span class="lineno">  752 </span>-- The LName passed in is (at least in most cases) the name of the
<span class="lineno">  753 </span>-- top-level binding the unification happens inside. Its position is
<span class="lineno">  754 </span>-- therefore usually not where the problem is except in a very
<span class="lineno">  755 </span>-- abstract sense and shouldn't be printed as if it's the error
<span class="lineno">  756 </span>-- location. So tack it onto the end of everything.
<span class="lineno">  757 </span>--
<span class="lineno">  758 </span>-- It's not clear that this is always the case, so in turn it's not
<span class="lineno">  759 </span>-- entirely clear that it's always useless and I'm hesitant to remove
<span class="lineno">  760 </span>-- it entirely, but that seems like a reasonable thing to do in the
<span class="lineno">  761 </span>-- future given more clarity.
<span class="lineno">  762 </span>--
<span class="lineno">  763 </span>unify :: LName -&gt; Type -&gt; Pos -&gt; Type -&gt; TI ()
<span class="lineno">  764 </span><span class="decl"><span class="istickedoff">unify m t1 pos t2 = do</span>
<span class="lineno">  765 </span><span class="spaces">  </span><span class="istickedoff">t1' &lt;- applyCurrentSubst =&lt;&lt; resolveCurrentTypedefs t1</span>
<span class="lineno">  766 </span><span class="spaces">  </span><span class="istickedoff">t2' &lt;- applyCurrentSubst =&lt;&lt; resolveCurrentTypedefs t2</span>
<span class="lineno">  767 </span><span class="spaces">  </span><span class="istickedoff">case mgu t1' t2' of</span>
<span class="lineno">  768 </span><span class="spaces">    </span><span class="istickedoff">Right s -&gt; TI $ modify $ \rw -&gt; rw { subst = mergeSubst s $ subst rw }</span>
<span class="lineno">  769 </span><span class="spaces">    </span><span class="istickedoff">Left msgs -&gt;</span>
<span class="lineno">  770 </span><span class="spaces">       </span><span class="istickedoff">recordError pos $ unlines $ firstline : morelines'</span>
<span class="lineno">  771 </span><span class="spaces">       </span><span class="istickedoff">where</span>
<span class="lineno">  772 </span><span class="spaces">         </span><span class="istickedoff">firstline = &quot;Type mismatch.&quot;</span>
<span class="lineno">  773 </span><span class="spaces">         </span><span class="istickedoff">morelines = ppFailMGU msgs ++ [&quot;within &quot; ++ show m]</span>
<span class="lineno">  774 </span><span class="spaces">         </span><span class="istickedoff">-- Indent all but the first line by four spaces.</span>
<span class="lineno">  775 </span><span class="spaces">         </span><span class="istickedoff">morelines' = map (\msg -&gt; &quot;    &quot; ++ msg) morelines</span></span>
<span class="lineno">  776 </span>
<span class="lineno">  777 </span>-- Check if two types match but don't actually unify them
<span class="lineno">  778 </span>-- (that is, on success throw away the substitution and on error
<span class="lineno">  779 </span>-- throw away the complaints)
<span class="lineno">  780 </span>--
<span class="lineno">  781 </span>-- This is inelegant, and used for some workaround logic to decide
<span class="lineno">  782 </span>-- which unifications to attempt to avoid failures on things we don't
<span class="lineno">  783 </span>-- want to make fatal just yet. It should be removed when no longer
<span class="lineno">  784 </span>-- needed.
<span class="lineno">  785 </span>matches :: Type -&gt; Type -&gt; TI Bool
<span class="lineno">  786 </span><span class="decl"><span class="istickedoff">matches t1 t2 = do</span>
<span class="lineno">  787 </span><span class="spaces">  </span><span class="istickedoff">t1' &lt;- applyCurrentSubst =&lt;&lt; resolveCurrentTypedefs t1</span>
<span class="lineno">  788 </span><span class="spaces">  </span><span class="istickedoff">t2' &lt;- applyCurrentSubst =&lt;&lt; resolveCurrentTypedefs t2</span>
<span class="lineno">  789 </span><span class="spaces">  </span><span class="istickedoff">case mgu t1' t2' of</span>
<span class="lineno">  790 </span><span class="spaces">    </span><span class="istickedoff">Right _ -&gt; return True</span>
<span class="lineno">  791 </span><span class="spaces">    </span><span class="istickedoff">Left _ -&gt; return False</span></span>
<span class="lineno">  792 </span>
<span class="lineno">  793 </span>-- }}}
<span class="lineno">  794 </span>
<span class="lineno">  795 </span>
<span class="lineno">  796 </span>------------------------------------------------------------
<span class="lineno">  797 </span>-- Main recursive pass {{{
<span class="lineno">  798 </span>
<span class="lineno">  799 </span>type OutExpr = Expr
<span class="lineno">  800 </span>type OutStmt = Stmt
<span class="lineno">  801 </span>
<span class="lineno">  802 </span>--
<span class="lineno">  803 </span>-- Expressions
<span class="lineno">  804 </span>--
<span class="lineno">  805 </span>
<span class="lineno">  806 </span>-- Take a struct field binding (name and expression) and return the
<span class="lineno">  807 </span>-- updated binding as well as the member entry for the enclosing
<span class="lineno">  808 </span>-- struct type.
<span class="lineno">  809 </span>inferField :: LName -&gt; (Name, Expr) -&gt; TI ((Name, OutExpr), (Name, Type))
<span class="lineno">  810 </span><span class="decl"><span class="nottickedoff">inferField m (n,e) = do</span>
<span class="lineno">  811 </span><span class="spaces">  </span><span class="nottickedoff">(e',t) &lt;- inferExpr (m,e)</span>
<span class="lineno">  812 </span><span class="spaces">  </span><span class="nottickedoff">return ((n,e'),(n,t))</span></span>
<span class="lineno">  813 </span>
<span class="lineno">  814 </span>-- wrap the action m with a type for x
<span class="lineno">  815 </span>withVar :: Located Name -&gt; Schema -&gt; TI a -&gt; TI a
<span class="lineno">  816 </span><span class="decl"><span class="istickedoff">withVar x s m =</span>
<span class="lineno">  817 </span><span class="spaces">  </span><span class="istickedoff">TI $ local (\ro -&gt; ro { varEnv = M.insert x s $ varEnv ro }) $ unTI m</span></span>
<span class="lineno">  818 </span>
<span class="lineno">  819 </span>-- wrap the action m with types for a list of vars
<span class="lineno">  820 </span>withVars :: [(Located Name, Schema)] -&gt; TI a -&gt; TI a
<span class="lineno">  821 </span><span class="decl"><span class="istickedoff">withVars bindings m = foldr (uncurry withVar) m bindings</span></span>
<span class="lineno">  822 </span>
<span class="lineno">  823 </span>-- wrap the action m with types for all the vars in a pattern
<span class="lineno">  824 </span>--
<span class="lineno">  825 </span>-- (note that the pattern should have already been processed so it
<span class="lineno">  826 </span>-- contains types; hence the irrefutable Just t)
<span class="lineno">  827 </span>withPattern :: Pattern -&gt; TI a -&gt; TI a
<span class="lineno">  828 </span><span class="decl"><span class="istickedoff">withPattern pat m = withVars bindings m</span>
<span class="lineno">  829 </span><span class="spaces">  </span><span class="istickedoff">where bindings = [ (x, tMono t) | (x, Just t) &lt;- patternBindings pat ]</span></span>
<span class="lineno">  830 </span>
<span class="lineno">  831 </span>-- wrap the action m with types for all the vars in a pattern, using
<span class="lineno">  832 </span>-- the passed-in schema to produce the types and ignoring the types
<span class="lineno">  833 </span>-- already loaded into the pattern.
<span class="lineno">  834 </span>--
<span class="lineno">  835 </span>-- XXX: is that what we want? should probably assert that the schema
<span class="lineno">  836 </span>-- matches the types in the pattern, unless the pattern hasn't already
<span class="lineno">  837 </span>-- been checked yet, and that seems like it would be a bug.
<span class="lineno">  838 </span>--
<span class="lineno">  839 </span>-- Note that if the pattern is a tuple and the schema is not a tuple
<span class="lineno">  840 </span>-- type, we do nothing. Presumably in this case a type error has
<span class="lineno">  841 </span>-- already been generated and we don't need another one? But it would
<span class="lineno">  842 </span>-- probably be a good idea to check up on that. XXX
<span class="lineno">  843 </span>withPatternSchema :: Pattern -&gt; Schema -&gt; TI a -&gt; TI a
<span class="lineno">  844 </span><span class="decl"><span class="istickedoff">withPatternSchema pat s@(Forall vs t) m =</span>
<span class="lineno">  845 </span><span class="spaces">  </span><span class="istickedoff">case pat of</span>
<span class="lineno">  846 </span><span class="spaces">    </span><span class="istickedoff">PWild _ _ -&gt; <span class="nottickedoff">m</span></span>
<span class="lineno">  847 </span><span class="spaces">    </span><span class="istickedoff">PVar _ x _ -&gt; withVar x s m</span>
<span class="lineno">  848 </span><span class="spaces">    </span><span class="istickedoff">PTuple _ ps -&gt;</span>
<span class="lineno">  849 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">case t of</span></span>
<span class="lineno">  850 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">TyCon _pos (TupleCon _) ts -&gt; foldr ($) m</span></span>
<span class="lineno">  851 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">[ withPatternSchema p (Forall vs t') | (p, t') &lt;- zip ps ts ]</span></span>
<span class="lineno">  852 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; m</span></span></span>
<span class="lineno">  853 </span>
<span class="lineno">  854 </span>-- wrap the action m with types for the vars in a declaration.
<span class="lineno">  855 </span>--
<span class="lineno">  856 </span>-- Do nothing if there's no type schema in this declaration yet.
<span class="lineno">  857 </span>withDecl :: Decl -&gt; TI a -&gt; TI a
<span class="lineno">  858 </span><span class="decl"><span class="istickedoff">withDecl (Decl _ _ Nothing _) m = <span class="nottickedoff">m</span></span>
<span class="lineno">  859 </span><span class="spaces"></span><span class="istickedoff">withDecl (Decl _ p (Just s) _) m = withPatternSchema p s m</span></span>
<span class="lineno">  860 </span>
<span class="lineno">  861 </span>-- wrap the action m with types for the vars in a declgroup.
<span class="lineno">  862 </span>withDeclGroup :: DeclGroup -&gt; TI a -&gt; TI a
<span class="lineno">  863 </span><span class="decl"><span class="istickedoff">withDeclGroup (NonRecursive d) m = withDecl d m</span>
<span class="lineno">  864 </span><span class="spaces"></span><span class="istickedoff">withDeclGroup (Recursive ds) m = <span class="nottickedoff">foldr withDecl m ds</span></span></span>
<span class="lineno">  865 </span>
<span class="lineno">  866 </span>--
<span class="lineno">  867 </span>-- Infer the type for an expression.
<span class="lineno">  868 </span>--
<span class="lineno">  869 </span>-- The LName is the context name passed to unify, which isn't generally
<span class="lineno">  870 </span>-- useful and should probably be removed.
<span class="lineno">  871 </span>--
<span class="lineno">  872 </span>inferExpr :: (LName, Expr) -&gt; TI (OutExpr,Type)
<span class="lineno">  873 </span><span class="decl"><span class="istickedoff">inferExpr (ln, expr) = case expr of</span>
<span class="lineno">  874 </span><span class="spaces">  </span><span class="istickedoff">Bool pos b    -&gt; <span class="nottickedoff">return (Bool pos b, tBool (PosInferred InfTerm pos))</span></span>
<span class="lineno">  875 </span><span class="spaces">  </span><span class="istickedoff">String pos s  -&gt; return (String <span class="nottickedoff">pos</span> s, tString <span class="nottickedoff">(PosInferred InfTerm pos)</span>)</span>
<span class="lineno">  876 </span><span class="spaces">  </span><span class="istickedoff">Int pos i     -&gt; return (Int pos i, tInt (PosInferred InfTerm pos))</span>
<span class="lineno">  877 </span><span class="spaces">  </span><span class="istickedoff">Code s        -&gt; return (Code s, tTerm <span class="nottickedoff">(PosInferred InfTerm $ getPos s)</span>)</span>
<span class="lineno">  878 </span><span class="spaces">  </span><span class="istickedoff">CType s       -&gt; return (CType s, tType <span class="nottickedoff">(PosInferred InfTerm $ getPos s)</span>)</span>
<span class="lineno">  879 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  880 </span><span class="spaces">  </span><span class="istickedoff">Array pos [] -&gt;</span>
<span class="lineno">  881 </span><span class="spaces">    </span><span class="istickedoff">do a &lt;- getFreshTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno">  882 </span><span class="spaces">       </span><span class="istickedoff">return (Array <span class="nottickedoff">pos</span> [], tArray <span class="nottickedoff">(PosInferred InfTerm pos)</span> a)</span>
<span class="lineno">  883 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  884 </span><span class="spaces">  </span><span class="istickedoff">Array pos (e:es) -&gt;</span>
<span class="lineno">  885 </span><span class="spaces">    </span><span class="istickedoff">do (e',t) &lt;- inferExpr (<span class="nottickedoff">ln</span>, e)</span>
<span class="lineno">  886 </span><span class="spaces">       </span><span class="istickedoff">es' &lt;- mapM (flip (checkExpr <span class="nottickedoff">ln</span>) t) es</span>
<span class="lineno">  887 </span><span class="spaces">       </span><span class="istickedoff">return (Array pos (e':es'), tArray (PosInferred InfTerm pos) t)</span>
<span class="lineno">  888 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  889 </span><span class="spaces">  </span><span class="istickedoff">Block pos bs -&gt;</span>
<span class="lineno">  890 </span><span class="spaces">    </span><span class="istickedoff">do ctx &lt;- getFreshTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno">  891 </span><span class="spaces">       </span><span class="istickedoff">(bs',t') &lt;- inferStmts ln <span class="nottickedoff">pos</span> ctx bs</span>
<span class="lineno">  892 </span><span class="spaces">       </span><span class="istickedoff">return (Block <span class="nottickedoff">pos</span> bs', tBlock <span class="nottickedoff">(PosInferred InfTerm pos)</span> ctx t')</span>
<span class="lineno">  893 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  894 </span><span class="spaces">  </span><span class="istickedoff">Tuple pos es -&gt;</span>
<span class="lineno">  895 </span><span class="spaces">    </span><span class="istickedoff">do (es',ts) &lt;- unzip `fmap` mapM (inferExpr . (<span class="nottickedoff">ln</span>,)) es</span>
<span class="lineno">  896 </span><span class="spaces">       </span><span class="istickedoff">return (Tuple <span class="nottickedoff">pos</span> es', tTuple <span class="nottickedoff">(PosInferred InfTerm pos)</span> ts)</span>
<span class="lineno">  897 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  898 </span><span class="spaces">  </span><span class="istickedoff">Record pos fs -&gt;</span>
<span class="lineno">  899 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">do (nes',nts) &lt;- unzip `fmap` mapM (inferField ln) (M.toList fs)</span></span>
<span class="lineno">  900 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">let ty = TyRecord (PosInferred InfTerm pos) $ M.fromList nts</span></span>
<span class="lineno">  901 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">return (Record pos (M.fromList nes'), ty)</span></span>
<span class="lineno">  902 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  903 </span><span class="spaces">  </span><span class="istickedoff">Index pos ar ix -&gt;</span>
<span class="lineno">  904 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">do (ar',at) &lt;- inferExpr (ln,ar)</span></span>
<span class="lineno">  905 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">ix'      &lt;- checkExpr ln ix (tInt (PosInferred InfContext (getPos ix)))</span></span>
<span class="lineno">  906 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">t        &lt;- getFreshTyVar (getPos ix')</span></span>
<span class="lineno">  907 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">unify ln (tArray (PosInferred InfContext (getPos ar')) t) (getPos ar') at</span></span>
<span class="lineno">  908 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">return (Index pos ar' ix', t)</span></span>
<span class="lineno">  909 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  910 </span><span class="spaces">  </span><span class="istickedoff">Lookup pos e n -&gt;</span>
<span class="lineno">  911 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">do (e1,t) &lt;- inferExpr (ln, e)</span></span>
<span class="lineno">  912 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">t1 &lt;- applyCurrentSubst =&lt;&lt; resolveCurrentTypedefs t</span></span>
<span class="lineno">  913 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">elTy &lt;- case t1 of</span></span>
<span class="lineno">  914 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">TyRecord typos fs</span></span>
<span class="lineno">  915 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">| Just ty &lt;- M.lookup n fs -&gt; return ty</span></span>
<span class="lineno">  916 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">| otherwise -&gt;</span></span>
<span class="lineno">  917 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">do recordError pos $ unlines</span></span>
<span class="lineno">  918 </span><span class="spaces">                                </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Selecting a missing field.&quot;</span></span>
<span class="lineno">  919 </span><span class="spaces">                                </span><span class="istickedoff"><span class="nottickedoff">, &quot;Field name: &quot; ++ n</span></span>
<span class="lineno">  920 </span><span class="spaces">                                </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  921 </span><span class="spaces">                             </span><span class="istickedoff"><span class="nottickedoff">getErrorTyVar typos</span></span>
<span class="lineno">  922 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; do recordError pos $ unlines</span></span>
<span class="lineno">  923 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Record lookup on non-record argument.&quot;</span></span>
<span class="lineno">  924 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">, &quot;Field name: &quot; ++ n</span></span>
<span class="lineno">  925 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  926 </span><span class="spaces">                         </span><span class="istickedoff"><span class="nottickedoff">getErrorTyVar pos</span></span>
<span class="lineno">  927 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">return (Lookup pos e1 n, elTy)</span></span>
<span class="lineno">  928 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  929 </span><span class="spaces">  </span><span class="istickedoff">TLookup pos e i -&gt;</span>
<span class="lineno">  930 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">do (e1,t) &lt;- inferExpr (ln,e)</span></span>
<span class="lineno">  931 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">t1 &lt;- applyCurrentSubst =&lt;&lt; resolveCurrentTypedefs t</span></span>
<span class="lineno">  932 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">elTy &lt;- case t1 of</span></span>
<span class="lineno">  933 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">TyCon typos (TupleCon n) tys</span></span>
<span class="lineno">  934 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">| i &lt; n -&gt; return (tys !! fromIntegral i)</span></span>
<span class="lineno">  935 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">| otherwise -&gt;</span></span>
<span class="lineno">  936 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">do recordError pos $ unlines</span></span>
<span class="lineno">  937 </span><span class="spaces">                                </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Tuple index out of bounds.&quot;</span></span>
<span class="lineno">  938 </span><span class="spaces">                                </span><span class="istickedoff"><span class="nottickedoff">, &quot;Given index &quot; ++ show i ++</span></span>
<span class="lineno">  939 </span><span class="spaces">                                  </span><span class="istickedoff"><span class="nottickedoff">&quot; is too large for tuple size of &quot; ++</span></span>
<span class="lineno">  940 </span><span class="spaces">                                  </span><span class="istickedoff"><span class="nottickedoff">show n</span></span>
<span class="lineno">  941 </span><span class="spaces">                                </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  942 </span><span class="spaces">                             </span><span class="istickedoff"><span class="nottickedoff">getErrorTyVar typos</span></span>
<span class="lineno">  943 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; do recordError pos $ unlines</span></span>
<span class="lineno">  944 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Tuple lookup on non-tuple argument.&quot;</span></span>
<span class="lineno">  945 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">, &quot;Given index &quot; ++ show i</span></span>
<span class="lineno">  946 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  947 </span><span class="spaces">                         </span><span class="istickedoff"><span class="nottickedoff">getErrorTyVar pos</span></span>
<span class="lineno">  948 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">return (TLookup pos e1 i, elTy)</span></span>
<span class="lineno">  949 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  950 </span><span class="spaces">  </span><span class="istickedoff">Var x -&gt;</span>
<span class="lineno">  951 </span><span class="spaces">    </span><span class="istickedoff">do env &lt;- TI $ asks varEnv</span>
<span class="lineno">  952 </span><span class="spaces">       </span><span class="istickedoff">case M.lookup x env of</span>
<span class="lineno">  953 </span><span class="spaces">         </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  954 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">recordError (getPos x) $ unlines</span></span>
<span class="lineno">  955 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Unbound variable: &quot; ++ show x</span></span>
<span class="lineno">  956 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">, &quot;Note that some built-in commands are available only after running&quot;</span></span>
<span class="lineno">  957 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">, &quot;either `enable_deprecated` or `enable_experimental`.&quot;</span></span>
<span class="lineno">  958 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  959 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">t &lt;- getFreshTyVar (getPos x)</span></span>
<span class="lineno">  960 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">return (Var x, t)</span></span>
<span class="lineno">  961 </span><span class="spaces">         </span><span class="istickedoff">Just (Forall as t) -&gt; do</span>
<span class="lineno">  962 </span><span class="spaces">           </span><span class="istickedoff">-- get a fresh tyvar for each quantifier binding, convert</span>
<span class="lineno">  963 </span><span class="spaces">           </span><span class="istickedoff">-- to a name -&gt; ty map, and instantiate with the fresh tyvars</span>
<span class="lineno">  964 </span><span class="spaces">           </span><span class="istickedoff">let once (apos, a) = do</span>
<span class="lineno">  965 </span><span class="spaces">                 </span><span class="istickedoff">at &lt;- getFreshTyVar <span class="nottickedoff">apos</span></span>
<span class="lineno">  966 </span><span class="spaces">                 </span><span class="istickedoff">return (a, ConcreteType at)</span>
<span class="lineno">  967 </span><span class="spaces">           </span><span class="istickedoff">substs &lt;- mapM once as</span>
<span class="lineno">  968 </span><span class="spaces">           </span><span class="istickedoff">let t' = instantiate (M.fromList substs) t</span>
<span class="lineno">  969 </span><span class="spaces">           </span><span class="istickedoff">return (Var x, t')</span>
<span class="lineno">  970 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  971 </span><span class="spaces">  </span><span class="istickedoff">Function pos pat body -&gt;</span>
<span class="lineno">  972 </span><span class="spaces">    </span><span class="istickedoff">do (pt, pat') &lt;- inferPattern pat</span>
<span class="lineno">  973 </span><span class="spaces">       </span><span class="istickedoff">(body', t) &lt;- withPattern pat' $ inferExpr (ln, body)</span>
<span class="lineno">  974 </span><span class="spaces">       </span><span class="istickedoff">return (Function <span class="nottickedoff">pos</span> pat' body', tFun <span class="nottickedoff">(PosInferred InfContext (getPos body))</span> pt t)</span>
<span class="lineno">  975 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  976 </span><span class="spaces">  </span><span class="istickedoff">Application pos f arg -&gt;</span>
<span class="lineno">  977 </span><span class="spaces">    </span><span class="istickedoff">do argtype &lt;- getFreshTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno">  978 </span><span class="spaces">       </span><span class="istickedoff">rettype &lt;- getFreshTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno">  979 </span><span class="spaces">       </span><span class="istickedoff">let ftype = tFun <span class="nottickedoff">(PosInferred InfContext $ getPos f)</span> argtype rettype</span>
<span class="lineno">  980 </span><span class="spaces">       </span><span class="istickedoff">-- Check f' first so that we complain about the arg (not the</span>
<span class="lineno">  981 </span><span class="spaces">       </span><span class="istickedoff">-- function) if they don't match. This is what everyone expects</span>
<span class="lineno">  982 </span><span class="spaces">       </span><span class="istickedoff">-- and doing it the other way is surprisingly confusing.</span>
<span class="lineno">  983 </span><span class="spaces">       </span><span class="istickedoff">f' &lt;- checkExpr <span class="nottickedoff">ln</span> f ftype</span>
<span class="lineno">  984 </span><span class="spaces">       </span><span class="istickedoff">arg' &lt;- checkExpr ln arg argtype</span>
<span class="lineno">  985 </span><span class="spaces">       </span><span class="istickedoff">return (Application pos f' arg', rettype)</span>
<span class="lineno">  986 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  987 </span><span class="spaces">  </span><span class="istickedoff">Let pos dg body -&gt;</span>
<span class="lineno">  988 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">do dg' &lt;- inferDeclGroup dg</span></span>
<span class="lineno">  989 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">(body', t) &lt;- withDeclGroup dg' (inferExpr (ln, body))</span></span>
<span class="lineno">  990 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">return (Let pos dg' body', t)</span></span>
<span class="lineno">  991 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  992 </span><span class="spaces">  </span><span class="istickedoff">TSig _pos e t -&gt;</span>
<span class="lineno">  993 </span><span class="spaces">    </span><span class="istickedoff">do t' &lt;- checkType kindStar t</span>
<span class="lineno">  994 </span><span class="spaces">       </span><span class="istickedoff">(e',t'') &lt;- inferExpr (<span class="nottickedoff">ln</span>,e)</span>
<span class="lineno">  995 </span><span class="spaces">       </span><span class="istickedoff">unify ln t' (getPos e') t''</span>
<span class="lineno">  996 </span><span class="spaces">       </span><span class="istickedoff">return (e',t'')</span>
<span class="lineno">  997 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  998 </span><span class="spaces">  </span><span class="istickedoff">IfThenElse pos e1 e2 e3 -&gt;</span>
<span class="lineno">  999 </span><span class="spaces">    </span><span class="istickedoff">do e1' &lt;- checkExpr <span class="nottickedoff">ln</span> e1 (tBool <span class="nottickedoff">(PosInferred InfContext $ getPos e1)</span>)</span>
<span class="lineno"> 1000 </span><span class="spaces">       </span><span class="istickedoff">(e2', t) &lt;- inferExpr (<span class="nottickedoff">ln</span>, e2)</span>
<span class="lineno"> 1001 </span><span class="spaces">       </span><span class="istickedoff">e3' &lt;- checkExpr <span class="nottickedoff">ln</span> e3 t</span>
<span class="lineno"> 1002 </span><span class="spaces">       </span><span class="istickedoff">return (IfThenElse <span class="nottickedoff">pos</span> e1' e2' e3', t)</span></span>
<span class="lineno"> 1003 </span>
<span class="lineno"> 1004 </span>--
<span class="lineno"> 1005 </span>-- Check the type of an expr, by inferring and then unifying the
<span class="lineno"> 1006 </span>-- result.
<span class="lineno"> 1007 </span>--
<span class="lineno"> 1008 </span>checkExpr :: LName -&gt; Expr -&gt; Type -&gt; TI OutExpr
<span class="lineno"> 1009 </span><span class="decl"><span class="istickedoff">checkExpr m e t = do</span>
<span class="lineno"> 1010 </span><span class="spaces">  </span><span class="istickedoff">(e',t') &lt;- inferExpr (m,e)</span>
<span class="lineno"> 1011 </span><span class="spaces">  </span><span class="istickedoff">unify m t (getPos e') t'</span>
<span class="lineno"> 1012 </span><span class="spaces">  </span><span class="istickedoff">return e'</span></span>
<span class="lineno"> 1013 </span>
<span class="lineno"> 1014 </span>--
<span class="lineno"> 1015 </span>-- patterns
<span class="lineno"> 1016 </span>--
<span class="lineno"> 1017 </span>
<span class="lineno"> 1018 </span>-- Infer types for a pattern, producing fresh type variables as needed.
<span class="lineno"> 1019 </span>--
<span class="lineno"> 1020 </span>-- There may already be types in the pattern if there were explicit
<span class="lineno"> 1021 </span>-- type annotations in the input; if so don't throw them away.
<span class="lineno"> 1022 </span>inferPattern :: Pattern -&gt; TI (Type, Pattern)
<span class="lineno"> 1023 </span><span class="decl"><span class="istickedoff">inferPattern pat =</span>
<span class="lineno"> 1024 </span><span class="spaces">  </span><span class="istickedoff">let resolveType pos mt = case mt of</span>
<span class="lineno"> 1025 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; getFreshTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno"> 1026 </span><span class="spaces">        </span><span class="istickedoff">Just t -&gt; checkType kindStar t</span>
<span class="lineno"> 1027 </span><span class="spaces">  </span><span class="istickedoff">in</span>
<span class="lineno"> 1028 </span><span class="spaces">  </span><span class="istickedoff">case pat of</span>
<span class="lineno"> 1029 </span><span class="spaces">    </span><span class="istickedoff">PWild pos mt -&gt;</span>
<span class="lineno"> 1030 </span><span class="spaces">      </span><span class="istickedoff">do t &lt;- resolveType <span class="nottickedoff">pos</span> mt</span>
<span class="lineno"> 1031 </span><span class="spaces">         </span><span class="istickedoff">return (t, PWild <span class="nottickedoff">pos</span> (Just t))</span>
<span class="lineno"> 1032 </span><span class="spaces">    </span><span class="istickedoff">PVar pos x mt -&gt;</span>
<span class="lineno"> 1033 </span><span class="spaces">      </span><span class="istickedoff">do t &lt;- resolveType <span class="nottickedoff">pos</span> mt</span>
<span class="lineno"> 1034 </span><span class="spaces">         </span><span class="istickedoff">return (t, PVar <span class="nottickedoff">pos</span> x (Just t))</span>
<span class="lineno"> 1035 </span><span class="spaces">    </span><span class="istickedoff">PTuple pos ps -&gt;</span>
<span class="lineno"> 1036 </span><span class="spaces">      </span><span class="istickedoff">do (ts, ps') &lt;- unzip &lt;$&gt; mapM inferPattern ps</span>
<span class="lineno"> 1037 </span><span class="spaces">         </span><span class="istickedoff">return (tTuple <span class="nottickedoff">(PosInferred InfTerm pos)</span> ts, PTuple <span class="nottickedoff">pos</span> ps')</span></span>
<span class="lineno"> 1038 </span>
<span class="lineno"> 1039 </span>-- Check the type of a pattern, by inferring and then unifying the
<span class="lineno"> 1040 </span>-- result.
<span class="lineno"> 1041 </span>--
<span class="lineno"> 1042 </span>-- XXX: it doesn't seem like there's any guarantee that fresh tyvars
<span class="lineno"> 1043 </span>-- produced by inferPattern will necessarily be resolved by the
<span class="lineno"> 1044 </span>-- unification, and therefore it seems that dropping the possibly
<span class="lineno"> 1045 </span>-- updated pattern is a bug.
<span class="lineno"> 1046 </span>checkPattern :: LName -&gt; Type -&gt; Pattern -&gt; TI ()
<span class="lineno"> 1047 </span><span class="decl"><span class="istickedoff">checkPattern ln t pat =</span>
<span class="lineno"> 1048 </span><span class="spaces">  </span><span class="istickedoff">do (pt, _pat') &lt;- inferPattern pat</span>
<span class="lineno"> 1049 </span><span class="spaces">     </span><span class="istickedoff">unify <span class="nottickedoff">ln</span> t <span class="nottickedoff">(getPos pat)</span> pt</span></span>
<span class="lineno"> 1050 </span>
<span class="lineno"> 1051 </span>--
<span class="lineno"> 1052 </span>-- statements
<span class="lineno"> 1053 </span>--
<span class="lineno"> 1054 </span>
<span class="lineno"> 1055 </span>-- wrap m with a typedef binding
<span class="lineno"> 1056 </span>withTypedef :: LName -&gt; Type -&gt; TI a -&gt; TI a
<span class="lineno"> 1057 </span><span class="decl"><span class="istickedoff">withTypedef n t m =</span>
<span class="lineno"> 1058 </span><span class="spaces">  </span><span class="istickedoff">TI $</span>
<span class="lineno"> 1059 </span><span class="spaces">  </span><span class="istickedoff">local</span>
<span class="lineno"> 1060 </span><span class="spaces">    </span><span class="istickedoff">(\ro -&gt;</span>
<span class="lineno"> 1061 </span><span class="spaces">      </span><span class="istickedoff">let t' = instantiate (tyEnv ro) t</span>
<span class="lineno"> 1062 </span><span class="spaces">      </span><span class="istickedoff">in  ro { tyEnv = M.insert (getVal n) (ConcreteType t') $ tyEnv ro })</span>
<span class="lineno"> 1063 </span><span class="spaces">    </span><span class="istickedoff">$ unTI m</span></span>
<span class="lineno"> 1064 </span>
<span class="lineno"> 1065 </span>-- Check if a statement is an allowable one for the end of a do-block.
<span class="lineno"> 1066 </span>-- The last thing in a do-block should be an expression, which manifests
<span class="lineno"> 1067 </span>-- as a bind-statement of the form _ &lt;- e.
<span class="lineno"> 1068 </span>legalEndOfBlock :: Stmt -&gt; Bool
<span class="lineno"> 1069 </span><span class="decl"><span class="istickedoff">legalEndOfBlock s = case s of</span>
<span class="lineno"> 1070 </span><span class="spaces">    </span><span class="istickedoff">StmtBind _spos (PWild _patpos _mt) _e -&gt; True</span>
<span class="lineno"> 1071 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">False</span></span></span>
<span class="lineno"> 1072 </span>
<span class="lineno"> 1073 </span>-- break a monadic type down into its monad and value types, if it is one
<span class="lineno"> 1074 </span>--
<span class="lineno"> 1075 </span>--    monadType (TopLevel Int) gives Just (TopLevel, Int)
<span class="lineno"> 1076 </span>--    monadType Int gives Nothing
<span class="lineno"> 1077 </span>--
<span class="lineno"> 1078 </span>monadType  :: Type -&gt; Maybe (Type, Type)
<span class="lineno"> 1079 </span><span class="decl"><span class="istickedoff">monadType ty = case ty of</span>
<span class="lineno"> 1080 </span><span class="spaces">  </span><span class="istickedoff">TyCon _ BlockCon [ctx@(TyCon _ (ContextCon _) []), valty] -&gt;</span>
<span class="lineno"> 1081 </span><span class="spaces">      </span><span class="istickedoff">Just (ctx, valty)</span>
<span class="lineno"> 1082 </span><span class="spaces">  </span><span class="istickedoff">-- We don't currently ever generate this type, but be future-proof</span>
<span class="lineno"> 1083 </span><span class="spaces">  </span><span class="istickedoff">TyCon pos (ContextCon ctx) [valty] -&gt;</span>
<span class="lineno"> 1084 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">Just (TyCon pos (ContextCon ctx) [], valty)</span></span>
<span class="lineno"> 1085 </span><span class="spaces">  </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 1086 </span><span class="spaces">      </span><span class="istickedoff">Nothing</span></span>
<span class="lineno"> 1087 </span>
<span class="lineno"> 1088 </span>-- wrap an expression in &quot;return&quot;
<span class="lineno"> 1089 </span>wrapReturn :: Expr -&gt; Expr
<span class="lineno"> 1090 </span><span class="decl"><span class="istickedoff">wrapReturn e =</span>
<span class="lineno"> 1091 </span><span class="spaces">   </span><span class="istickedoff">let <span class="nottickedoff">ePos = getPos e</span></span>
<span class="lineno"> 1092 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">retPos = PosInternal &quot;&lt;implicitly inserted return&gt;&quot;</span></span>
<span class="lineno"> 1093 </span><span class="spaces">       </span><span class="istickedoff">ret = Var $ Located &quot;return&quot; <span class="nottickedoff">&quot;return&quot;</span> <span class="nottickedoff">retPos</span> </span>
<span class="lineno"> 1094 </span><span class="spaces">   </span><span class="istickedoff">in</span>
<span class="lineno"> 1095 </span><span class="spaces">   </span><span class="istickedoff">Application <span class="nottickedoff">ePos</span> ret e</span></span>
<span class="lineno"> 1096 </span>
<span class="lineno"> 1097 </span>-- type inference for a single statement
<span class="lineno"> 1098 </span>--
<span class="lineno"> 1099 </span>-- the boolean is whether we're at the syntactic top level, which is used
<span class="lineno"> 1100 </span>-- for workaround logic for issue #2162
<span class="lineno"> 1101 </span>--
<span class="lineno"> 1102 </span>-- the passed-in position should be the position associated with the monad type
<span class="lineno"> 1103 </span>-- the first type argument (ctx) is the monad type for any binds that occur
<span class="lineno"> 1104 </span>--
<span class="lineno"> 1105 </span>-- returns a wrapper for checking subsequent statements as well as
<span class="lineno"> 1106 </span>-- an updated statement and a type.
<span class="lineno"> 1107 </span>inferStmt :: LName -&gt; Bool -&gt; Pos -&gt; Type -&gt; Stmt -&gt; TI (TI a -&gt; TI a, Stmt, Type)
<span class="lineno"> 1108 </span><span class="decl"><span class="istickedoff">inferStmt ln atSyntacticTopLevel blockpos ctx s =</span>
<span class="lineno"> 1109 </span><span class="spaces">    </span><span class="istickedoff">case s of</span>
<span class="lineno"> 1110 </span><span class="spaces">        </span><span class="istickedoff">StmtBind spos pat e -&gt; do</span>
<span class="lineno"> 1111 </span><span class="spaces">            </span><span class="istickedoff">(pty, pat') &lt;- inferPattern pat</span>
<span class="lineno"> 1112 </span><span class="spaces">            </span><span class="istickedoff">-- The expression should be of monad type. The</span>
<span class="lineno"> 1113 </span><span class="spaces">            </span><span class="istickedoff">-- straightforward way to proceed here is to unify both</span>
<span class="lineno"> 1114 </span><span class="spaces">            </span><span class="istickedoff">-- the monad type (ctx) and the result type expected by</span>
<span class="lineno"> 1115 </span><span class="spaces">            </span><span class="istickedoff">-- the pattern (pty), like this:</span>
<span class="lineno"> 1116 </span><span class="spaces">            </span><span class="istickedoff">--    e' &lt;- checkExpr ln e (tBlock blockpos ctx pty)</span>
<span class="lineno"> 1117 </span><span class="spaces">            </span><span class="istickedoff">--</span>
<span class="lineno"> 1118 </span><span class="spaces">            </span><span class="istickedoff">-- However, historically when at the syntactic top level</span>
<span class="lineno"> 1119 </span><span class="spaces">            </span><span class="istickedoff">-- (only), the monad type was left off, meaning that</span>
<span class="lineno"> 1120 </span><span class="spaces">            </span><span class="istickedoff">-- various incorrect forms were silently accepted. Fixing</span>
<span class="lineno"> 1121 </span><span class="spaces">            </span><span class="istickedoff">-- this in Dec 2024 triggered a lot of fallout, so for the</span>
<span class="lineno"> 1122 </span><span class="spaces">            </span><span class="istickedoff">-- time being we want to check for, warn about, and allow</span>
<span class="lineno"> 1123 </span><span class="spaces">            </span><span class="istickedoff">-- the following cases. (Again, only when at the syntactic</span>
<span class="lineno"> 1124 </span><span class="spaces">            </span><span class="istickedoff">-- top level. Which is not when in the TopLevel monad.)</span>
<span class="lineno"> 1125 </span><span class="spaces">            </span><span class="istickedoff">--    x &lt;- e for non-monadic e</span>
<span class="lineno"> 1126 </span><span class="spaces">            </span><span class="istickedoff">--    x &lt;- e for e in the wrong monad</span>
<span class="lineno"> 1127 </span><span class="spaces">            </span><span class="istickedoff">--</span>
<span class="lineno"> 1128 </span><span class="spaces">            </span><span class="istickedoff">-- These should be made errors again at some point, but</span>
<span class="lineno"> 1129 </span><span class="spaces">            </span><span class="istickedoff">-- definitely no earlier than the _second_ release after</span>
<span class="lineno"> 1130 </span><span class="spaces">            </span><span class="istickedoff">-- December 2024, as the first such release should include</span>
<span class="lineno"> 1131 </span><span class="spaces">            </span><span class="istickedoff">-- the warning behavior. Probably the explicit messages</span>
<span class="lineno"> 1132 </span><span class="spaces">            </span><span class="istickedoff">-- should then in turn not be removed for at least one</span>
<span class="lineno"> 1133 </span><span class="spaces">            </span><span class="istickedoff">-- further release. See #2167 and #2162.</span>
<span class="lineno"> 1134 </span><span class="spaces">            </span><span class="istickedoff">--</span>
<span class="lineno"> 1135 </span><span class="spaces">            </span><span class="istickedoff">-- To accomplish this, call inferExpr to get a type for</span>
<span class="lineno"> 1136 </span><span class="spaces">            </span><span class="istickedoff">-- the expression, and examine it. If the special cases</span>
<span class="lineno"> 1137 </span><span class="spaces">            </span><span class="istickedoff">-- apply, issue special-case warnings with explanations,</span>
<span class="lineno"> 1138 </span><span class="spaces">            </span><span class="istickedoff">-- unify the type with only the pattern type, and patch up</span>
<span class="lineno"> 1139 </span><span class="spaces">            </span><span class="istickedoff">-- the expression by wrapping it in &quot;return&quot;.  (The latter</span>
<span class="lineno"> 1140 </span><span class="spaces">            </span><span class="istickedoff">-- will restore the old behavior for both cases, so we</span>
<span class="lineno"> 1141 </span><span class="spaces">            </span><span class="istickedoff">-- don't need to also gunk up the interpreter to handle</span>
<span class="lineno"> 1142 </span><span class="spaces">            </span><span class="istickedoff">-- this problem.)</span>
<span class="lineno"> 1143 </span><span class="spaces">            </span><span class="istickedoff">--</span>
<span class="lineno"> 1144 </span><span class="spaces">            </span><span class="istickedoff">-- If the special cases don't apply, unify the result type</span>
<span class="lineno"> 1145 </span><span class="spaces">            </span><span class="istickedoff">-- with the complete type.</span>
<span class="lineno"> 1146 </span><span class="spaces">            </span><span class="istickedoff">(e', ty) &lt;- inferExpr (ln, e)</span>
<span class="lineno"> 1147 </span><span class="spaces">            </span><span class="istickedoff">ty' &lt;- applyCurrentSubst =&lt;&lt; resolveCurrentTypedefs ty</span>
<span class="lineno"> 1148 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1149 </span><span class="spaces">            </span><span class="istickedoff">-- The correct, restricted case</span>
<span class="lineno"> 1150 </span><span class="spaces">            </span><span class="istickedoff">let restrictToCorrect = do</span>
<span class="lineno"> 1151 </span><span class="spaces">                  </span><span class="istickedoff">-- unify the type of e with the expected monad and</span>
<span class="lineno"> 1152 </span><span class="spaces">                  </span><span class="istickedoff">-- pattern types</span>
<span class="lineno"> 1153 </span><span class="spaces">                  </span><span class="istickedoff">unify ln (tBlock blockpos ctx pty) (getPos e') ty</span>
<span class="lineno"> 1154 </span><span class="spaces">                  </span><span class="istickedoff">return e'</span>
<span class="lineno"> 1155 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1156 </span><span class="spaces">            </span><span class="istickedoff">-- The special case for non-monadic values</span>
<span class="lineno"> 1157 </span><span class="spaces">            </span><span class="istickedoff">let allowNonMonadic = do</span>
<span class="lineno"> 1158 </span><span class="spaces">                  </span><span class="istickedoff">recordWarning spos $ &quot;Monadic bind of non-monadic value; &quot; ++</span>
<span class="lineno"> 1159 </span><span class="spaces">                                       </span><span class="istickedoff">&quot;rewrite as let-binding or use return&quot;</span>
<span class="lineno"> 1160 </span><span class="spaces">                  </span><span class="istickedoff">recordWarning spos $ &quot;This will become an error in a &quot; ++</span>
<span class="lineno"> 1161 </span><span class="spaces">                                       </span><span class="istickedoff">&quot;future release of SAW&quot;</span>
<span class="lineno"> 1162 </span><span class="spaces">                  </span><span class="istickedoff">unify <span class="nottickedoff">ln</span> pty <span class="nottickedoff">(getPos e')</span> ty</span>
<span class="lineno"> 1163 </span><span class="spaces">                  </span><span class="istickedoff">-- Wrap the expression in &quot;return&quot; to correct the type</span>
<span class="lineno"> 1164 </span><span class="spaces">                  </span><span class="istickedoff">return $ wrapReturn e'</span>
<span class="lineno"> 1165 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1166 </span><span class="spaces">            </span><span class="istickedoff">-- The special case for the wrong monad</span>
<span class="lineno"> 1167 </span><span class="spaces">            </span><span class="istickedoff">let allowWrongMonad ctx' valty' = do</span>
<span class="lineno"> 1168 </span><span class="spaces">                  </span><span class="istickedoff">recordWarning spos $ &quot;Monadic bind with the wrong monad; &quot; ++</span>
<span class="lineno"> 1169 </span><span class="spaces">                                       </span><span class="istickedoff">&quot;found &quot; ++ pShow ctx' ++</span>
<span class="lineno"> 1170 </span><span class="spaces">                                       </span><span class="istickedoff">&quot; but expected &quot; ++ pShow ctx</span>
<span class="lineno"> 1171 </span><span class="spaces">                  </span><span class="istickedoff">recordWarning spos $ &quot;This creates the action but does &quot; ++</span>
<span class="lineno"> 1172 </span><span class="spaces">                                       </span><span class="istickedoff">&quot;not execute it; if you meant to do &quot; ++</span>
<span class="lineno"> 1173 </span><span class="spaces">                                       </span><span class="istickedoff">&quot;that, prefix the &quot; ++</span>
<span class="lineno"> 1174 </span><span class="spaces">                                       </span><span class="istickedoff">&quot;expression with return&quot;</span>
<span class="lineno"> 1175 </span><span class="spaces">                  </span><span class="istickedoff">recordWarning spos $ &quot;This will become an error in a &quot; ++</span>
<span class="lineno"> 1176 </span><span class="spaces">                                       </span><span class="istickedoff">&quot;future release of SAW&quot;</span>
<span class="lineno"> 1177 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1178 </span><span class="spaces">                  </span><span class="istickedoff">-- The historic behavior is that the pattern gets bound</span>
<span class="lineno"> 1179 </span><span class="spaces">                  </span><span class="istickedoff">-- to a value of type m t instead of type t. This means:</span>
<span class="lineno"> 1180 </span><span class="spaces">                  </span><span class="istickedoff">--    - we should unify pty, which is the type of the</span>
<span class="lineno"> 1181 </span><span class="spaces">                  </span><span class="istickedoff">--      pattern, with m t, which is tBlock ctx' valty'</span>
<span class="lineno"> 1182 </span><span class="spaces">                  </span><span class="istickedoff">--      (rather than tBlock ctx valty', which is the</span>
<span class="lineno"> 1183 </span><span class="spaces">                  </span><span class="istickedoff">--      type we should be getting)</span>
<span class="lineno"> 1184 </span><span class="spaces">                  </span><span class="istickedoff">--    - this will fail if the pattern includes a type</span>
<span class="lineno"> 1185 </span><span class="spaces">                  </span><span class="istickedoff">--      signature with a non-monad type, but that's ok</span>
<span class="lineno"> 1186 </span><span class="spaces">                  </span><span class="istickedoff">--      because that case also fails in old SAW</span>
<span class="lineno"> 1187 </span><span class="spaces">                  </span><span class="istickedoff">--    - we do _not_ need to update pty before returning</span>
<span class="lineno"> 1188 </span><span class="spaces">                  </span><span class="istickedoff">--      it out of inferStmt</span>
<span class="lineno"> 1189 </span><span class="spaces">                  </span><span class="istickedoff">--    - we _do_ need to wrap the expression in &quot;return&quot;</span>
<span class="lineno"> 1190 </span><span class="spaces">                  </span><span class="istickedoff">--      so that the ultimate results are well-typed and</span>
<span class="lineno"> 1191 </span><span class="spaces">                  </span><span class="istickedoff">--      happen in the TopLevel monad</span>
<span class="lineno"> 1192 </span><span class="spaces">                  </span><span class="istickedoff">unify ln pty (getPos e') (tBlock spos ctx' valty')</span>
<span class="lineno"> 1193 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1194 </span><span class="spaces">                  </span><span class="istickedoff">-- Wrap the expression in &quot;return&quot; to produce an</span>
<span class="lineno"> 1195 </span><span class="spaces">                  </span><span class="istickedoff">-- expression of type TopLevel (m t).</span>
<span class="lineno"> 1196 </span><span class="spaces">                  </span><span class="istickedoff">return $ wrapReturn e'</span>
<span class="lineno"> 1197 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1198 </span><span class="spaces">            </span><span class="istickedoff">-- Figure out which case applies.</span>
<span class="lineno"> 1199 </span><span class="spaces">            </span><span class="istickedoff">e'' &lt;-</span>
<span class="lineno"> 1200 </span><span class="spaces">                </span><span class="istickedoff">if not atSyntacticTopLevel then</span>
<span class="lineno"> 1201 </span><span class="spaces">                    </span><span class="istickedoff">restrictToCorrect</span>
<span class="lineno"> 1202 </span><span class="spaces">                </span><span class="istickedoff">else do</span>
<span class="lineno"> 1203 </span><span class="spaces">                    </span><span class="istickedoff">ok &lt;- matches (tBlock <span class="nottickedoff">blockpos</span> ctx pty) ty</span>
<span class="lineno"> 1204 </span><span class="spaces">                    </span><span class="istickedoff">if ok then</span>
<span class="lineno"> 1205 </span><span class="spaces">                        </span><span class="istickedoff">restrictToCorrect</span>
<span class="lineno"> 1206 </span><span class="spaces">                    </span><span class="istickedoff">else</span>
<span class="lineno"> 1207 </span><span class="spaces">                        </span><span class="istickedoff">case monadType ty' of</span>
<span class="lineno"> 1208 </span><span class="spaces">                            </span><span class="istickedoff">Just (ctx', valty') -&gt;</span>
<span class="lineno"> 1209 </span><span class="spaces">                               </span><span class="istickedoff">-- Allow it only for _ and a single var.</span>
<span class="lineno"> 1210 </span><span class="spaces">                               </span><span class="istickedoff">-- Binding elements of a tuple this way</span>
<span class="lineno"> 1211 </span><span class="spaces">                               </span><span class="istickedoff">-- failed typecheck in the old saw and</span>
<span class="lineno"> 1212 </span><span class="spaces">                               </span><span class="istickedoff">-- doesn't need to be allowed now.</span>
<span class="lineno"> 1213 </span><span class="spaces">                               </span><span class="istickedoff">case pat of</span>
<span class="lineno"> 1214 </span><span class="spaces">                                   </span><span class="istickedoff">PTuple _ _ -&gt; restrictToCorrect</span>
<span class="lineno"> 1215 </span><span class="spaces">                                   </span><span class="istickedoff">_ -&gt; allowWrongMonad ctx' valty'</span>
<span class="lineno"> 1216 </span><span class="spaces">                            </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1217 </span><span class="spaces">                               </span><span class="istickedoff">-- allow it only if actually binding something</span>
<span class="lineno"> 1218 </span><span class="spaces">                               </span><span class="istickedoff">-- (just proclaiming a value by itself is not a</span>
<span class="lineno"> 1219 </span><span class="spaces">                               </span><span class="istickedoff">-- case we need to worry about)</span>
<span class="lineno"> 1220 </span><span class="spaces">                               </span><span class="istickedoff">case pat of</span>
<span class="lineno"> 1221 </span><span class="spaces">                                   </span><span class="istickedoff">PWild _ _ -&gt; restrictToCorrect</span>
<span class="lineno"> 1222 </span><span class="spaces">                                   </span><span class="istickedoff">_ -&gt; allowNonMonadic</span>
<span class="lineno"> 1223 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1224 </span><span class="spaces">            </span><span class="istickedoff">let s' = StmtBind spos pat' e''</span>
<span class="lineno"> 1225 </span><span class="spaces">            </span><span class="istickedoff">let wrapper = withPattern pat'</span>
<span class="lineno"> 1226 </span><span class="spaces">            </span><span class="istickedoff">return (wrapper, s', pty)</span>
<span class="lineno"> 1227 </span><span class="spaces">        </span><span class="istickedoff">StmtLet spos dg -&gt; do</span>
<span class="lineno"> 1228 </span><span class="spaces">            </span><span class="istickedoff">dg' &lt;- inferDeclGroup dg</span>
<span class="lineno"> 1229 </span><span class="spaces">            </span><span class="istickedoff">let s' = StmtLet <span class="nottickedoff">spos</span> dg'</span>
<span class="lineno"> 1230 </span><span class="spaces">            </span><span class="istickedoff">let wrapper = withDeclGroup dg'</span>
<span class="lineno"> 1231 </span><span class="spaces">            </span><span class="istickedoff">return (wrapper, s', <span class="nottickedoff">tUnit $ PosInferred InfTerm spos</span>)</span>
<span class="lineno"> 1232 </span><span class="spaces">        </span><span class="istickedoff">StmtCode spos _ -&gt;</span>
<span class="lineno"> 1233 </span><span class="spaces">            </span><span class="istickedoff">return (<span class="nottickedoff">id</span>, s, <span class="nottickedoff">tUnit $ PosInferred InfTerm spos</span>)</span>
<span class="lineno"> 1234 </span><span class="spaces">        </span><span class="istickedoff">StmtImport spos _ -&gt;</span>
<span class="lineno"> 1235 </span><span class="spaces">            </span><span class="istickedoff">return (<span class="nottickedoff">id</span>, s, <span class="nottickedoff">tUnit $ PosInferred InfTerm spos</span>)</span>
<span class="lineno"> 1236 </span><span class="spaces">        </span><span class="istickedoff">StmtTypedef spos name ty -&gt; do</span>
<span class="lineno"> 1237 </span><span class="spaces">            </span><span class="istickedoff">ty' &lt;- checkType kindStar ty</span>
<span class="lineno"> 1238 </span><span class="spaces">            </span><span class="istickedoff">let s' = StmtTypedef <span class="nottickedoff">spos</span> name ty'</span>
<span class="lineno"> 1239 </span><span class="spaces">            </span><span class="istickedoff">let wrapper = withTypedef name ty'</span>
<span class="lineno"> 1240 </span><span class="spaces">            </span><span class="istickedoff">return (wrapper, s', <span class="nottickedoff">tUnit $ PosInferred InfTerm spos</span>)</span></span>
<span class="lineno"> 1241 </span>
<span class="lineno"> 1242 </span>-- the passed-in position should be the position for the whole statement block
<span class="lineno"> 1243 </span>-- the first type argument (ctx) is the monad type for the block
<span class="lineno"> 1244 </span>inferStmts :: LName -&gt; Pos -&gt; Type -&gt; [Stmt] -&gt; TI ([OutStmt], Type)
<span class="lineno"> 1245 </span><span class="decl"><span class="istickedoff">inferStmts ln blockpos ctx stmts = case stmts of</span>
<span class="lineno"> 1246 </span><span class="spaces">    </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno"> 1247 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">recordError blockpos (&quot;do block must include at least one &quot; ++</span></span>
<span class="lineno"> 1248 </span><span class="spaces">                              </span><span class="istickedoff"><span class="nottickedoff">&quot;expression at &quot; ++ show ln)</span></span>
<span class="lineno"> 1249 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">t &lt;- getErrorTyVar blockpos</span></span>
<span class="lineno"> 1250 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return ([], t)</span></span>
<span class="lineno"> 1251 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1252 </span><span class="spaces">    </span><span class="istickedoff">s : more -&gt; do</span>
<span class="lineno"> 1253 </span><span class="spaces">        </span><span class="istickedoff">let atSyntacticTopLevel = False</span>
<span class="lineno"> 1254 </span><span class="spaces">        </span><span class="istickedoff">(wrapper, s', t) &lt;- inferStmt ln atSyntacticTopLevel <span class="nottickedoff">blockpos</span> ctx s</span>
<span class="lineno"> 1255 </span><span class="spaces">        </span><span class="istickedoff">case more of</span>
<span class="lineno"> 1256 </span><span class="spaces">            </span><span class="istickedoff">[] -&gt;</span>
<span class="lineno"> 1257 </span><span class="spaces">                </span><span class="istickedoff">if <span class="tickonlytrue">legalEndOfBlock s</span> then</span>
<span class="lineno"> 1258 </span><span class="spaces">                    </span><span class="istickedoff">return ([s'], t)</span>
<span class="lineno"> 1259 </span><span class="spaces">                </span><span class="istickedoff">else <span class="nottickedoff">do</span></span>
<span class="lineno"> 1260 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">recordError blockpos (&quot;do block must end with &quot; ++</span></span>
<span class="lineno"> 1261 </span><span class="spaces">                                          </span><span class="istickedoff"><span class="nottickedoff">&quot;expression at &quot; ++ show ln)</span></span>
<span class="lineno"> 1262 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">t' &lt;- getErrorTyVar blockpos</span></span>
<span class="lineno"> 1263 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">-- XXX this has been throwing away s' but probably shouldn't</span></span>
<span class="lineno"> 1264 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">return ([], t')</span></span>
<span class="lineno"> 1265 </span><span class="spaces">            </span><span class="istickedoff">_ : _ -&gt; do</span>
<span class="lineno"> 1266 </span><span class="spaces">               </span><span class="istickedoff">(more', t') &lt;- wrapper $ inferStmts ln <span class="nottickedoff">blockpos</span> ctx more</span>
<span class="lineno"> 1267 </span><span class="spaces">               </span><span class="istickedoff">return (s' : more', t')</span></span>
<span class="lineno"> 1268 </span>
<span class="lineno"> 1269 </span>-- Wrapper around inferStmt suitable for checking one statement at a
<span class="lineno"> 1270 </span>-- time. This is temporary scaffolding for the interpreter while
<span class="lineno"> 1271 </span>-- fixing it. (Currently the interpreter typechecks one statement at a
<span class="lineno"> 1272 </span>-- time when executing, even when not at the repl, and this involves
<span class="lineno"> 1273 </span>-- assorted messiness and technical debt. Eventually we'll get it into
<span class="lineno"> 1274 </span>-- a state where we can always just typecheck immediately after
<span class="lineno"> 1275 </span>-- parsing (including incrementally from the repl) but we're some
<span class="lineno"> 1276 </span>-- distance from that. In the meantime the first step is to get it to
<span class="lineno"> 1277 </span>-- typecheck one statement at a time without special-casing any of
<span class="lineno"> 1278 </span>-- them, and this is how it does that.
<span class="lineno"> 1279 </span>--
<span class="lineno"> 1280 </span>-- Run inferStmt and then apply the current substitution before
<span class="lineno"> 1281 </span>-- returning the updated statement. Ignore the wrapper returned for
<span class="lineno"> 1282 </span>-- typechecking subsequent statements; the interpreter has its own
<span class="lineno"> 1283 </span>-- (misbegotten) logic for handling that in its own way. (Which should
<span class="lineno"> 1284 </span>-- be removed, but we need to get rid of these wrappers here first;
<span class="lineno"> 1285 </span>-- any sane incremental typechecking interface requires updating the
<span class="lineno"> 1286 </span>-- environment for sequential declarations, not pretending that
<span class="lineno"> 1287 </span>-- subsequent statements in a block are nested inside prior ones.)
<span class="lineno"> 1288 </span>inferSingleStmt :: LName -&gt; Pos -&gt; Type -&gt; Stmt -&gt; TI Stmt
<span class="lineno"> 1289 </span><span class="decl"><span class="istickedoff">inferSingleStmt ln pos ctx s = do</span>
<span class="lineno"> 1290 </span><span class="spaces">  </span><span class="istickedoff">-- currently we are always at the syntactic top level here because</span>
<span class="lineno"> 1291 </span><span class="spaces">  </span><span class="istickedoff">-- that's how the interpreter works</span>
<span class="lineno"> 1292 </span><span class="spaces">  </span><span class="istickedoff">let atSyntacticTopLevel = True</span>
<span class="lineno"> 1293 </span><span class="spaces">  </span><span class="istickedoff">(_wrapper, s', _ty') &lt;- inferStmt ln atSyntacticTopLevel pos ctx s</span>
<span class="lineno"> 1294 </span><span class="spaces">  </span><span class="istickedoff">s'' &lt;- applyCurrentSubst s'</span>
<span class="lineno"> 1295 </span><span class="spaces">  </span><span class="istickedoff">return s''</span></span>
<span class="lineno"> 1296 </span>
<span class="lineno"> 1297 </span>--
<span class="lineno"> 1298 </span>-- decls
<span class="lineno"> 1299 </span>--
<span class="lineno"> 1300 </span>
<span class="lineno"> 1301 </span>-- Create a type schema for a declaration out of its free vars.
<span class="lineno"> 1302 </span>--
<span class="lineno"> 1303 </span>-- (This creates names for any remaining unification vars, so
<span class="lineno"> 1304 </span>-- potentially updates the expression.)
<span class="lineno"> 1305 </span>generalize :: [OutExpr] -&gt; [Type] -&gt; TI [(OutExpr,Schema)]
<span class="lineno"> 1306 </span><span class="decl"><span class="istickedoff">generalize es0 ts0 =</span>
<span class="lineno"> 1307 </span><span class="spaces">  </span><span class="istickedoff">do es &lt;- applyCurrentSubst es0</span>
<span class="lineno"> 1308 </span><span class="spaces">     </span><span class="istickedoff">ts &lt;- applyCurrentSubst ts0</span>
<span class="lineno"> 1309 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1310 </span><span class="spaces">     </span><span class="istickedoff">envUnify &lt;- unifyVarsInEnv</span>
<span class="lineno"> 1311 </span><span class="spaces">     </span><span class="istickedoff">envNamed &lt;- namedVarsInEnv</span>
<span class="lineno"> 1312 </span><span class="spaces">     </span><span class="istickedoff">let is = M.toList (unifyVars ts M.\\ envUnify)</span>
<span class="lineno"> 1313 </span><span class="spaces">     </span><span class="istickedoff">let bs = M.toList (namedVars ts M.\\ envNamed)</span>
<span class="lineno"> 1314 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1315 </span><span class="spaces">     </span><span class="istickedoff">-- if the position is &quot;fresh&quot; turn it into &quot;inferred from term&quot;</span>
<span class="lineno"> 1316 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">adjustPos pos = case pos of</span></span>
<span class="lineno"> 1317 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">PosInferred InfFresh pos' -&gt; PosInferred InfTerm pos'</span></span>
<span class="lineno"> 1318 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; pos</span></span>
<span class="lineno"> 1319 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1320 </span><span class="spaces">     </span><span class="istickedoff">-- generate names for the unification vars</span>
<span class="lineno"> 1321 </span><span class="spaces">     </span><span class="istickedoff">let is' = [ (i, <span class="nottickedoff">adjustPos pos</span>, &quot;a.&quot; ++ show i) | (i, pos) &lt;- is ]</span>
<span class="lineno"> 1322 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1323 </span><span class="spaces">     </span><span class="istickedoff">-- build the substitution</span>
<span class="lineno"> 1324 </span><span class="spaces">     </span><span class="istickedoff">let s = substFromList [ (i, TyVar <span class="nottickedoff">pos</span> n) | (i, pos, n) &lt;- is' ]</span>
<span class="lineno"> 1325 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1326 </span><span class="spaces">     </span><span class="istickedoff">-- get the names for the Forall</span>
<span class="lineno"> 1327 </span><span class="spaces">     </span><span class="istickedoff">let inames = [ (<span class="nottickedoff">pos</span>, n) | (_i, pos, n) &lt;- is' ]</span>
<span class="lineno"> 1328 </span><span class="spaces">     </span><span class="istickedoff">let bnames = [ <span class="nottickedoff">(pos, x)</span> | (x, pos) &lt;- bs ]</span>
<span class="lineno"> 1329 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1330 </span><span class="spaces">     </span><span class="istickedoff">let mk e t = (appSubst <span class="nottickedoff">s</span> e, Forall (inames ++ bnames) (appSubst s t))</span>
<span class="lineno"> 1331 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1332 </span><span class="spaces">     </span><span class="istickedoff">return $ zipWith mk es ts</span></span>
<span class="lineno"> 1333 </span>
<span class="lineno"> 1334 </span>-- Type inference for a declaration.
<span class="lineno"> 1335 </span>--
<span class="lineno"> 1336 </span>-- Note that the type schema slot in Decl is always Nothing as we get
<span class="lineno"> 1337 </span>-- it from the parser; if there's an explicit type annotation on the
<span class="lineno"> 1338 </span>-- declaration that shows up as a type signature in the expression.
<span class="lineno"> 1339 </span>inferDecl :: Decl -&gt; TI Decl
<span class="lineno"> 1340 </span><span class="decl"><span class="istickedoff">inferDecl (Decl pos pat _ e) = do</span>
<span class="lineno"> 1341 </span><span class="spaces">  </span><span class="istickedoff">let n = patternLName pat</span>
<span class="lineno"> 1342 </span><span class="spaces">  </span><span class="istickedoff">(e',t) &lt;- inferExpr (n, e)</span>
<span class="lineno"> 1343 </span><span class="spaces">  </span><span class="istickedoff">checkPattern <span class="nottickedoff">n</span> t pat</span>
<span class="lineno"> 1344 </span><span class="spaces">  </span><span class="istickedoff">~[(e1,s)] &lt;- generalize [e'] [t]</span>
<span class="lineno"> 1345 </span><span class="spaces">  </span><span class="istickedoff">return (Decl <span class="nottickedoff">pos</span> pat (Just s) e1)</span></span>
<span class="lineno"> 1346 </span>
<span class="lineno"> 1347 </span>-- Type inference for a system of mutually recursive declarations.
<span class="lineno"> 1348 </span>--
<span class="lineno"> 1349 </span>-- Note that the type schema slot in the Decls is always Nothing as we
<span class="lineno"> 1350 </span>-- get them from the parser; if there's an explicit type annotation on
<span class="lineno"> 1351 </span>-- some or all of the declarations those shows up as type signatures
<span class="lineno"> 1352 </span>-- in the expressions.
<span class="lineno"> 1353 </span>inferRecDecls :: [Decl] -&gt; TI [Decl]
<span class="lineno"> 1354 </span><span class="decl"><span class="nottickedoff">inferRecDecls ds =</span>
<span class="lineno"> 1355 </span><span class="spaces">  </span><span class="nottickedoff">do let pats = map dPat ds</span>
<span class="lineno"> 1356 </span><span class="spaces">         </span><span class="nottickedoff">pat =</span>
<span class="lineno"> 1357 </span><span class="spaces">           </span><span class="nottickedoff">case pats of</span>
<span class="lineno"> 1358 </span><span class="spaces">             </span><span class="nottickedoff">p:_ -&gt; p</span>
<span class="lineno"> 1359 </span><span class="spaces">             </span><span class="nottickedoff">[] -&gt; panic</span>
<span class="lineno"> 1360 </span><span class="spaces">                     </span><span class="nottickedoff">&quot;inferRecDecls&quot;</span>
<span class="lineno"> 1361 </span><span class="spaces">                     </span><span class="nottickedoff">[&quot;Empty list of declarations in recursive group&quot;]</span>
<span class="lineno"> 1362 </span><span class="spaces">     </span><span class="nottickedoff">(_ts, pats') &lt;- unzip &lt;$&gt; mapM inferPattern pats</span>
<span class="lineno"> 1363 </span><span class="spaces">     </span><span class="nottickedoff">(es, ts) &lt;- fmap unzip</span>
<span class="lineno"> 1364 </span><span class="spaces">                 </span><span class="nottickedoff">$ flip (foldr withPattern) pats'</span>
<span class="lineno"> 1365 </span><span class="spaces">                 </span><span class="nottickedoff">$ sequence [ inferExpr (patternLName p, e)</span>
<span class="lineno"> 1366 </span><span class="spaces">                            </span><span class="nottickedoff">| Decl _pos p _ e &lt;- ds</span>
<span class="lineno"> 1367 </span><span class="spaces">                            </span><span class="nottickedoff">]</span>
<span class="lineno"> 1368 </span><span class="spaces">     </span><span class="nottickedoff">sequence_ $ zipWith (checkPattern (patternLName pat)) ts pats'</span>
<span class="lineno"> 1369 </span><span class="spaces">     </span><span class="nottickedoff">ess &lt;- generalize es ts</span>
<span class="lineno"> 1370 </span><span class="spaces">     </span><span class="nottickedoff">return [ Decl pos p (Just s) e1</span>
<span class="lineno"> 1371 </span><span class="spaces">            </span><span class="nottickedoff">| (pos, p, (e1, s)) &lt;- zip3 (map getPos ds) pats ess</span>
<span class="lineno"> 1372 </span><span class="spaces">            </span><span class="nottickedoff">]</span></span>
<span class="lineno"> 1373 </span>
<span class="lineno"> 1374 </span>-- Type inference for a decl group.
<span class="lineno"> 1375 </span>inferDeclGroup :: DeclGroup -&gt; TI DeclGroup
<span class="lineno"> 1376 </span><span class="decl"><span class="istickedoff">inferDeclGroup (NonRecursive d) = do</span>
<span class="lineno"> 1377 </span><span class="spaces">  </span><span class="istickedoff">d' &lt;- inferDecl d</span>
<span class="lineno"> 1378 </span><span class="spaces">  </span><span class="istickedoff">return (NonRecursive d')</span>
<span class="lineno"> 1379 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1380 </span><span class="spaces"></span><span class="istickedoff">inferDeclGroup (Recursive ds) = <span class="nottickedoff">do</span></span>
<span class="lineno"> 1381 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">ds' &lt;- inferRecDecls ds</span></span>
<span class="lineno"> 1382 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">return (Recursive ds')</span></span></span>
<span class="lineno"> 1383 </span>
<span class="lineno"> 1384 </span>--
<span class="lineno"> 1385 </span>-- types
<span class="lineno"> 1386 </span>--
<span class="lineno"> 1387 </span>
<span class="lineno"> 1388 </span>-- Look up a type constructor (in our fixed environment of hardcoded
<span class="lineno"> 1389 </span>-- types) and return its params as a list of kinds.
<span class="lineno"> 1390 </span>lookupTyCon :: TyCon -&gt; [Kind]
<span class="lineno"> 1391 </span><span class="decl"><span class="istickedoff">lookupTyCon tycon = case tycon of</span>
<span class="lineno"> 1392 </span><span class="spaces">  </span><span class="istickedoff">TupleCon n -&gt; genericTake n <span class="nottickedoff">(repeat kindStar)</span></span>
<span class="lineno"> 1393 </span><span class="spaces">  </span><span class="istickedoff">ArrayCon -&gt; <span class="nottickedoff">[kindStar]</span></span>
<span class="lineno"> 1394 </span><span class="spaces">  </span><span class="istickedoff">FunCon -&gt; <span class="nottickedoff">[kindStar, kindStar]</span></span>
<span class="lineno"> 1395 </span><span class="spaces">  </span><span class="istickedoff">StringCon -&gt; []</span>
<span class="lineno"> 1396 </span><span class="spaces">  </span><span class="istickedoff">TermCon -&gt; []</span>
<span class="lineno"> 1397 </span><span class="spaces">  </span><span class="istickedoff">TypeCon -&gt; <span class="nottickedoff">[]</span></span>
<span class="lineno"> 1398 </span><span class="spaces">  </span><span class="istickedoff">BoolCon -&gt; <span class="nottickedoff">[]</span></span>
<span class="lineno"> 1399 </span><span class="spaces">  </span><span class="istickedoff">IntCon -&gt; []</span>
<span class="lineno"> 1400 </span><span class="spaces">  </span><span class="istickedoff">BlockCon -&gt; [kindStar, kindStar]</span>
<span class="lineno"> 1401 </span><span class="spaces">  </span><span class="istickedoff">AIGCon -&gt; <span class="nottickedoff">[]</span></span>
<span class="lineno"> 1402 </span><span class="spaces">  </span><span class="istickedoff">CFGCon -&gt; <span class="nottickedoff">[]</span></span>
<span class="lineno"> 1403 </span><span class="spaces">  </span><span class="istickedoff">JVMSpecCon -&gt; <span class="nottickedoff">[]</span></span>
<span class="lineno"> 1404 </span><span class="spaces">  </span><span class="istickedoff">LLVMSpecCon -&gt; <span class="nottickedoff">[]</span></span>
<span class="lineno"> 1405 </span><span class="spaces">  </span><span class="istickedoff">MIRSpecCon -&gt; <span class="nottickedoff">[]</span></span>
<span class="lineno"> 1406 </span><span class="spaces">  </span><span class="istickedoff">ContextCon _ctx -&gt;</span>
<span class="lineno"> 1407 </span><span class="spaces">    </span><span class="istickedoff">-- XXX: while BlockCon exists, ContextCon has kind * and you</span>
<span class="lineno"> 1408 </span><span class="spaces">    </span><span class="istickedoff">-- have to use BlockCon to paste a result type to a ContextCon.</span>
<span class="lineno"> 1409 </span><span class="spaces">    </span><span class="istickedoff">-- (BlockCon should be removed. Then ContextCon has kind * -&gt; *</span>
<span class="lineno"> 1410 </span><span class="spaces">    </span><span class="istickedoff">-- like you'd expect.)</span>
<span class="lineno"> 1411 </span><span class="spaces">    </span><span class="istickedoff">[]</span></span>
<span class="lineno"> 1412 </span>
<span class="lineno"> 1413 </span>-- Check a type for validity and also for having the
<span class="lineno"> 1414 </span>-- correct kinding.
<span class="lineno"> 1415 </span>checkType :: Kind -&gt; Type -&gt; TI Type
<span class="lineno"> 1416 </span><span class="decl"><span class="istickedoff">checkType kind ty = case ty of</span>
<span class="lineno"> 1417 </span><span class="spaces">  </span><span class="istickedoff">TyCon pos tycon args -&gt; do</span>
<span class="lineno"> 1418 </span><span class="spaces">      </span><span class="istickedoff">-- First, look up the constructor.</span>
<span class="lineno"> 1419 </span><span class="spaces">      </span><span class="istickedoff">let params = lookupTyCon tycon</span>
<span class="lineno"> 1420 </span><span class="spaces">      </span><span class="istickedoff">let nparams = length params</span>
<span class="lineno"> 1421 </span><span class="spaces">          </span><span class="istickedoff">nargs = length args</span>
<span class="lineno"> 1422 </span><span class="spaces">          </span><span class="istickedoff">argsleft = kindNumArgs kind</span>
<span class="lineno"> 1423 </span><span class="spaces">      </span><span class="istickedoff">if <span class="tickonlyfalse">nargs &gt; nparams</span> then <span class="nottickedoff">do</span></span>
<span class="lineno"> 1424 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">-- XXX special case for BlockCon (remove along with BlockCon)</span></span>
<span class="lineno"> 1425 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">case (tycon, args) of</span></span>
<span class="lineno"> 1426 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">(BlockCon, arg : _) -&gt;</span></span>
<span class="lineno"> 1427 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">recordError pos (&quot;Too many type arguments for type &quot; ++</span></span>
<span class="lineno"> 1428 </span><span class="spaces">                                   </span><span class="istickedoff"><span class="nottickedoff">&quot;constructor &quot; ++ pShow arg ++</span></span>
<span class="lineno"> 1429 </span><span class="spaces">                                   </span><span class="istickedoff"><span class="nottickedoff">&quot;; found &quot; ++ show (nargs - 1) ++</span></span>
<span class="lineno"> 1430 </span><span class="spaces">                                   </span><span class="istickedoff"><span class="nottickedoff">&quot; but expected only &quot; ++ show (nparams - 1))</span></span>
<span class="lineno"> 1431 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">(_, _) -&gt;</span></span>
<span class="lineno"> 1432 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">recordError pos (&quot;Too many type arguments for type &quot; ++</span></span>
<span class="lineno"> 1433 </span><span class="spaces">                                   </span><span class="istickedoff"><span class="nottickedoff">&quot;constructor &quot; ++ pShow tycon ++</span></span>
<span class="lineno"> 1434 </span><span class="spaces">                                   </span><span class="istickedoff"><span class="nottickedoff">&quot;; found &quot; ++ show nargs ++</span></span>
<span class="lineno"> 1435 </span><span class="spaces">                                   </span><span class="istickedoff"><span class="nottickedoff">&quot; but expected only &quot; ++ show nparams)</span></span>
<span class="lineno"> 1436 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">getErrorTyVar pos</span></span>
<span class="lineno"> 1437 </span><span class="spaces">      </span><span class="istickedoff">else if <span class="tickonlyfalse">nargs + argsleft /= nparams</span> then <span class="nottickedoff">do</span></span>
<span class="lineno"> 1438 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">recordError pos (&quot;Kind mismatch: expected &quot; ++ pShow kind ++</span></span>
<span class="lineno"> 1439 </span><span class="spaces">                           </span><span class="istickedoff"><span class="nottickedoff">&quot; but found &quot; ++ (pShow $ Kind (nparams - nargs)))</span></span>
<span class="lineno"> 1440 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">getErrorTyVar pos</span></span>
<span class="lineno"> 1441 </span><span class="spaces">      </span><span class="istickedoff">else do</span>
<span class="lineno"> 1442 </span><span class="spaces">          </span><span class="istickedoff">-- note that this will ignore the extra params</span>
<span class="lineno"> 1443 </span><span class="spaces">          </span><span class="istickedoff">args' &lt;- zipWithM checkType params args</span>
<span class="lineno"> 1444 </span><span class="spaces">          </span><span class="istickedoff">return $ TyCon pos tycon args'</span>
<span class="lineno"> 1445 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1446 </span><span class="spaces">  </span><span class="istickedoff">TyRecord pos fields -&gt; do</span>
<span class="lineno"> 1447 </span><span class="spaces">      </span><span class="istickedoff">if <span class="tickonlyfalse">kind /= kindStar</span> then <span class="nottickedoff">do</span></span>
<span class="lineno"> 1448 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">recordError pos (&quot;Kind mismatch: expected &quot; ++ pShow kind ++</span></span>
<span class="lineno"> 1449 </span><span class="spaces">                           </span><span class="istickedoff"><span class="nottickedoff">&quot; but found &quot; ++ pShow kindStar)</span></span>
<span class="lineno"> 1450 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">getErrorTyVar pos</span></span>
<span class="lineno"> 1451 </span><span class="spaces">      </span><span class="istickedoff">else do</span>
<span class="lineno"> 1452 </span><span class="spaces">          </span><span class="istickedoff">-- Someone upstream had better have checked for duplicate</span>
<span class="lineno"> 1453 </span><span class="spaces">          </span><span class="istickedoff">-- field names because we can't once the fields are loaded</span>
<span class="lineno"> 1454 </span><span class="spaces">          </span><span class="istickedoff">-- into a map. (XXX: someone hasn't)</span>
<span class="lineno"> 1455 </span><span class="spaces">          </span><span class="istickedoff">fields' &lt;- traverse (checkType kindStar) fields</span>
<span class="lineno"> 1456 </span><span class="spaces">          </span><span class="istickedoff">return $ <span class="nottickedoff">TyRecord pos fields'</span></span>
<span class="lineno"> 1457 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1458 </span><span class="spaces">  </span><span class="istickedoff">TyVar pos x -&gt; do</span>
<span class="lineno"> 1459 </span><span class="spaces">      </span><span class="istickedoff">tyenv &lt;- TI $ asks tyEnv</span>
<span class="lineno"> 1460 </span><span class="spaces">      </span><span class="istickedoff">case M.lookup x tyenv of</span>
<span class="lineno"> 1461 </span><span class="spaces">          </span><span class="istickedoff">Nothing -&gt; do</span>
<span class="lineno"> 1462 </span><span class="spaces">              </span><span class="istickedoff">recordError pos (&quot;Unbound type variable &quot; ++ x)</span>
<span class="lineno"> 1463 </span><span class="spaces">              </span><span class="istickedoff">getErrorTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno"> 1464 </span><span class="spaces">          </span><span class="istickedoff">Just _ty' -&gt;</span>
<span class="lineno"> 1465 </span><span class="spaces">              </span><span class="istickedoff">-- Assume ty' was checked when it was entered.</span>
<span class="lineno"> 1466 </span><span class="spaces">              </span><span class="istickedoff">-- (If we entered it that's true, if it was in the</span>
<span class="lineno"> 1467 </span><span class="spaces">              </span><span class="istickedoff">-- initial environment we were given that depends on the</span>
<span class="lineno"> 1468 </span><span class="spaces">              </span><span class="istickedoff">-- interpreter not doing unfortunate things. This isn't</span>
<span class="lineno"> 1469 </span><span class="spaces">              </span><span class="istickedoff">-- currently seeming like a very good bet.)</span>
<span class="lineno"> 1470 </span><span class="spaces">              </span><span class="istickedoff">--</span>
<span class="lineno"> 1471 </span><span class="spaces">              </span><span class="istickedoff">-- For now at least we require typedefs to be kind *</span>
<span class="lineno"> 1472 </span><span class="spaces">              </span><span class="istickedoff">-- (they can't have parameters and the expansions are thus</span>
<span class="lineno"> 1473 </span><span class="spaces">              </span><span class="istickedoff">-- restricted) so just fail if we use one in a context</span>
<span class="lineno"> 1474 </span><span class="spaces">              </span><span class="istickedoff">-- expecting something else.</span>
<span class="lineno"> 1475 </span><span class="spaces">              </span><span class="istickedoff">--</span>
<span class="lineno"> 1476 </span><span class="spaces">              </span><span class="istickedoff">-- The same holds for abstract types, so we don't need</span>
<span class="lineno"> 1477 </span><span class="spaces">              </span><span class="istickedoff">-- separate cases.</span>
<span class="lineno"> 1478 </span><span class="spaces">              </span><span class="istickedoff">if <span class="tickonlyfalse">kind /= kindStar</span> then <span class="nottickedoff">do</span></span>
<span class="lineno"> 1479 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">recordError pos (&quot;Kind mismatch: expected &quot; ++ pShow kind ++</span></span>
<span class="lineno"> 1480 </span><span class="spaces">                                   </span><span class="istickedoff"><span class="nottickedoff">&quot; but found &quot; ++ pShow kindStar)</span></span>
<span class="lineno"> 1481 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">getErrorTyVar pos</span></span>
<span class="lineno"> 1482 </span><span class="spaces">              </span><span class="istickedoff">else</span>
<span class="lineno"> 1483 </span><span class="spaces">                  </span><span class="istickedoff">-- We do _not_ want to expand typedefs when checking,</span>
<span class="lineno"> 1484 </span><span class="spaces">                  </span><span class="istickedoff">-- so return the original TyVar.</span>
<span class="lineno"> 1485 </span><span class="spaces">                  </span><span class="istickedoff">return ty</span>
<span class="lineno"> 1486 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1487 </span><span class="spaces">  </span><span class="istickedoff">TyUnifyVar _pos _ix -&gt;</span>
<span class="lineno"> 1488 </span><span class="spaces">      </span><span class="istickedoff">-- for now at least we don't track the kinds of unification vars</span>
<span class="lineno"> 1489 </span><span class="spaces">      </span><span class="istickedoff">-- (types of mismatch kinds can't be the same types, so they</span>
<span class="lineno"> 1490 </span><span class="spaces">      </span><span class="istickedoff">-- won't ever unify, so the possible mischief is limited) and all</span>
<span class="lineno"> 1491 </span><span class="spaces">      </span><span class="istickedoff">-- possible unification var numbers are well formed, so we don't</span>
<span class="lineno"> 1492 </span><span class="spaces">      </span><span class="istickedoff">-- need to do anything.</span>
<span class="lineno"> 1493 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">return ty</span></span></span>
<span class="lineno"> 1494 </span>
<span class="lineno"> 1495 </span>
<span class="lineno"> 1496 </span>-- }}}
<span class="lineno"> 1497 </span>
<span class="lineno"> 1498 </span>
<span class="lineno"> 1499 </span>------------------------------------------------------------
<span class="lineno"> 1500 </span>-- External interface {{{
<span class="lineno"> 1501 </span>
<span class="lineno"> 1502 </span>-- Some short names for use in the signatures below
<span class="lineno"> 1503 </span>type MsgList = [(Pos, String)]
<span class="lineno"> 1504 </span>type Result a = (Either MsgList a, MsgList)
<span class="lineno"> 1505 </span>
<span class="lineno"> 1506 </span>-- Run the TI monad.
<span class="lineno"> 1507 </span>--
<span class="lineno"> 1508 </span>-- Note that the error and warning lists accumulate in reverse order
<span class="lineno"> 1509 </span>-- (later messages are consed onto the head of the list) so we
<span class="lineno"> 1510 </span>-- reverse on the way out.
<span class="lineno"> 1511 </span>runTIWithEnv :: VarEnv -&gt; TyEnv -&gt; TI a -&gt; (a, Subst, MsgList, MsgList)
<span class="lineno"> 1512 </span><span class="decl"><span class="istickedoff">runTIWithEnv env tenv m = (a, <span class="nottickedoff">subst rw</span>, reverse $ errors rw, reverse $ warnings rw)</span>
<span class="lineno"> 1513 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1514 </span><span class="spaces">  </span><span class="istickedoff">m' = runReaderT (unTI m) (RO env tenv)</span>
<span class="lineno"> 1515 </span><span class="spaces">  </span><span class="istickedoff">(a,rw) = runState m' emptyRW</span></span>
<span class="lineno"> 1516 </span>
<span class="lineno"> 1517 </span>-- Run the TI monad and interpret/collect the results
<span class="lineno"> 1518 </span>-- (failure if any errors were produced)
<span class="lineno"> 1519 </span>evalTIWithEnv :: VarEnv -&gt; TyEnv -&gt; TI a -&gt; Result a
<span class="lineno"> 1520 </span><span class="decl"><span class="istickedoff">evalTIWithEnv env tenv m =</span>
<span class="lineno"> 1521 </span><span class="spaces">  </span><span class="istickedoff">case runTIWithEnv env tenv m of</span>
<span class="lineno"> 1522 </span><span class="spaces">    </span><span class="istickedoff">(res, _, [], warns) -&gt; (Right res, warns)</span>
<span class="lineno"> 1523 </span><span class="spaces">    </span><span class="istickedoff">(_, _, errs, warns) -&gt; (Left errs, warns)</span></span>
<span class="lineno"> 1524 </span>
<span class="lineno"> 1525 </span>-- | Check a single statement. (This is an external interface.)
<span class="lineno"> 1526 </span>--
<span class="lineno"> 1527 </span>-- The first two arguments are the starting variable and typedef
<span class="lineno"> 1528 </span>-- environments to use.
<span class="lineno"> 1529 </span>--
<span class="lineno"> 1530 </span>-- The third is a current position, and the fourth is the
<span class="lineno"> 1531 </span>-- context/monad type associated with the execution.
<span class="lineno"> 1532 </span>checkStmt :: VarEnv -&gt; TyEnv -&gt; Context -&gt; Stmt -&gt; Result Stmt
<span class="lineno"> 1533 </span><span class="decl"><span class="istickedoff">checkStmt env tenv ctx stmt =</span>
<span class="lineno"> 1534 </span><span class="spaces">  </span><span class="istickedoff">-- XXX: we shouldn't need this position here.</span>
<span class="lineno"> 1535 </span><span class="spaces">  </span><span class="istickedoff">-- The position is used for the following things:</span>
<span class="lineno"> 1536 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno"> 1537 </span><span class="spaces">  </span><span class="istickedoff">--    - to create ln, which is used as part of the error printing</span>
<span class="lineno"> 1538 </span><span class="spaces">  </span><span class="istickedoff">--      scheme, but is no longer particularly useful after recent</span>
<span class="lineno"> 1539 </span><span class="spaces">  </span><span class="istickedoff">--      improvements (especially here where it contains no real</span>
<span class="lineno"> 1540 </span><span class="spaces">  </span><span class="istickedoff">--      information) and should be removed;</span>
<span class="lineno"> 1541 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno"> 1542 </span><span class="spaces">  </span><span class="istickedoff">--    - to be the position associated with the monad context, which</span>
<span class="lineno"> 1543 </span><span class="spaces">  </span><span class="istickedoff">--      in a tidy world should just be PosRepl (as in, the only</span>
<span class="lineno"> 1544 </span><span class="spaces">  </span><span class="istickedoff">--      time we should be typechecking a single statement is when</span>
<span class="lineno"> 1545 </span><span class="spaces">  </span><span class="istickedoff">--      it was just typed interactively, and which monad we're in</span>
<span class="lineno"> 1546 </span><span class="spaces">  </span><span class="istickedoff">--      is a direct property of that context) but this is not</span>
<span class="lineno"> 1547 </span><span class="spaces">  </span><span class="istickedoff">--      currently true and will require a good bit of interpreter</span>
<span class="lineno"> 1548 </span><span class="spaces">  </span><span class="istickedoff">--      cleanup to make it true;</span>
<span class="lineno"> 1549 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno"> 1550 </span><span class="spaces">  </span><span class="istickedoff">--    - to pass to inferStmt, which also uses it as part of the</span>
<span class="lineno"> 1551 </span><span class="spaces">  </span><span class="istickedoff">--      position associated with the monad context. (This part is a</span>
<span class="lineno"> 1552 </span><span class="spaces">  </span><span class="istickedoff">--      result of BlockCon existing and can go away when BlockCon is</span>
<span class="lineno"> 1553 </span><span class="spaces">  </span><span class="istickedoff">--      removed.)</span>
<span class="lineno"> 1554 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno"> 1555 </span><span class="spaces">  </span><span class="istickedoff">-- XXX: using the position of the statement as the position</span>
<span class="lineno"> 1556 </span><span class="spaces">  </span><span class="istickedoff">-- associated with the monad context is not correct (or at least,</span>
<span class="lineno"> 1557 </span><span class="spaces">  </span><span class="istickedoff">-- will be confusing) and we should figure something else out if the</span>
<span class="lineno"> 1558 </span><span class="spaces">  </span><span class="istickedoff">-- interpreter cleanup doesn't come through soon. Note that</span>
<span class="lineno"> 1559 </span><span class="spaces">  </span><span class="istickedoff">-- currently we come through here only for syntactically top-level</span>
<span class="lineno"> 1560 </span><span class="spaces">  </span><span class="istickedoff">-- statements in the interpreter; these are TopLevel except when in</span>
<span class="lineno"> 1561 </span><span class="spaces">  </span><span class="istickedoff">-- the ProofScript repl. So perhaps we should use PosRepl when in</span>
<span class="lineno"> 1562 </span><span class="spaces">  </span><span class="istickedoff">-- ProofScript, and then either PosRepl or PosBuiltin for TopLevel?</span>
<span class="lineno"> 1563 </span><span class="spaces">  </span><span class="istickedoff">-- But we don't have a good way of knowing here whether we're</span>
<span class="lineno"> 1564 </span><span class="spaces">  </span><span class="istickedoff">-- actually in the repl.</span>
<span class="lineno"> 1565 </span><span class="spaces">  </span><span class="istickedoff">let pos = getPos stmt</span>
<span class="lineno"> 1566 </span><span class="spaces">      </span><span class="istickedoff">ln = case ctx of</span>
<span class="lineno"> 1567 </span><span class="spaces">          </span><span class="istickedoff">TopLevel -&gt; Located <span class="nottickedoff">&quot;&lt;toplevel&gt;&quot;</span> &quot;&lt;toplevel&gt;&quot; pos</span>
<span class="lineno"> 1568 </span><span class="spaces">          </span><span class="istickedoff">ProofScript -&gt; <span class="nottickedoff">Located &quot;&lt;proofscript&gt;&quot; &quot;&lt;proofscript&gt;&quot; pos</span></span>
<span class="lineno"> 1569 </span><span class="spaces">          </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">panic &quot;checkStmt&quot; [&quot;Invalid monad context &quot; ++ pShow ctx]</span></span>
<span class="lineno"> 1570 </span><span class="spaces">      </span><span class="istickedoff">ctxtype = TyCon pos (ContextCon ctx) []</span>
<span class="lineno"> 1571 </span><span class="spaces">  </span><span class="istickedoff">in</span>
<span class="lineno"> 1572 </span><span class="spaces">  </span><span class="istickedoff">evalTIWithEnv env tenv (inferSingleStmt ln pos ctxtype stmt)</span></span>
<span class="lineno"> 1573 </span>
<span class="lineno"> 1574 </span>-- | Check a single declaration. (This is an external interface.)
<span class="lineno"> 1575 </span>--
<span class="lineno"> 1576 </span>-- The first two arguments are the starting variable and typedef
<span class="lineno"> 1577 </span>-- environments to use.
<span class="lineno"> 1578 </span>checkDecl :: VarEnv -&gt; TyEnv -&gt; Decl -&gt; Result Decl
<span class="lineno"> 1579 </span><span class="decl"><span class="nottickedoff">checkDecl env tenv decl =</span>
<span class="lineno"> 1580 </span><span class="spaces">  </span><span class="nottickedoff">evalTIWithEnv env tenv (inferDecl decl)</span></span>
<span class="lineno"> 1581 </span>
<span class="lineno"> 1582 </span>-- }}}
<span class="lineno"> 1583 </span>
<span class="lineno"> 1584 </span>
<span class="lineno"> 1585 </span>{-
<span class="lineno"> 1586 </span>Note [-Wincomplete-uni-patterns and irrefutable patterns]
<span class="lineno"> 1587 </span>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<span class="lineno"> 1588 </span>Various parts of SAW use irrefutable patterns in functions that assume that
<span class="lineno"> 1589 </span>their arguments have particular shapes. For example, inferDecl in this module
<span class="lineno"> 1590 </span>matches on ~[(e1,s)] with an irrefutable pattern because it assumes the
<span class="lineno"> 1591 </span>invariant that the list will have exactly one element. This lets inferDecl be
<span class="lineno"> 1592 </span>slightly lazier when evaluated.
<span class="lineno"> 1593 </span>
<span class="lineno"> 1594 </span>Unfortunately, this use of irrefutable patterns is at odds with the
<span class="lineno"> 1595 </span>-Wincomplete-uni-patterns warning. At present, -Wincomplete-uni-patterns will
<span class="lineno"> 1596 </span>produce a warning for any irrefutable pattern that does not cover all possible
<span class="lineno"> 1597 </span>data constructors. While we could rewrite functions like `inferDecl` to
<span class="lineno"> 1598 </span>explicitly provide a fall-through case, that would change its strictness
<span class="lineno"> 1599 </span>properties. As a result, we simply disable -Wincomplete-uni-patterns warnings
<span class="lineno"> 1600 </span>in each part of SAW that uses irrefutable patterns.
<span class="lineno"> 1601 </span>
<span class="lineno"> 1602 </span>Arguably, -Wincomplete-uni-patterns shouldn't be producing warnings for
<span class="lineno"> 1603 </span>irrefutable patterns at all. GHC issue #14800
<span class="lineno"> 1604 </span>(https://gitlab.haskell.org/ghc/ghc/-/issues/14800) proposes this idea.
<span class="lineno"> 1605 </span>If that issue is fixed in the future, we may want to reconsider whether we want
<span class="lineno"> 1606 </span>to disable -Wincomplete-uni-patterns.
<span class="lineno"> 1607 </span>-}

</pre>
</body>
</html>
