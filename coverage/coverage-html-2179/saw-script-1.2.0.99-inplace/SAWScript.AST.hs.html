<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- |
<span class="lineno">    2 </span>Module      : SAWScript.AST
<span class="lineno">    3 </span>Description : Datatypes representing SAWScript statements, expressions, and types.
<span class="lineno">    4 </span>License     : BSD3
<span class="lineno">    5 </span>Maintainer  : huffman
<span class="lineno">    6 </span>Stability   : provisional
<span class="lineno">    7 </span>-}
<span class="lineno">    8 </span>{-# LANGUAGE CPP #-}
<span class="lineno">    9 </span>{-# LANGUAGE DeriveFunctor,DeriveFoldable,DeriveTraversable #-}
<span class="lineno">   10 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">   11 </span>{-# LANGUAGE TypeOperators #-}
<span class="lineno">   12 </span>{-# LANGUAGE FlexibleContexts #-}
<span class="lineno">   13 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">   14 </span>{-# LANGUAGE ViewPatterns #-}
<span class="lineno">   15 </span>{-# LANGUAGE NamedFieldPuns #-}
<span class="lineno">   16 </span>
<span class="lineno">   17 </span>module SAWScript.AST
<span class="lineno">   18 </span>       ( Name
<span class="lineno">   19 </span>       , LName
<span class="lineno">   20 </span>       , Located(..)
<span class="lineno">   21 </span>       , Import(..)
<span class="lineno">   22 </span>       , Expr(..)
<span class="lineno">   23 </span>       , Pattern(..)
<span class="lineno">   24 </span>       , Stmt(..)
<span class="lineno">   25 </span>       , DeclGroup(..)
<span class="lineno">   26 </span>       , Decl(..)
<span class="lineno">   27 </span>       , Context(..)
<span class="lineno">   28 </span>       , Type(..), TypeIndex
<span class="lineno">   29 </span>       , TyCon(..)
<span class="lineno">   30 </span>       , Schema(..)
<span class="lineno">   31 </span>       , NamedType(..)
<span class="lineno">   32 </span>       , toLName
<span class="lineno">   33 </span>       , tMono, tForall, tTuple, tRecord, tArray, tFun
<span class="lineno">   34 </span>       , tString, tTerm, tType, tBool, tInt, tAIG, tCFG
<span class="lineno">   35 </span>       , tJVMSpec, tLLVMSpec, tMIRSpec
<span class="lineno">   36 </span>       , tBlock, tContext, tVar
<span class="lineno">   37 </span>       , isContext
<span class="lineno">   38 </span>
<span class="lineno">   39 </span>       , PrettyPrint(..), pShow, commaSepAll, prettyWholeModule
<span class="lineno">   40 </span>       ) where
<span class="lineno">   41 </span>
<span class="lineno">   42 </span>import SAWScript.Token
<span class="lineno">   43 </span>import SAWScript.Position (Pos(..), Positioned(..), maxSpan)
<span class="lineno">   44 </span>
<span class="lineno">   45 </span>import Data.Map (Map)
<span class="lineno">   46 </span>import qualified Data.Map as Map
<span class="lineno">   47 </span>import Data.List (intercalate)
<span class="lineno">   48 </span>
<span class="lineno">   49 </span>#if !MIN_VERSION_base(4,8,0)
<span class="lineno">   50 </span>import Data.Foldable (Foldable)
<span class="lineno">   51 </span>import Data.Traversable (Traversable)
<span class="lineno">   52 </span>#endif
<span class="lineno">   53 </span>import qualified Prettyprinter as PP
<span class="lineno">   54 </span>import           Prettyprinter (Pretty)
<span class="lineno">   55 </span>
<span class="lineno">   56 </span>import qualified Cryptol.Parser.AST as P (ImportSpec(..), ModName)
<span class="lineno">   57 </span>import qualified Cryptol.Utils.Ident as P (identText, modNameChunks)
<span class="lineno">   58 </span>
<span class="lineno">   59 </span>-- Names {{{
<span class="lineno">   60 </span>
<span class="lineno">   61 </span>type Name = String
<span class="lineno">   62 </span>
<span class="lineno">   63 </span>-- }}}
<span class="lineno">   64 </span>
<span class="lineno">   65 </span>-- Location tracking {{{
<span class="lineno">   66 </span>
<span class="lineno">   67 </span>--
<span class="lineno">   68 </span>-- Type to wrap a thing with a position
<span class="lineno">   69 </span>--
<span class="lineno">   70 </span>-- This is declared with record syntax to provide accessors/projection
<span class="lineno">   71 </span>-- functions; it is intended to be used positionally.
<span class="lineno">   72 </span>--
<span class="lineno">   73 </span>data Located a = Located {
<span class="lineno">   74 </span>  <span class="istickedoff"><span class="decl"><span class="istickedoff">getVal</span></span></span> :: a,          -- the thing
<span class="lineno">   75 </span>  <span class="istickedoff"><span class="decl"><span class="istickedoff">getOrig</span></span></span> :: Name,      -- a name/string for it, where applicable
<span class="lineno">   76 </span>  <span class="istickedoff"><span class="decl"><span class="istickedoff">locatedPos</span></span></span> :: Pos     -- the position
<span class="lineno">   77 </span>} deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Functor</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Traversable</span></span></span></span></span></span></span></span>)
<span class="lineno">   78 </span>
<span class="lineno">   79 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show (Located a)</span></span></span></span> where
<span class="lineno">   80 </span>  <span class="decl"><span class="istickedoff">show (Located _ v p) = show v ++ &quot; (&quot; ++ show p ++ &quot;)&quot;</span></span>
<span class="lineno">   81 </span>
<span class="lineno">   82 </span>instance Positioned (Located a) where
<span class="lineno">   83 </span>  <span class="decl"><span class="istickedoff">getPos = locatedPos</span></span>
<span class="lineno">   84 </span>
<span class="lineno">   85 </span>instance <span class="decl"><span class="nottickedoff">Eq a =&gt; Eq (Located a)</span></span> where
<span class="lineno">   86 </span>  <span class="decl"><span class="nottickedoff">a == b = getVal a == getVal b</span></span>
<span class="lineno">   87 </span>
<span class="lineno">   88 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord a =&gt; Ord (Located a)</span></span></span></span></span></span></span></span></span></span></span></span> where
<span class="lineno">   89 </span>  <span class="decl"><span class="istickedoff">compare a b = compare (getVal a) (getVal b)</span></span>
<span class="lineno">   90 </span>
<span class="lineno">   91 </span>type LName = Located Name
<span class="lineno">   92 </span>
<span class="lineno">   93 </span>toLName :: Token Pos -&gt; LName
<span class="lineno">   94 </span><span class="decl"><span class="istickedoff">toLName p = Located (tokStr p) (tokStr p) (tokPos p)</span></span>
<span class="lineno">   95 </span>
<span class="lineno">   96 </span>-- }}}
<span class="lineno">   97 </span>
<span class="lineno">   98 </span>-- Expr Level {{{
<span class="lineno">   99 </span>
<span class="lineno">  100 </span>data Import = Import
<span class="lineno">  101 </span>  { <span class="istickedoff"><span class="decl"><span class="istickedoff">iModule</span></span></span>    :: Either FilePath P.ModName
<span class="lineno">  102 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">iAs</span></span></span>        :: Maybe P.ModName
<span class="lineno">  103 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">iSpec</span></span></span>      :: Maybe P.ImportSpec
<span class="lineno">  104 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">iPos</span></span></span>       :: Pos
<span class="lineno">  105 </span>  } deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>
<span class="lineno">  106 </span>
<span class="lineno">  107 </span>instance Positioned Import where
<span class="lineno">  108 </span>  <span class="decl"><span class="nottickedoff">getPos = iPos</span></span>
<span class="lineno">  109 </span>
<span class="lineno">  110 </span>data Expr
<span class="lineno">  111 </span>  -- Constants
<span class="lineno">  112 </span>  = Bool Pos Bool
<span class="lineno">  113 </span>  | String Pos String
<span class="lineno">  114 </span>  | Int Pos Integer
<span class="lineno">  115 </span>  | Code (Located String)
<span class="lineno">  116 </span>  | CType (Located String)
<span class="lineno">  117 </span>  -- Structures
<span class="lineno">  118 </span>  | Array  Pos [Expr]
<span class="lineno">  119 </span>  | Block  Pos [Stmt]
<span class="lineno">  120 </span>  | Tuple  Pos [Expr]
<span class="lineno">  121 </span>  | Record Pos (Map Name Expr)
<span class="lineno">  122 </span>  -- Accessors
<span class="lineno">  123 </span>  | Index   Pos Expr Expr
<span class="lineno">  124 </span>  | Lookup  Pos Expr Name
<span class="lineno">  125 </span>  | TLookup Pos Expr Integer
<span class="lineno">  126 </span>  -- LC
<span class="lineno">  127 </span>  | Var (Located Name)
<span class="lineno">  128 </span>  | Function Pos Pattern Expr
<span class="lineno">  129 </span>  | Application Pos Expr Expr
<span class="lineno">  130 </span>  -- Sugar
<span class="lineno">  131 </span>  | Let Pos DeclGroup Expr
<span class="lineno">  132 </span>  | TSig Pos Expr Type
<span class="lineno">  133 </span>  | IfThenElse Pos Expr Expr Expr
<span class="lineno">  134 </span>  deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>
<span class="lineno">  135 </span>
<span class="lineno">  136 </span>instance Positioned Expr where
<span class="lineno">  137 </span>  <span class="decl"><span class="istickedoff">getPos (Bool pos _) = <span class="nottickedoff">pos</span></span>
<span class="lineno">  138 </span><span class="spaces">  </span><span class="istickedoff">getPos (String pos _) = pos</span>
<span class="lineno">  139 </span><span class="spaces">  </span><span class="istickedoff">getPos (Int pos _) = pos</span>
<span class="lineno">  140 </span><span class="spaces">  </span><span class="istickedoff">getPos (Code c) = getPos c</span>
<span class="lineno">  141 </span><span class="spaces">  </span><span class="istickedoff">getPos (CType t) = getPos t</span>
<span class="lineno">  142 </span><span class="spaces">  </span><span class="istickedoff">getPos (Array pos _) = pos</span>
<span class="lineno">  143 </span><span class="spaces">  </span><span class="istickedoff">getPos (Block pos _) = pos</span>
<span class="lineno">  144 </span><span class="spaces">  </span><span class="istickedoff">getPos (Tuple pos _) = pos</span>
<span class="lineno">  145 </span><span class="spaces">  </span><span class="istickedoff">getPos (Record pos _) = <span class="nottickedoff">pos</span></span>
<span class="lineno">  146 </span><span class="spaces">  </span><span class="istickedoff">getPos (Index pos _ _) = <span class="nottickedoff">pos</span></span>
<span class="lineno">  147 </span><span class="spaces">  </span><span class="istickedoff">getPos (Lookup pos _ _) = <span class="nottickedoff">pos</span></span>
<span class="lineno">  148 </span><span class="spaces">  </span><span class="istickedoff">getPos (TLookup pos _ _) = <span class="nottickedoff">pos</span></span>
<span class="lineno">  149 </span><span class="spaces">  </span><span class="istickedoff">getPos (Var n) = getPos n</span>
<span class="lineno">  150 </span><span class="spaces">  </span><span class="istickedoff">getPos (Function pos _ _) = <span class="nottickedoff">pos</span></span>
<span class="lineno">  151 </span><span class="spaces">  </span><span class="istickedoff">getPos (Application pos _ _) = pos</span>
<span class="lineno">  152 </span><span class="spaces">  </span><span class="istickedoff">getPos (Let pos _ _) = <span class="nottickedoff">pos</span></span>
<span class="lineno">  153 </span><span class="spaces">  </span><span class="istickedoff">getPos (TSig pos _ _) = <span class="nottickedoff">pos</span></span>
<span class="lineno">  154 </span><span class="spaces">  </span><span class="istickedoff">getPos (IfThenElse pos _ _ _) = pos</span></span>
<span class="lineno">  155 </span>
<span class="lineno">  156 </span>data Pattern
<span class="lineno">  157 </span>  = PWild Pos (Maybe Type)
<span class="lineno">  158 </span>  | PVar Pos LName (Maybe Type)
<span class="lineno">  159 </span>  | PTuple Pos [Pattern]
<span class="lineno">  160 </span>  deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>
<span class="lineno">  161 </span>
<span class="lineno">  162 </span>instance Positioned Pattern where
<span class="lineno">  163 </span>  <span class="decl"><span class="istickedoff">getPos (PWild pos _) = <span class="nottickedoff">pos</span></span>
<span class="lineno">  164 </span><span class="spaces">  </span><span class="istickedoff">getPos (PVar pos _ _) = pos</span>
<span class="lineno">  165 </span><span class="spaces">  </span><span class="istickedoff">getPos (PTuple pos _) = pos</span></span>
<span class="lineno">  166 </span>
<span class="lineno">  167 </span>data Stmt
<span class="lineno">  168 </span>  = StmtBind     Pos Pattern Expr
<span class="lineno">  169 </span>  | StmtLet      Pos DeclGroup
<span class="lineno">  170 </span>  | StmtCode     Pos (Located String)
<span class="lineno">  171 </span>  | StmtImport   Pos Import
<span class="lineno">  172 </span>  | StmtTypedef  Pos (Located String) Type
<span class="lineno">  173 </span>  deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>
<span class="lineno">  174 </span>
<span class="lineno">  175 </span>instance Positioned Stmt where
<span class="lineno">  176 </span>  <span class="decl"><span class="istickedoff">getPos (StmtBind pos _ _)  = pos</span>
<span class="lineno">  177 </span><span class="spaces">  </span><span class="istickedoff">getPos (StmtLet pos _)       = <span class="nottickedoff">pos</span></span>
<span class="lineno">  178 </span><span class="spaces">  </span><span class="istickedoff">getPos (StmtCode pos _)      = <span class="nottickedoff">pos</span></span>
<span class="lineno">  179 </span><span class="spaces">  </span><span class="istickedoff">getPos (StmtImport pos _)    = <span class="nottickedoff">pos</span></span>
<span class="lineno">  180 </span><span class="spaces">  </span><span class="istickedoff">getPos (StmtTypedef pos _ _) = <span class="nottickedoff">pos</span></span></span>
<span class="lineno">  181 </span>
<span class="lineno">  182 </span>data DeclGroup
<span class="lineno">  183 </span>  = Recursive [Decl]
<span class="lineno">  184 </span>  | NonRecursive Decl
<span class="lineno">  185 </span>  deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>
<span class="lineno">  186 </span>
<span class="lineno">  187 </span>instance Positioned DeclGroup where
<span class="lineno">  188 </span>  <span class="decl"><span class="nottickedoff">getPos (Recursive ds) = maxSpan ds</span>
<span class="lineno">  189 </span><span class="spaces">  </span><span class="nottickedoff">getPos (NonRecursive d) = getPos d</span></span>
<span class="lineno">  190 </span>
<span class="lineno">  191 </span>data Decl
<span class="lineno">  192 </span>  = Decl { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">dPos</span></span></span> :: Pos, <span class="nottickedoff"><span class="decl"><span class="nottickedoff">dPat</span></span></span> :: Pattern, <span class="nottickedoff"><span class="decl"><span class="nottickedoff">dType</span></span></span> :: Maybe Schema, <span class="nottickedoff"><span class="decl"><span class="nottickedoff">dDef</span></span></span> :: Expr }
<span class="lineno">  193 </span>  deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>
<span class="lineno">  194 </span>
<span class="lineno">  195 </span>instance Positioned Decl where
<span class="lineno">  196 </span>  <span class="decl"><span class="nottickedoff">getPos = dPos</span></span>
<span class="lineno">  197 </span>
<span class="lineno">  198 </span>-- }}}
<span class="lineno">  199 </span>
<span class="lineno">  200 </span>-- Type Level {{{
<span class="lineno">  201 </span>
<span class="lineno">  202 </span>data Context
<span class="lineno">  203 </span>  = CryptolSetup
<span class="lineno">  204 </span>  | JavaSetup
<span class="lineno">  205 </span>  | LLVMSetup
<span class="lineno">  206 </span>  | MIRSetup
<span class="lineno">  207 </span>  | ProofScript
<span class="lineno">  208 </span>  | TopLevel
<span class="lineno">  209 </span>  | CrucibleSetup
<span class="lineno">  210 </span>  deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>,<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  211 </span>
<span class="lineno">  212 </span>-- The position information in a type should be thought of as its
<span class="lineno">  213 </span>-- provenance; for a type annotation in the input it'll be a concrete
<span class="lineno">  214 </span>-- file position. For types we infer, we want the position to record
<span class="lineno">  215 </span>-- not just where but also how the inference happened, so that when we
<span class="lineno">  216 </span>-- report this to the user they can see what's going on. (For example,
<span class="lineno">  217 </span>-- if we infer that a type must be a function because it's applied to
<span class="lineno">  218 </span>-- an argument, we record that it's inferred from context and the
<span class="lineno">  219 </span>-- position of the context is the position of the term that was
<span class="lineno">  220 </span>-- applied.) When the type flows around during type inference it
<span class="lineno">  221 </span>-- carries the position info with it.
<span class="lineno">  222 </span>--
<span class="lineno">  223 </span>-- Note that for a non-primitive type the various layers of the type
<span class="lineno">  224 </span>-- may have totally different provenance. (E.g. we might have List Int
<span class="lineno">  225 </span>-- where List was inferred from a term &quot;[x]&quot; somewhere but Int came
<span class="lineno">  226 </span>-- from an explicit annotation somewhere completely different.) So
<span class="lineno">  227 </span>-- printing this information usefully requires some thought. As of
<span class="lineno">  228 </span>-- this writing most of that thought hasn't been put in yet and we
<span class="lineno">  229 </span>-- just stuff the inference info into the Show instance output. See
<span class="lineno">  230 </span>-- notes in Position.hs.
<span class="lineno">  231 </span>data Type
<span class="lineno">  232 </span>  = TyCon Pos TyCon [Type]
<span class="lineno">  233 </span>  | TyRecord Pos (Map Name Type)
<span class="lineno">  234 </span>  | TyVar Pos Name
<span class="lineno">  235 </span>  | TyUnifyVar Pos TypeIndex       -- ^ For internal typechecker use only
<span class="lineno">  236 </span>  deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>
<span class="lineno">  237 </span>
<span class="lineno">  238 </span>instance Positioned Type where
<span class="lineno">  239 </span>  <span class="decl"><span class="istickedoff">getPos (TyCon pos _ _) = pos</span>
<span class="lineno">  240 </span><span class="spaces">  </span><span class="istickedoff">getPos (TyRecord pos _) = <span class="nottickedoff">pos</span></span>
<span class="lineno">  241 </span><span class="spaces">  </span><span class="istickedoff">getPos (TyVar pos _) = <span class="nottickedoff">pos</span></span>
<span class="lineno">  242 </span><span class="spaces">  </span><span class="istickedoff">getPos (TyUnifyVar pos _) = <span class="nottickedoff">pos</span></span></span>
<span class="lineno">  243 </span>
<span class="lineno">  244 </span>type TypeIndex = Integer
<span class="lineno">  245 </span>
<span class="lineno">  246 </span>data TyCon
<span class="lineno">  247 </span>  = TupleCon Integer
<span class="lineno">  248 </span>  | ArrayCon
<span class="lineno">  249 </span>  | FunCon
<span class="lineno">  250 </span>  | StringCon
<span class="lineno">  251 </span>  | TermCon
<span class="lineno">  252 </span>  | TypeCon
<span class="lineno">  253 </span>  | BoolCon
<span class="lineno">  254 </span>  | IntCon
<span class="lineno">  255 </span>  | BlockCon
<span class="lineno">  256 </span>  | AIGCon
<span class="lineno">  257 </span>  | CFGCon
<span class="lineno">  258 </span>  | JVMSpecCon
<span class="lineno">  259 </span>  | LLVMSpecCon
<span class="lineno">  260 </span>  | MIRSpecCon
<span class="lineno">  261 </span>  | ContextCon Context
<span class="lineno">  262 </span>  deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  263 </span>
<span class="lineno">  264 </span>data Schema = Forall [(Pos, Name)] Type
<span class="lineno">  265 </span>  deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>
<span class="lineno">  266 </span>
<span class="lineno">  267 </span>-- | The things a (named) TyVar can refer to by its name.
<span class="lineno">  268 </span>--
<span class="lineno">  269 </span>-- AbstractType is an opaque type whose only semantics are the
<span class="lineno">  270 </span>-- operations available for it, if any. The name identifies it; the
<span class="lineno">  271 </span>-- AbstractType constructor is a placeholder.
<span class="lineno">  272 </span>data NamedType = ConcreteType Type | AbstractType
<span class="lineno">  273 </span>
<span class="lineno">  274 </span>-- }}}
<span class="lineno">  275 </span>
<span class="lineno">  276 </span>-- Pretty Printing {{{
<span class="lineno">  277 </span>
<span class="lineno">  278 </span>prettyWholeModule :: [Stmt] -&gt; PP.Doc ann
<span class="lineno">  279 </span><span class="decl"><span class="nottickedoff">prettyWholeModule = (PP.&lt;&gt; PP.line') . vcatWithSemi . map PP.pretty</span></span>
<span class="lineno">  280 </span>
<span class="lineno">  281 </span>vcatWithSemi :: [PP.Doc ann] -&gt; PP.Doc ann
<span class="lineno">  282 </span><span class="decl"><span class="nottickedoff">vcatWithSemi = PP.vcat . map (PP.&lt;&gt; PP.semi)</span></span>
<span class="lineno">  283 </span>
<span class="lineno">  284 </span>instance <span class="decl"><span class="nottickedoff">Pretty Expr</span></span> where
<span class="lineno">  285 </span>  <span class="decl"><span class="nottickedoff">pretty expr0 = case expr0 of</span>
<span class="lineno">  286 </span><span class="spaces">    </span><span class="nottickedoff">Bool _ b   -&gt; PP.viaShow b</span>
<span class="lineno">  287 </span><span class="spaces">    </span><span class="nottickedoff">String _ s -&gt; PP.dquotes (PP.pretty s)</span>
<span class="lineno">  288 </span><span class="spaces">    </span><span class="nottickedoff">Int _ i    -&gt; PP.pretty i</span>
<span class="lineno">  289 </span><span class="spaces">    </span><span class="nottickedoff">Code ls    -&gt; PP.braces . PP.braces $ PP.pretty (getVal ls)</span>
<span class="lineno">  290 </span><span class="spaces">    </span><span class="nottickedoff">CType (Located string _ _) -&gt; PP.braces . PP.pretty $ &quot;|&quot; ++ string ++ &quot;|&quot;</span>
<span class="lineno">  291 </span><span class="spaces">    </span><span class="nottickedoff">Array _ xs -&gt; PP.list (map PP.pretty xs)</span>
<span class="lineno">  292 </span><span class="spaces">    </span><span class="nottickedoff">Block _ stmts -&gt;</span>
<span class="lineno">  293 </span><span class="spaces">      </span><span class="nottickedoff">&quot;do&quot; PP.&lt;+&gt; PP.lbrace PP.&lt;&gt; PP.line' PP.&lt;&gt;</span>
<span class="lineno">  294 </span><span class="spaces">      </span><span class="nottickedoff">(PP.indent 3 $ (PP.align . vcatWithSemi . map PP.pretty $ stmts)) PP.&lt;&gt;</span>
<span class="lineno">  295 </span><span class="spaces">      </span><span class="nottickedoff">PP.line' PP.&lt;&gt; PP.rbrace</span>
<span class="lineno">  296 </span><span class="spaces">    </span><span class="nottickedoff">Tuple _ exprs -&gt; PP.tupled (map PP.pretty exprs)</span>
<span class="lineno">  297 </span><span class="spaces">    </span><span class="nottickedoff">Record _ mapping -&gt;</span>
<span class="lineno">  298 </span><span class="spaces">      </span><span class="nottickedoff">PP.braces . (PP.space PP.&lt;&gt;) . (PP.&lt;&gt; PP.space) . PP.align . PP.sep . PP.punctuate PP.comma $</span>
<span class="lineno">  299 </span><span class="spaces">      </span><span class="nottickedoff">map (\(name, value) -&gt; PP.pretty name PP.&lt;+&gt; &quot;=&quot; PP.&lt;+&gt; PP.pretty value)</span>
<span class="lineno">  300 </span><span class="spaces">      </span><span class="nottickedoff">(Map.assocs mapping)</span>
<span class="lineno">  301 </span><span class="spaces">    </span><span class="nottickedoff">Index _ _ _ -&gt; error &quot;No concrete syntax for AST node 'Index'&quot;</span>
<span class="lineno">  302 </span><span class="spaces">    </span><span class="nottickedoff">Lookup _ expr name -&gt; PP.pretty expr PP.&lt;&gt; PP.dot PP.&lt;&gt; PP.pretty name</span>
<span class="lineno">  303 </span><span class="spaces">    </span><span class="nottickedoff">TLookup _ expr int -&gt; PP.pretty expr PP.&lt;&gt; PP.dot PP.&lt;&gt; PP.pretty int</span>
<span class="lineno">  304 </span><span class="spaces">    </span><span class="nottickedoff">Var (Located name _ _) -&gt;</span>
<span class="lineno">  305 </span><span class="spaces">      </span><span class="nottickedoff">PP.pretty name</span>
<span class="lineno">  306 </span><span class="spaces">    </span><span class="nottickedoff">Function _ pat expr -&gt;</span>
<span class="lineno">  307 </span><span class="spaces">      </span><span class="nottickedoff">&quot;\\&quot; PP.&lt;+&gt; PP.pretty pat PP.&lt;+&gt; &quot;-&gt;&quot; PP.&lt;+&gt; PP.pretty expr</span>
<span class="lineno">  308 </span><span class="spaces">    </span><span class="nottickedoff">-- FIXME, use precedence to minimize parentheses</span>
<span class="lineno">  309 </span><span class="spaces">    </span><span class="nottickedoff">Application _ f a -&gt; PP.parens (PP.pretty f PP.&lt;+&gt; PP.pretty a)</span>
<span class="lineno">  310 </span><span class="spaces">    </span><span class="nottickedoff">Let _ (NonRecursive decl) expr -&gt;</span>
<span class="lineno">  311 </span><span class="spaces">      </span><span class="nottickedoff">PP.fillSep</span>
<span class="lineno">  312 </span><span class="spaces">      </span><span class="nottickedoff">[ &quot;let&quot; PP.&lt;+&gt; prettyDef decl</span>
<span class="lineno">  313 </span><span class="spaces">      </span><span class="nottickedoff">, &quot;in&quot; PP.&lt;+&gt; PP.pretty expr</span>
<span class="lineno">  314 </span><span class="spaces">      </span><span class="nottickedoff">]</span>
<span class="lineno">  315 </span><span class="spaces">    </span><span class="nottickedoff">Let _ (Recursive decls) expr -&gt;</span>
<span class="lineno">  316 </span><span class="spaces">      </span><span class="nottickedoff">PP.fillSep</span>
<span class="lineno">  317 </span><span class="spaces">      </span><span class="nottickedoff">[ &quot;let&quot; PP.&lt;+&gt;</span>
<span class="lineno">  318 </span><span class="spaces">        </span><span class="nottickedoff">PP.cat (PP.punctuate</span>
<span class="lineno">  319 </span><span class="spaces">                </span><span class="nottickedoff">(PP.fillSep [PP.emptyDoc, &quot;and&quot; PP.&lt;&gt; PP.space])</span>
<span class="lineno">  320 </span><span class="spaces">                </span><span class="nottickedoff">(map prettyDef decls))</span>
<span class="lineno">  321 </span><span class="spaces">      </span><span class="nottickedoff">, &quot;in&quot; PP.&lt;+&gt; PP.pretty expr</span>
<span class="lineno">  322 </span><span class="spaces">      </span><span class="nottickedoff">]</span>
<span class="lineno">  323 </span><span class="spaces">    </span><span class="nottickedoff">TSig _ expr typ -&gt; PP.parens $ PP.pretty expr PP.&lt;+&gt; PP.colon PP.&lt;+&gt; pretty 0 typ</span>
<span class="lineno">  324 </span><span class="spaces">    </span><span class="nottickedoff">IfThenElse _ e1 e2 e3 -&gt;</span>
<span class="lineno">  325 </span><span class="spaces">      </span><span class="nottickedoff">&quot;if&quot; PP.&lt;+&gt; PP.pretty e1 PP.&lt;+&gt;</span>
<span class="lineno">  326 </span><span class="spaces">      </span><span class="nottickedoff">&quot;then&quot; PP.&lt;+&gt; PP.pretty e2 PP.&lt;+&gt;</span>
<span class="lineno">  327 </span><span class="spaces">      </span><span class="nottickedoff">&quot;else&quot; PP.&lt;+&gt; PP.pretty e3</span></span>
<span class="lineno">  328 </span>
<span class="lineno">  329 </span>instance PrettyPrint Expr where
<span class="lineno">  330 </span>  <span class="decl"><span class="nottickedoff">pretty _ e = PP.pretty e</span></span>
<span class="lineno">  331 </span>
<span class="lineno">  332 </span>instance <span class="decl"><span class="nottickedoff">Pretty Pattern</span></span> where
<span class="lineno">  333 </span>  <span class="decl"><span class="nottickedoff">pretty pat = case pat of</span>
<span class="lineno">  334 </span><span class="spaces">    </span><span class="nottickedoff">PWild _ mType -&gt;</span>
<span class="lineno">  335 </span><span class="spaces">      </span><span class="nottickedoff">prettyMaybeTypedArg (&quot;_&quot;, mType)</span>
<span class="lineno">  336 </span><span class="spaces">    </span><span class="nottickedoff">PVar _ (Located name _ _) mType -&gt;</span>
<span class="lineno">  337 </span><span class="spaces">      </span><span class="nottickedoff">prettyMaybeTypedArg (name, mType)</span>
<span class="lineno">  338 </span><span class="spaces">    </span><span class="nottickedoff">PTuple _ pats -&gt;</span>
<span class="lineno">  339 </span><span class="spaces">      </span><span class="nottickedoff">PP.tupled (map PP.pretty pats)</span></span>
<span class="lineno">  340 </span>
<span class="lineno">  341 </span>instance <span class="decl"><span class="nottickedoff">Pretty Stmt</span></span> where
<span class="lineno">  342 </span>   <span class="decl"><span class="nottickedoff">pretty = \case</span>
<span class="lineno">  343 </span><span class="spaces">      </span><span class="nottickedoff">StmtBind _ (PWild _ _ty) expr -&gt;</span>
<span class="lineno">  344 </span><span class="spaces">         </span><span class="nottickedoff">PP.pretty expr</span>
<span class="lineno">  345 </span><span class="spaces">      </span><span class="nottickedoff">StmtBind _ pat expr -&gt;</span>
<span class="lineno">  346 </span><span class="spaces">         </span><span class="nottickedoff">PP.pretty pat PP.&lt;+&gt; &quot;&lt;-&quot; PP.&lt;+&gt; PP.align (PP.pretty expr)</span>
<span class="lineno">  347 </span><span class="spaces">      </span><span class="nottickedoff">StmtLet _ (NonRecursive decl) -&gt;</span>
<span class="lineno">  348 </span><span class="spaces">         </span><span class="nottickedoff">&quot;let&quot; PP.&lt;+&gt; prettyDef decl</span>
<span class="lineno">  349 </span><span class="spaces">      </span><span class="nottickedoff">StmtLet _ (Recursive decls) -&gt;</span>
<span class="lineno">  350 </span><span class="spaces">         </span><span class="nottickedoff">&quot;rec&quot; PP.&lt;+&gt;</span>
<span class="lineno">  351 </span><span class="spaces">         </span><span class="nottickedoff">PP.cat (PP.punctuate</span>
<span class="lineno">  352 </span><span class="spaces">            </span><span class="nottickedoff">(PP.fillSep [PP.emptyDoc, &quot;and&quot; PP.&lt;&gt; PP.space])</span>
<span class="lineno">  353 </span><span class="spaces">            </span><span class="nottickedoff">(map prettyDef decls))</span>
<span class="lineno">  354 </span><span class="spaces">      </span><span class="nottickedoff">StmtCode _ (Located code _ _) -&gt;</span>
<span class="lineno">  355 </span><span class="spaces">         </span><span class="nottickedoff">&quot;let&quot; PP.&lt;+&gt;</span>
<span class="lineno">  356 </span><span class="spaces">            </span><span class="nottickedoff">(PP.braces . PP.braces $ PP.pretty code)</span>
<span class="lineno">  357 </span><span class="spaces">      </span><span class="nottickedoff">StmtImport _ Import{iModule,iAs,iSpec} -&gt;</span>
<span class="lineno">  358 </span><span class="spaces">         </span><span class="nottickedoff">&quot;import&quot; PP.&lt;+&gt;</span>
<span class="lineno">  359 </span><span class="spaces">         </span><span class="nottickedoff">(case iModule of</span>
<span class="lineno">  360 </span><span class="spaces">            </span><span class="nottickedoff">Left filepath -&gt;</span>
<span class="lineno">  361 </span><span class="spaces">               </span><span class="nottickedoff">PP.dquotes . PP.pretty $ filepath</span>
<span class="lineno">  362 </span><span class="spaces">            </span><span class="nottickedoff">Right modName -&gt;</span>
<span class="lineno">  363 </span><span class="spaces">               </span><span class="nottickedoff">ppModName modName) PP.&lt;&gt;</span>
<span class="lineno">  364 </span><span class="spaces">         </span><span class="nottickedoff">(case iAs of</span>
<span class="lineno">  365 </span><span class="spaces">            </span><span class="nottickedoff">Just modName -&gt;</span>
<span class="lineno">  366 </span><span class="spaces">               </span><span class="nottickedoff">PP.space PP.&lt;&gt; &quot;as&quot; PP.&lt;+&gt; ppModName modName</span>
<span class="lineno">  367 </span><span class="spaces">            </span><span class="nottickedoff">Nothing -&gt; PP.emptyDoc) PP.&lt;&gt;</span>
<span class="lineno">  368 </span><span class="spaces">         </span><span class="nottickedoff">(case iSpec of</span>
<span class="lineno">  369 </span><span class="spaces">            </span><span class="nottickedoff">Just (P.Hiding names) -&gt;</span>
<span class="lineno">  370 </span><span class="spaces">               </span><span class="nottickedoff">PP.space PP.&lt;&gt; &quot;hiding&quot; PP.&lt;+&gt; PP.tupled (map ppIdent names)</span>
<span class="lineno">  371 </span><span class="spaces">            </span><span class="nottickedoff">Just (P.Only names) -&gt;</span>
<span class="lineno">  372 </span><span class="spaces">               </span><span class="nottickedoff">PP.space PP.&lt;&gt; PP.tupled (map ppIdent names)</span>
<span class="lineno">  373 </span><span class="spaces">            </span><span class="nottickedoff">Nothing -&gt; PP.emptyDoc)</span>
<span class="lineno">  374 </span><span class="spaces">      </span><span class="nottickedoff">StmtTypedef _ (Located name _ _) ty -&gt;</span>
<span class="lineno">  375 </span><span class="spaces">         </span><span class="nottickedoff">&quot;typedef&quot; PP.&lt;+&gt; PP.pretty name PP.&lt;+&gt; pretty 0 ty</span>
<span class="lineno">  376 </span><span class="spaces">      </span><span class="nottickedoff">--expr -&gt; PP.cyan . PP.viaShow expr</span>
<span class="lineno">  377 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  378 </span><span class="spaces">      </span><span class="nottickedoff">where</span>
<span class="lineno">  379 </span><span class="spaces">        </span><span class="nottickedoff">ppModName mn = PP.pretty (intercalate &quot;.&quot; (P.modNameChunks mn))</span>
<span class="lineno">  380 </span><span class="spaces">        </span><span class="nottickedoff">ppIdent i = PP.pretty (P.identText i)</span></span>
<span class="lineno">  381 </span>        --ppName n = ppIdent (P.nameIdent n)
<span class="lineno">  382 </span>
<span class="lineno">  383 </span>prettyDef :: Decl -&gt; PP.Doc ann
<span class="lineno">  384 </span><span class="decl"><span class="nottickedoff">prettyDef (Decl _ pat _ def) =</span>
<span class="lineno">  385 </span><span class="spaces">   </span><span class="nottickedoff">PP.pretty pat PP.&lt;+&gt;</span>
<span class="lineno">  386 </span><span class="spaces">   </span><span class="nottickedoff">let (args, body) = dissectLambda def</span>
<span class="lineno">  387 </span><span class="spaces">   </span><span class="nottickedoff">in (if not (null args)</span>
<span class="lineno">  388 </span><span class="spaces">          </span><span class="nottickedoff">then PP.hsep (map PP.pretty args) PP.&lt;&gt; PP.space</span>
<span class="lineno">  389 </span><span class="spaces">          </span><span class="nottickedoff">else PP.emptyDoc) PP.&lt;&gt;</span>
<span class="lineno">  390 </span><span class="spaces">      </span><span class="nottickedoff">&quot;=&quot; PP.&lt;+&gt; PP.pretty body</span></span>
<span class="lineno">  391 </span>
<span class="lineno">  392 </span>prettyMaybeTypedArg :: (Name, Maybe Type) -&gt; PP.Doc ann
<span class="lineno">  393 </span><span class="decl"><span class="nottickedoff">prettyMaybeTypedArg (name,Nothing) =</span>
<span class="lineno">  394 </span><span class="spaces">   </span><span class="nottickedoff">PP.pretty name</span>
<span class="lineno">  395 </span><span class="spaces"></span><span class="nottickedoff">prettyMaybeTypedArg (name,Just typ) =</span>
<span class="lineno">  396 </span><span class="spaces">   </span><span class="nottickedoff">PP.parens $ PP.pretty name PP.&lt;+&gt; PP.colon PP.&lt;+&gt; pretty 0 typ</span></span>
<span class="lineno">  397 </span>
<span class="lineno">  398 </span>dissectLambda :: Expr -&gt; ([Pattern], Expr)
<span class="lineno">  399 </span><span class="decl"><span class="nottickedoff">dissectLambda = \case</span>
<span class="lineno">  400 </span><span class="spaces">  </span><span class="nottickedoff">Function _ pat (dissectLambda -&gt; (pats, expr)) -&gt; (pat : pats, expr)</span>
<span class="lineno">  401 </span><span class="spaces">  </span><span class="nottickedoff">expr -&gt; ([], expr)</span></span>
<span class="lineno">  402 </span>
<span class="lineno">  403 </span>pShow :: PrettyPrint a =&gt; a -&gt; String
<span class="lineno">  404 </span><span class="decl"><span class="istickedoff">pShow = show . pretty 0</span></span>
<span class="lineno">  405 </span>
<span class="lineno">  406 </span>class PrettyPrint p where
<span class="lineno">  407 </span>  pretty :: Int -&gt; p -&gt; PP.Doc ann
<span class="lineno">  408 </span>
<span class="lineno">  409 </span>instance PrettyPrint Schema where
<span class="lineno">  410 </span>  <span class="decl"><span class="nottickedoff">pretty _ (Forall ns t) = case ns of</span>
<span class="lineno">  411 </span><span class="spaces">    </span><span class="nottickedoff">[] -&gt; pretty 0 t</span>
<span class="lineno">  412 </span><span class="spaces">    </span><span class="nottickedoff">_  -&gt; PP.braces (commaSepAll $ map PP.pretty ns') PP.&lt;+&gt; pretty 0 t</span>
<span class="lineno">  413 </span><span class="spaces">          </span><span class="nottickedoff">where ns' = map (\(_pos, n) -&gt; n) ns</span></span>
<span class="lineno">  414 </span>
<span class="lineno">  415 </span>instance PrettyPrint Type where
<span class="lineno">  416 </span>  <span class="decl"><span class="istickedoff">pretty par t@(TyCon _ tc ts) = case (tc,ts) of</span>
<span class="lineno">  417 </span><span class="spaces">    </span><span class="istickedoff">(_,[])                 -&gt; pretty <span class="nottickedoff">par</span> tc</span>
<span class="lineno">  418 </span><span class="spaces">    </span><span class="istickedoff">(TupleCon _,_)         -&gt; PP.parens $ commaSepAll $ map (pretty <span class="nottickedoff">0</span>) ts</span>
<span class="lineno">  419 </span><span class="spaces">    </span><span class="istickedoff">(ArrayCon,[typ])       -&gt; PP.brackets (pretty <span class="nottickedoff">0</span> typ)</span>
<span class="lineno">  420 </span><span class="spaces">    </span><span class="istickedoff">(FunCon,[f,v])         -&gt; <span class="nottickedoff">(if par &gt; 0 then PP.parens else id) $</span></span>
<span class="lineno">  421 </span><span class="spaces">                                </span><span class="istickedoff"><span class="nottickedoff">pretty 1 f PP.&lt;+&gt; &quot;-&gt;&quot; PP.&lt;+&gt; pretty 0 v</span></span>
<span class="lineno">  422 </span><span class="spaces">    </span><span class="istickedoff">(BlockCon,[cxt,typ])   -&gt; (if <span class="tickonlyfalse">par &gt; 1</span> then <span class="nottickedoff">PP.parens</span> else id) $</span>
<span class="lineno">  423 </span><span class="spaces">                                </span><span class="istickedoff">pretty <span class="nottickedoff">1</span> cxt PP.&lt;+&gt; pretty <span class="nottickedoff">2</span> typ</span>
<span class="lineno">  424 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">error $ &quot;malformed TyCon: &quot; ++ show t</span></span>
<span class="lineno">  425 </span><span class="spaces">  </span><span class="istickedoff">pretty _par (TyRecord _ fs) =</span>
<span class="lineno">  426 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">PP.braces</span></span>
<span class="lineno">  427 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">$ commaSepAll</span></span>
<span class="lineno">  428 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">$ map (\(n,t) -&gt; PP.pretty n `prettyTypeSig` pretty 0 t)</span></span>
<span class="lineno">  429 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">$ Map.toList fs</span></span>
<span class="lineno">  430 </span><span class="spaces">  </span><span class="istickedoff">pretty _par (TyUnifyVar _ i)    = &quot;t.&quot; PP.&lt;&gt; PP.pretty i</span>
<span class="lineno">  431 </span><span class="spaces">  </span><span class="istickedoff">pretty _par (TyVar _ n)         = PP.pretty n</span></span>
<span class="lineno">  432 </span>
<span class="lineno">  433 </span>instance PrettyPrint TyCon where
<span class="lineno">  434 </span>  <span class="decl"><span class="istickedoff">pretty par tc = case tc of</span>
<span class="lineno">  435 </span><span class="spaces">    </span><span class="istickedoff">TupleCon n     -&gt; <span class="nottickedoff">PP.parens $ replicateDoc (n - 1) $ PP.pretty ','</span></span>
<span class="lineno">  436 </span><span class="spaces">    </span><span class="istickedoff">ArrayCon       -&gt; PP.parens $ PP.brackets $ PP.emptyDoc</span>
<span class="lineno">  437 </span><span class="spaces">    </span><span class="istickedoff">FunCon         -&gt; <span class="nottickedoff">PP.parens $ &quot;-&gt;&quot;</span></span>
<span class="lineno">  438 </span><span class="spaces">    </span><span class="istickedoff">StringCon      -&gt; &quot;String&quot;</span>
<span class="lineno">  439 </span><span class="spaces">    </span><span class="istickedoff">TermCon        -&gt; <span class="nottickedoff">&quot;Term&quot;</span></span>
<span class="lineno">  440 </span><span class="spaces">    </span><span class="istickedoff">TypeCon        -&gt; <span class="nottickedoff">&quot;Type&quot;</span></span>
<span class="lineno">  441 </span><span class="spaces">    </span><span class="istickedoff">BoolCon        -&gt; <span class="nottickedoff">&quot;Bool&quot;</span></span>
<span class="lineno">  442 </span><span class="spaces">    </span><span class="istickedoff">IntCon         -&gt; &quot;Int&quot;</span>
<span class="lineno">  443 </span><span class="spaces">    </span><span class="istickedoff">AIGCon         -&gt; <span class="nottickedoff">&quot;AIG&quot;</span></span>
<span class="lineno">  444 </span><span class="spaces">    </span><span class="istickedoff">CFGCon         -&gt; <span class="nottickedoff">&quot;CFG&quot;</span></span>
<span class="lineno">  445 </span><span class="spaces">    </span><span class="istickedoff">JVMSpecCon     -&gt; <span class="nottickedoff">&quot;JVMSpec&quot;</span></span>
<span class="lineno">  446 </span><span class="spaces">    </span><span class="istickedoff">LLVMSpecCon    -&gt; <span class="nottickedoff">&quot;LLVMSpec&quot;</span></span>
<span class="lineno">  447 </span><span class="spaces">    </span><span class="istickedoff">MIRSpecCon     -&gt; <span class="nottickedoff">&quot;MIRSpec&quot;</span></span>
<span class="lineno">  448 </span><span class="spaces">    </span><span class="istickedoff">BlockCon       -&gt; &quot;&lt;Block&gt;&quot;</span>
<span class="lineno">  449 </span><span class="spaces">    </span><span class="istickedoff">ContextCon cxt -&gt; pretty <span class="nottickedoff">par</span> cxt</span></span>
<span class="lineno">  450 </span>
<span class="lineno">  451 </span>instance PrettyPrint Context where
<span class="lineno">  452 </span>  <span class="decl"><span class="istickedoff">pretty _ c = case c of</span>
<span class="lineno">  453 </span><span class="spaces">    </span><span class="istickedoff">CryptolSetup -&gt; <span class="nottickedoff">&quot;CryptolSetup&quot;</span></span>
<span class="lineno">  454 </span><span class="spaces">    </span><span class="istickedoff">JavaSetup    -&gt; <span class="nottickedoff">&quot;JavaSetup&quot;</span></span>
<span class="lineno">  455 </span><span class="spaces">    </span><span class="istickedoff">LLVMSetup    -&gt; &quot;LLVMSetup&quot;</span>
<span class="lineno">  456 </span><span class="spaces">    </span><span class="istickedoff">MIRSetup     -&gt; <span class="nottickedoff">&quot;MIRSetup&quot;</span></span>
<span class="lineno">  457 </span><span class="spaces">    </span><span class="istickedoff">ProofScript  -&gt; <span class="nottickedoff">&quot;ProofScript&quot;</span></span>
<span class="lineno">  458 </span><span class="spaces">    </span><span class="istickedoff">TopLevel     -&gt; &quot;TopLevel&quot;</span>
<span class="lineno">  459 </span><span class="spaces">    </span><span class="istickedoff">CrucibleSetup-&gt; <span class="nottickedoff">&quot;CrucibleSetup&quot;</span></span></span>
<span class="lineno">  460 </span>
<span class="lineno">  461 </span>instance PrettyPrint NamedType where
<span class="lineno">  462 </span>  <span class="decl"><span class="nottickedoff">pretty par ty = case ty of</span>
<span class="lineno">  463 </span><span class="spaces">    </span><span class="nottickedoff">ConcreteType ty' -&gt; pretty par ty'</span>
<span class="lineno">  464 </span><span class="spaces">    </span><span class="nottickedoff">AbstractType -&gt; &quot;&lt;opaque&gt;&quot;</span></span>
<span class="lineno">  465 </span>
<span class="lineno">  466 </span>replicateDoc :: Integer -&gt; PP.Doc ann -&gt; PP.Doc ann
<span class="lineno">  467 </span><span class="decl"><span class="nottickedoff">replicateDoc n d</span>
<span class="lineno">  468 </span><span class="spaces">  </span><span class="nottickedoff">| n &lt; 1 = PP.emptyDoc</span>
<span class="lineno">  469 </span><span class="spaces">  </span><span class="nottickedoff">| True  = d PP.&lt;&gt; replicateDoc (n-1) d</span></span>
<span class="lineno">  470 </span>
<span class="lineno">  471 </span>prettyTypeSig :: PP.Doc ann -&gt; PP.Doc ann -&gt; PP.Doc ann
<span class="lineno">  472 </span><span class="decl"><span class="nottickedoff">prettyTypeSig n t = n PP.&lt;+&gt; PP.pretty ':' PP.&lt;+&gt; t</span></span>
<span class="lineno">  473 </span>
<span class="lineno">  474 </span>commaSep :: PP.Doc ann -&gt; PP.Doc ann -&gt; PP.Doc ann
<span class="lineno">  475 </span><span class="decl"><span class="istickedoff">commaSep = ((PP.&lt;+&gt;) . (PP.&lt;&gt; PP.comma))</span></span>
<span class="lineno">  476 </span>
<span class="lineno">  477 </span>commaSepAll :: [PP.Doc ann] -&gt; PP.Doc ann
<span class="lineno">  478 </span><span class="decl"><span class="istickedoff">commaSepAll ds = case ds of</span>
<span class="lineno">  479 </span><span class="spaces">  </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">PP.emptyDoc</span></span>
<span class="lineno">  480 </span><span class="spaces">  </span><span class="istickedoff">_  -&gt; foldl1 commaSep ds</span></span>
<span class="lineno">  481 </span>
<span class="lineno">  482 </span>-- }}}
<span class="lineno">  483 </span>
<span class="lineno">  484 </span>-- Type Constructors {{{
<span class="lineno">  485 </span>
<span class="lineno">  486 </span>tMono :: Type -&gt; Schema
<span class="lineno">  487 </span><span class="decl"><span class="istickedoff">tMono = Forall []</span></span>
<span class="lineno">  488 </span>
<span class="lineno">  489 </span>tForall :: [(Pos, Name)] -&gt; Schema -&gt; Schema
<span class="lineno">  490 </span><span class="decl"><span class="nottickedoff">tForall xs (Forall ys t) = Forall (xs ++ ys) t</span></span>
<span class="lineno">  491 </span>
<span class="lineno">  492 </span>tTuple :: Pos -&gt; [Type] -&gt; Type
<span class="lineno">  493 </span><span class="decl"><span class="istickedoff">tTuple pos ts = TyCon <span class="nottickedoff">pos</span> (TupleCon $ fromIntegral $ length ts) ts</span></span>
<span class="lineno">  494 </span>
<span class="lineno">  495 </span>tRecord :: Pos -&gt; [(Name, Type)] -&gt; Type
<span class="lineno">  496 </span><span class="decl"><span class="istickedoff">tRecord pos fields = TyRecord <span class="nottickedoff">pos</span> (Map.fromList fields)</span></span>
<span class="lineno">  497 </span>
<span class="lineno">  498 </span>tArray :: Pos -&gt; Type -&gt; Type
<span class="lineno">  499 </span><span class="decl"><span class="istickedoff">tArray pos t = TyCon pos ArrayCon [t]</span></span>
<span class="lineno">  500 </span>
<span class="lineno">  501 </span>tFun :: Pos -&gt; Type -&gt; Type -&gt; Type
<span class="lineno">  502 </span><span class="decl"><span class="istickedoff">tFun pos f v = TyCon <span class="nottickedoff">pos</span> FunCon [f,v]</span></span>
<span class="lineno">  503 </span>
<span class="lineno">  504 </span>tString :: Pos -&gt; Type
<span class="lineno">  505 </span><span class="decl"><span class="istickedoff">tString pos = TyCon pos StringCon []</span></span>
<span class="lineno">  506 </span>
<span class="lineno">  507 </span>tTerm :: Pos -&gt; Type
<span class="lineno">  508 </span><span class="decl"><span class="istickedoff">tTerm pos = TyCon <span class="nottickedoff">pos</span> TermCon []</span></span>
<span class="lineno">  509 </span>
<span class="lineno">  510 </span>tType :: Pos -&gt; Type
<span class="lineno">  511 </span><span class="decl"><span class="istickedoff">tType pos = TyCon <span class="nottickedoff">pos</span> TypeCon []</span></span>
<span class="lineno">  512 </span>
<span class="lineno">  513 </span>tBool :: Pos -&gt; Type
<span class="lineno">  514 </span><span class="decl"><span class="istickedoff">tBool pos = TyCon <span class="nottickedoff">pos</span> BoolCon []</span></span>
<span class="lineno">  515 </span>
<span class="lineno">  516 </span>tAIG :: Pos -&gt; Type
<span class="lineno">  517 </span><span class="decl"><span class="istickedoff">tAIG pos = TyCon <span class="nottickedoff">pos</span> <span class="nottickedoff">AIGCon</span> []</span></span>
<span class="lineno">  518 </span>
<span class="lineno">  519 </span>tCFG :: Pos -&gt; Type
<span class="lineno">  520 </span><span class="decl"><span class="istickedoff">tCFG pos = TyCon <span class="nottickedoff">pos</span> <span class="nottickedoff">CFGCon</span> []</span></span>
<span class="lineno">  521 </span>
<span class="lineno">  522 </span>tInt :: Pos -&gt; Type
<span class="lineno">  523 </span><span class="decl"><span class="istickedoff">tInt pos = TyCon pos IntCon []</span></span>
<span class="lineno">  524 </span>
<span class="lineno">  525 </span>tJVMSpec :: Pos -&gt; Type
<span class="lineno">  526 </span><span class="decl"><span class="istickedoff">tJVMSpec pos = TyCon <span class="nottickedoff">pos</span> JVMSpecCon []</span></span>
<span class="lineno">  527 </span>
<span class="lineno">  528 </span>tLLVMSpec :: Pos -&gt; Type
<span class="lineno">  529 </span><span class="decl"><span class="istickedoff">tLLVMSpec pos = TyCon <span class="nottickedoff">pos</span> LLVMSpecCon []</span></span>
<span class="lineno">  530 </span>
<span class="lineno">  531 </span>tMIRSpec :: Pos -&gt; Type
<span class="lineno">  532 </span><span class="decl"><span class="istickedoff">tMIRSpec pos = TyCon <span class="nottickedoff">pos</span> MIRSpecCon []</span></span>
<span class="lineno">  533 </span>
<span class="lineno">  534 </span>tBlock :: Pos -&gt; Type -&gt; Type -&gt; Type
<span class="lineno">  535 </span><span class="decl"><span class="istickedoff">tBlock pos c t = TyCon pos BlockCon [c,t]</span></span>
<span class="lineno">  536 </span>
<span class="lineno">  537 </span>tContext :: Pos -&gt; Context -&gt; Type
<span class="lineno">  538 </span><span class="decl"><span class="istickedoff">tContext pos c = TyCon pos (ContextCon c) []</span></span>
<span class="lineno">  539 </span>
<span class="lineno">  540 </span>tVar :: Pos -&gt; Name -&gt; Type
<span class="lineno">  541 </span><span class="decl"><span class="istickedoff">tVar pos n = TyVar pos n</span></span>
<span class="lineno">  542 </span>
<span class="lineno">  543 </span>-- }}}
<span class="lineno">  544 </span>
<span class="lineno">  545 </span>-- Type Classifiers {{{
<span class="lineno">  546 </span>
<span class="lineno">  547 </span>-- The idea is that calling these is/should be less messy than direct
<span class="lineno">  548 </span>-- pattern matching, and also help a little to avoid splattering the
<span class="lineno">  549 </span>-- internal representation of types all over the place.
<span class="lineno">  550 </span>
<span class="lineno">  551 </span>-- | Check if type 'ty' is a 'Context' type of context 'c'.
<span class="lineno">  552 </span>isContext ::
<span class="lineno">  553 </span>       Context          -- ^ The context 'c' to look for
<span class="lineno">  554 </span>    -&gt; Type             -- ^ The type 'ty' to inspect
<span class="lineno">  555 </span>    -&gt; Bool
<span class="lineno">  556 </span><span class="decl"><span class="nottickedoff">isContext c ty = case ty of</span>
<span class="lineno">  557 </span><span class="spaces">  </span><span class="nottickedoff">TyCon _pos (ContextCon c') [] | c' == c -&gt; True</span>
<span class="lineno">  558 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt; False</span></span>
<span class="lineno">  559 </span>
<span class="lineno">  560 </span>-- }}}

</pre>
</body>
</html>
