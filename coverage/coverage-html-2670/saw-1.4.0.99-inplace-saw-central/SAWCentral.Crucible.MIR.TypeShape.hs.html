<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE DataKinds #-}
<span class="lineno">    2 </span>{-# LANGUAGE GADTs #-}
<span class="lineno">    3 </span>{-# LANGUAGE KindSignatures #-}
<span class="lineno">    4 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">    5 </span>{-# LANGUAGE PatternSynonyms #-}
<span class="lineno">    6 </span>{-# LANGUAGE RankNTypes #-}
<span class="lineno">    7 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">    8 </span>{-# LANGUAGE StandaloneDeriving #-}
<span class="lineno">    9 </span>{-# LANGUAGE TemplateHaskell #-}
<span class="lineno">   10 </span>{-# LANGUAGE TypeApplications #-}
<span class="lineno">   11 </span>{-# LANGUAGE TypeOperators #-}
<span class="lineno">   12 </span>{-# LANGUAGE DeriveTraversable #-}
<span class="lineno">   13 </span>
<span class="lineno">   14 </span>-- | The 'TypeShape' data type and related utilities.
<span class="lineno">   15 </span>module SAWCentral.Crucible.MIR.TypeShape
<span class="lineno">   16 </span>  ( TypeShape(..)
<span class="lineno">   17 </span>  , FieldShape(..)
<span class="lineno">   18 </span>  , VariantShape(..)
<span class="lineno">   19 </span>  , AgElemShape(..)
<span class="lineno">   20 </span>  , CryTermAdaptor(..)
<span class="lineno">   21 </span>  , isCryNoAdapt
<span class="lineno">   22 </span>  , adaptTuple
<span class="lineno">   23 </span>  , adaptArray
<span class="lineno">   24 </span>  , tyToShape
<span class="lineno">   25 </span>  , tyToShapeEq
<span class="lineno">   26 </span>  , shapeType
<span class="lineno">   27 </span>  , fieldShapeType
<span class="lineno">   28 </span>  , variantShapeType
<span class="lineno">   29 </span>  , shapeMirTy
<span class="lineno">   30 </span>  , fieldShapeMirTy
<span class="lineno">   31 </span>  , shapeToTerm
<span class="lineno">   32 </span>  , shapeToTerm'
<span class="lineno">   33 </span>  , IsBVShape(..)
<span class="lineno">   34 </span>  , testBVShape
<span class="lineno">   35 </span>  , IsRefShape(..)
<span class="lineno">   36 </span>  , testRefShape
<span class="lineno">   37 </span>  , sliceShapeParts
<span class="lineno">   38 </span>  -- `MirAggregate` / `AgElemShape` helpers
<span class="lineno">   39 </span>  , buildMirAggregate
<span class="lineno">   40 </span>  , traverseMirAggregate
<span class="lineno">   41 </span>  , accessMirAggregate
<span class="lineno">   42 </span>  , accessMirAggregate'
<span class="lineno">   43 </span>  , zipMirAggregates
<span class="lineno">   44 </span>  -- Misc helpers
<span class="lineno">   45 </span>  , readMaybeType
<span class="lineno">   46 </span>  , readPartExprMaybe
<span class="lineno">   47 </span>  ) where
<span class="lineno">   48 </span>
<span class="lineno">   49 </span>import Control.Lens ((^.), (^..), each)
<span class="lineno">   50 </span>import Control.Monad (when, forM, zipWithM)
<span class="lineno">   51 </span>import Control.Monad.IO.Class (MonadIO(..))
<span class="lineno">   52 </span>import Data.IntMap (IntMap)
<span class="lineno">   53 </span>import qualified Data.IntMap as IntMap
<span class="lineno">   54 </span>import qualified Data.IntSet as IntSet
<span class="lineno">   55 </span>import qualified Data.Map as Map
<span class="lineno">   56 </span>import Data.Maybe (isJust)
<span class="lineno">   57 </span>import Data.Text (Text)
<span class="lineno">   58 </span>import qualified Data.Text as Text
<span class="lineno">   59 </span>import Data.Parameterized.Classes (ShowF)
<span class="lineno">   60 </span>import Data.Parameterized.Context (pattern Empty, pattern (:&gt;), Assignment)
<span class="lineno">   61 </span>import Data.Parameterized.Some
<span class="lineno">   62 </span>import Data.Parameterized.TH.GADT
<span class="lineno">   63 </span>import Data.Parameterized.TraversableFC
<span class="lineno">   64 </span>import GHC.Stack (HasCallStack)
<span class="lineno">   65 </span>import qualified Prettyprinter as PP
<span class="lineno">   66 </span>
<span class="lineno">   67 </span>import qualified What4.Interface as W4
<span class="lineno">   68 </span>import qualified What4.Partial as W4
<span class="lineno">   69 </span>
<span class="lineno">   70 </span>import Lang.Crucible.Backend (IsSymInterface)
<span class="lineno">   71 </span>import Lang.Crucible.Simulator.RegValue (RegValue)
<span class="lineno">   72 </span>import Lang.Crucible.Types
<span class="lineno">   73 </span>
<span class="lineno">   74 </span>import Mir.Intrinsics
<span class="lineno">   75 </span>import qualified Mir.Mir as M
<span class="lineno">   76 </span>import Mir.TransTy ( tyListToCtx, tyToRepr, tyToReprCont, canInitialize
<span class="lineno">   77 </span>                   , isUnsized, reprTransparentFieldTy )
<span class="lineno">   78 </span>
<span class="lineno">   79 </span>import SAWCentral.Panic (panic)
<span class="lineno">   80 </span>import qualified SAWCore.SharedTerm as SAW
<span class="lineno">   81 </span>
<span class="lineno">   82 </span>-- | TypeShape is used to classify MIR `Ty`s and their corresponding
<span class="lineno">   83 </span>-- CrucibleTypes into a few common cases.  We don't use `Ty` directly because
<span class="lineno">   84 </span>-- there are some `Ty`s that have identical structure (such as TyRef vs.
<span class="lineno">   85 </span>-- TyRawPtr) or similar enough structure that we'd rather write only one case
<span class="lineno">   86 </span>-- (such as `u8` vs `i8` vs `i32`, all primitives/BaseTypes).  And we don't use
<span class="lineno">   87 </span>-- TypeRepr directly because it's lacking information in some cases.
<span class="lineno">   88 </span>--
<span class="lineno">   89 </span>-- In each constructor, the first `M.Ty` is the overall MIR type (e.g., for
<span class="lineno">   90 </span>-- ArrayShape, this is the TyArray type).  The overall `TypeRepr tp` isn't
<span class="lineno">   91 </span>-- stored directly, but can be computed with `shapeType`.
<span class="lineno">   92 </span>data TypeShape (tp :: CrucibleType) where
<span class="lineno">   93 </span>    UnitShape :: M.Ty -&gt; TypeShape UnitType
<span class="lineno">   94 </span>    PrimShape :: M.Ty -&gt; BaseTypeRepr btp -&gt; TypeShape (BaseToType btp)
<span class="lineno">   95 </span>    TupleShape :: M.Ty -&gt; [AgElemShape] -&gt; TypeShape MirAggregateType
<span class="lineno">   96 </span>    ArrayShape :: M.Ty -&gt; M.Ty -&gt; TypeShape tp -&gt; TypeShape (MirVectorType tp)
<span class="lineno">   97 </span>    StructShape :: M.Ty -&gt; [M.Ty] -&gt; Assignment FieldShape ctx -&gt; TypeShape (StructType ctx)
<span class="lineno">   98 </span>    TransparentShape :: M.Ty -&gt; TypeShape tp -&gt; TypeShape tp
<span class="lineno">   99 </span>    -- | Note that RefShape contains only a TypeRepr for the pointee type, not
<span class="lineno">  100 </span>    -- a TypeShape.  None of our operations need to recurse inside pointers,
<span class="lineno">  101 </span>    -- and also this saves us from some infinite recursion.
<span class="lineno">  102 </span>    --
<span class="lineno">  103 </span>    -- If there are raw pointer casts involved, the pointee type, the pointee
<span class="lineno">  104 </span>    -- type contained in the reference type, and the pointee 'TypeRepr' might
<span class="lineno">  105 </span>    -- not reflect the actual pointee type of any Crucible reference that is
<span class="lineno">  106 </span>    -- paired with this 'TypeShape'. See @Note [Raw pointer casts]@ in
<span class="lineno">  107 </span>    -- &quot;SAWCentral.Crucible.MIR.Setup.Value&quot; for more info.
<span class="lineno">  108 </span>    RefShape :: M.Ty
<span class="lineno">  109 </span>             -- ^ The reference type
<span class="lineno">  110 </span>             -&gt; M.Ty
<span class="lineno">  111 </span>             -- ^ The pointee type
<span class="lineno">  112 </span>             -&gt; M.Mutability
<span class="lineno">  113 </span>             -- ^ Is the reference mutable or immutable?
<span class="lineno">  114 </span>             -&gt; TypeRepr tp
<span class="lineno">  115 </span>             -- ^ The Crucible representation of the pointee type
<span class="lineno">  116 </span>             -&gt; TypeShape MirReferenceType
<span class="lineno">  117 </span>    -- | A shape for a slice reference of type @&amp;[T]@ or @&amp;str@, which is
<span class="lineno">  118 </span>    -- represented in @crucible-mir@ as a 'MirSlice', i.e., a 'StructType'
<span class="lineno">  119 </span>    -- where:
<span class="lineno">  120 </span>    --
<span class="lineno">  121 </span>    -- * The first type in the struct is a reference to the element type.
<span class="lineno">  122 </span>    --   If the slice reference has type @&amp;[T]@, then the element type is @T@.
<span class="lineno">  123 </span>    --   If the slice reference has type @&amp;str@, then the element type is @u8@.
<span class="lineno">  124 </span>    --
<span class="lineno">  125 </span>    -- * The second type in the struct is the length of the slice.
<span class="lineno">  126 </span>    --
<span class="lineno">  127 </span>    -- The @crucible-mir@ representations for tuples and slices are almost, but
<span class="lineno">  128 </span>    -- not quite, the same, as tuples can wrap their fields in 'MaybeType's (see
<span class="lineno">  129 </span>    -- 'FieldShape') but slices never do this. Nevertheless, many places in the
<span class="lineno">  130 </span>    -- code effectively treat tuples and slices identically (modulo 'MaybeType's).
<span class="lineno">  131 </span>    --
<span class="lineno">  132 </span>    -- To make it easier to recurse on the 'TypeShape's for the slice's
<span class="lineno">  133 </span>    -- reference and length types, we provide the 'sliceShapeParts' function.
<span class="lineno">  134 </span>    SliceShape :: M.Ty
<span class="lineno">  135 </span>               -- ^ The type of the slice reference (either @&amp;[T]@ or @&amp;str@).
<span class="lineno">  136 </span>               -&gt; M.Ty
<span class="lineno">  137 </span>               -- ^ The element type (either @T@ or @u8@).
<span class="lineno">  138 </span>               -&gt; M.Mutability
<span class="lineno">  139 </span>               -- ^ Is the reference mutable or immutable?
<span class="lineno">  140 </span>               -&gt; TypeRepr tp
<span class="lineno">  141 </span>               -- ^ The Crucible representation of the element type.
<span class="lineno">  142 </span>               -&gt; TypeShape MirSlice
<span class="lineno">  143 </span>    -- | A shape for an enum type.
<span class="lineno">  144 </span>    EnumShape :: M.Ty
<span class="lineno">  145 </span>              -- ^ The overall enum type.
<span class="lineno">  146 </span>              -&gt; [[M.Ty]]
<span class="lineno">  147 </span>              -- ^ The field types in each of the enum's variants.
<span class="lineno">  148 </span>              -&gt; Assignment VariantShape variantsCtx
<span class="lineno">  149 </span>              -- ^ The shapes of the enum type's variants.
<span class="lineno">  150 </span>              -&gt; M.Ty
<span class="lineno">  151 </span>              -- ^ The discriminant type.
<span class="lineno">  152 </span>              -&gt; TypeShape discrTp
<span class="lineno">  153 </span>              -- ^ The shape of the discriminant type.
<span class="lineno">  154 </span>              -&gt; TypeShape (RustEnumType discrTp variantsCtx)
<span class="lineno">  155 </span>    -- | Note that 'FnPtrShape' contains only 'TypeRepr's for the argument and
<span class="lineno">  156 </span>    -- result types, not 'TypeShape's, as none of our operations need to recurse
<span class="lineno">  157 </span>    -- inside them.
<span class="lineno">  158 </span>    FnPtrShape :: M.Ty -&gt; CtxRepr args -&gt; TypeRepr ret
<span class="lineno">  159 </span>               -&gt; TypeShape (FunctionHandleType args ret)
<span class="lineno">  160 </span>
<span class="lineno">  161 </span>-- TODO: Improve?
<span class="lineno">  162 </span>instance <span class="decl"><span class="nottickedoff">PP.Pretty (TypeShape tp)</span></span> where
<span class="lineno">  163 </span>  <span class="decl"><span class="nottickedoff">pretty = PP.viaShow</span></span>
<span class="lineno">  164 </span>
<span class="lineno">  165 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving instance Show (TypeShape tp)</span></span></span></span></span></span>
<span class="lineno">  166 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">ShowF TypeShape</span></span></span></span></span></span>
<span class="lineno">  167 </span>
<span class="lineno">  168 </span>-- | The TypeShape of a struct field, which might have a MaybeType wrapper to
<span class="lineno">  169 </span>-- allow for partial initialization.
<span class="lineno">  170 </span>data FieldShape (tp :: CrucibleType) where
<span class="lineno">  171 </span>    OptField :: TypeShape tp -&gt; FieldShape (MaybeType tp)
<span class="lineno">  172 </span>    ReqField :: TypeShape tp -&gt; FieldShape tp
<span class="lineno">  173 </span>
<span class="lineno">  174 </span>-- TODO: Improve?
<span class="lineno">  175 </span>instance <span class="decl"><span class="nottickedoff">PP.Pretty (FieldShape tp)</span></span> where
<span class="lineno">  176 </span>  <span class="decl"><span class="nottickedoff">pretty = PP.viaShow</span></span>
<span class="lineno">  177 </span>
<span class="lineno">  178 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving instance Show (FieldShape tp)</span></span></span></span></span></span>
<span class="lineno">  179 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">ShowF FieldShape</span></span></span></span></span></span>
<span class="lineno">  180 </span>
<span class="lineno">  181 </span>data AgElemShape where
<span class="lineno">  182 </span>    AgElemShape :: Word -&gt; Word -&gt; TypeShape tp -&gt; AgElemShape
<span class="lineno">  183 </span>
<span class="lineno">  184 </span>-- TODO: Improve?
<span class="lineno">  185 </span>instance <span class="decl"><span class="nottickedoff">PP.Pretty AgElemShape</span></span> where
<span class="lineno">  186 </span>  <span class="decl"><span class="nottickedoff">pretty = PP.viaShow</span></span>
<span class="lineno">  187 </span>
<span class="lineno">  188 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving instance Show AgElemShape</span></span></span></span></span></span>
<span class="lineno">  189 </span>
<span class="lineno">  190 </span>
<span class="lineno">  191 </span>-- | The 'TypeShape' of an enum variant, which consists of some number of field
<span class="lineno">  192 </span>-- types.
<span class="lineno">  193 </span>--
<span class="lineno">  194 </span>-- This is indexed by a 'StructType', but that is simply an artifact of the
<span class="lineno">  195 </span>-- particular way that @crucible-mir@ encodes enum types. Despite the use of
<span class="lineno">  196 </span>-- 'StructType' as a type index, we only use 'VariantShape' for enums, not
<span class="lineno">  197 </span>-- structs.
<span class="lineno">  198 </span>data VariantShape (tp :: CrucibleType) where
<span class="lineno">  199 </span>    VariantShape :: Assignment FieldShape ctx
<span class="lineno">  200 </span>                 -- ^ The shapes of the variant's field types.
<span class="lineno">  201 </span>                 -&gt; VariantShape (StructType ctx)
<span class="lineno">  202 </span>
<span class="lineno">  203 </span>-- TODO: Improve?
<span class="lineno">  204 </span>instance <span class="decl"><span class="nottickedoff">PP.Pretty (VariantShape tp)</span></span> where
<span class="lineno">  205 </span>  <span class="decl"><span class="nottickedoff">pretty = PP.viaShow</span></span>
<span class="lineno">  206 </span>
<span class="lineno">  207 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving instance Show (VariantShape tp)</span></span></span></span></span></span>
<span class="lineno">  208 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">ShowF VariantShape</span></span></span></span></span></span>
<span class="lineno">  209 </span>
<span class="lineno">  210 </span>-- | Return the `TypeShape` of `ty`.
<span class="lineno">  211 </span>--
<span class="lineno">  212 </span>-- It is guaranteed that the `tp :: CrucibleType` index of the resulting
<span class="lineno">  213 </span>-- `TypeShape` matches that returned by `tyToRepr`.
<span class="lineno">  214 </span>tyToShape :: M.Collection -&gt; M.Ty -&gt; Some TypeShape
<span class="lineno">  215 </span><span class="decl"><span class="istickedoff">tyToShape col = go</span>
<span class="lineno">  216 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  217 </span><span class="spaces">    </span><span class="istickedoff">go :: M.Ty -&gt; Some TypeShape</span>
<span class="lineno">  218 </span><span class="spaces">    </span><span class="istickedoff">go ty = case ty of</span>
<span class="lineno">  219 </span><span class="spaces">        </span><span class="istickedoff">M.TyBool -&gt; goPrim ty</span>
<span class="lineno">  220 </span><span class="spaces">        </span><span class="istickedoff">M.TyChar -&gt; goPrim ty</span>
<span class="lineno">  221 </span><span class="spaces">        </span><span class="istickedoff">M.TyInt _ -&gt; goPrim ty</span>
<span class="lineno">  222 </span><span class="spaces">        </span><span class="istickedoff">M.TyUint _ -&gt; goPrim ty</span>
<span class="lineno">  223 </span><span class="spaces">        </span><span class="istickedoff">M.TyTuple [] -&gt; goUnit <span class="nottickedoff">ty</span></span>
<span class="lineno">  224 </span><span class="spaces">        </span><span class="istickedoff">M.TyTuple tys -&gt; goTuple ty tys</span>
<span class="lineno">  225 </span><span class="spaces">        </span><span class="istickedoff">M.TyClosure tys -&gt; <span class="nottickedoff">goTuple ty tys</span></span>
<span class="lineno">  226 </span><span class="spaces">        </span><span class="istickedoff">M.TyFnDef _ -&gt; <span class="nottickedoff">goUnit ty</span></span>
<span class="lineno">  227 </span><span class="spaces">        </span><span class="istickedoff">M.TyArray ty' _ | Some shp &lt;- go ty' -&gt; Some $ ArrayShape ty ty' shp</span>
<span class="lineno">  228 </span><span class="spaces">        </span><span class="istickedoff">M.TyAdt nm _ _ -&gt; case Map.lookup nm (col ^. M.adts) of</span>
<span class="lineno">  229 </span><span class="spaces">            </span><span class="istickedoff">Just adt | Just ty' &lt;- reprTransparentFieldTy col adt -&gt;</span>
<span class="lineno">  230 </span><span class="spaces">                </span><span class="istickedoff">mapSome (TransparentShape ty) $ go ty'</span>
<span class="lineno">  231 </span><span class="spaces">            </span><span class="istickedoff">Just (M.Adt _ kind vs _ _ _ _) -&gt;</span>
<span class="lineno">  232 </span><span class="spaces">              </span><span class="istickedoff">case kind of</span>
<span class="lineno">  233 </span><span class="spaces">                </span><span class="istickedoff">M.Struct</span>
<span class="lineno">  234 </span><span class="spaces">                  </span><span class="istickedoff">|  [v] &lt;- vs</span>
<span class="lineno">  235 </span><span class="spaces">                  </span><span class="istickedoff">-&gt; goStruct ty (variantFieldTys v)</span>
<span class="lineno">  236 </span><span class="spaces">                  </span><span class="istickedoff">|  <span class="nottickedoff">otherwise</span></span>
<span class="lineno">  237 </span><span class="spaces">                  </span><span class="istickedoff">-&gt; <span class="nottickedoff">error $ &quot;tyToShape: Unexpected struct with multiple variants: &quot;</span></span>
<span class="lineno">  238 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">++ show (PP.pretty vs)</span></span>
<span class="lineno">  239 </span><span class="spaces">                </span><span class="istickedoff">M.Enum discrTy -&gt; goEnum ty discrTy vs</span>
<span class="lineno">  240 </span><span class="spaces">                </span><span class="istickedoff">M.Union -&gt; <span class="nottickedoff">error &quot;tyToShape: Union types NYI&quot;</span></span>
<span class="lineno">  241 </span><span class="spaces">            </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">error $ &quot;tyToShape: bad adt: &quot; ++ show ty</span></span>
<span class="lineno">  242 </span><span class="spaces">        </span><span class="istickedoff">M.TyRef ty' mutbl -&gt; goRef ty ty' mutbl</span>
<span class="lineno">  243 </span><span class="spaces">        </span><span class="istickedoff">M.TyRawPtr ty' mutbl -&gt; goRef ty ty' mutbl</span>
<span class="lineno">  244 </span><span class="spaces">        </span><span class="istickedoff">M.TyFnPtr sig -&gt; <span class="nottickedoff">goFnPtr ty sig</span></span>
<span class="lineno">  245 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">error $ &quot;tyToShape: &quot; ++ show ty ++ &quot; NYI&quot;</span></span>
<span class="lineno">  246 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  247 </span><span class="spaces">    </span><span class="istickedoff">goPrim :: M.Ty -&gt; Some TypeShape</span>
<span class="lineno">  248 </span><span class="spaces">    </span><span class="istickedoff">goPrim ty =</span>
<span class="lineno">  249 </span><span class="spaces">      </span><span class="istickedoff">case tyToRepr <span class="nottickedoff">col</span> ty of</span>
<span class="lineno">  250 </span><span class="spaces">        </span><span class="istickedoff">Left err -&gt; <span class="nottickedoff">error (&quot;goPrim: type &quot; ++ show ty ++ &quot; not supported: &quot; ++ err)</span></span>
<span class="lineno">  251 </span><span class="spaces">        </span><span class="istickedoff">Right (Some tpr)</span>
<span class="lineno">  252 </span><span class="spaces">          </span><span class="istickedoff">| AsBaseType btpr &lt;- asBaseType tpr -&gt; Some (PrimShape ty btpr)</span>
<span class="lineno">  253 </span><span class="spaces">          </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> -&gt; <span class="nottickedoff">error (&quot;goPrim: type &quot; ++ show ty ++ &quot; produced non-primitive type &quot; ++ show tpr)</span></span>
<span class="lineno">  254 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  255 </span><span class="spaces">    </span><span class="istickedoff">goUnit :: M.Ty -&gt; Some TypeShape</span>
<span class="lineno">  256 </span><span class="spaces">    </span><span class="istickedoff">goUnit ty = Some $ UnitShape <span class="nottickedoff">ty</span></span>
<span class="lineno">  257 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  258 </span><span class="spaces">    </span><span class="istickedoff">goTuple :: M.Ty -&gt; [M.Ty] -&gt; Some TypeShape</span>
<span class="lineno">  259 </span><span class="spaces">    </span><span class="istickedoff">goTuple ty tys = Some $ TupleShape ty (zipWith mkElem [0..] tys)</span>
<span class="lineno">  260 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  261 </span><span class="spaces">        </span><span class="istickedoff">mkElem i ty' | Some shp &lt;- go ty' = AgElemShape i 1 shp</span>
<span class="lineno">  262 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  263 </span><span class="spaces">    </span><span class="istickedoff">goStruct :: M.Ty -&gt; [M.Ty] -&gt; Some TypeShape</span>
<span class="lineno">  264 </span><span class="spaces">    </span><span class="istickedoff">goStruct ty tys | Some flds &lt;- goFields tys = Some $ StructShape ty <span class="nottickedoff">tys</span> flds</span>
<span class="lineno">  265 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  266 </span><span class="spaces">    </span><span class="istickedoff">-- The first Ty is the overall enum type, and the second Ty is the</span>
<span class="lineno">  267 </span><span class="spaces">    </span><span class="istickedoff">-- discriminant type.</span>
<span class="lineno">  268 </span><span class="spaces">    </span><span class="istickedoff">goEnum :: M.Ty -&gt; M.Ty -&gt; [M.Variant] -&gt; Some TypeShape</span>
<span class="lineno">  269 </span><span class="spaces">    </span><span class="istickedoff">goEnum ty discrTy vs</span>
<span class="lineno">  270 </span><span class="spaces">        </span><span class="istickedoff">| Some discrShp &lt;- go discrTy</span>
<span class="lineno">  271 </span><span class="spaces">        </span><span class="istickedoff">, Some variants &lt;- loop vs Empty</span>
<span class="lineno">  272 </span><span class="spaces">        </span><span class="istickedoff">= Some $ EnumShape ty variantTys variants discrTy discrShp</span>
<span class="lineno">  273 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  274 </span><span class="spaces">        </span><span class="istickedoff">variantTys = map variantFieldTys vs</span>
<span class="lineno">  275 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  276 </span><span class="spaces">        </span><span class="istickedoff">loop ::</span>
<span class="lineno">  277 </span><span class="spaces">          </span><span class="istickedoff">forall ctx.</span>
<span class="lineno">  278 </span><span class="spaces">          </span><span class="istickedoff">[M.Variant] -&gt;</span>
<span class="lineno">  279 </span><span class="spaces">          </span><span class="istickedoff">Assignment VariantShape ctx -&gt;</span>
<span class="lineno">  280 </span><span class="spaces">          </span><span class="istickedoff">Some (Assignment VariantShape)</span>
<span class="lineno">  281 </span><span class="spaces">        </span><span class="istickedoff">loop [] variants = Some variants</span>
<span class="lineno">  282 </span><span class="spaces">        </span><span class="istickedoff">loop (v':vs') variants</span>
<span class="lineno">  283 </span><span class="spaces">          </span><span class="istickedoff">| Some variant &lt;- goVariant v'</span>
<span class="lineno">  284 </span><span class="spaces">          </span><span class="istickedoff">= loop vs' (variants :&gt; variant)</span>
<span class="lineno">  285 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  286 </span><span class="spaces">    </span><span class="istickedoff">-- Process a single Variant in an enum type.</span>
<span class="lineno">  287 </span><span class="spaces">    </span><span class="istickedoff">goVariant :: M.Variant -&gt; Some VariantShape</span>
<span class="lineno">  288 </span><span class="spaces">    </span><span class="istickedoff">goVariant v</span>
<span class="lineno">  289 </span><span class="spaces">        </span><span class="istickedoff">| Some flds &lt;- goFields tys</span>
<span class="lineno">  290 </span><span class="spaces">        </span><span class="istickedoff">= Some $ VariantShape flds</span>
<span class="lineno">  291 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  292 </span><span class="spaces">        </span><span class="istickedoff">tys = variantFieldTys v</span>
<span class="lineno">  293 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  294 </span><span class="spaces">    </span><span class="istickedoff">goFields :: [M.Ty] -&gt; Some (Assignment FieldShape)</span>
<span class="lineno">  295 </span><span class="spaces">    </span><span class="istickedoff">goFields tys = loop tys Empty</span>
<span class="lineno">  296 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  297 </span><span class="spaces">        </span><span class="istickedoff">loop :: forall ctx. [M.Ty] -&gt; Assignment FieldShape ctx -&gt; Some (Assignment FieldShape)</span>
<span class="lineno">  298 </span><span class="spaces">        </span><span class="istickedoff">loop [] flds = Some flds</span>
<span class="lineno">  299 </span><span class="spaces">        </span><span class="istickedoff">loop (ty':tys') flds | Some fld &lt;- goField ty' = loop tys' (flds :&gt; fld)</span>
<span class="lineno">  300 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  301 </span><span class="spaces">    </span><span class="istickedoff">goField :: M.Ty -&gt; Some FieldShape</span>
<span class="lineno">  302 </span><span class="spaces">    </span><span class="istickedoff">goField ty | Some shp &lt;- go ty = case canInitialize col ty of</span>
<span class="lineno">  303 </span><span class="spaces">        </span><span class="istickedoff">True -&gt; Some $ ReqField shp</span>
<span class="lineno">  304 </span><span class="spaces">        </span><span class="istickedoff">False -&gt; Some $ OptField shp</span>
<span class="lineno">  305 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  306 </span><span class="spaces">    </span><span class="istickedoff">goRef :: M.Ty -&gt; M.Ty -&gt; M.Mutability -&gt; Some TypeShape</span>
<span class="lineno">  307 </span><span class="spaces">    </span><span class="istickedoff">goRef ty ty' mutbl</span>
<span class="lineno">  308 </span><span class="spaces">      </span><span class="istickedoff">| M.TySlice slicedTy &lt;- ty' =</span>
<span class="lineno">  309 </span><span class="spaces">        </span><span class="istickedoff">case tyToRepr <span class="nottickedoff">col</span> slicedTy of</span>
<span class="lineno">  310 </span><span class="spaces">          </span><span class="istickedoff">Left err -&gt; <span class="nottickedoff">error (&quot;goRef: &quot; ++ err)</span></span>
<span class="lineno">  311 </span><span class="spaces">          </span><span class="istickedoff">Right (Some tpr) -&gt; Some (SliceShape ty slicedTy <span class="nottickedoff">mutbl</span> tpr)</span>
<span class="lineno">  312 </span><span class="spaces">      </span><span class="istickedoff">| M.TyStr &lt;- ty'</span>
<span class="lineno">  313 </span><span class="spaces">      </span><span class="istickedoff">= Some $ SliceShape ty (M.TyUint M.B8) <span class="nottickedoff">mutbl</span> (BVRepr (knownNat @8))</span>
<span class="lineno">  314 </span><span class="spaces">    </span><span class="istickedoff">goRef ty ty' _ | <span class="tickonlyfalse">isUnsized ty'</span> = <span class="nottickedoff">error $</span></span>
<span class="lineno">  315 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">&quot;tyToShape: fat pointer &quot; ++ show ty ++ &quot; NYI&quot;</span></span>
<span class="lineno">  316 </span><span class="spaces">    </span><span class="istickedoff">goRef ty ty' mutbl =</span>
<span class="lineno">  317 </span><span class="spaces">      </span><span class="istickedoff">case tyToRepr col ty' of</span>
<span class="lineno">  318 </span><span class="spaces">        </span><span class="istickedoff">Left err -&gt; <span class="nottickedoff">error (&quot;goRef: &quot; ++ err)</span></span>
<span class="lineno">  319 </span><span class="spaces">        </span><span class="istickedoff">Right (Some tpr) -&gt; Some (RefShape ty ty' mutbl tpr)</span>
<span class="lineno">  320 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  321 </span><span class="spaces">    </span><span class="istickedoff">goFnPtr :: M.Ty -&gt; M.FnSig -&gt; Some TypeShape</span>
<span class="lineno">  322 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">goFnPtr ty (M.FnSig args ret _abi) =</span></span>
<span class="lineno">  323 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">case tyListToCtx col args $ \argsr  -&gt;</span></span>
<span class="lineno">  324 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">tyToReprCont col ret $ \retr -&gt;</span></span>
<span class="lineno">  325 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">Right (Some (FnPtrShape ty argsr retr)) of</span></span>
<span class="lineno">  326 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">Left err -&gt; error (&quot;goFnPtr: &quot; ++ err)</span></span>
<span class="lineno">  327 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">Right x -&gt; x</span></span>
<span class="lineno">  328 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  329 </span><span class="spaces">    </span><span class="istickedoff">-- Retrieve the field types in a variant. This used for both struct and enum</span>
<span class="lineno">  330 </span><span class="spaces">    </span><span class="istickedoff">-- variants.</span>
<span class="lineno">  331 </span><span class="spaces">    </span><span class="istickedoff">variantFieldTys :: M.Variant -&gt; [M.Ty]</span>
<span class="lineno">  332 </span><span class="spaces">    </span><span class="istickedoff">variantFieldTys v = v ^.. M.vfields . each . M.fty</span></span>
<span class="lineno">  333 </span>
<span class="lineno">  334 </span>-- | Given a `Ty` and the result of `tyToRepr ty`, produce a `TypeShape` with
<span class="lineno">  335 </span>-- the same index `tp`.  Raises an `error` if the `TypeRepr` doesn't match
<span class="lineno">  336 </span>-- `tyToRepr ty`.
<span class="lineno">  337 </span>tyToShapeEq :: HasCallStack =&gt; M.Collection -&gt; M.Ty -&gt; TypeRepr tp -&gt; TypeShape tp
<span class="lineno">  338 </span><span class="decl"><span class="istickedoff">tyToShapeEq col ty tpr | Some shp &lt;- tyToShape col ty =</span>
<span class="lineno">  339 </span><span class="spaces">    </span><span class="istickedoff">case testEquality (shapeType shp) tpr of</span>
<span class="lineno">  340 </span><span class="spaces">        </span><span class="istickedoff">Just Refl -&gt; shp</span>
<span class="lineno">  341 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">error $ &quot;tyToShapeEq: type &quot; ++ show ty ++</span></span>
<span class="lineno">  342 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot; does not have representation &quot; ++ show tpr ++</span></span>
<span class="lineno">  343 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot; (got &quot; ++ show (shapeType shp) ++ &quot; instead)&quot;</span></span></span>
<span class="lineno">  344 </span>
<span class="lineno">  345 </span>shapeType :: TypeShape tp -&gt; TypeRepr tp
<span class="lineno">  346 </span><span class="decl"><span class="istickedoff">shapeType = go</span>
<span class="lineno">  347 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  348 </span><span class="spaces">    </span><span class="istickedoff">go :: forall tp. TypeShape tp -&gt; TypeRepr tp</span>
<span class="lineno">  349 </span><span class="spaces">    </span><span class="istickedoff">go (UnitShape _) = UnitRepr</span>
<span class="lineno">  350 </span><span class="spaces">    </span><span class="istickedoff">go (PrimShape _ btpr) = baseToType btpr</span>
<span class="lineno">  351 </span><span class="spaces">    </span><span class="istickedoff">go (TupleShape _ _) = MirAggregateRepr</span>
<span class="lineno">  352 </span><span class="spaces">    </span><span class="istickedoff">go (ArrayShape _ _ shp) = MirVectorRepr $ shapeType shp</span>
<span class="lineno">  353 </span><span class="spaces">    </span><span class="istickedoff">go (StructShape _ _ flds) = StructRepr $ fmapFC fieldShapeType flds</span>
<span class="lineno">  354 </span><span class="spaces">    </span><span class="istickedoff">go (EnumShape _ _ variantTys _ discrShp) =</span>
<span class="lineno">  355 </span><span class="spaces">      </span><span class="istickedoff">RustEnumRepr (shapeType discrShp) (fmapFC variantShapeType variantTys)</span>
<span class="lineno">  356 </span><span class="spaces">    </span><span class="istickedoff">go (TransparentShape _ shp) = go shp</span>
<span class="lineno">  357 </span><span class="spaces">    </span><span class="istickedoff">go (RefShape _ _ _ _) = MirReferenceRepr</span>
<span class="lineno">  358 </span><span class="spaces">    </span><span class="istickedoff">go (SliceShape _ _ _ _) = MirSliceRepr</span>
<span class="lineno">  359 </span><span class="spaces">    </span><span class="istickedoff">go (FnPtrShape _ args ret) = <span class="nottickedoff">FunctionHandleRepr args ret</span></span></span>
<span class="lineno">  360 </span>
<span class="lineno">  361 </span>fieldShapeType :: FieldShape tp -&gt; TypeRepr tp
<span class="lineno">  362 </span><span class="decl"><span class="istickedoff">fieldShapeType (ReqField shp) = shapeType shp</span>
<span class="lineno">  363 </span><span class="spaces"></span><span class="istickedoff">fieldShapeType (OptField shp) = MaybeRepr $ shapeType shp</span></span>
<span class="lineno">  364 </span>
<span class="lineno">  365 </span>variantShapeType :: VariantShape tp -&gt; TypeRepr tp
<span class="lineno">  366 </span><span class="decl"><span class="istickedoff">variantShapeType (VariantShape flds) =</span>
<span class="lineno">  367 </span><span class="spaces">  </span><span class="istickedoff">StructRepr $ fmapFC fieldShapeType flds</span></span>
<span class="lineno">  368 </span>
<span class="lineno">  369 </span>shapeMirTy :: TypeShape tp -&gt; M.Ty
<span class="lineno">  370 </span><span class="decl"><span class="istickedoff">shapeMirTy (UnitShape ty) = <span class="nottickedoff">ty</span></span>
<span class="lineno">  371 </span><span class="spaces"></span><span class="istickedoff">shapeMirTy (PrimShape ty _) = ty</span>
<span class="lineno">  372 </span><span class="spaces"></span><span class="istickedoff">shapeMirTy (TupleShape ty _) = <span class="nottickedoff">ty</span></span>
<span class="lineno">  373 </span><span class="spaces"></span><span class="istickedoff">shapeMirTy (ArrayShape ty _ _) = ty</span>
<span class="lineno">  374 </span><span class="spaces"></span><span class="istickedoff">shapeMirTy (StructShape ty _ _) = ty</span>
<span class="lineno">  375 </span><span class="spaces"></span><span class="istickedoff">shapeMirTy (EnumShape ty _ _ _ _) = ty</span>
<span class="lineno">  376 </span><span class="spaces"></span><span class="istickedoff">shapeMirTy (TransparentShape ty _) = ty</span>
<span class="lineno">  377 </span><span class="spaces"></span><span class="istickedoff">shapeMirTy (RefShape ty _ _ _) = ty</span>
<span class="lineno">  378 </span><span class="spaces"></span><span class="istickedoff">shapeMirTy (SliceShape ty _ _ _) = <span class="nottickedoff">ty</span></span>
<span class="lineno">  379 </span><span class="spaces"></span><span class="istickedoff">shapeMirTy (FnPtrShape ty _ _) = <span class="nottickedoff">ty</span></span></span>
<span class="lineno">  380 </span>
<span class="lineno">  381 </span>fieldShapeMirTy :: FieldShape tp -&gt; M.Ty
<span class="lineno">  382 </span><span class="decl"><span class="nottickedoff">fieldShapeMirTy (ReqField shp) = shapeMirTy shp</span>
<span class="lineno">  383 </span><span class="spaces"></span><span class="nottickedoff">fieldShapeMirTy (OptField shp) = shapeMirTy shp</span></span>
<span class="lineno">  384 </span>
<span class="lineno">  385 </span>-- | This is to accomodate multiple Rust types mapping to the same Cryptol
<span class="lineno">  386 </span>-- type.  For example, if a Cryptol function expects [3][8], we could map
<span class="lineno">  387 </span>-- it to a Rust function that either expects `[u8;3]`, or `&amp;[u8]` with a
<span class="lineno">  388 </span>-- dynamic check that it has 3 elements.  The type parameter `a` is for the
<span class="lineno">  389 </span>-- the lengths of the slices---it will be either Cryptol's `Type` during
<span class="lineno">  390 </span>-- type checking, or `Intgeger`, once we instantiate a schema at a concrete
<span class="lineno">  391 </span>-- type.
<span class="lineno">  392 </span>data CryTermAdaptor a =
<span class="lineno">  393 </span>    NoAdapt                        -- ^ Use default translation
<span class="lineno">  394 </span>  | AdaptTuple [CryTermAdaptor a]  -- ^ Adapt a tuple
<span class="lineno">  395 </span>  | AdaptArray (CryTermAdaptor a)  -- ^ Adapt an array
<span class="lineno">  396 </span>  | AdaptDerefSlice a
<span class="lineno">  397 </span>    -- ^ A reference to a slice.  At the moment we only support slices of
<span class="lineno">  398 </span>    -- primitive types (i.e., no further references in the elements)
<span class="lineno">  399 </span>    -- so we don't need further adaptors.
<span class="lineno">  400 </span>    deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Functor</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Traversable</span></span></span></span></span></span></span></span>)
<span class="lineno">  401 </span>
<span class="lineno">  402 </span>isCryNoAdapt :: CryTermAdaptor a -&gt; Bool
<span class="lineno">  403 </span><span class="decl"><span class="nottickedoff">isCryNoAdapt ada =</span>
<span class="lineno">  404 </span><span class="spaces">  </span><span class="nottickedoff">case ada of</span>
<span class="lineno">  405 </span><span class="spaces">    </span><span class="nottickedoff">NoAdapt -&gt; True</span>
<span class="lineno">  406 </span><span class="spaces">    </span><span class="nottickedoff">_       -&gt; False</span></span>
<span class="lineno">  407 </span>
<span class="lineno">  408 </span>adaptTuple :: [CryTermAdaptor a] -&gt; CryTermAdaptor a
<span class="lineno">  409 </span><span class="decl"><span class="nottickedoff">adaptTuple as</span>
<span class="lineno">  410 </span><span class="spaces">  </span><span class="nottickedoff">| all isCryNoAdapt as = NoAdapt</span>
<span class="lineno">  411 </span><span class="spaces">  </span><span class="nottickedoff">| otherwise = AdaptTuple as</span></span>
<span class="lineno">  412 </span>
<span class="lineno">  413 </span>adaptArray :: CryTermAdaptor a -&gt; CryTermAdaptor a
<span class="lineno">  414 </span><span class="decl"><span class="nottickedoff">adaptArray a</span>
<span class="lineno">  415 </span><span class="spaces">  </span><span class="nottickedoff">| isCryNoAdapt a = NoAdapt</span>
<span class="lineno">  416 </span><span class="spaces">  </span><span class="nottickedoff">| otherwise = AdaptArray a</span></span>
<span class="lineno">  417 </span>
<span class="lineno">  418 </span>shapeToTerm :: forall tp m.
<span class="lineno">  419 </span>    (MonadIO m, MonadFail m) =&gt;
<span class="lineno">  420 </span>    SAW.SharedContext -&gt;
<span class="lineno">  421 </span>    TypeShape tp -&gt;
<span class="lineno">  422 </span>    m SAW.Term
<span class="lineno">  423 </span><span class="decl"><span class="istickedoff">shapeToTerm sc = shapeToTerm' sc NoAdapt</span></span>
<span class="lineno">  424 </span>
<span class="lineno">  425 </span>-- | Convert a type shape to a `Term` representing the type of values we'd
<span class="lineno">  426 </span>-- get for the type shape.  References to slices are mapped to vectors (the values
<span class="lineno">  427 </span>-- pointed to by the reference), and the `CryTermAnnot`, if any,
<span class="lineno">  428 </span>-- contains the information about the length of the vector.
<span class="lineno">  429 </span>shapeToTerm' :: forall tp m.
<span class="lineno">  430 </span>    (MonadIO m, MonadFail m) =&gt;
<span class="lineno">  431 </span>    SAW.SharedContext -&gt;
<span class="lineno">  432 </span>    CryTermAdaptor Integer -&gt;
<span class="lineno">  433 </span>    TypeShape tp -&gt;
<span class="lineno">  434 </span>    m SAW.Term
<span class="lineno">  435 </span><span class="decl"><span class="istickedoff">shapeToTerm' sc = go</span>
<span class="lineno">  436 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  437 </span><span class="spaces">    </span><span class="istickedoff">go :: forall tp'. CryTermAdaptor Integer -&gt; TypeShape tp' -&gt; m SAW.Term</span>
<span class="lineno">  438 </span><span class="spaces">    </span><span class="istickedoff">go NoAdapt (UnitShape _) = <span class="nottickedoff">liftIO $ SAW.scUnitType sc</span></span>
<span class="lineno">  439 </span><span class="spaces">    </span><span class="istickedoff">go NoAdapt (PrimShape _ BaseBoolRepr) = <span class="nottickedoff">liftIO $ SAW.scBoolType sc</span></span>
<span class="lineno">  440 </span><span class="spaces">    </span><span class="istickedoff">go NoAdapt (PrimShape _ (BaseBVRepr w)) = liftIO $ SAW.scBitvector sc (natValue w)</span>
<span class="lineno">  441 </span><span class="spaces">    </span><span class="istickedoff">go ada (TupleShape _ elems) = do</span>
<span class="lineno">  442 </span><span class="spaces">        </span><span class="istickedoff">subAda &lt;- case ada of</span>
<span class="lineno">  443 </span><span class="spaces">                    </span><span class="istickedoff">NoAdapt -&gt; pure (repeat NoAdapt)</span>
<span class="lineno">  444 </span><span class="spaces">                    </span><span class="istickedoff">AdaptTuple as -&gt; <span class="nottickedoff">pure as</span></span>
<span class="lineno">  445 </span><span class="spaces">                    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">fail &quot;Expected a tuple Cryptol adaptor&quot;</span></span>
<span class="lineno">  446 </span><span class="spaces">        </span><span class="istickedoff">tys &lt;- zipWithM goAgElem subAda elems</span>
<span class="lineno">  447 </span><span class="spaces">        </span><span class="istickedoff">liftIO $ SAW.scTupleType sc tys</span>
<span class="lineno">  448 </span><span class="spaces">    </span><span class="istickedoff">go ada (ArrayShape (M.TyArray _ n) _ shp) = do</span>
<span class="lineno">  449 </span><span class="spaces">        </span><span class="istickedoff">sub &lt;- case ada of</span>
<span class="lineno">  450 </span><span class="spaces">                 </span><span class="istickedoff">NoAdapt -&gt; pure NoAdapt</span>
<span class="lineno">  451 </span><span class="spaces">                 </span><span class="istickedoff">AdaptArray a -&gt; <span class="nottickedoff">pure a</span></span>
<span class="lineno">  452 </span><span class="spaces">                 </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">fail &quot;Expected an array Cryptol adaptor&quot;</span></span>
<span class="lineno">  453 </span><span class="spaces">        </span><span class="istickedoff">ty &lt;- go sub shp</span>
<span class="lineno">  454 </span><span class="spaces">        </span><span class="istickedoff">liftIO (mkVec n ty)</span>
<span class="lineno">  455 </span><span class="spaces">    </span><span class="istickedoff">go (AdaptDerefSlice n) (SliceShape _ elT M.Immut tpr) =</span>
<span class="lineno">  456 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">case asBaseType tpr of</span></span>
<span class="lineno">  457 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">AsBaseType bt -&gt;</span></span>
<span class="lineno">  458 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">do et &lt;- go NoAdapt (PrimShape elT bt)</span></span>
<span class="lineno">  459 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">liftIO (mkVec n et)</span></span>
<span class="lineno">  460 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">NotBaseType -&gt; fail &quot;We only support reference to slices with base type elements&quot;</span></span>
<span class="lineno">  461 </span><span class="spaces">    </span><span class="istickedoff">go _ada shp = <span class="nottickedoff">fail $ &quot;shapeToTerm: unsupported type &quot; ++ show (shapeType shp)</span></span>
<span class="lineno">  462 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  463 </span><span class="spaces">    </span><span class="istickedoff">mkVec :: Integral a =&gt; a -&gt; SAW.Term -&gt; IO SAW.Term</span>
<span class="lineno">  464 </span><span class="spaces">    </span><span class="istickedoff">mkVec n ty =</span>
<span class="lineno">  465 </span><span class="spaces">      </span><span class="istickedoff">do</span>
<span class="lineno">  466 </span><span class="spaces">        </span><span class="istickedoff">n' &lt;- SAW.scNat sc (fromIntegral n)</span>
<span class="lineno">  467 </span><span class="spaces">        </span><span class="istickedoff">SAW.scVecType sc n' ty</span>
<span class="lineno">  468 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  469 </span><span class="spaces">    </span><span class="istickedoff">goAgElem :: CryTermAdaptor Integer -&gt; AgElemShape -&gt; m SAW.Term</span>
<span class="lineno">  470 </span><span class="spaces">    </span><span class="istickedoff">goAgElem ada (AgElemShape _ _ shp) = go ada shp</span></span>
<span class="lineno">  471 </span>
<span class="lineno">  472 </span>
<span class="lineno">  473 </span>-- | A witness that a 'TypeShape' is equal to a 'PrimShape' that characterizes
<span class="lineno">  474 </span>-- a bitvector.
<span class="lineno">  475 </span>data IsBVShape (tp :: CrucibleType) where
<span class="lineno">  476 </span>  IsBVShape :: (1 &lt;= w)
<span class="lineno">  477 </span>            =&gt; M.Ty
<span class="lineno">  478 </span>            -&gt; NatRepr w
<span class="lineno">  479 </span>            -&gt; IsBVShape (BVType w)
<span class="lineno">  480 </span>
<span class="lineno">  481 </span>-- | Check that a 'TypeShape' is equal to a 'PrimShape' that characterizes a
<span class="lineno">  482 </span>-- bitvector. If so, return 'Just' a witness of that equality. Otherwise, return
<span class="lineno">  483 </span>-- 'Nothing'.
<span class="lineno">  484 </span>testBVShape :: TypeShape tp -&gt; Maybe (IsBVShape tp)
<span class="lineno">  485 </span><span class="decl"><span class="istickedoff">testBVShape shp =</span>
<span class="lineno">  486 </span><span class="spaces">  </span><span class="istickedoff">case shp of</span>
<span class="lineno">  487 </span><span class="spaces">    </span><span class="istickedoff">PrimShape ty (BaseBVRepr w)</span>
<span class="lineno">  488 </span><span class="spaces">      </span><span class="istickedoff">-&gt; Just $ IsBVShape ty w</span>
<span class="lineno">  489 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno">  490 </span>
<span class="lineno">  491 </span>-- | A witness that a 'TypeShape' is equal to a 'RefShape'.
<span class="lineno">  492 </span>data IsRefShape (tp :: CrucibleType) where
<span class="lineno">  493 </span>  IsRefShape :: M.Ty
<span class="lineno">  494 </span>             -- ^ The reference type
<span class="lineno">  495 </span>             -&gt; M.Ty
<span class="lineno">  496 </span>             -- ^ The pointee type
<span class="lineno">  497 </span>             -&gt; M.Mutability
<span class="lineno">  498 </span>             -- ^ Is the reference mutable or immutable?
<span class="lineno">  499 </span>             -&gt; TypeRepr tp
<span class="lineno">  500 </span>             -- ^ The Crucible representation of the pointee type
<span class="lineno">  501 </span>             -&gt; IsRefShape MirReferenceType
<span class="lineno">  502 </span>
<span class="lineno">  503 </span>-- | Check that a 'TypeShape' is equal to a 'RefShape'. If so, return 'Just' a
<span class="lineno">  504 </span>-- witness of that equality. Otherwise, return 'Nothing'.
<span class="lineno">  505 </span>testRefShape :: TypeShape tp -&gt; Maybe (IsRefShape tp)
<span class="lineno">  506 </span><span class="decl"><span class="istickedoff">testRefShape shp =</span>
<span class="lineno">  507 </span><span class="spaces">  </span><span class="istickedoff">case shp of</span>
<span class="lineno">  508 </span><span class="spaces">    </span><span class="istickedoff">RefShape ty ty' mut shp'</span>
<span class="lineno">  509 </span><span class="spaces">      </span><span class="istickedoff">-&gt; Just $ IsRefShape <span class="nottickedoff">ty</span> ty' <span class="nottickedoff">mut</span> shp'</span>
<span class="lineno">  510 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno">  511 </span>
<span class="lineno">  512 </span>-- | Construct the 'TypeShape's for a slice's reference and length types.
<span class="lineno">  513 </span>sliceShapeParts ::
<span class="lineno">  514 </span>    M.Ty -&gt;
<span class="lineno">  515 </span>    M.Mutability -&gt;
<span class="lineno">  516 </span>    TypeRepr tp -&gt;
<span class="lineno">  517 </span>    (TypeShape MirReferenceType, TypeShape UsizeType)
<span class="lineno">  518 </span><span class="decl"><span class="nottickedoff">sliceShapeParts referentTy refMutbl referentTpr =</span>
<span class="lineno">  519 </span><span class="spaces">    </span><span class="nottickedoff">( RefShape refTy referentTy refMutbl referentTpr</span>
<span class="lineno">  520 </span><span class="spaces">    </span><span class="nottickedoff">, PrimShape usizeTy BaseUsizeRepr</span>
<span class="lineno">  521 </span><span class="spaces">    </span><span class="nottickedoff">)</span>
<span class="lineno">  522 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  523 </span><span class="spaces">    </span><span class="nottickedoff">-- We use a ref (of the same mutability as `ty`) when possible, to</span>
<span class="lineno">  524 </span><span class="spaces">    </span><span class="nottickedoff">-- avoid unnecessary clobbering.</span>
<span class="lineno">  525 </span><span class="spaces">    </span><span class="nottickedoff">refTy = M.TyRef referentTy refMutbl</span>
<span class="lineno">  526 </span><span class="spaces">    </span><span class="nottickedoff">usizeTy = M.TyUint M.USize</span></span>
<span class="lineno">  527 </span>
<span class="lineno">  528 </span>
<span class="lineno">  529 </span>-- Helpers for manipulating `MirAggregate` with matching `AgElemShape`s.
<span class="lineno">  530 </span>
<span class="lineno">  531 </span>agCheckLengthsEq :: Monad m =&gt; Text -&gt; [AgElemShape] -&gt; [a] -&gt; m ()
<span class="lineno">  532 </span><span class="decl"><span class="istickedoff">agCheckLengthsEq loc elems xs =</span>
<span class="lineno">  533 </span><span class="spaces">  </span><span class="istickedoff">when (length elems /= length xs) $</span>
<span class="lineno">  534 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">panic loc</span></span>
<span class="lineno">  535 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">[Text.pack $ &quot;got &quot; ++ show (length elems) ++ &quot; elems, but &quot; ++ show (length xs) ++ &quot; xs&quot;]</span></span></span>
<span class="lineno">  536 </span>
<span class="lineno">  537 </span>agCheckKeysEq :: MonadFail m =&gt; String -&gt; [AgElemShape] -&gt; IntMap (MirAggregateEntry sym) -&gt; m ()
<span class="lineno">  538 </span><span class="decl"><span class="istickedoff">agCheckKeysEq loc elems m = do</span>
<span class="lineno">  539 </span><span class="spaces">  </span><span class="istickedoff">let mKeys = IntMap.keysSet m</span>
<span class="lineno">  540 </span><span class="spaces">  </span><span class="istickedoff">let elemsKeys = IntSet.fromList [fromIntegral off | AgElemShape off _ _ &lt;- elems]</span>
<span class="lineno">  541 </span><span class="spaces">  </span><span class="istickedoff">when (mKeys /= elemsKeys) $</span>
<span class="lineno">  542 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">if mKeys `IntSet.isSubsetOf` elemsKeys</span></span>
<span class="lineno">  543 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">then fail $ loc ++ &quot;: missing or uninitialized fields at offsets &quot;</span></span>
<span class="lineno">  544 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">++ show (elemsKeys IntSet.\\ mKeys)</span></span>
<span class="lineno">  545 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">else fail $ loc ++ &quot;: expected aggregate to have fields at offsets &quot;</span></span>
<span class="lineno">  546 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">++ show elemsKeys ++ &quot;, but got fields at offsets &quot; ++ show mKeys</span></span></span>
<span class="lineno">  547 </span>
<span class="lineno">  548 </span>-- | Build a `MirAggregate` with one entry for each provided `AgElemShape`.
<span class="lineno">  549 </span>-- The callback receives the offset, size, and type of the entry, along with
<span class="lineno">  550 </span>-- the corresponding value from @xs@ (which must have as many items as there
<span class="lineno">  551 </span>-- are `AgElemShape`s), and the result of the callback is used as the value for
<span class="lineno">  552 </span>-- the entry.
<span class="lineno">  553 </span>buildMirAggregate ::
<span class="lineno">  554 </span>  (IsSymInterface sym, Monad m, MonadFail m) =&gt;
<span class="lineno">  555 </span>  sym -&gt;
<span class="lineno">  556 </span>  [AgElemShape] -&gt;
<span class="lineno">  557 </span>  [a] -&gt;
<span class="lineno">  558 </span>  (forall tp. Word -&gt; Word -&gt; TypeShape tp -&gt; a -&gt; m (RegValue sym tp)) -&gt;
<span class="lineno">  559 </span>  m (MirAggregate sym)
<span class="lineno">  560 </span><span class="decl"><span class="istickedoff">buildMirAggregate sym elems xs f = do</span>
<span class="lineno">  561 </span><span class="spaces">  </span><span class="istickedoff">agCheckLengthsEq <span class="nottickedoff">&quot;buildMirAggregate&quot;</span> elems xs</span>
<span class="lineno">  562 </span><span class="spaces">  </span><span class="istickedoff">let totalSize = maximum (0 : [off + sz | AgElemShape off sz _ &lt;- elems])</span>
<span class="lineno">  563 </span><span class="spaces">  </span><span class="istickedoff">entries &lt;- forM (zip elems xs) $ \(AgElemShape off sz shp, x) -&gt; do</span>
<span class="lineno">  564 </span><span class="spaces">    </span><span class="istickedoff">rv &lt;- f <span class="nottickedoff">off</span> <span class="nottickedoff">sz</span> shp x</span>
<span class="lineno">  565 </span><span class="spaces">    </span><span class="istickedoff">let rvPart = W4.justPartExpr sym rv</span>
<span class="lineno">  566 </span><span class="spaces">    </span><span class="istickedoff">return (fromIntegral off, MirAggregateEntry sz (shapeType shp) rvPart)</span>
<span class="lineno">  567 </span><span class="spaces">  </span><span class="istickedoff">return $ MirAggregate totalSize (IntMap.fromList entries)</span></span>
<span class="lineno">  568 </span>
<span class="lineno">  569 </span>-- | Modify the value of each entry in a `MirAggregate`.  The callback gets the
<span class="lineno">  570 </span>-- offset, size, type, and value of the entry, and its result is stored as the
<span class="lineno">  571 </span>-- new value in the output.
<span class="lineno">  572 </span>traverseMirAggregate ::
<span class="lineno">  573 </span>  (IsSymInterface sym, Monad m, MonadFail m, MonadIO m) =&gt;
<span class="lineno">  574 </span>  sym -&gt;
<span class="lineno">  575 </span>  [AgElemShape] -&gt;
<span class="lineno">  576 </span>  MirAggregate sym -&gt;
<span class="lineno">  577 </span>  (forall tp. Word -&gt; Word -&gt; TypeShape tp -&gt; RegValue sym tp -&gt; m (RegValue sym tp)) -&gt;
<span class="lineno">  578 </span>  m (MirAggregate sym)
<span class="lineno">  579 </span><span class="decl"><span class="nottickedoff">traverseMirAggregate sym elems (MirAggregate totalSize m) f = do</span>
<span class="lineno">  580 </span><span class="spaces">  </span><span class="nottickedoff">agCheckKeysEq &quot;traverseMirAggregate&quot; elems m</span>
<span class="lineno">  581 </span><span class="spaces">  </span><span class="nottickedoff">m' &lt;- sequence $ IntMap.mergeWithKey</span>
<span class="lineno">  582 </span><span class="spaces">    </span><span class="nottickedoff">(\_off' (AgElemShape off _sz' shp) (MirAggregateEntry sz tpr rvPart) -&gt; Just $ do</span>
<span class="lineno">  583 </span><span class="spaces">        </span><span class="nottickedoff">Refl &lt;- case testEquality tpr (shapeType shp) of</span>
<span class="lineno">  584 </span><span class="spaces">            </span><span class="nottickedoff">Just pf -&gt; return pf</span>
<span class="lineno">  585 </span><span class="spaces">            </span><span class="nottickedoff">Nothing -&gt; fail $ &quot;traverseMirAggregate: ill-typed field value at offset &quot;</span>
<span class="lineno">  586 </span><span class="spaces">              </span><span class="nottickedoff">++ show off ++ &quot;: expected &quot; ++ show (shapeType shp) ++ &quot;, but got &quot; ++ show tpr</span>
<span class="lineno">  587 </span><span class="spaces">        </span><span class="nottickedoff">let rv = readMaybeType sym &quot;elem&quot; tpr rvPart</span>
<span class="lineno">  588 </span><span class="spaces">        </span><span class="nottickedoff">rv' &lt;- f off sz shp rv</span>
<span class="lineno">  589 </span><span class="spaces">        </span><span class="nottickedoff">let rvPart' = W4.justPartExpr sym rv'</span>
<span class="lineno">  590 </span><span class="spaces">        </span><span class="nottickedoff">return $ MirAggregateEntry sz tpr rvPart')</span>
<span class="lineno">  591 </span><span class="spaces">    </span><span class="nottickedoff">(\_ -&gt; panic &quot;traverseMirAggregate&quot; [&quot;mismatched keys in aggregate&quot;])</span>
<span class="lineno">  592 </span><span class="spaces">    </span><span class="nottickedoff">(\_ -&gt; panic &quot;traverseMirAggregate&quot; [&quot;mismatched keys in aggregate&quot;])</span>
<span class="lineno">  593 </span><span class="spaces">    </span><span class="nottickedoff">(IntMap.fromList [(fromIntegral off, e) | e@(AgElemShape off _ _) &lt;- elems])</span>
<span class="lineno">  594 </span><span class="spaces">    </span><span class="nottickedoff">m</span>
<span class="lineno">  595 </span><span class="spaces">  </span><span class="nottickedoff">return $ MirAggregate totalSize m'</span></span>
<span class="lineno">  596 </span>
<span class="lineno">  597 </span>-- | Extract values from a `MirAggregate`, one for each entry.  The callback
<span class="lineno">  598 </span>-- gets the offset, size, type, and value of the entry.  Callback results are
<span class="lineno">  599 </span>-- returned in a list in the same order as @elems@.
<span class="lineno">  600 </span>accessMirAggregate ::
<span class="lineno">  601 </span>  (IsSymInterface sym, Monad m, MonadFail m, MonadIO m) =&gt;
<span class="lineno">  602 </span>  sym -&gt;
<span class="lineno">  603 </span>  [AgElemShape] -&gt;
<span class="lineno">  604 </span>  MirAggregate sym -&gt;
<span class="lineno">  605 </span>  (forall tp. Word -&gt; Word -&gt; TypeShape tp -&gt; RegValue sym tp -&gt; m b) -&gt;
<span class="lineno">  606 </span>  m [b]
<span class="lineno">  607 </span><span class="decl"><span class="nottickedoff">accessMirAggregate sym elems ag f =</span>
<span class="lineno">  608 </span><span class="spaces">  </span><span class="nottickedoff">accessMirAggregate' sym elems [() | _ &lt;- elems] ag $</span>
<span class="lineno">  609 </span><span class="spaces">    </span><span class="nottickedoff">\off sz shp val () -&gt; f off sz shp val</span></span>
<span class="lineno">  610 </span>
<span class="lineno">  611 </span>-- | Extract values from a `MirAggregate`, one for each entry.  This is like
<span class="lineno">  612 </span>-- `accessMirAggregate`, but the callback also gets the value from the input
<span class="lineno">  613 </span>-- list @xs@ that corresponds to the current entry.
<span class="lineno">  614 </span>accessMirAggregate' ::
<span class="lineno">  615 </span>  (IsSymInterface sym, Monad m, MonadFail m, MonadIO m) =&gt;
<span class="lineno">  616 </span>  sym -&gt;
<span class="lineno">  617 </span>  [AgElemShape] -&gt;
<span class="lineno">  618 </span>  [a] -&gt;
<span class="lineno">  619 </span>  MirAggregate sym -&gt;
<span class="lineno">  620 </span>  (forall tp. Word -&gt; Word -&gt; TypeShape tp -&gt; RegValue sym tp -&gt; a -&gt; m b) -&gt;
<span class="lineno">  621 </span>  m [b]
<span class="lineno">  622 </span><span class="decl"><span class="istickedoff">accessMirAggregate' sym elems xs (MirAggregate _totalSize m) f = do</span>
<span class="lineno">  623 </span><span class="spaces">  </span><span class="istickedoff">agCheckLengthsEq <span class="nottickedoff">&quot;accessMirAggregate'&quot;</span> elems xs</span>
<span class="lineno">  624 </span><span class="spaces">  </span><span class="istickedoff">agCheckKeysEq <span class="nottickedoff">&quot;accessMirAggregate'&quot;</span> elems m</span>
<span class="lineno">  625 </span><span class="spaces">  </span><span class="istickedoff">forM (zip elems xs) $ \(AgElemShape off sz shp, x) -&gt; do</span>
<span class="lineno">  626 </span><span class="spaces">    </span><span class="istickedoff">MirAggregateEntry _sz' tpr rvPart &lt;-</span>
<span class="lineno">  627 </span><span class="spaces">      </span><span class="istickedoff">case IntMap.lookup (fromIntegral off) m of</span>
<span class="lineno">  628 </span><span class="spaces">        </span><span class="istickedoff">Just e -&gt; return e</span>
<span class="lineno">  629 </span><span class="spaces">        </span><span class="istickedoff">-- Should be impossible, since we checked above that the key sets</span>
<span class="lineno">  630 </span><span class="spaces">        </span><span class="istickedoff">-- match.</span>
<span class="lineno">  631 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">panic &quot;accessMirAggregate&quot;</span></span>
<span class="lineno">  632 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">[Text.pack $ &quot;missing MirAggregateEntry at offset &quot; ++ show off]</span></span>
<span class="lineno">  633 </span><span class="spaces">    </span><span class="istickedoff">Refl &lt;- case testEquality tpr (shapeType shp) of</span>
<span class="lineno">  634 </span><span class="spaces">      </span><span class="istickedoff">Just pf -&gt; return pf</span>
<span class="lineno">  635 </span><span class="spaces">      </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail $ &quot;accessMirAggregate: ill-typed field value at offset &quot;</span></span>
<span class="lineno">  636 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">++ show off ++ &quot;: expected &quot; ++ show (shapeType shp) ++ &quot;, but got &quot; ++ show tpr</span></span>
<span class="lineno">  637 </span><span class="spaces">    </span><span class="istickedoff">let rv = readMaybeType <span class="nottickedoff">sym</span> <span class="nottickedoff">&quot;elem&quot;</span> <span class="nottickedoff">tpr</span> rvPart</span>
<span class="lineno">  638 </span><span class="spaces">    </span><span class="istickedoff">f <span class="nottickedoff">off</span> <span class="nottickedoff">sz</span> shp rv x</span></span>
<span class="lineno">  639 </span>
<span class="lineno">  640 </span>-- | Zip together two `MirAggregate`s and extract values from them.  The callback
<span class="lineno">  641 </span>-- gets the offset, size, type, and the value at that offset in each aggregate.
<span class="lineno">  642 </span>-- Callback results are returned in a list in the same order as @elems@.
<span class="lineno">  643 </span>zipMirAggregates ::
<span class="lineno">  644 </span>  (IsSymInterface sym, Monad m, MonadFail m, MonadIO m) =&gt;
<span class="lineno">  645 </span>  sym -&gt;
<span class="lineno">  646 </span>  [AgElemShape] -&gt;
<span class="lineno">  647 </span>  MirAggregate sym -&gt;
<span class="lineno">  648 </span>  MirAggregate sym -&gt;
<span class="lineno">  649 </span>  (forall tp. Word -&gt; Word -&gt; TypeShape tp -&gt; RegValue sym tp -&gt; RegValue sym tp -&gt; m b) -&gt;
<span class="lineno">  650 </span>  m [b]
<span class="lineno">  651 </span><span class="decl"><span class="nottickedoff">zipMirAggregates sym elems (MirAggregate _totalSize1 m1) (MirAggregate _totalSize2 m2) f = do</span>
<span class="lineno">  652 </span><span class="spaces">  </span><span class="nottickedoff">agCheckKeysEq &quot;zipMirAggregates&quot; elems m1</span>
<span class="lineno">  653 </span><span class="spaces">  </span><span class="nottickedoff">agCheckKeysEq &quot;zipMirAggregates&quot; elems m2</span>
<span class="lineno">  654 </span><span class="spaces">  </span><span class="nottickedoff">-- We don't require the `totalSize`s of the two aggregates to match.</span>
<span class="lineno">  655 </span><span class="spaces">  </span><span class="nottickedoff">-- `buildMirAggregate` sets the `totalSize` to the end of the last field, but</span>
<span class="lineno">  656 </span><span class="spaces">  </span><span class="nottickedoff">-- other methods of building aggregates use the actual layout from rustc,</span>
<span class="lineno">  657 </span><span class="spaces">  </span><span class="nottickedoff">-- which may have extra padding at the end.</span>
<span class="lineno">  658 </span><span class="spaces">  </span><span class="nottickedoff">forM elems $ \(AgElemShape off sz shp) -&gt; do</span>
<span class="lineno">  659 </span><span class="spaces">    </span><span class="nottickedoff">MirAggregateEntry _sz1 tpr1 rvPart1 &lt;-</span>
<span class="lineno">  660 </span><span class="spaces">      </span><span class="nottickedoff">case IntMap.lookup (fromIntegral off) m1 of</span>
<span class="lineno">  661 </span><span class="spaces">        </span><span class="nottickedoff">Just e -&gt; return e</span>
<span class="lineno">  662 </span><span class="spaces">        </span><span class="nottickedoff">Nothing -&gt; panic &quot;zipMirAggregates&quot;</span>
<span class="lineno">  663 </span><span class="spaces">          </span><span class="nottickedoff">[Text.pack $ &quot;missing MirAggregateEntry at offset &quot; ++ show off</span>
<span class="lineno">  664 </span><span class="spaces">            </span><span class="nottickedoff">++ &quot; (in first input)&quot;]</span>
<span class="lineno">  665 </span><span class="spaces">    </span><span class="nottickedoff">MirAggregateEntry _sz2 tpr2 rvPart2 &lt;-</span>
<span class="lineno">  666 </span><span class="spaces">      </span><span class="nottickedoff">case IntMap.lookup (fromIntegral off) m2 of</span>
<span class="lineno">  667 </span><span class="spaces">        </span><span class="nottickedoff">Just e -&gt; return e</span>
<span class="lineno">  668 </span><span class="spaces">        </span><span class="nottickedoff">Nothing -&gt; panic &quot;zipMirAggregates&quot;</span>
<span class="lineno">  669 </span><span class="spaces">          </span><span class="nottickedoff">[Text.pack $ &quot;missing MirAggregateEntry at offset &quot; ++ show off</span>
<span class="lineno">  670 </span><span class="spaces">            </span><span class="nottickedoff">++ &quot; (in second input)&quot;]</span>
<span class="lineno">  671 </span><span class="spaces">    </span><span class="nottickedoff">Refl &lt;- case testEquality tpr1 (shapeType shp) of</span>
<span class="lineno">  672 </span><span class="spaces">      </span><span class="nottickedoff">Just pf -&gt; return pf</span>
<span class="lineno">  673 </span><span class="spaces">      </span><span class="nottickedoff">Nothing -&gt; fail $ &quot;zipMirAggregates: ill-typed field value at offset &quot;</span>
<span class="lineno">  674 </span><span class="spaces">        </span><span class="nottickedoff">++ show off ++ &quot;: expected &quot; ++ show (shapeType shp) ++ &quot;, but got &quot; ++ show tpr1</span>
<span class="lineno">  675 </span><span class="spaces">        </span><span class="nottickedoff">++ &quot; (in first aggregate)&quot;</span>
<span class="lineno">  676 </span><span class="spaces">    </span><span class="nottickedoff">Refl &lt;- case testEquality tpr2 (shapeType shp) of</span>
<span class="lineno">  677 </span><span class="spaces">      </span><span class="nottickedoff">Just pf -&gt; return pf</span>
<span class="lineno">  678 </span><span class="spaces">      </span><span class="nottickedoff">Nothing -&gt; fail $ &quot;zipMirAggregates: ill-typed field value at offset &quot;</span>
<span class="lineno">  679 </span><span class="spaces">        </span><span class="nottickedoff">++ show off ++ &quot;: expected &quot; ++ show (shapeType shp) ++ &quot;, but got &quot; ++ show tpr2</span>
<span class="lineno">  680 </span><span class="spaces">        </span><span class="nottickedoff">++ &quot; (in second aggregate)&quot;</span>
<span class="lineno">  681 </span><span class="spaces">    </span><span class="nottickedoff">let rv1 = readMaybeType sym &quot;elem&quot; tpr1 rvPart1</span>
<span class="lineno">  682 </span><span class="spaces">    </span><span class="nottickedoff">let rv2 = readMaybeType sym &quot;elem&quot; tpr2 rvPart2</span>
<span class="lineno">  683 </span><span class="spaces">    </span><span class="nottickedoff">f off sz shp rv1 rv2</span></span>
<span class="lineno">  684 </span>
<span class="lineno">  685 </span>
<span class="lineno">  686 </span>-- Misc helpers
<span class="lineno">  687 </span>
<span class="lineno">  688 </span>-- | Read the value out of a 'MaybeType' expression that is assumed to be
<span class="lineno">  689 </span>-- assigned to a value. If this assumption does not hold (i.e., if the value is
<span class="lineno">  690 </span>-- unassigned), then this function will raise an error.
<span class="lineno">  691 </span>readMaybeType ::
<span class="lineno">  692 </span>  IsSymInterface sym =&gt;
<span class="lineno">  693 </span>  sym -&gt;
<span class="lineno">  694 </span>  String -&gt;
<span class="lineno">  695 </span>  TypeRepr tp -&gt;
<span class="lineno">  696 </span>  RegValue sym (MaybeType tp) -&gt;
<span class="lineno">  697 </span>  RegValue sym tp
<span class="lineno">  698 </span><span class="decl"><span class="istickedoff">readMaybeType sym desc tpr rv =</span>
<span class="lineno">  699 </span><span class="spaces">  </span><span class="istickedoff">case readPartExprMaybe <span class="nottickedoff">sym</span> rv of</span>
<span class="lineno">  700 </span><span class="spaces">    </span><span class="istickedoff">Just x -&gt; x</span>
<span class="lineno">  701 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">error $ &quot;readMaybeType: accessed possibly-uninitialized &quot; ++ desc ++</span></span>
<span class="lineno">  702 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">&quot; of type &quot; ++ show tpr</span></span></span>
<span class="lineno">  703 </span>
<span class="lineno">  704 </span>readPartExprMaybe ::
<span class="lineno">  705 </span>  IsSymInterface sym =&gt;
<span class="lineno">  706 </span>  sym -&gt;
<span class="lineno">  707 </span>  W4.PartExpr (W4.Pred sym) a -&gt;
<span class="lineno">  708 </span>  Maybe a
<span class="lineno">  709 </span><span class="decl"><span class="istickedoff">readPartExprMaybe _sym W4.Unassigned = <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  710 </span><span class="spaces"></span><span class="istickedoff">readPartExprMaybe _sym (W4.PE p v)</span>
<span class="lineno">  711 </span><span class="spaces">  </span><span class="istickedoff">| Just True &lt;- W4.asConstantPred p = Just v</span>
<span class="lineno">  712 </span><span class="spaces">  </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> = <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno">  713 </span>
<span class="lineno">  714 </span>
<span class="lineno">  715 </span>$(pure [])
<span class="lineno">  716 </span>
<span class="lineno">  717 </span>instance TestEquality TypeShape where
<span class="lineno">  718 </span>  <span class="decl"><span class="istickedoff">testEquality =</span>
<span class="lineno">  719 </span><span class="spaces">    </span><span class="istickedoff">$<span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">(structuralTypeEquality</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno">  720 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">[t|TypeShape|]</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno">  721 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">[ (TypeApp (ConType [t|TypeShape|]) AnyType, [|testEquality|])</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno">  722 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">, (TypeApp (ConType [t|BaseTypeRepr|]) AnyType, [|testEquality|])</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno">  723 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">, (TypeApp (TypeApp (ConType [t|Assignment|]) AnyType) AnyType, [|testEquality|])</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno">  724 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">, (TypeApp (ConType [t|TypeRepr|]) AnyType, [|testEquality|])</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno">  725 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">, (TypeApp (ConType [t|CtxRepr|]) AnyType, [|testEquality|])</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno">  726 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">])</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno">  727 </span>
<span class="lineno">  728 </span>instance TestEquality VariantShape where
<span class="lineno">  729 </span>  <span class="decl"><span class="istickedoff">testEquality =</span>
<span class="lineno">  730 </span><span class="spaces">    </span><span class="istickedoff">$<span class="nottickedoff"><span class="istickedoff">(structuralTypeEquality</span></span></span>
<span class="lineno">  731 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">[t|VariantShape|]</span></span></span>
<span class="lineno">  732 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">[ (TypeApp (TypeApp (ConType [t|Assignment|]) AnyType) AnyType, [|testEquality|])</span></span></span>
<span class="lineno">  733 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">])</span></span></span></span>
<span class="lineno">  734 </span>
<span class="lineno">  735 </span>instance TestEquality FieldShape where
<span class="lineno">  736 </span>  <span class="decl"><span class="istickedoff">testEquality =</span>
<span class="lineno">  737 </span><span class="spaces">    </span><span class="istickedoff">$<span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">(structuralTypeEquality</span></span></span></span></span></span></span>
<span class="lineno">  738 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">[t|FieldShape|]</span></span></span></span></span></span></span>
<span class="lineno">  739 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">[ (TypeApp (ConType [t|TypeShape|]) AnyType, [|testEquality|])</span></span></span></span></span></span></span>
<span class="lineno">  740 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">])</span></span></span></span></span></span></span></span>
<span class="lineno">  741 </span>
<span class="lineno">  742 </span>instance <span class="decl"><span class="nottickedoff">Eq AgElemShape</span></span> where
<span class="lineno">  743 </span>    <span class="decl"><span class="istickedoff">AgElemShape off1 sz1 shp1 == AgElemShape off2 sz2 shp2 =</span>
<span class="lineno">  744 </span><span class="spaces">        </span><span class="istickedoff">off1 == off2</span>
<span class="lineno">  745 </span><span class="spaces">            </span><span class="istickedoff">&amp;&amp; sz1 == sz2</span>
<span class="lineno">  746 </span><span class="spaces">            </span><span class="istickedoff">&amp;&amp; isJust (testEquality shp1 shp2)</span></span>

</pre>
</body>
</html>
