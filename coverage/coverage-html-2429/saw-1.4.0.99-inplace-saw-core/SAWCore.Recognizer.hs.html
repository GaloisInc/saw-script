<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- |
<span class="lineno">    2 </span>Module      : SAWCore.Recognizer
<span class="lineno">    3 </span>Copyright   : Galois, Inc. 2012-2015
<span class="lineno">    4 </span>License     : BSD3
<span class="lineno">    5 </span>Maintainer  : jhendrix@galois.com
<span class="lineno">    6 </span>Stability   : experimental
<span class="lineno">    7 </span>Portability : non-portable (language extensions)
<span class="lineno">    8 </span>
<span class="lineno">    9 </span>Lightweight calculus for composing patterns as functions.
<span class="lineno">   10 </span>-}
<span class="lineno">   11 </span>
<span class="lineno">   12 </span>{-# LANGUAGE FlexibleInstances #-}
<span class="lineno">   13 </span>{-# LANGUAGE MultiParamTypeClasses #-}
<span class="lineno">   14 </span>{-# LANGUAGE PatternGuards #-}
<span class="lineno">   15 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">   16 </span>{-# LANGUAGE TypeOperators #-}
<span class="lineno">   17 </span>{-# LANGUAGE ViewPatterns #-}
<span class="lineno">   18 </span>
<span class="lineno">   19 </span>module SAWCore.Recognizer
<span class="lineno">   20 </span>  ( Recognizer
<span class="lineno">   21 </span>  , (&lt;:&gt;), (&lt;:), emptyl, endl
<span class="lineno">   22 </span>  , (:*:)(..)
<span class="lineno">   23 </span>  , asFTermF
<span class="lineno">   24 </span>
<span class="lineno">   25 </span>  , asGlobalDef
<span class="lineno">   26 </span>  , isGlobalDef
<span class="lineno">   27 </span>  , asApp
<span class="lineno">   28 </span>  , (&lt;@&gt;), (@&gt;), (&lt;@)
<span class="lineno">   29 </span>  , asApplyAll
<span class="lineno">   30 </span>  , asGlobalApply
<span class="lineno">   31 </span>  , asPairType
<span class="lineno">   32 </span>  , asPairValue
<span class="lineno">   33 </span>  , asPairSelector
<span class="lineno">   34 </span>  , asTupleType
<span class="lineno">   35 </span>  , asTupleValue
<span class="lineno">   36 </span>  , asTupleSelector
<span class="lineno">   37 </span>  , asRecordType
<span class="lineno">   38 </span>  , asRecordValue
<span class="lineno">   39 </span>  , asRecordSelector
<span class="lineno">   40 </span>  , asRecursorApp
<span class="lineno">   41 </span>  , asRecursorType
<span class="lineno">   42 </span>  , asNat
<span class="lineno">   43 </span>  , asBvNat
<span class="lineno">   44 </span>  , asUnsignedConcreteBv
<span class="lineno">   45 </span>  , asBvToNat
<span class="lineno">   46 </span>  , asUnsignedConcreteBvToNat
<span class="lineno">   47 </span>  , asArrayValue
<span class="lineno">   48 </span>  , asStringLit
<span class="lineno">   49 </span>  , asLambda
<span class="lineno">   50 </span>  , asLambdaList
<span class="lineno">   51 </span>  , asPi
<span class="lineno">   52 </span>  , asPiList
<span class="lineno">   53 </span>  , asLocalVar
<span class="lineno">   54 </span>  , asConstant
<span class="lineno">   55 </span>  , asVariable
<span class="lineno">   56 </span>  , asSort
<span class="lineno">   57 </span>  , asSortWithFlags
<span class="lineno">   58 </span>    -- * Prelude recognizers.
<span class="lineno">   59 </span>  , asBool
<span class="lineno">   60 </span>  , asBoolType
<span class="lineno">   61 </span>  , asNatType
<span class="lineno">   62 </span>  , asIntegerType
<span class="lineno">   63 </span>  , asIntModType
<span class="lineno">   64 </span>  , asBitvectorType
<span class="lineno">   65 </span>  , asVectorType
<span class="lineno">   66 </span>  , asVecType
<span class="lineno">   67 </span>  , isVecType
<span class="lineno">   68 </span>  , asMux
<span class="lineno">   69 </span>  , asEq
<span class="lineno">   70 </span>  , asEqTrue
<span class="lineno">   71 </span>  , asArrayType
<span class="lineno">   72 </span>  ) where
<span class="lineno">   73 </span>
<span class="lineno">   74 </span>import Control.Lens
<span class="lineno">   75 </span>import Control.Monad
<span class="lineno">   76 </span>import Data.List (foldl')
<span class="lineno">   77 </span>import Data.Map (Map)
<span class="lineno">   78 </span>import qualified Data.Map as Map
<span class="lineno">   79 </span>import qualified Data.Vector as V
<span class="lineno">   80 </span>import Data.Text (Text)
<span class="lineno">   81 </span>import Numeric.Natural (Natural)
<span class="lineno">   82 </span>
<span class="lineno">   83 </span>import SAWCore.Name
<span class="lineno">   84 </span>import SAWCore.Term.Functor
<span class="lineno">   85 </span>import SAWCore.Prelude.Constants
<span class="lineno">   86 </span>
<span class="lineno">   87 </span>data a :*: b = (:*:) a b
<span class="lineno">   88 </span>  deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>,<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span></span></span></span></span>,<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">   89 </span>
<span class="lineno">   90 </span>instance Field1 (a :*: b) (a' :*: b) a a' where
<span class="lineno">   91 </span>  <span class="decl"><span class="nottickedoff">_1 k (a :*: b) = indexed k (0 :: Int) a &lt;&amp;&gt; (:*: b)</span></span>
<span class="lineno">   92 </span>
<span class="lineno">   93 </span>instance Field2 (a :*: b) (a :*: b') b b' where
<span class="lineno">   94 </span>  <span class="decl"><span class="nottickedoff">_2 k (a :*: b) = (a :*:) &lt;$&gt; indexed k (1 :: Int) b</span></span>
<span class="lineno">   95 </span>
<span class="lineno">   96 </span>toPair :: a :*: b -&gt; (a, b)
<span class="lineno">   97 </span><span class="decl"><span class="nottickedoff">toPair (a :*: b) = (a, b)</span></span>
<span class="lineno">   98 </span>
<span class="lineno">   99 </span>type Recognizer t a = t -&gt; Maybe a
<span class="lineno">  100 </span>
<span class="lineno">  101 </span>-- | Recognizes the head and tail of a list, and returns head.
<span class="lineno">  102 </span>(&lt;:) :: Recognizer t a -&gt; Recognizer [t] () -&gt; Recognizer [t] a
<span class="lineno">  103 </span><span class="decl"><span class="nottickedoff">(&lt;:) f g (h:r) = do x &lt;- f h; _ &lt;- g r; return x</span>
<span class="lineno">  104 </span><span class="spaces"></span><span class="nottickedoff">(&lt;:) _ _ [] = Nothing</span></span>
<span class="lineno">  105 </span>
<span class="lineno">  106 </span>-- | Recognizes the head and tail of a list, and returns both.
<span class="lineno">  107 </span>(&lt;:&gt;) :: Recognizer t a -&gt; Recognizer [t] b -&gt; Recognizer [t] (a :*: b)
<span class="lineno">  108 </span><span class="decl"><span class="nottickedoff">(&lt;:&gt;) f g (h:r) = do x &lt;- f h; y &lt;- g r; return (x :*: y)</span>
<span class="lineno">  109 </span><span class="spaces"></span><span class="nottickedoff">(&lt;:&gt;) _ _ [] = Nothing</span></span>
<span class="lineno">  110 </span>
<span class="lineno">  111 </span>-- | Recognizes empty list
<span class="lineno">  112 </span>emptyl :: Recognizer [t] ()
<span class="lineno">  113 </span><span class="decl"><span class="nottickedoff">emptyl [] = return ()</span>
<span class="lineno">  114 </span><span class="spaces"></span><span class="nottickedoff">emptyl _ = Nothing</span></span>
<span class="lineno">  115 </span>
<span class="lineno">  116 </span>-- | Recognizes singleton list
<span class="lineno">  117 </span>endl :: Recognizer t a -&gt; Recognizer [t] a
<span class="lineno">  118 </span><span class="decl"><span class="nottickedoff">endl f = f &lt;: emptyl</span></span>
<span class="lineno">  119 </span>
<span class="lineno">  120 </span>asFTermF :: Recognizer Term (FlatTermF Term)
<span class="lineno">  121 </span><span class="decl"><span class="istickedoff">asFTermF (unwrapTermF -&gt; FTermF ftf) = return ftf</span>
<span class="lineno">  122 </span><span class="spaces"></span><span class="istickedoff">asFTermF _ = Nothing</span></span>
<span class="lineno">  123 </span>
<span class="lineno">  124 </span>asModuleIdentifier :: Recognizer Name Ident
<span class="lineno">  125 </span><span class="decl"><span class="istickedoff">asModuleIdentifier nm =</span>
<span class="lineno">  126 </span><span class="spaces">  </span><span class="istickedoff">case nameInfo nm of</span>
<span class="lineno">  127 </span><span class="spaces">    </span><span class="istickedoff">ModuleIdentifier ident -&gt; Just ident</span>
<span class="lineno">  128 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; Nothing</span></span>
<span class="lineno">  129 </span>
<span class="lineno">  130 </span>asGlobalDef :: Recognizer Term Ident
<span class="lineno">  131 </span><span class="decl"><span class="istickedoff">asGlobalDef t =</span>
<span class="lineno">  132 </span><span class="spaces">  </span><span class="istickedoff">case unwrapTermF t of</span>
<span class="lineno">  133 </span><span class="spaces">    </span><span class="istickedoff">Constant nm -&gt; asModuleIdentifier nm</span>
<span class="lineno">  134 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; Nothing</span></span>
<span class="lineno">  135 </span>
<span class="lineno">  136 </span>isGlobalDef :: Ident -&gt; Recognizer Term ()
<span class="lineno">  137 </span><span class="decl"><span class="istickedoff">isGlobalDef i t = do</span>
<span class="lineno">  138 </span><span class="spaces">  </span><span class="istickedoff">o &lt;- asGlobalDef t</span>
<span class="lineno">  139 </span><span class="spaces">  </span><span class="istickedoff">if i == o then Just () else Nothing</span></span>
<span class="lineno">  140 </span>
<span class="lineno">  141 </span>asApp :: Recognizer Term (Term, Term)
<span class="lineno">  142 </span><span class="decl"><span class="istickedoff">asApp (unwrapTermF -&gt; App x y) = return (x, y)</span>
<span class="lineno">  143 </span><span class="spaces"></span><span class="istickedoff">asApp _ = Nothing</span></span>
<span class="lineno">  144 </span>
<span class="lineno">  145 </span>(&lt;@&gt;) :: Recognizer Term a -&gt; Recognizer Term b -&gt; Recognizer Term (a :*: b)
<span class="lineno">  146 </span><span class="decl"><span class="istickedoff">(&lt;@&gt;) f g t = do</span>
<span class="lineno">  147 </span><span class="spaces">  </span><span class="istickedoff">(a,b) &lt;- asApp t</span>
<span class="lineno">  148 </span><span class="spaces">  </span><span class="istickedoff">liftM2 (:*:) (f a) (g b)</span></span>
<span class="lineno">  149 </span>
<span class="lineno">  150 </span>-- | Recognizes a function application, and returns argument.
<span class="lineno">  151 </span>(@&gt;) :: Recognizer Term () -&gt; Recognizer Term b -&gt; Recognizer Term b
<span class="lineno">  152 </span><span class="decl"><span class="istickedoff">(@&gt;) f g t = do</span>
<span class="lineno">  153 </span><span class="spaces">  </span><span class="istickedoff">(x, y) &lt;- asApp t</span>
<span class="lineno">  154 </span><span class="spaces">  </span><span class="istickedoff">liftM2 (const id) (f x) (g y)</span></span>
<span class="lineno">  155 </span>
<span class="lineno">  156 </span>-- | Recognizes a function application, and returns the function
<span class="lineno">  157 </span>(&lt;@) :: Recognizer Term a -&gt; Recognizer Term () -&gt; Recognizer Term a
<span class="lineno">  158 </span><span class="decl"><span class="istickedoff">(&lt;@) f g t = do</span>
<span class="lineno">  159 </span><span class="spaces">  </span><span class="istickedoff">(x, y) &lt;- asApp t</span>
<span class="lineno">  160 </span><span class="spaces">  </span><span class="istickedoff">liftM2 const (f x) (g y)</span></span>
<span class="lineno">  161 </span>
<span class="lineno">  162 </span>asApplyAll :: Term -&gt; (Term, [Term])
<span class="lineno">  163 </span><span class="decl"><span class="istickedoff">asApplyAll = go []</span>
<span class="lineno">  164 </span><span class="spaces">  </span><span class="istickedoff">where go xs t =</span>
<span class="lineno">  165 </span><span class="spaces">          </span><span class="istickedoff">case asApp t of</span>
<span class="lineno">  166 </span><span class="spaces">            </span><span class="istickedoff">Nothing -&gt; (t, xs)</span>
<span class="lineno">  167 </span><span class="spaces">            </span><span class="istickedoff">Just (t', x) -&gt; go (x : xs) t'</span></span>
<span class="lineno">  168 </span>
<span class="lineno">  169 </span>asGlobalApply :: Ident -&gt; Recognizer Term [Term]
<span class="lineno">  170 </span><span class="decl"><span class="istickedoff">asGlobalApply i t =</span>
<span class="lineno">  171 </span><span class="spaces">  </span><span class="istickedoff">do let (f, xs) = asApplyAll t</span>
<span class="lineno">  172 </span><span class="spaces">     </span><span class="istickedoff">isGlobalDef i f</span>
<span class="lineno">  173 </span><span class="spaces">     </span><span class="istickedoff">pure xs</span></span>
<span class="lineno">  174 </span>
<span class="lineno">  175 </span>asPairType :: Recognizer Term (Term, Term)
<span class="lineno">  176 </span><span class="decl"><span class="istickedoff">asPairType t = do</span>
<span class="lineno">  177 </span><span class="spaces">  </span><span class="istickedoff">ftf &lt;- asFTermF t</span>
<span class="lineno">  178 </span><span class="spaces">  </span><span class="istickedoff">case ftf of</span>
<span class="lineno">  179 </span><span class="spaces">    </span><span class="istickedoff">PairType x y -&gt; return (x, y)</span>
<span class="lineno">  180 </span><span class="spaces">    </span><span class="istickedoff">_            -&gt; Nothing</span></span>
<span class="lineno">  181 </span>
<span class="lineno">  182 </span>asPairValue :: Recognizer Term (Term, Term)
<span class="lineno">  183 </span><span class="decl"><span class="istickedoff">asPairValue t = do</span>
<span class="lineno">  184 </span><span class="spaces">  </span><span class="istickedoff">ftf &lt;- asFTermF t</span>
<span class="lineno">  185 </span><span class="spaces">  </span><span class="istickedoff">case ftf of</span>
<span class="lineno">  186 </span><span class="spaces">    </span><span class="istickedoff">PairValue x y -&gt; return (x, y)</span>
<span class="lineno">  187 </span><span class="spaces">    </span><span class="istickedoff">_             -&gt; Nothing</span></span>
<span class="lineno">  188 </span>
<span class="lineno">  189 </span>asPairSelector :: Recognizer Term (Term, Bool)
<span class="lineno">  190 </span><span class="decl"><span class="istickedoff">asPairSelector t = do</span>
<span class="lineno">  191 </span><span class="spaces">  </span><span class="istickedoff">ftf &lt;- asFTermF t</span>
<span class="lineno">  192 </span><span class="spaces">  </span><span class="istickedoff">case ftf of</span>
<span class="lineno">  193 </span><span class="spaces">    </span><span class="istickedoff">PairLeft x  -&gt; return (x, False)</span>
<span class="lineno">  194 </span><span class="spaces">    </span><span class="istickedoff">PairRight x -&gt; return (x, True)</span>
<span class="lineno">  195 </span><span class="spaces">    </span><span class="istickedoff">_           -&gt; Nothing</span></span>
<span class="lineno">  196 </span>
<span class="lineno">  197 </span>destTupleType :: Term -&gt; [Term]
<span class="lineno">  198 </span><span class="decl"><span class="nottickedoff">destTupleType t =</span>
<span class="lineno">  199 </span><span class="spaces">  </span><span class="nottickedoff">case unwrapTermF t of</span>
<span class="lineno">  200 </span><span class="spaces">    </span><span class="nottickedoff">FTermF (PairType x y) -&gt; x : destTupleType y</span>
<span class="lineno">  201 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; [t]</span></span>
<span class="lineno">  202 </span>
<span class="lineno">  203 </span>destTupleValue :: Term -&gt; [Term]
<span class="lineno">  204 </span><span class="decl"><span class="nottickedoff">destTupleValue t =</span>
<span class="lineno">  205 </span><span class="spaces">  </span><span class="nottickedoff">case unwrapTermF t of</span>
<span class="lineno">  206 </span><span class="spaces">    </span><span class="nottickedoff">FTermF (PairValue x y) -&gt; x : destTupleType y</span>
<span class="lineno">  207 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; [t]</span></span>
<span class="lineno">  208 </span>
<span class="lineno">  209 </span>asTupleType :: Recognizer Term [Term]
<span class="lineno">  210 </span><span class="decl"><span class="nottickedoff">asTupleType t =</span>
<span class="lineno">  211 </span><span class="spaces">  </span><span class="nottickedoff">do ftf &lt;- asFTermF t</span>
<span class="lineno">  212 </span><span class="spaces">     </span><span class="nottickedoff">case ftf of</span>
<span class="lineno">  213 </span><span class="spaces">       </span><span class="nottickedoff">UnitType     -&gt; Just []</span>
<span class="lineno">  214 </span><span class="spaces">       </span><span class="nottickedoff">PairType x y -&gt; Just (x : destTupleType y)</span>
<span class="lineno">  215 </span><span class="spaces">       </span><span class="nottickedoff">_            -&gt; Nothing</span></span>
<span class="lineno">  216 </span>
<span class="lineno">  217 </span>asTupleValue :: Recognizer Term [Term]
<span class="lineno">  218 </span><span class="decl"><span class="nottickedoff">asTupleValue t =</span>
<span class="lineno">  219 </span><span class="spaces">  </span><span class="nottickedoff">do ftf &lt;- asFTermF t</span>
<span class="lineno">  220 </span><span class="spaces">     </span><span class="nottickedoff">case ftf of</span>
<span class="lineno">  221 </span><span class="spaces">       </span><span class="nottickedoff">UnitValue     -&gt; Just []</span>
<span class="lineno">  222 </span><span class="spaces">       </span><span class="nottickedoff">PairValue x y -&gt; Just (x : destTupleValue y)</span>
<span class="lineno">  223 </span><span class="spaces">       </span><span class="nottickedoff">_             -&gt; Nothing</span></span>
<span class="lineno">  224 </span>
<span class="lineno">  225 </span>asTupleSelector :: Recognizer Term (Term, Int)
<span class="lineno">  226 </span><span class="decl"><span class="nottickedoff">asTupleSelector t = do</span>
<span class="lineno">  227 </span><span class="spaces">  </span><span class="nottickedoff">ftf &lt;- asFTermF t</span>
<span class="lineno">  228 </span><span class="spaces">  </span><span class="nottickedoff">case ftf of</span>
<span class="lineno">  229 </span><span class="spaces">    </span><span class="nottickedoff">PairLeft x  -&gt; return (x, 1)</span>
<span class="lineno">  230 </span><span class="spaces">    </span><span class="nottickedoff">PairRight y -&gt; do (x, i) &lt;- asTupleSelector y; return (x, i+1)</span>
<span class="lineno">  231 </span><span class="spaces">    </span><span class="nottickedoff">_           -&gt; Nothing</span></span>
<span class="lineno">  232 </span>
<span class="lineno">  233 </span>asRecordType :: Recognizer Term (Map FieldName Term)
<span class="lineno">  234 </span><span class="decl"><span class="istickedoff">asRecordType t = do</span>
<span class="lineno">  235 </span><span class="spaces">  </span><span class="istickedoff">ftf &lt;- asFTermF t</span>
<span class="lineno">  236 </span><span class="spaces">  </span><span class="istickedoff">case ftf of</span>
<span class="lineno">  237 </span><span class="spaces">    </span><span class="istickedoff">RecordType elems -&gt; return $ Map.fromList elems</span>
<span class="lineno">  238 </span><span class="spaces">    </span><span class="istickedoff">_                -&gt; Nothing</span></span>
<span class="lineno">  239 </span>
<span class="lineno">  240 </span>asRecordValue :: Recognizer Term (Map FieldName Term)
<span class="lineno">  241 </span><span class="decl"><span class="istickedoff">asRecordValue t = do</span>
<span class="lineno">  242 </span><span class="spaces">  </span><span class="istickedoff">ftf &lt;- asFTermF t</span>
<span class="lineno">  243 </span><span class="spaces">  </span><span class="istickedoff">case ftf of</span>
<span class="lineno">  244 </span><span class="spaces">    </span><span class="istickedoff">RecordValue elems -&gt; return $ Map.fromList elems</span>
<span class="lineno">  245 </span><span class="spaces">    </span><span class="istickedoff">_                 -&gt; Nothing</span></span>
<span class="lineno">  246 </span>
<span class="lineno">  247 </span>asRecordSelector :: Recognizer Term (Term, FieldName)
<span class="lineno">  248 </span><span class="decl"><span class="istickedoff">asRecordSelector t = do</span>
<span class="lineno">  249 </span><span class="spaces">  </span><span class="istickedoff">RecordProj u s &lt;- asFTermF t</span>
<span class="lineno">  250 </span><span class="spaces">  </span><span class="istickedoff">return (u, <span class="nottickedoff">s</span>)</span></span>
<span class="lineno">  251 </span>
<span class="lineno">  252 </span>asRecursorType :: Recognizer Term (Name, [Term], Term, Term)
<span class="lineno">  253 </span><span class="decl"><span class="istickedoff">asRecursorType t =</span>
<span class="lineno">  254 </span><span class="spaces">  </span><span class="istickedoff">do RecursorType d ps motive motive_ty &lt;- asFTermF t</span>
<span class="lineno">  255 </span><span class="spaces">     </span><span class="istickedoff">return (<span class="nottickedoff">d</span>,<span class="nottickedoff">ps</span>,motive,motive_ty)</span></span>
<span class="lineno">  256 </span>
<span class="lineno">  257 </span>asRecursorApp :: Recognizer Term (Term, CompiledRecursor Term, [Term])
<span class="lineno">  258 </span><span class="decl"><span class="istickedoff">asRecursorApp t =</span>
<span class="lineno">  259 </span><span class="spaces">  </span><span class="istickedoff">do RecursorApp rc ixs &lt;- asFTermF t</span>
<span class="lineno">  260 </span><span class="spaces">     </span><span class="istickedoff">Recursor crec &lt;- asFTermF rc</span>
<span class="lineno">  261 </span><span class="spaces">     </span><span class="istickedoff">return (rc, crec, ixs)</span></span>
<span class="lineno">  262 </span>
<span class="lineno">  263 </span>asNat :: Recognizer Term Natural
<span class="lineno">  264 </span><span class="decl"><span class="istickedoff">asNat (unwrapTermF -&gt; FTermF (NatLit i)) = pure i</span>
<span class="lineno">  265 </span><span class="spaces"></span><span class="istickedoff">asNat (asGlobalApply preludeZeroIdent -&gt; Just []) = pure 0</span>
<span class="lineno">  266 </span><span class="spaces"></span><span class="istickedoff">asNat (asGlobalApply preludeSuccIdent -&gt; Just [asNat -&gt; Just i]) = <span class="nottickedoff">pure (i+1)</span></span>
<span class="lineno">  267 </span><span class="spaces"></span><span class="istickedoff">asNat _ = Nothing</span></span>
<span class="lineno">  268 </span>
<span class="lineno">  269 </span>-- | Recognize an application of @bvNat@
<span class="lineno">  270 </span>asBvNat :: Recognizer Term (Term, Term)
<span class="lineno">  271 </span><span class="decl"><span class="nottickedoff">asBvNat = fmap toPair . ((isGlobalDef &quot;Prelude.bvNat&quot; @&gt; return) &lt;@&gt; return)</span></span>
<span class="lineno">  272 </span>
<span class="lineno">  273 </span>-- | Try to convert the given term of type @Vec w Bool@ to a concrete 'Natural',
<span class="lineno">  274 </span>-- taking into account nat, bitvector and integer conversions (treating all
<span class="lineno">  275 </span>-- bitvectors as unsigned)
<span class="lineno">  276 </span>asUnsignedConcreteBv :: Recognizer Term Natural
<span class="lineno">  277 </span><span class="decl"><span class="istickedoff">asUnsignedConcreteBv (asApplyAll -&gt; (asGlobalDef -&gt; Just &quot;Prelude.bvNat&quot;,</span>
<span class="lineno">  278 </span><span class="spaces">                                     </span><span class="istickedoff">[asNat -&gt; Just n, v])) =</span>
<span class="lineno">  279 </span><span class="spaces">  </span><span class="istickedoff">(`mod` (2 ^ n)) &lt;$&gt; asUnsignedConcreteBvToNat v</span>
<span class="lineno">  280 </span><span class="spaces"></span><span class="istickedoff">asUnsignedConcreteBv (asArrayValue -&gt; Just (asBoolType -&gt; Just _,</span>
<span class="lineno">  281 </span><span class="spaces">                                            </span><span class="istickedoff">mapM asBool -&gt; Just bits)) =</span>
<span class="lineno">  282 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">return $ foldl' (\n bit -&gt; if bit then 2*n+1 else 2*n) 0 bits</span></span>
<span class="lineno">  283 </span><span class="spaces"></span><span class="istickedoff">asUnsignedConcreteBv (asApplyAll -&gt; (asGlobalDef -&gt; Just &quot;Prelude.intToBv&quot;,</span>
<span class="lineno">  284 </span><span class="spaces">                                     </span><span class="istickedoff">[asNat -&gt; Just n, i])) = <span class="nottickedoff">case i of</span></span>
<span class="lineno">  285 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">(asApplyAll -&gt; (asGlobalDef -&gt; Just &quot;Prelude.natToInt&quot;, [v])) -&gt;</span></span>
<span class="lineno">  286 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(`mod` (2 ^ n)) &lt;$&gt; asUnsignedConcreteBvToNat v</span></span>
<span class="lineno">  287 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">(asApplyAll -&gt; (asGlobalDef -&gt; Just &quot;Prelude.bvToInt&quot;, [_, bv])) -&gt;</span></span>
<span class="lineno">  288 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">asUnsignedConcreteBv bv</span></span>
<span class="lineno">  289 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; Nothing</span></span>
<span class="lineno">  290 </span><span class="spaces"></span><span class="istickedoff">asUnsignedConcreteBv _ = Nothing</span></span>
<span class="lineno">  291 </span>
<span class="lineno">  292 </span>-- | Recognize an application of @bvToNat@
<span class="lineno">  293 </span>asBvToNat :: Recognizer Term (Term, Term)
<span class="lineno">  294 </span><span class="decl"><span class="nottickedoff">asBvToNat = fmap toPair . ((isGlobalDef &quot;Prelude.bvToNat&quot; @&gt; return) &lt;@&gt; return)</span></span>
<span class="lineno">  295 </span>
<span class="lineno">  296 </span>-- | Try to convert the given term of type @Nat@ to a concrete 'Natural',
<span class="lineno">  297 </span>-- taking into account nat, bitvector and integer conversions (treating all
<span class="lineno">  298 </span>-- bitvectors as unsigned)
<span class="lineno">  299 </span>asUnsignedConcreteBvToNat :: Recognizer Term Natural
<span class="lineno">  300 </span><span class="decl"><span class="istickedoff">asUnsignedConcreteBvToNat (asNat -&gt; Just v) = return v</span>
<span class="lineno">  301 </span><span class="spaces"></span><span class="istickedoff">asUnsignedConcreteBvToNat (asBvToNat -&gt; Just (_, bv)) = <span class="nottickedoff">asUnsignedConcreteBv bv</span></span>
<span class="lineno">  302 </span><span class="spaces"></span><span class="istickedoff">asUnsignedConcreteBvToNat (asApplyAll -&gt; (asGlobalDef -&gt; Just &quot;Prelude.intToNat&quot;,</span>
<span class="lineno">  303 </span><span class="spaces">                                        </span><span class="istickedoff">[i])) = <span class="nottickedoff">case i of</span></span>
<span class="lineno">  304 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">(asApplyAll -&gt; (asGlobalDef -&gt; Just &quot;Prelude.natToInt&quot;, [v])) -&gt;</span></span>
<span class="lineno">  305 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">asUnsignedConcreteBvToNat v</span></span>
<span class="lineno">  306 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">(asApplyAll -&gt; (asGlobalDef -&gt; Just &quot;Prelude.bvToInt&quot;, [_, bv])) -&gt;</span></span>
<span class="lineno">  307 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">asUnsignedConcreteBv bv</span></span>
<span class="lineno">  308 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; Nothing</span></span>
<span class="lineno">  309 </span><span class="spaces"></span><span class="istickedoff">asUnsignedConcreteBvToNat _ = <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno">  310 </span>
<span class="lineno">  311 </span>asArrayValue :: Recognizer Term (Term, [Term])
<span class="lineno">  312 </span><span class="decl"><span class="istickedoff">asArrayValue (unwrapTermF -&gt; FTermF (ArrayValue tp tms)) =</span>
<span class="lineno">  313 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">return (tp, V.toList tms)</span></span>
<span class="lineno">  314 </span><span class="spaces"></span><span class="istickedoff">asArrayValue _ = Nothing</span></span>
<span class="lineno">  315 </span>
<span class="lineno">  316 </span>asStringLit :: Recognizer Term Text
<span class="lineno">  317 </span><span class="decl"><span class="nottickedoff">asStringLit t = do StringLit i &lt;- asFTermF t; return i</span></span>
<span class="lineno">  318 </span>
<span class="lineno">  319 </span>asLambda :: Recognizer Term (LocalName, Term, Term)
<span class="lineno">  320 </span><span class="decl"><span class="istickedoff">asLambda (unwrapTermF -&gt; Lambda s ty body) = return (s, ty, body)</span>
<span class="lineno">  321 </span><span class="spaces"></span><span class="istickedoff">asLambda _ = Nothing</span></span>
<span class="lineno">  322 </span>
<span class="lineno">  323 </span>asLambdaList :: Term -&gt; ([(LocalName, Term)], Term)
<span class="lineno">  324 </span><span class="decl"><span class="istickedoff">asLambdaList = go []</span>
<span class="lineno">  325 </span><span class="spaces">  </span><span class="istickedoff">where go r (asLambda -&gt; Just (nm,tp,rhs)) = go ((nm,tp):r) rhs</span>
<span class="lineno">  326 </span><span class="spaces">        </span><span class="istickedoff">go r rhs = (reverse r, rhs)</span></span>
<span class="lineno">  327 </span>
<span class="lineno">  328 </span>asPi :: Recognizer Term (LocalName, Term, Term)
<span class="lineno">  329 </span><span class="decl"><span class="istickedoff">asPi (unwrapTermF -&gt; Pi nm tp body) = return (nm, tp, body)</span>
<span class="lineno">  330 </span><span class="spaces"></span><span class="istickedoff">asPi _ = Nothing</span></span>
<span class="lineno">  331 </span>
<span class="lineno">  332 </span>-- | Decomposes a term into a list of pi bindings, followed by a right
<span class="lineno">  333 </span>-- term that is not a pi binding.
<span class="lineno">  334 </span>asPiList :: Term -&gt; ([(LocalName, Term)], Term)
<span class="lineno">  335 </span><span class="decl"><span class="istickedoff">asPiList = go []</span>
<span class="lineno">  336 </span><span class="spaces">  </span><span class="istickedoff">where go r (asPi -&gt; Just (nm,tp,rhs)) = go ((nm,tp):r) rhs</span>
<span class="lineno">  337 </span><span class="spaces">        </span><span class="istickedoff">go r rhs = (reverse r, rhs)</span></span>
<span class="lineno">  338 </span>
<span class="lineno">  339 </span>asLocalVar :: Recognizer Term DeBruijnIndex
<span class="lineno">  340 </span><span class="decl"><span class="nottickedoff">asLocalVar (unwrapTermF -&gt; LocalVar i) = return i</span>
<span class="lineno">  341 </span><span class="spaces"></span><span class="nottickedoff">asLocalVar _ = Nothing</span></span>
<span class="lineno">  342 </span>
<span class="lineno">  343 </span>asConstant :: Recognizer Term Name
<span class="lineno">  344 </span><span class="decl"><span class="istickedoff">asConstant (unwrapTermF -&gt; Constant nm) = pure nm</span>
<span class="lineno">  345 </span><span class="spaces"></span><span class="istickedoff">asConstant _ = Nothing</span></span>
<span class="lineno">  346 </span>
<span class="lineno">  347 </span>asVariable :: Recognizer Term (ExtCns Term)
<span class="lineno">  348 </span><span class="decl"><span class="istickedoff">asVariable t =</span>
<span class="lineno">  349 </span><span class="spaces">  </span><span class="istickedoff">case unwrapTermF t of</span>
<span class="lineno">  350 </span><span class="spaces">    </span><span class="istickedoff">Variable ec -&gt; pure ec</span>
<span class="lineno">  351 </span><span class="spaces">    </span><span class="istickedoff">_           -&gt; Nothing</span></span>
<span class="lineno">  352 </span>
<span class="lineno">  353 </span>asSort :: Recognizer Term Sort
<span class="lineno">  354 </span><span class="decl"><span class="istickedoff">asSort t = do</span>
<span class="lineno">  355 </span><span class="spaces">  </span><span class="istickedoff">ftf &lt;- asFTermF t</span>
<span class="lineno">  356 </span><span class="spaces">  </span><span class="istickedoff">case ftf of</span>
<span class="lineno">  357 </span><span class="spaces">    </span><span class="istickedoff">Sort s _ -&gt; return s</span>
<span class="lineno">  358 </span><span class="spaces">    </span><span class="istickedoff">_      -&gt; Nothing</span></span>
<span class="lineno">  359 </span>
<span class="lineno">  360 </span>asSortWithFlags :: Recognizer Term (Sort, SortFlags)
<span class="lineno">  361 </span><span class="decl"><span class="nottickedoff">asSortWithFlags t = do</span>
<span class="lineno">  362 </span><span class="spaces">  </span><span class="nottickedoff">ftf &lt;- asFTermF t</span>
<span class="lineno">  363 </span><span class="spaces">  </span><span class="nottickedoff">case ftf of</span>
<span class="lineno">  364 </span><span class="spaces">    </span><span class="nottickedoff">Sort s h -&gt; return (s, h)</span>
<span class="lineno">  365 </span><span class="spaces">    </span><span class="nottickedoff">_      -&gt; Nothing</span></span>
<span class="lineno">  366 </span>
<span class="lineno">  367 </span>
<span class="lineno">  368 </span>
<span class="lineno">  369 </span>-- | Returns term as a constant Boolean if it is one.
<span class="lineno">  370 </span>asBool :: Recognizer Term Bool
<span class="lineno">  371 </span><span class="decl"><span class="istickedoff">asBool (isGlobalDef &quot;Prelude.True&quot; -&gt; Just ()) = <span class="nottickedoff">return True</span></span>
<span class="lineno">  372 </span><span class="spaces"></span><span class="istickedoff">asBool (isGlobalDef &quot;Prelude.False&quot; -&gt; Just ()) = <span class="nottickedoff">return False</span></span>
<span class="lineno">  373 </span><span class="spaces"></span><span class="istickedoff">asBool _ = Nothing</span></span>
<span class="lineno">  374 </span>
<span class="lineno">  375 </span>asBoolType :: Recognizer Term ()
<span class="lineno">  376 </span><span class="decl"><span class="istickedoff">asBoolType = isGlobalDef &quot;Prelude.Bool&quot;</span></span>
<span class="lineno">  377 </span>
<span class="lineno">  378 </span>asNatType :: Recognizer Term ()
<span class="lineno">  379 </span><span class="decl"><span class="nottickedoff">asNatType (asConstant -&gt; Just o)</span>
<span class="lineno">  380 </span><span class="spaces">  </span><span class="nottickedoff">| nameInfo o == ModuleIdentifier preludeNatIdent = pure ()</span>
<span class="lineno">  381 </span><span class="spaces"></span><span class="nottickedoff">asNatType _ = Nothing</span></span>
<span class="lineno">  382 </span>
<span class="lineno">  383 </span>asIntegerType :: Recognizer Term ()
<span class="lineno">  384 </span><span class="decl"><span class="nottickedoff">asIntegerType = isGlobalDef &quot;Prelude.Integer&quot;</span></span>
<span class="lineno">  385 </span>
<span class="lineno">  386 </span>asIntModType :: Recognizer Term Natural
<span class="lineno">  387 </span><span class="decl"><span class="nottickedoff">asIntModType = isGlobalDef &quot;Prelude.IntMod&quot; @&gt; asNat</span></span>
<span class="lineno">  388 </span>
<span class="lineno">  389 </span>asVectorType :: Recognizer Term (Term, Term)
<span class="lineno">  390 </span><span class="decl"><span class="nottickedoff">asVectorType = fmap toPair . ((isGlobalDef &quot;Prelude.Vec&quot; @&gt; return) &lt;@&gt; return)</span></span>
<span class="lineno">  391 </span>
<span class="lineno">  392 </span>isVecType :: Recognizer Term a -&gt; Recognizer Term (Natural :*: a)
<span class="lineno">  393 </span><span class="decl"><span class="istickedoff">isVecType tp = (isGlobalDef &quot;Prelude.Vec&quot; @&gt; asNat) &lt;@&gt; tp</span></span>
<span class="lineno">  394 </span>
<span class="lineno">  395 </span>asVecType :: Recognizer Term (Natural :*: Term)
<span class="lineno">  396 </span><span class="decl"><span class="istickedoff">asVecType = isVecType return</span></span>
<span class="lineno">  397 </span>
<span class="lineno">  398 </span>asBitvectorType :: Recognizer Term Natural
<span class="lineno">  399 </span><span class="decl"><span class="istickedoff">asBitvectorType = (isGlobalDef &quot;Prelude.Vec&quot; @&gt; asNat) &lt;@ asBoolType</span></span>
<span class="lineno">  400 </span>
<span class="lineno">  401 </span>asMux :: Recognizer Term (Term :*: Term :*: Term :*: Term)
<span class="lineno">  402 </span><span class="decl"><span class="nottickedoff">asMux = isGlobalDef &quot;Prelude.ite&quot; @&gt; return &lt;@&gt; return &lt;@&gt; return &lt;@&gt; return</span></span>
<span class="lineno">  403 </span>
<span class="lineno">  404 </span>asEq :: Recognizer Term (Term, Term, Term)
<span class="lineno">  405 </span><span class="decl"><span class="istickedoff">asEq t =</span>
<span class="lineno">  406 </span><span class="spaces">  </span><span class="istickedoff">do l &lt;- asGlobalApply &quot;Prelude.Eq&quot; t</span>
<span class="lineno">  407 </span><span class="spaces">     </span><span class="istickedoff">case l of</span>
<span class="lineno">  408 </span><span class="spaces">       </span><span class="istickedoff">[a, x, y] -&gt; Just (a, x, y)</span>
<span class="lineno">  409 </span><span class="spaces">       </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno">  410 </span>
<span class="lineno">  411 </span>asEqTrue :: Recognizer Term Term
<span class="lineno">  412 </span><span class="decl"><span class="istickedoff">asEqTrue t =</span>
<span class="lineno">  413 </span><span class="spaces">  </span><span class="istickedoff">case (isGlobalDef &quot;Prelude.EqTrue&quot; @&gt; return) t of</span>
<span class="lineno">  414 </span><span class="spaces">    </span><span class="istickedoff">Just x -&gt; Just x</span>
<span class="lineno">  415 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  416 </span><span class="spaces">      </span><span class="istickedoff">do (a,x,y) &lt;- asEq t</span>
<span class="lineno">  417 </span><span class="spaces">         </span><span class="istickedoff">isGlobalDef &quot;Prelude.Bool&quot; a</span>
<span class="lineno">  418 </span><span class="spaces">         </span><span class="istickedoff">isGlobalDef &quot;Prelude.True&quot; y</span>
<span class="lineno">  419 </span><span class="spaces">         </span><span class="istickedoff">return x</span></span>
<span class="lineno">  420 </span>
<span class="lineno">  421 </span>asArrayType :: Recognizer Term (Term :*: Term)
<span class="lineno">  422 </span><span class="decl"><span class="nottickedoff">asArrayType = (isGlobalDef &quot;Prelude.Array&quot; @&gt; return) &lt;@&gt; return</span></span>

</pre>
</body>
</html>
