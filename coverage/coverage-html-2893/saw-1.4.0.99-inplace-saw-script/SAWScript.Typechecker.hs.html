<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- |
<span class="lineno">    2 </span>Module      : SAWScript.Typechecker
<span class="lineno">    3 </span>Description : SAW-Script type checking.
<span class="lineno">    4 </span>License     : BSD3
<span class="lineno">    5 </span>Maintainer  : diatchki
<span class="lineno">    6 </span>Stability   : provisional
<span class="lineno">    7 </span>-}
<span class="lineno">    8 </span>
<span class="lineno">    9 </span>{-# LANGUAGE FlexibleInstances #-}
<span class="lineno">   10 </span>{-# LANGUAGE GeneralizedNewtypeDeriving #-}
<span class="lineno">   11 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">   12 </span>{-# LANGUAGE TupleSections #-}
<span class="lineno">   13 </span>-- See Note [-Wincomplete-uni-patterns and irrefutable patterns]
<span class="lineno">   14 </span>{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}
<span class="lineno">   15 </span>
<span class="lineno">   16 </span>module SAWScript.Typechecker
<span class="lineno">   17 </span>       ( checkDecl
<span class="lineno">   18 </span>       , checkStmt
<span class="lineno">   19 </span>       , typesMatch
<span class="lineno">   20 </span>       , checkSchema
<span class="lineno">   21 </span>       , checkSchemaPattern
<span class="lineno">   22 </span>       ) where
<span class="lineno">   23 </span>
<span class="lineno">   24 </span>import Control.Monad (when, zipWithM, zipWithM_)
<span class="lineno">   25 </span>import Control.Monad.Reader (MonadReader(..), ReaderT(..), asks)
<span class="lineno">   26 </span>import Control.Monad.State (MonadState(..), StateT, gets, modify, runState)
<span class="lineno">   27 </span>import Control.Monad.Identity (Identity)
<span class="lineno">   28 </span>import qualified Data.Text as Text
<span class="lineno">   29 </span>import Data.List (genericTake, genericLength)
<span class="lineno">   30 </span>import Data.Either (partitionEithers)
<span class="lineno">   31 </span>import qualified Data.Map as Map
<span class="lineno">   32 </span>import Data.Map (Map)
<span class="lineno">   33 </span>import qualified Data.Set as Set
<span class="lineno">   34 </span>import Data.Set (Set)
<span class="lineno">   35 </span>
<span class="lineno">   36 </span>import qualified SAWSupport.ScopedMap as ScopedMap
<span class="lineno">   37 </span>import SAWSupport.ScopedMap (ScopedMap)
<span class="lineno">   38 </span>import SAWSupport.Pretty (pShow)
<span class="lineno">   39 </span>
<span class="lineno">   40 </span>import SAWCentral.AST
<span class="lineno">   41 </span>import SAWCentral.ASTUtil (namedTyVars, SubstituteTyVars(..), SubstituteTyVars'(..), isDeprecated)
<span class="lineno">   42 </span>import SAWScript.Panic (panic)
<span class="lineno">   43 </span>import SAWCentral.Position (Inference(..), Pos(..), Positioned(..), choosePos)
<span class="lineno">   44 </span>
<span class="lineno">   45 </span>
<span class="lineno">   46 </span>-- short names for the environment types we use
<span class="lineno">   47 </span>type VarEnv = ScopedMap Name (Pos, PrimitiveLifecycle, Rebindable, Schema)
<span class="lineno">   48 </span>type TyEnv = ScopedMap Name (PrimitiveLifecycle, NamedType)
<span class="lineno">   49 </span>
<span class="lineno">   50 </span>
<span class="lineno">   51 </span>------------------------------------------------------------
<span class="lineno">   52 </span>-- UnifyVars
<span class="lineno">   53 </span>
<span class="lineno">   54 </span>--
<span class="lineno">   55 </span>-- unifyVars is a type-class-polymorphic function for extracting
<span class="lineno">   56 </span>-- unification vars from a type or type schema. It returns a set of
<span class="lineno">   57 </span>-- TypeIndex (TypeIndex is just Integer) manifested as a map from
<span class="lineno">   58 </span>-- those TypeIndexes to their positions/provenance.
<span class="lineno">   59 </span>--
<span class="lineno">   60 </span>
<span class="lineno">   61 </span>class UnifyVars t where
<span class="lineno">   62 </span>  unifyVars :: t -&gt; Map TypeIndex Pos
<span class="lineno">   63 </span>
<span class="lineno">   64 </span>instance (Ord k, UnifyVars a) =&gt; UnifyVars (Map k a) where
<span class="lineno">   65 </span>  <span class="decl"><span class="istickedoff">unifyVars = unifyVars . Map.elems</span></span>
<span class="lineno">   66 </span>
<span class="lineno">   67 </span>instance (UnifyVars a) =&gt; UnifyVars [a] where
<span class="lineno">   68 </span>  <span class="decl"><span class="istickedoff">unifyVars = Map.unionsWith <span class="nottickedoff">choosePos</span> . map unifyVars</span></span>
<span class="lineno">   69 </span>
<span class="lineno">   70 </span>instance (UnifyVars a) =&gt; UnifyVars (PrimitiveLifecycle, a) where
<span class="lineno">   71 </span>  <span class="decl"><span class="istickedoff">unifyVars (_lc, t) = unifyVars t</span></span>
<span class="lineno">   72 </span>
<span class="lineno">   73 </span>instance (UnifyVars a) =&gt; UnifyVars (Pos, PrimitiveLifecycle, Rebindable, a) where
<span class="lineno">   74 </span>  <span class="decl"><span class="istickedoff">unifyVars (_pos, _lc, _rb, t) = unifyVars t</span></span>
<span class="lineno">   75 </span>
<span class="lineno">   76 </span>instance UnifyVars Type where
<span class="lineno">   77 </span>  <span class="decl"><span class="istickedoff">unifyVars t = case t of</span>
<span class="lineno">   78 </span><span class="spaces">    </span><span class="istickedoff">TyCon _ _ ts      -&gt; unifyVars ts</span>
<span class="lineno">   79 </span><span class="spaces">    </span><span class="istickedoff">TyRecord _ tm     -&gt; unifyVars tm</span>
<span class="lineno">   80 </span><span class="spaces">    </span><span class="istickedoff">TyVar _ _         -&gt; Map.empty</span>
<span class="lineno">   81 </span><span class="spaces">    </span><span class="istickedoff">TyUnifyVar pos i  -&gt; Map.singleton i <span class="nottickedoff">pos</span></span></span>
<span class="lineno">   82 </span>
<span class="lineno">   83 </span>instance UnifyVars Schema where
<span class="lineno">   84 </span>  <span class="decl"><span class="istickedoff">unifyVars (Forall _ t) = unifyVars t</span></span>
<span class="lineno">   85 </span>
<span class="lineno">   86 </span>instance UnifyVars NamedType where
<span class="lineno">   87 </span>  <span class="decl"><span class="istickedoff">unifyVars nt = case nt of</span>
<span class="lineno">   88 </span><span class="spaces">    </span><span class="istickedoff">ConcreteType ty -&gt; unifyVars ty</span>
<span class="lineno">   89 </span><span class="spaces">    </span><span class="istickedoff">AbstractType _kind -&gt; Map.empty</span></span>
<span class="lineno">   90 </span>
<span class="lineno">   91 </span>
<span class="lineno">   92 </span>------------------------------------------------------------
<span class="lineno">   93 </span>-- Substitutions
<span class="lineno">   94 </span>
<span class="lineno">   95 </span>-- Subst is the type of a substitution map for unification vars.
<span class="lineno">   96 </span>newtype Subst = Subst { <span class="istickedoff"><span class="decl"><span class="istickedoff">unSubst</span></span></span> :: Map TypeIndex Type } deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">   97 </span>
<span class="lineno">   98 </span>-- Merge two substitution maps.
<span class="lineno">   99 </span>--
<span class="lineno">  100 </span>-- XXX: this knows that in the uses below the right substitution (m1)
<span class="lineno">  101 </span>-- is the older/preexisting one. That probably shouldn't be silently
<span class="lineno">  102 </span>-- baked in.
<span class="lineno">  103 </span>--
<span class="lineno">  104 </span>-- We apply the left substitution (m2) into the types in the right
<span class="lineno">  105 </span>-- substitution (m1). That is, any new substitutions are applied into
<span class="lineno">  106 </span>-- the existing ones. I expect this in pursuit of an invariant where
<span class="lineno">  107 </span>-- any unification variables existing in the right-hand sides of the
<span class="lineno">  108 </span>-- substitution aren't themselves defined by the substitution, so we
<span class="lineno">  109 </span>-- don't have to recurse into the right-hand sides later when applying
<span class="lineno">  110 </span>-- the substitution.
<span class="lineno">  111 </span>--
<span class="lineno">  112 </span>-- XXX: However, this assumes that whatever is on the left-hand side
<span class="lineno">  113 </span>-- doesn't already violate this invariant. We can check this with
<span class="lineno">  114 </span>-- reasonable accuracy since we have right here all the ways to create
<span class="lineno">  115 </span>-- a Subst (and we can check that there aren't any others hidden
<span class="lineno">  116 </span>-- below)... and we find that while emptySubst is obviously ok, and
<span class="lineno">  117 </span>-- singletonSubst is ok (an attempt to create a singleton substitution
<span class="lineno">  118 </span>-- that refers to itself will fail the occurs check right before
<span class="lineno">  119 </span>-- calling singletonSubst), there doesn't seem to be any such
<span class="lineno">  120 </span>-- assurance for substFromList. I'm not sure if this is actually a
<span class="lineno">  121 </span>-- problem or not but it should probably be looked into at some point.
<span class="lineno">  122 </span>--
<span class="lineno">  123 </span>-- XXX: we should probably crosscheck the key space of the maps. Note
<span class="lineno">  124 </span>-- that the ordering of the Map.union args means that if there are
<span class="lineno">  125 </span>-- duplicated keys we prefer the right substitution (m1), namely the
<span class="lineno">  126 </span>-- preexisting one. Given that this choice seems to be explicit, it
<span class="lineno">  127 </span>-- must have been for a reason, but I'm not sure what that reason
<span class="lineno">  128 </span>-- would be. Ordinarily in this kind of typechecker you might update a
<span class="lineno">  129 </span>-- substitution you've already made, but only when replacing a weak
<span class="lineno">  130 </span>-- substitution (one unification var for another, like a1 -&gt; a2) with
<span class="lineno">  131 </span>-- a strong one (involving a real type, like a1 -&gt; Int)... but if so
<span class="lineno">  132 </span>-- it would always be the _new_ substitution you'd want to keep.
<span class="lineno">  133 </span>-- However, in this particular code we always apply the existing
<span class="lineno">  134 </span>-- substitution before doing further unification, so once we have any
<span class="lineno">  135 </span>-- substitution for a given unification var we shouldn't get another.
<span class="lineno">  136 </span>-- (Unless I guess if the intended invariant above is violated, but if
<span class="lineno">  137 </span>-- that happens we should probably panic, not chug along.)
<span class="lineno">  138 </span>--
<span class="lineno">  139 </span>-- XXX: also it isn't clear that anything below guarantees that we
<span class="lineno">  140 </span>-- won't just derive multiple inconsistent substitutions (e.g. from
<span class="lineno">  141 </span>-- disjoint subexpressions) and combine them incoherently. This should
<span class="lineno">  142 </span>-- really be looked into further.
<span class="lineno">  143 </span>--
<span class="lineno">  144 </span>-- XXX: and _furthermore_ it's not clear that we can't get cyclic
<span class="lineno">  145 </span>-- substitutions. If we already have a substitution a1 -&gt; a2, and we
<span class="lineno">  146 </span>-- add a2 -&gt; a1, we'll resolve the existing substitution to a1 -&gt; a1
<span class="lineno">  147 </span>-- rather than going directly into an infinite loop. That's not
<span class="lineno">  148 </span>-- necessarily preferable though. Normally in this kind of typechecker
<span class="lineno">  149 </span>-- one also wants some kind of acyclicity-oriented invariant, like
<span class="lineno">  150 </span>-- aN resolves to aM only if N &gt; M (otherwise you substitute the other
<span class="lineno">  151 </span>-- way) but we don't do anything like that.
<span class="lineno">  152 </span>--
<span class="lineno">  153 </span>-- When all the above issues get clarified we should consider coming
<span class="lineno">  154 </span>-- up with a different name that indicates that this operation isn't
<span class="lineno">  155 </span>-- commutative. Unless it actually can be.
<span class="lineno">  156 </span>mergeSubst :: Subst -&gt; Subst -&gt; Subst
<span class="lineno">  157 </span><span class="decl"><span class="istickedoff">mergeSubst s2@(Subst m2) (Subst m1) = Subst $ m1' `Map.union` m2</span>
<span class="lineno">  158 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  159 </span><span class="spaces">  </span><span class="istickedoff">m1' = fmap (appSubst s2) m1</span></span>
<span class="lineno">  160 </span>
<span class="lineno">  161 </span>emptySubst :: Subst
<span class="lineno">  162 </span><span class="decl"><span class="istickedoff">emptySubst = Subst Map.empty</span></span>
<span class="lineno">  163 </span>
<span class="lineno">  164 </span>singletonSubst :: TypeIndex -&gt; Type -&gt; Subst
<span class="lineno">  165 </span><span class="decl"><span class="istickedoff">singletonSubst tv t = Subst $ Map.singleton tv t</span></span>
<span class="lineno">  166 </span>
<span class="lineno">  167 </span>substFromList :: [(TypeIndex, Type)] -&gt; Subst
<span class="lineno">  168 </span><span class="decl"><span class="istickedoff">substFromList entries = Subst $ Map.fromList entries</span></span>
<span class="lineno">  169 </span>
<span class="lineno">  170 </span>--
<span class="lineno">  171 </span>-- appSubst is a type-class-polymorphic function for applying a
<span class="lineno">  172 </span>-- substitution (of numbered unification vars) to AST elements.
<span class="lineno">  173 </span>--
<span class="lineno">  174 </span>
<span class="lineno">  175 </span>class AppSubst t where
<span class="lineno">  176 </span>  appSubst :: Subst -&gt; t -&gt; t
<span class="lineno">  177 </span>
<span class="lineno">  178 </span>instance (AppSubst t) =&gt; AppSubst (Maybe t) where
<span class="lineno">  179 </span>  <span class="decl"><span class="istickedoff">appSubst s = fmap $ appSubst s</span></span>
<span class="lineno">  180 </span>
<span class="lineno">  181 </span>instance (AppSubst t) =&gt; AppSubst [t] where
<span class="lineno">  182 </span>  <span class="decl"><span class="istickedoff">appSubst s = map $ appSubst s</span></span>
<span class="lineno">  183 </span>
<span class="lineno">  184 </span>instance (AppSubst t) =&gt; AppSubst (PrimitiveLifecycle, t) where
<span class="lineno">  185 </span>  <span class="decl"><span class="istickedoff">appSubst s (lc, x) = (<span class="nottickedoff">lc</span>, appSubst <span class="nottickedoff">s</span> x)</span></span>
<span class="lineno">  186 </span>
<span class="lineno">  187 </span>instance (AppSubst t) =&gt; AppSubst (Pos, PrimitiveLifecycle, Rebindable, t) where
<span class="lineno">  188 </span>  <span class="decl"><span class="istickedoff">appSubst s (pos, lc, rb, x) = (<span class="nottickedoff">pos</span>, <span class="nottickedoff">lc</span>, <span class="nottickedoff">rb</span>, appSubst <span class="nottickedoff">s</span> x)</span></span>
<span class="lineno">  189 </span>
<span class="lineno">  190 </span>instance (Ord k, AppSubst a) =&gt; AppSubst (Map k a) where
<span class="lineno">  191 </span>  <span class="decl"><span class="istickedoff">appSubst s = fmap (appSubst s)</span></span>
<span class="lineno">  192 </span>
<span class="lineno">  193 </span>instance AppSubst Expr where
<span class="lineno">  194 </span>  <span class="decl"><span class="istickedoff">appSubst s expr = case expr of</span>
<span class="lineno">  195 </span><span class="spaces">    </span><span class="istickedoff">TSig pos e t           -&gt; <span class="nottickedoff">TSig pos (appSubst s e) (appSubst s t)</span></span>
<span class="lineno">  196 </span><span class="spaces">    </span><span class="istickedoff">Bool _ _               -&gt; <span class="nottickedoff">expr</span></span>
<span class="lineno">  197 </span><span class="spaces">    </span><span class="istickedoff">String _ _             -&gt; expr</span>
<span class="lineno">  198 </span><span class="spaces">    </span><span class="istickedoff">Int _ _                -&gt; expr</span>
<span class="lineno">  199 </span><span class="spaces">    </span><span class="istickedoff">Code _ _               -&gt; expr</span>
<span class="lineno">  200 </span><span class="spaces">    </span><span class="istickedoff">CType _ _              -&gt; expr</span>
<span class="lineno">  201 </span><span class="spaces">    </span><span class="istickedoff">Array pos es           -&gt; Array <span class="nottickedoff">pos</span> (appSubst <span class="nottickedoff">s</span> es)</span>
<span class="lineno">  202 </span><span class="spaces">    </span><span class="istickedoff">Block pos (bs, e)      -&gt; Block <span class="nottickedoff">pos</span> (appSubst <span class="nottickedoff">s</span> bs, appSubst <span class="nottickedoff">s</span> e)</span>
<span class="lineno">  203 </span><span class="spaces">    </span><span class="istickedoff">Tuple pos es           -&gt; Tuple <span class="nottickedoff">pos</span> (appSubst s es)</span>
<span class="lineno">  204 </span><span class="spaces">    </span><span class="istickedoff">Record pos fs          -&gt; Record <span class="nottickedoff">pos</span> (appSubst <span class="nottickedoff">s</span> fs)</span>
<span class="lineno">  205 </span><span class="spaces">    </span><span class="istickedoff">Index pos ar ix        -&gt; <span class="nottickedoff">Index pos (appSubst s ar) (appSubst s ix)</span></span>
<span class="lineno">  206 </span><span class="spaces">    </span><span class="istickedoff">Lookup pos rec fld     -&gt; <span class="nottickedoff">Lookup pos (appSubst s rec) fld</span></span>
<span class="lineno">  207 </span><span class="spaces">    </span><span class="istickedoff">TLookup pos tpl idx    -&gt; <span class="nottickedoff">TLookup pos (appSubst s tpl) idx</span></span>
<span class="lineno">  208 </span><span class="spaces">    </span><span class="istickedoff">Var _pos _x            -&gt; expr</span>
<span class="lineno">  209 </span><span class="spaces">    </span><span class="istickedoff">Lambda pos mname pat body -&gt; Lambda <span class="nottickedoff">pos</span> mname (appSubst s pat) (appSubst <span class="nottickedoff">s</span> body)</span>
<span class="lineno">  210 </span><span class="spaces">    </span><span class="istickedoff">Application pos f v    -&gt; Application pos (appSubst <span class="nottickedoff">s</span> f) (appSubst s v)</span>
<span class="lineno">  211 </span><span class="spaces">    </span><span class="istickedoff">Let pos dg e           -&gt; Let <span class="nottickedoff">pos</span> (appSubst <span class="nottickedoff">s</span> dg) (appSubst <span class="nottickedoff">s</span> e)</span>
<span class="lineno">  212 </span><span class="spaces">    </span><span class="istickedoff">IfThenElse pos e e2 e3 -&gt; IfThenElse <span class="nottickedoff">pos</span> (appSubst <span class="nottickedoff">s</span> e) (appSubst <span class="nottickedoff">s</span> e2) (appSubst <span class="nottickedoff">s</span> e3)</span></span>
<span class="lineno">  213 </span>
<span class="lineno">  214 </span>instance AppSubst Pattern where
<span class="lineno">  215 </span>  <span class="decl"><span class="istickedoff">appSubst s pat = case pat of</span>
<span class="lineno">  216 </span><span class="spaces">    </span><span class="istickedoff">PWild pos mt  -&gt; PWild <span class="nottickedoff">pos</span> (appSubst s mt)</span>
<span class="lineno">  217 </span><span class="spaces">    </span><span class="istickedoff">PVar allpos xpos x mt -&gt; PVar <span class="nottickedoff">allpos</span> xpos x (appSubst s mt)</span>
<span class="lineno">  218 </span><span class="spaces">    </span><span class="istickedoff">PTuple pos ps -&gt; PTuple <span class="nottickedoff">pos</span> (appSubst s ps)</span></span>
<span class="lineno">  219 </span>
<span class="lineno">  220 </span>instance AppSubst Stmt where
<span class="lineno">  221 </span>  <span class="decl"><span class="istickedoff">appSubst s bst = case bst of</span>
<span class="lineno">  222 </span><span class="spaces">    </span><span class="istickedoff">StmtBind pos pat e       -&gt; StmtBind pos (appSubst s pat) (appSubst s e)</span>
<span class="lineno">  223 </span><span class="spaces">    </span><span class="istickedoff">StmtLet pos rb dg        -&gt; StmtLet <span class="nottickedoff">pos</span> rb (appSubst <span class="nottickedoff">s</span> dg)</span>
<span class="lineno">  224 </span><span class="spaces">    </span><span class="istickedoff">StmtCode allpos spos str -&gt; StmtCode <span class="nottickedoff">allpos</span> spos str</span>
<span class="lineno">  225 </span><span class="spaces">    </span><span class="istickedoff">StmtImport pos imp       -&gt; StmtImport <span class="nottickedoff">pos</span> imp</span>
<span class="lineno">  226 </span><span class="spaces">    </span><span class="istickedoff">StmtInclude pos file once -&gt; <span class="nottickedoff">StmtInclude pos file once</span></span>
<span class="lineno">  227 </span><span class="spaces">    </span><span class="istickedoff">StmtTypedef allpos apos a ty -&gt; StmtTypedef <span class="nottickedoff">allpos</span> <span class="nottickedoff">apos</span> a (appSubst <span class="nottickedoff">s</span> ty)</span>
<span class="lineno">  228 </span><span class="spaces">    </span><span class="istickedoff">StmtPushdir pos dir      -&gt; StmtPushdir <span class="nottickedoff">pos</span> dir</span>
<span class="lineno">  229 </span><span class="spaces">    </span><span class="istickedoff">StmtPopdir pos           -&gt; StmtPopdir <span class="nottickedoff">pos</span></span></span>
<span class="lineno">  230 </span>
<span class="lineno">  231 </span>instance AppSubst DeclGroup where
<span class="lineno">  232 </span>  <span class="decl"><span class="istickedoff">appSubst s (Recursive ds) = Recursive (appSubst <span class="nottickedoff">s</span> ds)</span>
<span class="lineno">  233 </span><span class="spaces">  </span><span class="istickedoff">appSubst s (NonRecursive d) = NonRecursive (appSubst <span class="nottickedoff">s</span> d)</span></span>
<span class="lineno">  234 </span>
<span class="lineno">  235 </span>instance AppSubst Decl where
<span class="lineno">  236 </span>  <span class="decl"><span class="istickedoff">appSubst s (Decl pos p mt e) = Decl <span class="nottickedoff">pos</span> (appSubst <span class="nottickedoff">s</span> p) (appSubst <span class="nottickedoff">s</span> mt) (appSubst <span class="nottickedoff">s</span> e)</span></span>
<span class="lineno">  237 </span>
<span class="lineno">  238 </span>instance AppSubst Type where
<span class="lineno">  239 </span>  <span class="decl"><span class="istickedoff">appSubst s t = case t of</span>
<span class="lineno">  240 </span><span class="spaces">    </span><span class="istickedoff">TyCon pos tc ts     -&gt; TyCon pos tc (appSubst s ts)</span>
<span class="lineno">  241 </span><span class="spaces">    </span><span class="istickedoff">TyRecord pos fs     -&gt; TyRecord pos (appSubst s fs)</span>
<span class="lineno">  242 </span><span class="spaces">    </span><span class="istickedoff">TyVar _ _           -&gt; t</span>
<span class="lineno">  243 </span><span class="spaces">    </span><span class="istickedoff">TyUnifyVar _ i      -&gt; case Map.lookup i (unSubst s) of</span>
<span class="lineno">  244 </span><span class="spaces">                             </span><span class="istickedoff">Just t' -&gt; t'</span>
<span class="lineno">  245 </span><span class="spaces">                             </span><span class="istickedoff">Nothing -&gt; t</span></span>
<span class="lineno">  246 </span>
<span class="lineno">  247 </span>instance AppSubst Schema where
<span class="lineno">  248 </span>  <span class="decl"><span class="istickedoff">appSubst s (Forall ns t) = Forall ns (appSubst <span class="nottickedoff">s</span> t)</span></span>
<span class="lineno">  249 </span>
<span class="lineno">  250 </span>instance AppSubst NamedType where
<span class="lineno">  251 </span>  <span class="decl"><span class="istickedoff">appSubst s nt = case nt of</span>
<span class="lineno">  252 </span><span class="spaces">    </span><span class="istickedoff">ConcreteType ty -&gt; ConcreteType $ appSubst <span class="nottickedoff">s</span> ty</span>
<span class="lineno">  253 </span><span class="spaces">    </span><span class="istickedoff">AbstractType kind -&gt; AbstractType <span class="nottickedoff">kind</span></span></span>
<span class="lineno">  254 </span>
<span class="lineno">  255 </span>
<span class="lineno">  256 </span>------------------------------------------------------------
<span class="lineno">  257 </span>-- Context names
<span class="lineno">  258 </span>
<span class="lineno">  259 </span>-- Type errors include a &quot;context name&quot; that's typically the name (and
<span class="lineno">  260 </span>-- position) of the enclosing function. This should probably be removed
<span class="lineno">  261 </span>-- now that we report accurate positions with type errors. However,
<span class="lineno">  262 </span>-- until then, wrap it up to avoid confusion and crosstalk.
<span class="lineno">  263 </span>
<span class="lineno">  264 </span>data ContextName = ContextName Pos Name
<span class="lineno">  265 </span>
<span class="lineno">  266 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show ContextName</span></span></span></span> where
<span class="lineno">  267 </span>  <span class="decl"><span class="istickedoff">show (ContextName pos name) = show name ++ &quot; (&quot; ++ show pos ++ &quot;)&quot;</span></span>
<span class="lineno">  268 </span>
<span class="lineno">  269 </span>
<span class="lineno">  270 </span>
<span class="lineno">  271 </span>------------------------------------------------------------
<span class="lineno">  272 </span>-- Pass context
<span class="lineno">  273 </span>
<span class="lineno">  274 </span>-- | The monad for this pass is &quot;TI&quot;, which is composed of a read-only
<span class="lineno">  275 </span>--   part plus a read-write part that accumulates as we move through the
<span class="lineno">  276 </span>--   code.
<span class="lineno">  277 </span>newtype TI a = TI { <span class="istickedoff"><span class="decl"><span class="istickedoff">unTI</span></span></span> :: ReaderT RO (StateT RW Identity) a }
<span class="lineno">  278 </span>    deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Functor</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Applicative</span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Monad</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff">MonadReader RO</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff">MonadState RW</span></span></span></span></span></span>)
<span class="lineno">  279 </span>
<span class="lineno">  280 </span>-- | The read-only portion
<span class="lineno">  281 </span>data RO = RO {
<span class="lineno">  282 </span>    -- | The variable availability (lifecycle set)
<span class="lineno">  283 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">primsAvail</span></span></span> :: Set PrimitiveLifecycle
<span class="lineno">  284 </span>}
<span class="lineno">  285 </span>
<span class="lineno">  286 </span>-- | The read-write portion
<span class="lineno">  287 </span>data RW = RW {
<span class="lineno">  288 </span>    -- | The variable typing environment (variable name to type scheme)
<span class="lineno">  289 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">varEnv</span></span></span> :: VarEnv,
<span class="lineno">  290 </span>
<span class="lineno">  291 </span>    -- | The type environment: named type variables, which are either
<span class="lineno">  292 </span>    --   typedefs (map to ConcreteType) or abstract types (AbstractType)
<span class="lineno">  293 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">tyEnv</span></span></span> :: TyEnv,
<span class="lineno">  294 </span>
<span class="lineno">  295 </span>    -- | The next fresh unification var number
<span class="lineno">  296 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">nextTypeIndex</span></span></span> :: TypeIndex,
<span class="lineno">  297 </span>
<span class="lineno">  298 </span>    -- | The unification var substitution we're accumulating
<span class="lineno">  299 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">subst</span></span></span> :: Subst,
<span class="lineno">  300 </span>
<span class="lineno">  301 </span>    -- | Any type errors and warnings we've generated so far
<span class="lineno">  302 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">errors</span></span></span> :: [(Pos, String)],
<span class="lineno">  303 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">warnings</span></span></span> :: [(Pos, String)]
<span class="lineno">  304 </span>}
<span class="lineno">  305 </span>
<span class="lineno">  306 </span>-- | A startup read-write state, given an initial varEnv and tyEnv.
<span class="lineno">  307 </span>initialRW :: VarEnv -&gt; TyEnv -&gt; RW
<span class="lineno">  308 </span><span class="decl"><span class="istickedoff">initialRW varenv tyenv = RW {</span>
<span class="lineno">  309 </span><span class="spaces">    </span><span class="istickedoff">varEnv = varenv,</span>
<span class="lineno">  310 </span><span class="spaces">    </span><span class="istickedoff">tyEnv = tyenv,</span>
<span class="lineno">  311 </span><span class="spaces">    </span><span class="istickedoff">nextTypeIndex = 0,</span>
<span class="lineno">  312 </span><span class="spaces">    </span><span class="istickedoff">subst = emptySubst,</span>
<span class="lineno">  313 </span><span class="spaces">    </span><span class="istickedoff">errors = [],</span>
<span class="lineno">  314 </span><span class="spaces">    </span><span class="istickedoff">warnings = []</span>
<span class="lineno">  315 </span><span class="spaces"></span><span class="istickedoff">}</span></span>
<span class="lineno">  316 </span>
<span class="lineno">  317 </span>-- | Enter a scope
<span class="lineno">  318 </span>pushScope :: TI ()
<span class="lineno">  319 </span><span class="decl"><span class="istickedoff">pushScope = do</span>
<span class="lineno">  320 </span><span class="spaces">  </span><span class="istickedoff">varenv &lt;- gets varEnv</span>
<span class="lineno">  321 </span><span class="spaces">  </span><span class="istickedoff">tyenv &lt;- gets tyEnv</span>
<span class="lineno">  322 </span><span class="spaces">  </span><span class="istickedoff">let varenv' = ScopedMap.push varenv</span>
<span class="lineno">  323 </span><span class="spaces">      </span><span class="istickedoff">tyenv' = ScopedMap.push tyenv</span>
<span class="lineno">  324 </span><span class="spaces">  </span><span class="istickedoff">modify (\rw -&gt; rw { varEnv = varenv', tyEnv = tyenv' })</span></span>
<span class="lineno">  325 </span>
<span class="lineno">  326 </span>-- | Leave a scope
<span class="lineno">  327 </span>popScope :: TI ()
<span class="lineno">  328 </span><span class="decl"><span class="istickedoff">popScope = do</span>
<span class="lineno">  329 </span><span class="spaces">  </span><span class="istickedoff">varenv &lt;- gets varEnv</span>
<span class="lineno">  330 </span><span class="spaces">  </span><span class="istickedoff">tyenv &lt;- gets tyEnv</span>
<span class="lineno">  331 </span><span class="spaces">  </span><span class="istickedoff">let varenv' = ScopedMap.pop varenv</span>
<span class="lineno">  332 </span><span class="spaces">      </span><span class="istickedoff">tyenv' = ScopedMap.pop tyenv</span>
<span class="lineno">  333 </span><span class="spaces">  </span><span class="istickedoff">modify (\rw -&gt; rw { varEnv = varenv', tyEnv = tyenv' })</span></span>
<span class="lineno">  334 </span>
<span class="lineno">  335 </span>-- Get a fresh unification var number.
<span class="lineno">  336 </span>getFreshTypeIndex :: TI TypeIndex
<span class="lineno">  337 </span><span class="decl"><span class="istickedoff">getFreshTypeIndex = do</span>
<span class="lineno">  338 </span><span class="spaces">  </span><span class="istickedoff">next &lt;- gets nextTypeIndex</span>
<span class="lineno">  339 </span><span class="spaces">  </span><span class="istickedoff">modify $ (\rw -&gt; rw { nextTypeIndex = next + 1 })</span>
<span class="lineno">  340 </span><span class="spaces">  </span><span class="istickedoff">return next</span></span>
<span class="lineno">  341 </span>
<span class="lineno">  342 </span>-- Construct a fresh type variable.
<span class="lineno">  343 </span>--
<span class="lineno">  344 </span>-- Collect the position that prompted us to make it; for example, if
<span class="lineno">  345 </span>-- we're the element type of an empty list we get the position of the
<span class="lineno">  346 </span>-- []. We haven't inferred anything, so use the InfFresh position.
<span class="lineno">  347 </span>-- This will cause the position of anything more substantive that gets
<span class="lineno">  348 </span>-- unified with it to be preferred. If no such thing happens though
<span class="lineno">  349 </span>-- this will be the position that gets attached to the quantifier
<span class="lineno">  350 </span>-- binding in generalize.
<span class="lineno">  351 </span>getFreshTyVar :: Pos -&gt; TI Type
<span class="lineno">  352 </span><span class="decl"><span class="istickedoff">getFreshTyVar pos = TyUnifyVar (PosInferred InfFresh pos) &lt;$&gt; getFreshTypeIndex</span></span>
<span class="lineno">  353 </span>
<span class="lineno">  354 </span>-- Construct a new type variable to use as a placeholder after an
<span class="lineno">  355 </span>-- error occurs. For now this is the same as other fresh type
<span class="lineno">  356 </span>-- variables, but I've split it out in case we want to distinguish it
<span class="lineno">  357 </span>-- in the future.
<span class="lineno">  358 </span>getErrorTyVar :: Pos -&gt; TI Type
<span class="lineno">  359 </span><span class="decl"><span class="istickedoff">getErrorTyVar pos = getFreshTyVar <span class="nottickedoff">pos</span></span></span>
<span class="lineno">  360 </span>
<span class="lineno">  361 </span>-- Add an error message.
<span class="lineno">  362 </span>recordError :: Pos -&gt; String -&gt; TI ()
<span class="lineno">  363 </span><span class="decl"><span class="istickedoff">recordError pos err = do</span>
<span class="lineno">  364 </span><span class="spaces">    </span><span class="istickedoff">modify $ \rw -&gt; rw { errors = (pos, err) : errors rw }</span></span>
<span class="lineno">  365 </span>
<span class="lineno">  366 </span>-- Add a warning message.
<span class="lineno">  367 </span>recordWarning :: Pos -&gt; String -&gt; TI ()
<span class="lineno">  368 </span><span class="decl"><span class="istickedoff">recordWarning pos msg = do</span>
<span class="lineno">  369 </span><span class="spaces">    </span><span class="istickedoff">modify $ \rw -&gt; rw { warnings = (pos, msg) : warnings rw }</span></span>
<span class="lineno">  370 </span>
<span class="lineno">  371 </span>-- Apply the current substitution with appSubst.
<span class="lineno">  372 </span>applyCurrentSubst :: AppSubst t =&gt; t -&gt; TI t
<span class="lineno">  373 </span><span class="decl"><span class="istickedoff">applyCurrentSubst t = do</span>
<span class="lineno">  374 </span><span class="spaces">    </span><span class="istickedoff">s &lt;- gets subst</span>
<span class="lineno">  375 </span><span class="spaces">    </span><span class="istickedoff">return $ appSubst s t</span></span>
<span class="lineno">  376 </span>
<span class="lineno">  377 </span>-- Apply the current typedef collection with substituteTyVars.
<span class="lineno">  378 </span>--
<span class="lineno">  379 </span>-- The type t has already been checked, so it's ok to panic if it refers
<span class="lineno">  380 </span>-- to something in the typedef collection that's not visible.
<span class="lineno">  381 </span>resolveCurrentTypedefs :: SubstituteTyVars t =&gt; t -&gt; TI t
<span class="lineno">  382 </span><span class="decl"><span class="istickedoff">resolveCurrentTypedefs t = do</span>
<span class="lineno">  383 </span><span class="spaces">    </span><span class="istickedoff">avail &lt;- asks primsAvail</span>
<span class="lineno">  384 </span><span class="spaces">    </span><span class="istickedoff">s &lt;- gets tyEnv</span>
<span class="lineno">  385 </span><span class="spaces">    </span><span class="istickedoff">return $ substituteTyVars avail s t</span></span>
<span class="lineno">  386 </span>
<span class="lineno">  387 </span>-- Get the unification vars that are used in the current variable typing
<span class="lineno">  388 </span>-- and named type environments.
<span class="lineno">  389 </span>--
<span class="lineno">  390 </span>-- FIXME: This function may miss type variables that occur in the type
<span class="lineno">  391 </span>-- of a binding that has been shadowed by another value with the same
<span class="lineno">  392 </span>-- name. This could potentially cause a run-time type error if the
<span class="lineno">  393 </span>-- type of a local function gets generalized too much. We can probably
<span class="lineno">  394 </span>-- wait to fix it until someone finds a sawscript program that breaks.
<span class="lineno">  395 </span>--
<span class="lineno">  396 </span>-- dholland 20241220: I don't think that's a problem. If there's a
<span class="lineno">  397 </span>-- loose unification var somewhere that's been shadowed to the point
<span class="lineno">  398 </span>-- where it's not accessible, we can't have accessed it in order to
<span class="lineno">  399 </span>-- generate a reference to it in the current block. If it is somewhere
<span class="lineno">  400 </span>-- accessible, we'll find it there. This might have broken in the past
<span class="lineno">  401 </span>-- when it didn't search the named type environment, but that leak has
<span class="lineno">  402 </span>-- been corrected.
<span class="lineno">  403 </span>--
<span class="lineno">  404 </span>-- dholland 20251120: If it does turn out to be a problem, we can now
<span class="lineno">  405 </span>-- also get shadowed values out of the environment by adding a suitable
<span class="lineno">  406 </span>-- variant of @elems@ to `ScopedMap`.
<span class="lineno">  407 </span>--
<span class="lineno">  408 </span>-- Note that we apply the current substitution first. This means that
<span class="lineno">  409 </span>-- the caller must also apply the current substitution before reasoning
<span class="lineno">  410 </span>-- about what unification vars do and don't appear.
<span class="lineno">  411 </span>--
<span class="lineno">  412 </span>-- Returns a map of the index number to the occurrence position.
<span class="lineno">  413 </span>unifyVarsInEnvs :: TI (Map TypeIndex Pos)
<span class="lineno">  414 </span><span class="decl"><span class="istickedoff">unifyVarsInEnvs = do</span>
<span class="lineno">  415 </span><span class="spaces">    </span><span class="istickedoff">venv &lt;- gets varEnv</span>
<span class="lineno">  416 </span><span class="spaces">    </span><span class="istickedoff">tenv &lt;- gets tyEnv</span>
<span class="lineno">  417 </span><span class="spaces">    </span><span class="istickedoff">vtys &lt;- mapM applyCurrentSubst $ ScopedMap.allElems venv</span>
<span class="lineno">  418 </span><span class="spaces">    </span><span class="istickedoff">ttys &lt;- mapM applyCurrentSubst $ ScopedMap.allElems tenv</span>
<span class="lineno">  419 </span><span class="spaces">    </span><span class="istickedoff">return $ Map.unionWith <span class="nottickedoff">choosePos</span> (unifyVars vtys) (unifyVars ttys)</span></span>
<span class="lineno">  420 </span>
<span class="lineno">  421 </span>-- Get the named type vars that occur as keys in the current type name
<span class="lineno">  422 </span>-- environment.
<span class="lineno">  423 </span>namedVarDefinitions :: TI (Set Name)
<span class="lineno">  424 </span><span class="decl"><span class="istickedoff">namedVarDefinitions = do</span>
<span class="lineno">  425 </span><span class="spaces">    </span><span class="istickedoff">env &lt;- gets tyEnv</span>
<span class="lineno">  426 </span><span class="spaces">    </span><span class="istickedoff">return $ ScopedMap.allKeysSet env</span></span>
<span class="lineno">  427 </span>
<span class="lineno">  428 </span>-- Get the position and name of the first binding in a pattern,
<span class="lineno">  429 </span>-- for use as context info when printing messages. If there's a
<span class="lineno">  430 </span>-- real variable, prefer that (Right cases); otherwise take the
<span class="lineno">  431 </span>-- position of the first wildcard or empty tuple (Left cases).
<span class="lineno">  432 </span>getPatternContext :: Pattern -&gt; ContextName
<span class="lineno">  433 </span><span class="decl"><span class="istickedoff">getPatternContext pat0 =</span>
<span class="lineno">  434 </span><span class="spaces">  </span><span class="istickedoff">case visit pat0 of</span>
<span class="lineno">  435 </span><span class="spaces">    </span><span class="istickedoff">Left pos -&gt; ContextName pos &quot;_&quot;</span>
<span class="lineno">  436 </span><span class="spaces">    </span><span class="istickedoff">Right (pos, name) -&gt; ContextName pos name</span>
<span class="lineno">  437 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  438 </span><span class="spaces">    </span><span class="istickedoff">visit pat =</span>
<span class="lineno">  439 </span><span class="spaces">      </span><span class="istickedoff">case pat of</span>
<span class="lineno">  440 </span><span class="spaces">        </span><span class="istickedoff">PWild pos _ -&gt; Left pos</span>
<span class="lineno">  441 </span><span class="spaces">        </span><span class="istickedoff">PVar _ npos name _ -&gt; Right (npos, name)</span>
<span class="lineno">  442 </span><span class="spaces">        </span><span class="istickedoff">PTuple pos [] -&gt; <span class="nottickedoff">Left pos</span></span>
<span class="lineno">  443 </span><span class="spaces">        </span><span class="istickedoff">PTuple allpos ps -&gt;</span>
<span class="lineno">  444 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">case partitionEithers $ map visit ps of</span></span>
<span class="lineno">  445 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">(_, (pos, name) : _) -&gt; Right (pos, name)</span></span>
<span class="lineno">  446 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">(pos : _, _) -&gt; Left pos</span></span>
<span class="lineno">  447 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; Left allpos</span></span></span>
<span class="lineno">  448 </span>
<span class="lineno">  449 </span>-- Get all the bindings in a pattern.
<span class="lineno">  450 </span>patternBindings :: Pattern -&gt; [(Name, Pos, Maybe Type)]
<span class="lineno">  451 </span><span class="decl"><span class="istickedoff">patternBindings pat =</span>
<span class="lineno">  452 </span><span class="spaces">  </span><span class="istickedoff">case pat of</span>
<span class="lineno">  453 </span><span class="spaces">    </span><span class="istickedoff">PWild _ _mt -&gt; []</span>
<span class="lineno">  454 </span><span class="spaces">    </span><span class="istickedoff">PVar _ xpos x mt -&gt; [(x, xpos, mt)]</span>
<span class="lineno">  455 </span><span class="spaces">    </span><span class="istickedoff">PTuple _ ps -&gt; concatMap patternBindings ps</span></span>
<span class="lineno">  456 </span>
<span class="lineno">  457 </span>-- Get all the bindings in a pattern, using a separate passed-in
<span class="lineno">  458 </span>-- schema to get the types. Ignore the types in the pattern.
<span class="lineno">  459 </span>--
<span class="lineno">  460 </span>-- XXX: is that reasonable? Should probably assert that the schema
<span class="lineno">  461 </span>-- matches the types in the pattern, unless the pattern hasn't already
<span class="lineno">  462 </span>-- been checked yet, and that seems like it would be a bug.
<span class="lineno">  463 </span>--
<span class="lineno">  464 </span>-- Note that if the pattern is a tuple and the schema is not a tuple
<span class="lineno">  465 </span>-- type, we return nothing. Presumably in this case a type error has
<span class="lineno">  466 </span>-- already been generated and we don't need another one? But it would
<span class="lineno">  467 </span>-- probably be a good idea to check up on that. XXX
<span class="lineno">  468 </span>--
<span class="lineno">  469 </span>-- Alternatively if the pattern has had its types filled in, this
<span class="lineno">  470 </span>-- should not be different from the plain patternBindings and should
<span class="lineno">  471 </span>-- probably just be removed.
<span class="lineno">  472 </span>--
<span class="lineno">  473 </span>patternBindingsWithSchema :: Pattern -&gt; Schema -&gt; [(Name, Pos, Schema)]
<span class="lineno">  474 </span><span class="decl"><span class="istickedoff">patternBindingsWithSchema pat sch =</span>
<span class="lineno">  475 </span><span class="spaces">  </span><span class="istickedoff">case pat of</span>
<span class="lineno">  476 </span><span class="spaces">    </span><span class="istickedoff">PWild _ _ -&gt; []</span>
<span class="lineno">  477 </span><span class="spaces">    </span><span class="istickedoff">PVar _ xpos x _ -&gt; [(x, xpos, sch)]</span>
<span class="lineno">  478 </span><span class="spaces">    </span><span class="istickedoff">PTuple _ ps -&gt;</span>
<span class="lineno">  479 </span><span class="spaces">      </span><span class="istickedoff">case sch of</span>
<span class="lineno">  480 </span><span class="spaces">        </span><span class="istickedoff">Forall vs t -&gt; case t of</span>
<span class="lineno">  481 </span><span class="spaces">          </span><span class="istickedoff">TyCon _pos (TupleCon _) ts' -&gt;</span>
<span class="lineno">  482 </span><span class="spaces">            </span><span class="istickedoff">let once pat' t' = patternBindingsWithSchema pat' (Forall vs t') in</span>
<span class="lineno">  483 </span><span class="spaces">            </span><span class="istickedoff">concat $ zipWith once ps ts'</span>
<span class="lineno">  484 </span><span class="spaces">          </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">[]</span></span></span>
<span class="lineno">  485 </span>
<span class="lineno">  486 </span>
<span class="lineno">  487 </span>------------------------------------------------------------
<span class="lineno">  488 </span>-- Unification
<span class="lineno">  489 </span>
<span class="lineno">  490 </span>--
<span class="lineno">  491 </span>-- Error reporting.
<span class="lineno">  492 </span>--
<span class="lineno">  493 </span>-- When we find a mismatch, we have potentially recursed arbitrarily
<span class="lineno">  494 </span>-- deeply into the original type. We need to print the specific types
<span class="lineno">  495 </span>-- we trip on (this is important if they are e.g. elements in a large
<span class="lineno">  496 </span>-- system of nested records and typles) but we also want to print the
<span class="lineno">  497 </span>-- rest of the original context as well.
<span class="lineno">  498 </span>--
<span class="lineno">  499 </span>-- Therefore, we start with an initial descriptive message plus (in
<span class="lineno">  500 </span>-- most cases) a pair of expected and found types. Once we fail, we
<span class="lineno">  501 </span>-- add more expected/found type pairs on the way out of the recursion,
<span class="lineno">  502 </span>-- so we print every layer of the type.
<span class="lineno">  503 </span>--
<span class="lineno">  504 </span>-- As a special case, we keep only the outermost of a series of nested
<span class="lineno">  505 </span>-- function types, and drop the nested ones. Because functions are
<span class="lineno">  506 </span>-- curried, this prints the complete function signature once and skips
<span class="lineno">  507 </span>-- the incremental types completed by consuming each argument. (These
<span class="lineno">  508 </span>-- add little information and can also confuse casual users.)
<span class="lineno">  509 </span>--
<span class="lineno">  510 </span>-- The FailMGU type tracks this material. It contains three elements:
<span class="lineno">  511 </span>--    * the initial message
<span class="lineno">  512 </span>--    * the list of pairs of expected/found messages
<span class="lineno">  513 </span>--    * the current function-type expected/found message, if any
<span class="lineno">  514 </span>--
<span class="lineno">  515 </span>-- Empty strings are inserted between pairs to make the output more
<span class="lineno">  516 </span>-- readable.
<span class="lineno">  517 </span>--
<span class="lineno">  518 </span>-- Note that we print the messages on the fly rather than accumulating
<span class="lineno">  519 </span>-- a list of type pairs and printing them at the end. (That may have
<span class="lineno">  520 </span>-- been a mistake; we'll see.)
<span class="lineno">  521 </span>--
<span class="lineno">  522 </span>-- The last element (current function-type expected/found message) is
<span class="lineno">  523 </span>-- always either a list of two message strings or empty. Function types
<span class="lineno">  524 </span>-- we see go in it (replacing anything already there, so we keep only
<span class="lineno">  525 </span>-- the outermost of a series) and are shifted out of it when we see
<span class="lineno">  526 </span>-- something else. It could be a Maybe (String, String), but the code
<span class="lineno">  527 </span>-- is noticeably more convenient the way it is.
<span class="lineno">  528 </span>--
<span class="lineno">  529 </span>-- The initial message is kept separate so that the expected/found
<span class="lineno">  530 </span>-- list can readily be built in either order. It's not clear if it's
<span class="lineno">  531 </span>-- better to print the outermost or innermost mismatches first.
<span class="lineno">  532 </span>--
<span class="lineno">  533 </span>-- Further notes on the message formatting:
<span class="lineno">  534 </span>--
<span class="lineno">  535 </span>-- Print the expected and found types on their own lines. They can be
<span class="lineno">  536 </span>-- large; if they are the resulting lines can still be fairly
<span class="lineno">  537 </span>-- illegible, but at least the user doesn't have to hunt for &quot;found&quot;
<span class="lineno">  538 </span>-- in the middle of a multi-line print.
<span class="lineno">  539 </span>--
<span class="lineno">  540 </span>-- Pad the prefix of the prints so that the types line up; this is
<span class="lineno">  541 </span>-- helpful for longer types that still fit on one output line.
<span class="lineno">  542 </span>--
<span class="lineno">  543 </span>-- We'll indent each line with four spaces. What we send back gets
<span class="lineno">  544 </span>-- printed underneath a message that's already (at least in some
<span class="lineno">  545 </span>-- cases) indented by two spaces. It's important to make it clear that
<span class="lineno">  546 </span>-- all the stuff we generate is part of that message and not, for
<span class="lineno">  547 </span>-- example, an additional separate error. The indenting happens below.
<span class="lineno">  548 </span>--
<span class="lineno">  549 </span>-- Note that although we append to the end of the expected/found list,
<span class="lineno">  550 </span>-- we don't stick the start line in that list, because I keep going
<span class="lineno">  551 </span>-- back and forth on whether the larger types should be printed first
<span class="lineno">  552 </span>-- (prepending in failMGUadd) or last (appending). If we commit to
<span class="lineno">  553 </span>-- appending we don't need to keep the start line separate.
<span class="lineno">  554 </span>--
<span class="lineno">  555 </span>
<span class="lineno">  556 </span>data FailMGU = FailMGU
<span class="lineno">  557 </span>                    [String]    -- initial error message (often multiple lines)
<span class="lineno">  558 </span>                    [String]    -- list of found/expected message pairs
<span class="lineno">  559 </span>                    [String]    -- current found/expected function pair if any
<span class="lineno">  560 </span>
<span class="lineno">  561 </span>-- common code for printing expected/found types
<span class="lineno">  562 </span>showTypes :: Type -&gt; Type -&gt; [String]
<span class="lineno">  563 </span><span class="decl"><span class="istickedoff">showTypes ty1 ty2 =</span>
<span class="lineno">  564 </span><span class="spaces">  </span><span class="istickedoff">let expected = &quot;Expected: &quot; ++ pShow ty1</span>
<span class="lineno">  565 </span><span class="spaces">      </span><span class="istickedoff">found    = &quot;Found:    &quot; ++ pShow ty2</span>
<span class="lineno">  566 </span><span class="spaces">  </span><span class="istickedoff">in</span>
<span class="lineno">  567 </span><span class="spaces">  </span><span class="istickedoff">[expected, found, &quot;&quot;]</span></span>
<span class="lineno">  568 </span>
<span class="lineno">  569 </span>-- logic for showing details of a type
<span class="lineno">  570 </span>showTypeDetails :: Type -&gt; String
<span class="lineno">  571 </span><span class="decl"><span class="istickedoff">showTypeDetails ty =</span>
<span class="lineno">  572 </span><span class="spaces">  </span><span class="istickedoff">let pr pos what =</span>
<span class="lineno">  573 </span><span class="spaces">        </span><span class="istickedoff">show pos ++ &quot;: The type &quot; ++ pShow ty ++ &quot; arises from &quot; ++ what</span>
<span class="lineno">  574 </span><span class="spaces">  </span><span class="istickedoff">in</span>
<span class="lineno">  575 </span><span class="spaces">  </span><span class="istickedoff">case getPos ty of</span>
<span class="lineno">  576 </span><span class="spaces">    </span><span class="istickedoff">PosInferred InfFresh pos -&gt; pr pos &quot;a fresh type variable introduced here&quot;</span>
<span class="lineno">  577 </span><span class="spaces">    </span><span class="istickedoff">PosInferred InfTerm pos -&gt; pr pos &quot;the type of this term&quot;</span>
<span class="lineno">  578 </span><span class="spaces">    </span><span class="istickedoff">PosInferred InfContext pos -&gt; pr pos &quot;the context of the term&quot;</span>
<span class="lineno">  579 </span><span class="spaces">    </span><span class="istickedoff">pos -&gt; pr pos &quot;this type annotation&quot;</span></span>
<span class="lineno">  580 </span>
<span class="lineno">  581 </span>-- fail with expected/found types
<span class="lineno">  582 </span>failMGU :: String -&gt; Type -&gt; Type -&gt; Either FailMGU a
<span class="lineno">  583 </span><span class="decl"><span class="istickedoff">failMGU start ty1 ty2 = Left (FailMGU start' (&quot;&quot; : showTypes ty1 ty2) [])</span>
<span class="lineno">  584 </span><span class="spaces">  </span><span class="istickedoff">where start' = [start, showTypeDetails ty1, showTypeDetails ty2]</span></span>
<span class="lineno">  585 </span>
<span class="lineno">  586 </span>-- fail with no types
<span class="lineno">  587 </span>failMGU' :: String -&gt; Either FailMGU a
<span class="lineno">  588 </span><span class="decl"><span class="nottickedoff">failMGU' start = Left (FailMGU [start] [] [])</span></span>
<span class="lineno">  589 </span>
<span class="lineno">  590 </span>-- add another expected/found type pair to the failure
<span class="lineno">  591 </span>-- (pull in the last function-type lines if any)
<span class="lineno">  592 </span>failMGUAdd :: FailMGU -&gt; Type -&gt; Type -&gt; FailMGU
<span class="lineno">  593 </span><span class="decl"><span class="istickedoff">failMGUAdd (FailMGU start eflines lastfunlines) ty1 ty2 =</span>
<span class="lineno">  594 </span><span class="spaces">  </span><span class="istickedoff">FailMGU start (eflines ++ lastfunlines ++ showTypes ty1 ty2) []</span></span>
<span class="lineno">  595 </span>
<span class="lineno">  596 </span>-- add another pair that's a function type
<span class="lineno">  597 </span>-- (overwrite any previous function type lines)
<span class="lineno">  598 </span>failMGUAddFun :: FailMGU -&gt; Type -&gt; Type -&gt; FailMGU
<span class="lineno">  599 </span><span class="decl"><span class="istickedoff">failMGUAddFun (FailMGU start eflines _) ty1 ty2 =</span>
<span class="lineno">  600 </span><span class="spaces">  </span><span class="istickedoff">FailMGU start eflines (showTypes ty1 ty2)</span></span>
<span class="lineno">  601 </span>
<span class="lineno">  602 </span>-- print the failure as a string list
<span class="lineno">  603 </span>ppFailMGU :: FailMGU -&gt; [String]
<span class="lineno">  604 </span><span class="decl"><span class="istickedoff">ppFailMGU (FailMGU start eflines lastfunlines) =</span>
<span class="lineno">  605 </span><span class="spaces">  </span><span class="istickedoff">start ++ eflines ++ lastfunlines</span></span>
<span class="lineno">  606 </span>
<span class="lineno">  607 </span>-- We've found a substitution for unification var i.
<span class="lineno">  608 </span>--
<span class="lineno">  609 </span>-- Create the substitution, but first check that this doesn't result
<span class="lineno">  610 </span>-- in an invalid type. If it does, return Nothing. The caller handles
<span class="lineno">  611 </span>-- reporting the problem because we don't quite have enough context
<span class="lineno">  612 </span>-- here to do an adequate job.
<span class="lineno">  613 </span>--
<span class="lineno">  614 </span>-- Does not handle the case where t _is_ TyUnifyVar i; the caller
<span class="lineno">  615 </span>-- handles that.
<span class="lineno">  616 </span>--
<span class="lineno">  617 </span>-- XXX: we can resolve TyUnifyVar i to TyUnifyVar j here, which is
<span class="lineno">  618 </span>-- fine as far as it goes but there doesn't seem to be any logic to
<span class="lineno">  619 </span>-- prohibit also resolving TyUnifyVar j to TyUnifyVar i and creating
<span class="lineno">  620 </span>-- cycles.
<span class="lineno">  621 </span>resolveUnificationVar :: TypeIndex -&gt; Type -&gt; Maybe Subst
<span class="lineno">  622 </span><span class="decl"><span class="istickedoff">resolveUnificationVar i t2 =</span>
<span class="lineno">  623 </span><span class="spaces">  </span><span class="istickedoff">case Map.lookup i $ unifyVars t2 of</span>
<span class="lineno">  624 </span><span class="spaces">     </span><span class="istickedoff">Just _otherpos -&gt; Nothing</span>
<span class="lineno">  625 </span><span class="spaces">     </span><span class="istickedoff">Nothing -&gt; Just $ singletonSubst i t2</span></span>
<span class="lineno">  626 </span>
<span class="lineno">  627 </span>-- Guts of unification.
<span class="lineno">  628 </span>--
<span class="lineno">  629 </span>-- &quot;mgu&quot; stands for &quot;most general unifier&quot;.
<span class="lineno">  630 </span>--
<span class="lineno">  631 </span>-- Given two types, produce either a failure report or a substitution
<span class="lineno">  632 </span>-- (to add to the cumulative substitution we build up) that makes them
<span class="lineno">  633 </span>-- the same.
<span class="lineno">  634 </span>mgu :: Type -&gt; Type -&gt; Either FailMGU Subst
<span class="lineno">  635 </span><span class="decl"><span class="istickedoff">mgu t1 t2 = case (t1, t2) of</span>
<span class="lineno">  636 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  637 </span><span class="spaces">  </span><span class="istickedoff">(TyUnifyVar _ i, TyUnifyVar _ j) | i == j -&gt;</span>
<span class="lineno">  638 </span><span class="spaces">      </span><span class="istickedoff">-- same unification var, nothing to do</span>
<span class="lineno">  639 </span><span class="spaces">      </span><span class="istickedoff">return emptySubst</span>
<span class="lineno">  640 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  641 </span><span class="spaces">  </span><span class="istickedoff">(TyUnifyVar _ i, _) -&gt;</span>
<span class="lineno">  642 </span><span class="spaces">      </span><span class="istickedoff">-- one side is a unification var, resolve it</span>
<span class="lineno">  643 </span><span class="spaces">      </span><span class="istickedoff">case resolveUnificationVar i t2 of</span>
<span class="lineno">  644 </span><span class="spaces">          </span><span class="istickedoff">Just someSubst -&gt; return someSubst</span>
<span class="lineno">  645 </span><span class="spaces">          </span><span class="istickedoff">Nothing -&gt; do</span>
<span class="lineno">  646 </span><span class="spaces">              </span><span class="istickedoff">let t1' = pShow t1</span>
<span class="lineno">  647 </span><span class="spaces">                  </span><span class="istickedoff">t2' = pShow t2</span>
<span class="lineno">  648 </span><span class="spaces">              </span><span class="istickedoff">let msg = &quot;Occurs check failure: cannot unify &quot; ++ t1' ++</span>
<span class="lineno">  649 </span><span class="spaces">                        </span><span class="istickedoff">&quot; with &quot; ++ t2' ++ &quot; because &quot; ++ t1' ++</span>
<span class="lineno">  650 </span><span class="spaces">                        </span><span class="istickedoff">&quot; appears within &quot; ++ t2'</span>
<span class="lineno">  651 </span><span class="spaces">              </span><span class="istickedoff">failMGU msg t1 t2</span>
<span class="lineno">  652 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  653 </span><span class="spaces">  </span><span class="istickedoff">(_, TyUnifyVar _ i) -&gt;</span>
<span class="lineno">  654 </span><span class="spaces">      </span><span class="istickedoff">-- the other side is a unification var, resolve it</span>
<span class="lineno">  655 </span><span class="spaces">      </span><span class="istickedoff">case resolveUnificationVar i t1 of</span>
<span class="lineno">  656 </span><span class="spaces">          </span><span class="istickedoff">Just someSubst -&gt; return someSubst</span>
<span class="lineno">  657 </span><span class="spaces">          </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  658 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">let t1' = pShow t1</span></span>
<span class="lineno">  659 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">t2' = pShow t2</span></span>
<span class="lineno">  660 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">let msg = &quot;Occurs check failure: cannot unify &quot; ++ t1' ++</span></span>
<span class="lineno">  661 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">&quot; with &quot; ++ t2' ++ &quot; because &quot; ++ t2' ++</span></span>
<span class="lineno">  662 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">&quot; appears within &quot; ++ t1'</span></span>
<span class="lineno">  663 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">failMGU msg t1 t2</span></span>
<span class="lineno">  664 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  665 </span><span class="spaces">  </span><span class="istickedoff">(TyRecord _ ts1, TyRecord _ ts2)</span>
<span class="lineno">  666 </span><span class="spaces">    </span><span class="istickedoff">| Map.keys ts1 /= Map.keys ts2 -&gt;</span>
<span class="lineno">  667 </span><span class="spaces">      </span><span class="istickedoff">-- records with different keys</span>
<span class="lineno">  668 </span><span class="spaces">      </span><span class="istickedoff">failMGU &quot;Record field names mismatch.&quot; t1 t2</span>
<span class="lineno">  669 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  670 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt;</span>
<span class="lineno">  671 </span><span class="spaces">      </span><span class="istickedoff">-- records with the same field names, try unifying the field types</span>
<span class="lineno">  672 </span><span class="spaces">      </span><span class="istickedoff">case mgus (Map.elems ts1) (Map.elems ts2) of</span>
<span class="lineno">  673 </span><span class="spaces">        </span><span class="istickedoff">Right result -&gt; Right result</span>
<span class="lineno">  674 </span><span class="spaces">        </span><span class="istickedoff">Left msgs -&gt; Left $ failMGUAdd msgs t1 t2</span>
<span class="lineno">  675 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  676 </span><span class="spaces">  </span><span class="istickedoff">(TyCon _ tc1 ts1, TyCon _ tc2 ts2)</span>
<span class="lineno">  677 </span><span class="spaces">    </span><span class="istickedoff">| tc1 == tc2 -&gt;</span>
<span class="lineno">  678 </span><span class="spaces">      </span><span class="istickedoff">-- same type constructor, unify the args</span>
<span class="lineno">  679 </span><span class="spaces">      </span><span class="istickedoff">case mgus ts1 ts2 of</span>
<span class="lineno">  680 </span><span class="spaces">        </span><span class="istickedoff">Right result -&gt; Right result</span>
<span class="lineno">  681 </span><span class="spaces">        </span><span class="istickedoff">Left msgs -&gt;</span>
<span class="lineno">  682 </span><span class="spaces">          </span><span class="istickedoff">-- oops, didn't work. handle functions specially for</span>
<span class="lineno">  683 </span><span class="spaces">          </span><span class="istickedoff">-- nicer error reporting</span>
<span class="lineno">  684 </span><span class="spaces">          </span><span class="istickedoff">case tc1 of</span>
<span class="lineno">  685 </span><span class="spaces">            </span><span class="istickedoff">FunCon -&gt; Left $ failMGUAddFun msgs t1 t2</span>
<span class="lineno">  686 </span><span class="spaces">            </span><span class="istickedoff">_ -&gt; Left $ failMGUAdd msgs t1 t2</span>
<span class="lineno">  687 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  688 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt;</span>
<span class="lineno">  689 </span><span class="spaces">      </span><span class="istickedoff">-- Wrong type constructors</span>
<span class="lineno">  690 </span><span class="spaces">      </span><span class="istickedoff">case tc1 of</span>
<span class="lineno">  691 </span><span class="spaces">        </span><span class="istickedoff">FunCon -&gt;</span>
<span class="lineno">  692 </span><span class="spaces">          </span><span class="istickedoff">failMGU (&quot;Term is not a function. (Maybe a function is applied &quot; ++</span>
<span class="lineno">  693 </span><span class="spaces">                   </span><span class="istickedoff">&quot;to too many arguments?)&quot;) t1 t2</span>
<span class="lineno">  694 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  695 </span><span class="spaces">          </span><span class="istickedoff">failMGU (&quot;Mismatch of type constructors. Expected: &quot; ++ pShow tc1 ++</span>
<span class="lineno">  696 </span><span class="spaces">                   </span><span class="istickedoff">&quot; but got &quot; ++ pShow tc2) t1 t2</span>
<span class="lineno">  697 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  698 </span><span class="spaces">  </span><span class="istickedoff">(TyVar _ a, TyVar _ b) | <span class="tickonlytrue">a == b</span> -&gt;</span>
<span class="lineno">  699 </span><span class="spaces">      </span><span class="istickedoff">-- Same named variable</span>
<span class="lineno">  700 </span><span class="spaces">      </span><span class="istickedoff">return emptySubst</span>
<span class="lineno">  701 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  702 </span><span class="spaces">  </span><span class="istickedoff">(_, _) -&gt;</span>
<span class="lineno">  703 </span><span class="spaces">      </span><span class="istickedoff">-- Did not work</span>
<span class="lineno">  704 </span><span class="spaces">      </span><span class="istickedoff">failMGU &quot;Mismatch of types.&quot; t1 t2</span></span>
<span class="lineno">  705 </span>
<span class="lineno">  706 </span>-- Run mgu on two lists of types.
<span class="lineno">  707 </span>mgus :: [Type] -&gt; [Type] -&gt; Either FailMGU Subst
<span class="lineno">  708 </span><span class="decl"><span class="istickedoff">mgus t1s t2s = case (t1s, t2s) of</span>
<span class="lineno">  709 </span><span class="spaces">    </span><span class="istickedoff">([], []) -&gt;</span>
<span class="lineno">  710 </span><span class="spaces">        </span><span class="istickedoff">return emptySubst</span>
<span class="lineno">  711 </span><span class="spaces">    </span><span class="istickedoff">(t1 : t1s', t2 : t2s') -&gt; do</span>
<span class="lineno">  712 </span><span class="spaces">        </span><span class="istickedoff">-- unify the first types</span>
<span class="lineno">  713 </span><span class="spaces">        </span><span class="istickedoff">s &lt;- mgu t1 t2</span>
<span class="lineno">  714 </span><span class="spaces">        </span><span class="istickedoff">-- apply that substitution and then recurse</span>
<span class="lineno">  715 </span><span class="spaces">        </span><span class="istickedoff">s' &lt;- mgus (map (appSubst s) t1s') (map (appSubst s) t2s')</span>
<span class="lineno">  716 </span><span class="spaces">        </span><span class="istickedoff">return (mergeSubst s' s)</span>
<span class="lineno">  717 </span><span class="spaces">    </span><span class="istickedoff">(_, _) -&gt;</span>
<span class="lineno">  718 </span><span class="spaces">      </span><span class="istickedoff">-- XXX this is no good, it will always print one of the lengths as 0!</span>
<span class="lineno">  719 </span><span class="spaces">      </span><span class="istickedoff">-- (also, note that this is only reachable for type constructor args</span>
<span class="lineno">  720 </span><span class="spaces">      </span><span class="istickedoff">-- and not function args)</span>
<span class="lineno">  721 </span><span class="spaces">      </span><span class="istickedoff">--</span>
<span class="lineno">  722 </span><span class="spaces">      </span><span class="istickedoff">-- dholland 20250106: I believe this is currently unreachable.</span>
<span class="lineno">  723 </span><span class="spaces">      </span><span class="istickedoff">-- mgus is called from two places above (record fields and type</span>
<span class="lineno">  724 </span><span class="spaces">      </span><span class="istickedoff">-- constructor arguments); the record fields case always passes</span>
<span class="lineno">  725 </span><span class="spaces">      </span><span class="istickedoff">-- lists of the same length. The situation with type constructor</span>
<span class="lineno">  726 </span><span class="spaces">      </span><span class="istickedoff">-- arguments is murkier. However, there are only a handful of</span>
<span class="lineno">  727 </span><span class="spaces">      </span><span class="istickedoff">-- builtin types whose constructors take arguments at all:</span>
<span class="lineno">  728 </span><span class="spaces">      </span><span class="istickedoff">-- tuples, lists, functions, and monads/contexts/blocks. The</span>
<span class="lineno">  729 </span><span class="spaces">      </span><span class="istickedoff">-- parser special-cases the syntax for all of these, so that you</span>
<span class="lineno">  730 </span><span class="spaces">      </span><span class="istickedoff">-- apparently can't produce partially applied instances for</span>
<span class="lineno">  731 </span><span class="spaces">      </span><span class="istickedoff">-- any. (And for tuples, the arity is part of the constructor,</span>
<span class="lineno">  732 </span><span class="spaces">      </span><span class="istickedoff">-- so tuples of different arity won't get as far as trying to</span>
<span class="lineno">  733 </span><span class="spaces">      </span><span class="istickedoff">-- unify the arguments.)</span>
<span class="lineno">  734 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">failMGU' $ &quot;Wrong number of arguments. Expected &quot; ++ show (length t1s) ++</span></span>
<span class="lineno">  735 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">&quot; but got &quot; ++ show (length t2s)</span></span></span>
<span class="lineno">  736 </span>
<span class="lineno">  737 </span>--
<span class="lineno">  738 </span>-- Unify two types.
<span class="lineno">  739 </span>--
<span class="lineno">  740 </span>
<span class="lineno">  741 </span>-- When typechecking an expression the first type argument (t1) should
<span class="lineno">  742 </span>-- be the type expected from the context, and the second (t2) should
<span class="lineno">  743 </span>-- be the type found in the expression appearing in that context. For
<span class="lineno">  744 </span>-- example, when checking the second argument of a function application
<span class="lineno">  745 </span>-- (Application _pos e1 e2) checking e1 gives rise to an expected type
<span class="lineno">  746 </span>-- for e2, so when unifying that with the result of checking e2 the
<span class="lineno">  747 </span>-- t1 argument should be the expected type arising from e1, the t2
<span class="lineno">  748 </span>-- argument should be the type returned by checking e2, and the position
<span class="lineno">  749 </span>-- argument should be the position of e2 (not the position of the
<span class="lineno">  750 </span>-- enclosing apply node). If it doesn't work, the message generated
<span class="lineno">  751 </span>-- will be of the form &quot;pos: found t2, expected t1&quot;.
<span class="lineno">  752 </span>--
<span class="lineno">  753 </span>-- Other cases should pass the arguments analogously. As of this
<span class="lineno">  754 </span>-- writing some are definitely backwards.
<span class="lineno">  755 </span>--
<span class="lineno">  756 </span>-- Further notes on error messages:
<span class="lineno">  757 </span>--
<span class="lineno">  758 </span>-- The error message returned by mgu already prints the types at some
<span class="lineno">  759 </span>-- length, so we don't need to print any of that again.
<span class="lineno">  760 </span>--
<span class="lineno">  761 </span>-- Indent all but the first line by four spaces because the first line
<span class="lineno">  762 </span>-- ends up indented by two when it ultimately gets printed (or at
<span class="lineno">  763 </span>-- least sometimes it does) and we want the grouping to be clearly
<span class="lineno">  764 </span>-- recognizable.
<span class="lineno">  765 </span>--
<span class="lineno">  766 </span>-- The ContextName passed in is (at least in most cases) the name of
<span class="lineno">  767 </span>-- the top-level binding the unification happens inside. Its position
<span class="lineno">  768 </span>-- is therefore usually not where the problem is except in a very
<span class="lineno">  769 </span>-- abstract sense and shouldn't be printed as if it's the error
<span class="lineno">  770 </span>-- location. So tack it onto the end of everything.
<span class="lineno">  771 </span>--
<span class="lineno">  772 </span>-- It's not clear that this is always the case, so in turn it's not
<span class="lineno">  773 </span>-- entirely clear that it's always useless and I'm hesitant to remove
<span class="lineno">  774 </span>-- it entirely, but that seems like a reasonable thing to do in the
<span class="lineno">  775 </span>-- future given more clarity.
<span class="lineno">  776 </span>--
<span class="lineno">  777 </span>unify :: ContextName -&gt; Type -&gt; Pos -&gt; Type -&gt; TI ()
<span class="lineno">  778 </span><span class="decl"><span class="istickedoff">unify cname t1 pos t2 = do</span>
<span class="lineno">  779 </span><span class="spaces">  </span><span class="istickedoff">t1' &lt;- applyCurrentSubst =&lt;&lt; resolveCurrentTypedefs t1</span>
<span class="lineno">  780 </span><span class="spaces">  </span><span class="istickedoff">t2' &lt;- applyCurrentSubst =&lt;&lt; resolveCurrentTypedefs t2</span>
<span class="lineno">  781 </span><span class="spaces">  </span><span class="istickedoff">case mgu t1' t2' of</span>
<span class="lineno">  782 </span><span class="spaces">    </span><span class="istickedoff">Right s -&gt; modify $ \rw -&gt; rw { subst = mergeSubst s $ subst rw }</span>
<span class="lineno">  783 </span><span class="spaces">    </span><span class="istickedoff">Left msgs -&gt;</span>
<span class="lineno">  784 </span><span class="spaces">       </span><span class="istickedoff">recordError pos $ unlines $ firstline : morelines'</span>
<span class="lineno">  785 </span><span class="spaces">       </span><span class="istickedoff">where</span>
<span class="lineno">  786 </span><span class="spaces">         </span><span class="istickedoff">firstline = &quot;Type mismatch.&quot;</span>
<span class="lineno">  787 </span><span class="spaces">         </span><span class="istickedoff">morelines = ppFailMGU msgs ++ [&quot;within &quot; ++ show cname]</span>
<span class="lineno">  788 </span><span class="spaces">         </span><span class="istickedoff">-- Indent all but the first line by four spaces.</span>
<span class="lineno">  789 </span><span class="spaces">         </span><span class="istickedoff">-- Don't indent blank lines; that produces trailing whitespace.</span>
<span class="lineno">  790 </span><span class="spaces">         </span><span class="istickedoff">adjust msg = case msg of</span>
<span class="lineno">  791 </span><span class="spaces">             </span><span class="istickedoff">[] -&gt; []</span>
<span class="lineno">  792 </span><span class="spaces">             </span><span class="istickedoff">_ -&gt; &quot;    &quot; ++ msg</span>
<span class="lineno">  793 </span><span class="spaces">         </span><span class="istickedoff">morelines' = map adjust morelines</span></span>
<span class="lineno">  794 </span>
<span class="lineno">  795 </span>-- Check if two types match but don't actually unify them
<span class="lineno">  796 </span>-- (that is, on success throw away the substitution and on error
<span class="lineno">  797 </span>-- throw away the complaints)
<span class="lineno">  798 </span>--
<span class="lineno">  799 </span>-- This is inelegant, and used for some workaround logic to decide
<span class="lineno">  800 </span>-- which unifications to attempt to avoid failures on things we don't
<span class="lineno">  801 </span>-- want to make fatal just yet. It should be removed when no longer
<span class="lineno">  802 </span>-- needed.
<span class="lineno">  803 </span>matches :: Type -&gt; Type -&gt; TI Bool
<span class="lineno">  804 </span><span class="decl"><span class="istickedoff">matches t1 t2 = do</span>
<span class="lineno">  805 </span><span class="spaces">  </span><span class="istickedoff">t1' &lt;- applyCurrentSubst =&lt;&lt; resolveCurrentTypedefs t1</span>
<span class="lineno">  806 </span><span class="spaces">  </span><span class="istickedoff">t2' &lt;- applyCurrentSubst =&lt;&lt; resolveCurrentTypedefs t2</span>
<span class="lineno">  807 </span><span class="spaces">  </span><span class="istickedoff">case mgu t1' t2' of</span>
<span class="lineno">  808 </span><span class="spaces">    </span><span class="istickedoff">Right _ -&gt; return True</span>
<span class="lineno">  809 </span><span class="spaces">    </span><span class="istickedoff">Left _ -&gt; return False</span></span>
<span class="lineno">  810 </span>
<span class="lineno">  811 </span>
<span class="lineno">  812 </span>------------------------------------------------------------
<span class="lineno">  813 </span>-- Inspect for free type variables
<span class="lineno">  814 </span>
<span class="lineno">  815 </span>-- We want to allow declaring polymorphic functions by introducing
<span class="lineno">  816 </span>-- type variables in the function header (rather than requiring an
<span class="lineno">  817 </span>-- explicit forall binding), like Haskell does.
<span class="lineno">  818 </span>--
<span class="lineno">  819 </span>-- This means that free type variables in a function header (but not
<span class="lineno">  820 </span>-- elsewhere) should be accepted, collected, and handed off to
<span class="lineno">  821 </span>-- generalize for insertion in the resultant type scheme.
<span class="lineno">  822 </span>--
<span class="lineno">  823 </span>-- It turns out that because of the way the AST represents functions
<span class="lineno">  824 </span>-- in let-bindings that this is highly unpleasant to do on the fly
<span class="lineno">  825 </span>-- while typechecking. So instead extract the free type variables
<span class="lineno">  826 </span>-- separately.
<span class="lineno">  827 </span>--
<span class="lineno">  828 </span>-- A function header comes through like this:
<span class="lineno">  829 </span>--    Decl _pos &lt;function-name-pattern&gt; Nothing &lt;expr&gt;
<span class="lineno">  830 </span>--
<span class="lineno">  831 </span>-- where &lt;expr&gt; is
<span class="lineno">  832 </span>--    zero or more times, Lambda _pos &lt;arg-pattern&gt; &lt;expr'&gt;
<span class="lineno">  833 </span>--    then optionally, TSig _pos &lt;expr''&gt; &lt;return-type&gt;
<span class="lineno">  834 </span>--
<span class="lineno">  835 </span>-- so we need any free type variables in
<span class="lineno">  836 </span>--    - &lt;function-name-pattern&gt;
<span class="lineno">  837 </span>--    - &lt;return-type&gt;
<span class="lineno">  838 </span>--    - all &lt;arg-pattern&gt;
<span class="lineno">  839 </span>--
<span class="lineno">  840 </span>-- On the plus side this will also then work when people write
<span class="lineno">  841 </span>-- otherwise annoying things like
<span class="lineno">  842 </span>--    let f (x: a) = \(y: b) -&gt; (a, b)
<span class="lineno">  843 </span>--
<span class="lineno">  844 </span>-- We extract the type variables with the position of their
<span class="lineno">  845 </span>-- initial mention, and the kind that appears to apply.
<span class="lineno">  846 </span>--
<span class="lineno">  847 </span>-- If the kind usage is inconsistent, the declaration involved will
<span class="lineno">  848 </span>-- fail kind-checking downstream. So it doesn't matter which of the
<span class="lineno">  849 </span>-- multiple usages we return, and we'll leave that unspecified.
<span class="lineno">  850 </span>
<span class="lineno">  851 </span>-- Get the free type variables found in a Type.
<span class="lineno">  852 </span>inspectTypeFTVs :: Kind -&gt; Type -&gt; TI (Map Name (Pos, Kind))
<span class="lineno">  853 </span><span class="decl"><span class="istickedoff">inspectTypeFTVs kind ty = case ty of</span>
<span class="lineno">  854 </span><span class="spaces">    </span><span class="istickedoff">TyCon _pos ctor args -&gt; do</span>
<span class="lineno">  855 </span><span class="spaces">        </span><span class="istickedoff">let kinds = lookupTyCon ctor</span>
<span class="lineno">  856 </span><span class="spaces">        </span><span class="istickedoff">Map.unions &lt;$&gt; zipWithM inspectTypeFTVs kinds args</span>
<span class="lineno">  857 </span><span class="spaces">    </span><span class="istickedoff">TyRecord _pos fields -&gt;</span>
<span class="lineno">  858 </span><span class="spaces">        </span><span class="istickedoff">Map.unions &lt;$&gt; traverse (inspectTypeFTVs <span class="nottickedoff">kindStar</span>) fields</span>
<span class="lineno">  859 </span><span class="spaces">    </span><span class="istickedoff">TyUnifyVar _pos _x -&gt;</span>
<span class="lineno">  860 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return Map.empty</span></span>
<span class="lineno">  861 </span><span class="spaces">    </span><span class="istickedoff">TyVar pos x -&gt; do</span>
<span class="lineno">  862 </span><span class="spaces">        </span><span class="istickedoff">tyenv &lt;- gets tyEnv</span>
<span class="lineno">  863 </span><span class="spaces">        </span><span class="istickedoff">case ScopedMap.lookup x tyenv of</span>
<span class="lineno">  864 </span><span class="spaces">            </span><span class="istickedoff">Nothing -&gt; return $ Map.singleton x (<span class="nottickedoff">pos</span>, kind)</span>
<span class="lineno">  865 </span><span class="spaces">            </span><span class="istickedoff">Just _ -&gt; return $ Map.empty</span></span>
<span class="lineno">  866 </span>
<span class="lineno">  867 </span>-- Get the free type variables found in a Maybe Type.
<span class="lineno">  868 </span>inspectMaybeTypeFTVs :: Kind -&gt; Maybe Type -&gt; TI (Map Name (Pos, Kind))
<span class="lineno">  869 </span><span class="decl"><span class="istickedoff">inspectMaybeTypeFTVs kind mty = case mty of</span>
<span class="lineno">  870 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; return Map.empty</span>
<span class="lineno">  871 </span><span class="spaces">    </span><span class="istickedoff">Just ty -&gt; inspectTypeFTVs kind ty</span></span>
<span class="lineno">  872 </span>
<span class="lineno">  873 </span>-- Get the free type variables found in a Pattern.
<span class="lineno">  874 </span>inspectPatternFTVs :: Pattern -&gt; TI (Map Name (Pos, Kind))
<span class="lineno">  875 </span><span class="decl"><span class="istickedoff">inspectPatternFTVs pat = case pat of</span>
<span class="lineno">  876 </span><span class="spaces">    </span><span class="istickedoff">PWild _pos mty -&gt; inspectMaybeTypeFTVs <span class="nottickedoff">kindStar</span> mty</span>
<span class="lineno">  877 </span><span class="spaces">    </span><span class="istickedoff">PVar _allpos _xpos _x mty -&gt; inspectMaybeTypeFTVs kindStar mty</span>
<span class="lineno">  878 </span><span class="spaces">    </span><span class="istickedoff">PTuple _pos subpats -&gt;</span>
<span class="lineno">  879 </span><span class="spaces">        </span><span class="istickedoff">Map.unions &lt;$&gt; mapM inspectPatternFTVs subpats</span></span>
<span class="lineno">  880 </span>
<span class="lineno">  881 </span>-- Get the free type variables found in a chain of Lambda Exprs.
<span class="lineno">  882 </span>-- Also return the body expression found on the inside of the chain
<span class="lineno">  883 </span>-- for possible further analysis.
<span class="lineno">  884 </span>inspectLambdaFTVs :: Expr -&gt; TI (Expr, Map Name (Pos, Kind))
<span class="lineno">  885 </span><span class="decl"><span class="istickedoff">inspectLambdaFTVs e0 = case e0 of</span>
<span class="lineno">  886 </span><span class="spaces">    </span><span class="istickedoff">Lambda _fpos _mname pat e1 -&gt; do</span>
<span class="lineno">  887 </span><span class="spaces">        </span><span class="istickedoff">hereFTVs &lt;- inspectPatternFTVs pat</span>
<span class="lineno">  888 </span><span class="spaces">        </span><span class="istickedoff">(e1', moreFTVs) &lt;- inspectLambdaFTVs e1</span>
<span class="lineno">  889 </span><span class="spaces">        </span><span class="istickedoff">return (e1', Map.union hereFTVs moreFTVs)</span>
<span class="lineno">  890 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  891 </span><span class="spaces">        </span><span class="istickedoff">return (e0, Map.empty)</span></span>
<span class="lineno">  892 </span>
<span class="lineno">  893 </span>-- Get the free type variables found in a Decl.
<span class="lineno">  894 </span>inspectDeclFTVs :: Decl -&gt; TI (Map Name (Pos, Kind))
<span class="lineno">  895 </span><span class="decl"><span class="istickedoff">inspectDeclFTVs (Decl _dpos pat _mty e0) = do</span>
<span class="lineno">  896 </span><span class="spaces">    </span><span class="istickedoff">nameFTVs &lt;- inspectPatternFTVs pat</span>
<span class="lineno">  897 </span><span class="spaces">    </span><span class="istickedoff">(e1, argFTVs) &lt;- inspectLambdaFTVs e0</span>
<span class="lineno">  898 </span><span class="spaces">    </span><span class="istickedoff">retFTVs &lt;- case e1 of</span>
<span class="lineno">  899 </span><span class="spaces">        </span><span class="istickedoff">TSig _tspos _e2 ty -&gt; inspectTypeFTVs kindStar ty</span>
<span class="lineno">  900 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; return Map.empty</span>
<span class="lineno">  901 </span><span class="spaces">    </span><span class="istickedoff">return $ Map.unions [nameFTVs, argFTVs, retFTVs]</span></span>
<span class="lineno">  902 </span>
<span class="lineno">  903 </span>
<span class="lineno">  904 </span>
<span class="lineno">  905 </span>------------------------------------------------------------
<span class="lineno">  906 </span>-- Main recursive pass
<span class="lineno">  907 </span>
<span class="lineno">  908 </span>type OutExpr = Expr
<span class="lineno">  909 </span>type OutStmt = Stmt
<span class="lineno">  910 </span>
<span class="lineno">  911 </span>--
<span class="lineno">  912 </span>-- Expressions
<span class="lineno">  913 </span>--
<span class="lineno">  914 </span>
<span class="lineno">  915 </span>-- Take a struct field binding (name and expression) and return the
<span class="lineno">  916 </span>-- updated binding as well as the member entry for the enclosing
<span class="lineno">  917 </span>-- struct type.
<span class="lineno">  918 </span>inferField :: ContextName -&gt; (Name, Expr) -&gt; TI ((Name, OutExpr), (Name, Type))
<span class="lineno">  919 </span><span class="decl"><span class="istickedoff">inferField cname (n,e) = do</span>
<span class="lineno">  920 </span><span class="spaces">    </span><span class="istickedoff">(e', t) &lt;- inferExpr (<span class="nottickedoff">cname</span>, e)</span>
<span class="lineno">  921 </span><span class="spaces">    </span><span class="istickedoff">return ((n, e'), (n, t))</span></span>
<span class="lineno">  922 </span>
<span class="lineno">  923 </span>-- Add x with type ty to the environment.
<span class="lineno">  924 </span>addVar :: Name -&gt; Pos -&gt; Rebindable -&gt; Schema -&gt; TI ()
<span class="lineno">  925 </span><span class="decl"><span class="istickedoff">addVar x pos rb ty = do</span>
<span class="lineno">  926 </span><span class="spaces">    </span><span class="istickedoff">env &lt;- gets varEnv</span>
<span class="lineno">  927 </span><span class="spaces">    </span><span class="istickedoff">let env' = ScopedMap.insert x (pos, Current, rb, ty) env</span>
<span class="lineno">  928 </span><span class="spaces">    </span><span class="istickedoff">modify (\rw -&gt; rw { varEnv = env' })</span></span>
<span class="lineno">  929 </span>
<span class="lineno">  930 </span>-- Add xs with type tys to the environment.
<span class="lineno">  931 </span>addVars :: Rebindable -&gt; [(Name, Pos, Schema)] -&gt; TI ()
<span class="lineno">  932 </span><span class="decl"><span class="istickedoff">addVars rb bindings = mapM_ (\(x, pos, ty) -&gt; addVar x pos rb ty) bindings</span></span>
<span class="lineno">  933 </span>
<span class="lineno">  934 </span>-- Add all the vars in a pattern to the environment.
<span class="lineno">  935 </span>--
<span class="lineno">  936 </span>-- (Note that the pattern should have already been processed so it
<span class="lineno">  937 </span>-- contains types; hence the irrefutable Just t.)
<span class="lineno">  938 </span>addPattern :: Pattern -&gt; TI ()
<span class="lineno">  939 </span><span class="decl"><span class="istickedoff">addPattern pat = addVars <span class="nottickedoff">ReadOnlyVar</span> bindings</span>
<span class="lineno">  940 </span><span class="spaces">  </span><span class="istickedoff">where bindings = [ (x, pos, tMono t) | (x, pos, Just t) &lt;- patternBindings pat ]</span></span>
<span class="lineno">  941 </span>
<span class="lineno">  942 </span>-- Add all the vars in a list of patterns to the environment, while
<span class="lineno">  943 </span>-- running m.
<span class="lineno">  944 </span>--
<span class="lineno">  945 </span>-- (Note that the patterns should have already been processed so they
<span class="lineno">  946 </span>-- contain types; hence the irrefutable Just t.)
<span class="lineno">  947 </span>addPatterns :: [Pattern] -&gt; TI ()
<span class="lineno">  948 </span><span class="decl"><span class="istickedoff">addPatterns pats = addVars <span class="nottickedoff">ReadOnlyVar</span> allbindings</span>
<span class="lineno">  949 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  950 </span><span class="spaces">     </span><span class="istickedoff">bindings pat = [ (x, <span class="nottickedoff">pos</span>, tMono t) | (x, pos, Just t) &lt;- patternBindings pat ]</span>
<span class="lineno">  951 </span><span class="spaces">     </span><span class="istickedoff">allbindings = concatMap bindings pats</span></span>
<span class="lineno">  952 </span>
<span class="lineno">  953 </span>-- Add all the vars in a pattern to the environment.
<span class="lineno">  954 </span>--
<span class="lineno">  955 </span>-- Variant version that uses the passed-in schema to produce the types
<span class="lineno">  956 </span>-- and ignoring the types already loaded into the pattern.
<span class="lineno">  957 </span>addPatternSchema :: Pattern -&gt; Rebindable -&gt; Schema -&gt; TI ()
<span class="lineno">  958 </span><span class="decl"><span class="istickedoff">addPatternSchema pat rb ty = addVars rb bindings</span>
<span class="lineno">  959 </span><span class="spaces">  </span><span class="istickedoff">where bindings = patternBindingsWithSchema pat ty</span></span>
<span class="lineno">  960 </span>
<span class="lineno">  961 </span>-- Add all the vars in a declaration to the environment.
<span class="lineno">  962 </span>--
<span class="lineno">  963 </span>-- Do nothing if there's no type schema in this declaration yet.
<span class="lineno">  964 </span>-- XXX: is that reasonable? shouldn't it panic?
<span class="lineno">  965 </span>addDecl :: Rebindable -&gt; Decl -&gt; TI ()
<span class="lineno">  966 </span><span class="decl"><span class="istickedoff">addDecl _rb (Decl _ _ Nothing _) = <span class="nottickedoff">return ()</span></span>
<span class="lineno">  967 </span><span class="spaces"></span><span class="istickedoff">addDecl rb (Decl _ p (Just s) _) = addPatternSchema p rb s</span></span>
<span class="lineno">  968 </span>
<span class="lineno">  969 </span>-- Add all the vars in a declaration to the environment, while running m.
<span class="lineno">  970 </span>addDeclGroup :: Rebindable -&gt; DeclGroup -&gt; TI ()
<span class="lineno">  971 </span><span class="decl"><span class="istickedoff">addDeclGroup rb (NonRecursive d) = addDecl rb d</span>
<span class="lineno">  972 </span><span class="spaces"></span><span class="istickedoff">addDeclGroup rb (Recursive ds) = mapM_ (addDecl <span class="nottickedoff">rb</span>) ds</span></span>
<span class="lineno">  973 </span>
<span class="lineno">  974 </span>-- Add some abstract type variables.
<span class="lineno">  975 </span>addAbstractTyVars :: Map Name (Pos, Kind) -&gt; TI ()
<span class="lineno">  976 </span><span class="decl"><span class="istickedoff">addAbstractTyVars vars = do</span>
<span class="lineno">  977 </span><span class="spaces">    </span><span class="istickedoff">let insertOne x (_pos, kind) tyenv =</span>
<span class="lineno">  978 </span><span class="spaces">            </span><span class="istickedoff">ScopedMap.insert x (Current, AbstractType kind) tyenv</span>
<span class="lineno">  979 </span><span class="spaces">        </span><span class="istickedoff">insertAll tyenv =</span>
<span class="lineno">  980 </span><span class="spaces">            </span><span class="istickedoff">Map.foldrWithKey insertOne tyenv vars</span>
<span class="lineno">  981 </span><span class="spaces">    </span><span class="istickedoff">tyenv &lt;- gets tyEnv</span>
<span class="lineno">  982 </span><span class="spaces">    </span><span class="istickedoff">let tyenv' = insertAll tyenv</span>
<span class="lineno">  983 </span><span class="spaces">    </span><span class="istickedoff">modify (\rw -&gt; rw { tyEnv = tyenv' })</span></span>
<span class="lineno">  984 </span>
<span class="lineno">  985 </span>--
<span class="lineno">  986 </span>-- Infer the type for an expression.
<span class="lineno">  987 </span>--
<span class="lineno">  988 </span>-- The ContextName is the context name passed to unify, which isn't
<span class="lineno">  989 </span>-- generally useful and should probably be removed.
<span class="lineno">  990 </span>--
<span class="lineno">  991 </span>inferExpr :: (ContextName, Expr) -&gt; TI (OutExpr, Type)
<span class="lineno">  992 </span><span class="decl"><span class="istickedoff">inferExpr (ln, expr) = case expr of</span>
<span class="lineno">  993 </span><span class="spaces">  </span><span class="istickedoff">Bool pos b    -&gt; <span class="nottickedoff">return (Bool pos b, tBool (PosInferred InfTerm pos))</span></span>
<span class="lineno">  994 </span><span class="spaces">  </span><span class="istickedoff">String pos s  -&gt; return (String pos s, tString (PosInferred InfTerm pos))</span>
<span class="lineno">  995 </span><span class="spaces">  </span><span class="istickedoff">Int pos i     -&gt; return (Int pos i, tInt (PosInferred InfTerm pos))</span>
<span class="lineno">  996 </span><span class="spaces">  </span><span class="istickedoff">Code pos s    -&gt; return (Code pos s, tTerm (PosInferred InfTerm pos))</span>
<span class="lineno">  997 </span><span class="spaces">  </span><span class="istickedoff">CType pos s   -&gt; return (CType pos s, tType (PosInferred InfTerm pos))</span>
<span class="lineno">  998 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  999 </span><span class="spaces">  </span><span class="istickedoff">Array pos [] -&gt; do</span>
<span class="lineno"> 1000 </span><span class="spaces">      </span><span class="istickedoff">a &lt;- getFreshTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno"> 1001 </span><span class="spaces">      </span><span class="istickedoff">return (Array <span class="nottickedoff">pos</span> [], tArray <span class="nottickedoff">(PosInferred InfTerm pos)</span> a)</span>
<span class="lineno"> 1002 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1003 </span><span class="spaces">  </span><span class="istickedoff">Array pos (e:es) -&gt; do</span>
<span class="lineno"> 1004 </span><span class="spaces">      </span><span class="istickedoff">(e',t) &lt;- inferExpr (<span class="nottickedoff">ln</span>, e)</span>
<span class="lineno"> 1005 </span><span class="spaces">      </span><span class="istickedoff">es' &lt;- mapM (flip (checkExpr ln) t) es</span>
<span class="lineno"> 1006 </span><span class="spaces">      </span><span class="istickedoff">return (Array pos (e':es'), tArray (PosInferred InfTerm pos) t)</span>
<span class="lineno"> 1007 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1008 </span><span class="spaces">  </span><span class="istickedoff">Block pos body -&gt; do</span>
<span class="lineno"> 1009 </span><span class="spaces">      </span><span class="istickedoff">ctx &lt;- getFreshTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno"> 1010 </span><span class="spaces">      </span><span class="istickedoff">tyResult &lt;- getFreshTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno"> 1011 </span><span class="spaces">      </span><span class="istickedoff">let ty = tBlock <span class="nottickedoff">(PosInferred InfTerm pos)</span> ctx tyResult</span>
<span class="lineno"> 1012 </span><span class="spaces">      </span><span class="istickedoff">pushScope</span>
<span class="lineno"> 1013 </span><span class="spaces">      </span><span class="istickedoff">body' &lt;- inferBlock ln <span class="nottickedoff">pos</span> ctx ty body</span>
<span class="lineno"> 1014 </span><span class="spaces">      </span><span class="istickedoff">popScope</span>
<span class="lineno"> 1015 </span><span class="spaces">      </span><span class="istickedoff">return (Block <span class="nottickedoff">pos</span> body', ty)</span>
<span class="lineno"> 1016 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1017 </span><span class="spaces">  </span><span class="istickedoff">Tuple pos es -&gt; do</span>
<span class="lineno"> 1018 </span><span class="spaces">      </span><span class="istickedoff">(es',ts) &lt;- unzip `fmap` mapM (inferExpr . (ln,)) es</span>
<span class="lineno"> 1019 </span><span class="spaces">      </span><span class="istickedoff">return (Tuple pos es', tTuple (PosInferred InfTerm pos) ts)</span>
<span class="lineno"> 1020 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1021 </span><span class="spaces">  </span><span class="istickedoff">Record pos fs -&gt; do</span>
<span class="lineno"> 1022 </span><span class="spaces">      </span><span class="istickedoff">(nes',nts) &lt;- unzip `fmap` mapM (inferField <span class="nottickedoff">ln</span>) (Map.toList fs)</span>
<span class="lineno"> 1023 </span><span class="spaces">      </span><span class="istickedoff">let ty = TyRecord (PosInferred InfTerm pos) $ Map.fromList nts</span>
<span class="lineno"> 1024 </span><span class="spaces">      </span><span class="istickedoff">return (Record pos (Map.fromList nes'), ty)</span>
<span class="lineno"> 1025 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1026 </span><span class="spaces">  </span><span class="istickedoff">-- XXX this is currently unreachable because there's no concrete</span>
<span class="lineno"> 1027 </span><span class="spaces">  </span><span class="istickedoff">-- syntax for it; the parser will never produce it.</span>
<span class="lineno"> 1028 </span><span class="spaces">  </span><span class="istickedoff">Index pos ar ix -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno"> 1029 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">(ar',at) &lt;- inferExpr (ln,ar)</span></span>
<span class="lineno"> 1030 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">ix'      &lt;- checkExpr ln ix (tInt (PosInferred InfContext (getPos ix)))</span></span>
<span class="lineno"> 1031 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">t        &lt;- getFreshTyVar (getPos ix')</span></span>
<span class="lineno"> 1032 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">unify ln (tArray (PosInferred InfContext (getPos ar')) t) (getPos ar') at</span></span>
<span class="lineno"> 1033 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">return (Index pos ar' ix', t)</span></span>
<span class="lineno"> 1034 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1035 </span><span class="spaces">  </span><span class="istickedoff">Lookup pos e n -&gt; do</span>
<span class="lineno"> 1036 </span><span class="spaces">      </span><span class="istickedoff">(e1,t) &lt;- inferExpr (<span class="nottickedoff">ln</span>, e)</span>
<span class="lineno"> 1037 </span><span class="spaces">      </span><span class="istickedoff">t1 &lt;- applyCurrentSubst =&lt;&lt; resolveCurrentTypedefs t</span>
<span class="lineno"> 1038 </span><span class="spaces">      </span><span class="istickedoff">elTy &lt;- case t1 of</span>
<span class="lineno"> 1039 </span><span class="spaces">          </span><span class="istickedoff">TyRecord typos fs</span>
<span class="lineno"> 1040 </span><span class="spaces">           </span><span class="istickedoff">| Just ty &lt;- Map.lookup n fs -&gt; do</span>
<span class="lineno"> 1041 </span><span class="spaces">              </span><span class="istickedoff">return ty</span>
<span class="lineno"> 1042 </span><span class="spaces">           </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt; do</span>
<span class="lineno"> 1043 </span><span class="spaces">              </span><span class="istickedoff">recordError pos $</span>
<span class="lineno"> 1044 </span><span class="spaces">                  </span><span class="istickedoff">&quot;Record type has no field named &quot; ++ Text.unpack n</span>
<span class="lineno"> 1045 </span><span class="spaces">              </span><span class="istickedoff">getErrorTyVar <span class="nottickedoff">typos</span></span>
<span class="lineno"> 1046 </span><span class="spaces">          </span><span class="istickedoff">TyUnifyVar _ _ -&gt; do</span>
<span class="lineno"> 1047 </span><span class="spaces">              </span><span class="istickedoff">recordError pos $</span>
<span class="lineno"> 1048 </span><span class="spaces">                  </span><span class="istickedoff">&quot;Cannot infer a record type for field &quot; ++</span>
<span class="lineno"> 1049 </span><span class="spaces">                  </span><span class="istickedoff">Text.unpack n ++ &quot;; please use a type annotation&quot;</span>
<span class="lineno"> 1050 </span><span class="spaces">              </span><span class="istickedoff">getErrorTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno"> 1051 </span><span class="spaces">          </span><span class="istickedoff">_ -&gt; do</span>
<span class="lineno"> 1052 </span><span class="spaces">              </span><span class="istickedoff">recordError pos $</span>
<span class="lineno"> 1053 </span><span class="spaces">                  </span><span class="istickedoff">&quot;Record lookup on non-record value of type &quot; ++ pShow t1</span>
<span class="lineno"> 1054 </span><span class="spaces">              </span><span class="istickedoff">getErrorTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno"> 1055 </span><span class="spaces">      </span><span class="istickedoff">return (<span class="nottickedoff">Lookup pos e1 n</span>, elTy)</span>
<span class="lineno"> 1056 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1057 </span><span class="spaces">  </span><span class="istickedoff">TLookup pos e i -&gt; do</span>
<span class="lineno"> 1058 </span><span class="spaces">      </span><span class="istickedoff">(e1,t) &lt;- inferExpr (<span class="nottickedoff">ln</span>,e)</span>
<span class="lineno"> 1059 </span><span class="spaces">      </span><span class="istickedoff">t1 &lt;- applyCurrentSubst =&lt;&lt; resolveCurrentTypedefs t</span>
<span class="lineno"> 1060 </span><span class="spaces">      </span><span class="istickedoff">elTy &lt;- case t1 of</span>
<span class="lineno"> 1061 </span><span class="spaces">          </span><span class="istickedoff">TyCon typos (TupleCon n) tys</span>
<span class="lineno"> 1062 </span><span class="spaces">           </span><span class="istickedoff">| i &lt; n -&gt;</span>
<span class="lineno"> 1063 </span><span class="spaces">              </span><span class="istickedoff">return (tys !! fromIntegral i)</span>
<span class="lineno"> 1064 </span><span class="spaces">           </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt; do</span>
<span class="lineno"> 1065 </span><span class="spaces">              </span><span class="istickedoff">recordError pos $</span>
<span class="lineno"> 1066 </span><span class="spaces">                  </span><span class="istickedoff">&quot;Tuple index &quot; ++ show i ++ &quot; out of bounds; limit is &quot; ++</span>
<span class="lineno"> 1067 </span><span class="spaces">                  </span><span class="istickedoff">show n</span>
<span class="lineno"> 1068 </span><span class="spaces">              </span><span class="istickedoff">getErrorTyVar <span class="nottickedoff">typos</span></span>
<span class="lineno"> 1069 </span><span class="spaces">          </span><span class="istickedoff">TyUnifyVar _ _ -&gt; do</span>
<span class="lineno"> 1070 </span><span class="spaces">              </span><span class="istickedoff">recordError pos $</span>
<span class="lineno"> 1071 </span><span class="spaces">                  </span><span class="istickedoff">&quot;Cannot infer tuple arity for lookup of element &quot; ++</span>
<span class="lineno"> 1072 </span><span class="spaces">                  </span><span class="istickedoff">show i ++ &quot;; please use a type annotation&quot;</span>
<span class="lineno"> 1073 </span><span class="spaces">              </span><span class="istickedoff">getErrorTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno"> 1074 </span><span class="spaces">          </span><span class="istickedoff">_ -&gt; do</span>
<span class="lineno"> 1075 </span><span class="spaces">              </span><span class="istickedoff">recordError pos $ </span>
<span class="lineno"> 1076 </span><span class="spaces">                  </span><span class="istickedoff">&quot;Tuple lookup on non-tuple value of type &quot; ++ pShow t1</span>
<span class="lineno"> 1077 </span><span class="spaces">              </span><span class="istickedoff">getErrorTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno"> 1078 </span><span class="spaces">      </span><span class="istickedoff">return (<span class="nottickedoff">TLookup pos e1 i</span>, elTy)</span>
<span class="lineno"> 1079 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1080 </span><span class="spaces">  </span><span class="istickedoff">Var pos x -&gt; do</span>
<span class="lineno"> 1081 </span><span class="spaces">      </span><span class="istickedoff">avail &lt;- asks primsAvail</span>
<span class="lineno"> 1082 </span><span class="spaces">      </span><span class="istickedoff">env &lt;- gets varEnv</span>
<span class="lineno"> 1083 </span><span class="spaces">      </span><span class="istickedoff">case ScopedMap.lookup x env of</span>
<span class="lineno"> 1084 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; do</span>
<span class="lineno"> 1085 </span><span class="spaces">          </span><span class="istickedoff">recordError pos $ &quot;Unbound variable: &quot; ++ show x ++ &quot; (&quot; ++ show pos ++ &quot;)&quot;</span>
<span class="lineno"> 1086 </span><span class="spaces">          </span><span class="istickedoff">t &lt;- getFreshTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno"> 1087 </span><span class="spaces">          </span><span class="istickedoff">return (<span class="nottickedoff">Var pos x</span>, t)</span>
<span class="lineno"> 1088 </span><span class="spaces">        </span><span class="istickedoff">Just (_prevpos, lc, _rebindable, Forall as t)</span>
<span class="lineno"> 1089 </span><span class="spaces">         </span><span class="istickedoff">| Set.member lc avail -&gt; do</span>
<span class="lineno"> 1090 </span><span class="spaces">          </span><span class="istickedoff">when (isDeprecated lc) $</span>
<span class="lineno"> 1091 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">case t of</span></span>
<span class="lineno"> 1092 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">TyCon _typos FunCon _args -&gt;</span></span>
<span class="lineno"> 1093 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">recordWarning pos $ &quot;Function is deprecated: &quot; &lt;&gt; show x</span></span>
<span class="lineno"> 1094 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">_ -&gt;</span></span>
<span class="lineno"> 1095 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">recordWarning pos $ &quot;Value is deprecated: &quot; &lt;&gt; show x</span></span>
<span class="lineno"> 1096 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1097 </span><span class="spaces">          </span><span class="istickedoff">-- get a fresh tyvar for each quantifier binding, convert</span>
<span class="lineno"> 1098 </span><span class="spaces">          </span><span class="istickedoff">-- to a name -&gt; ty map, and substitute the fresh tyvars</span>
<span class="lineno"> 1099 </span><span class="spaces">          </span><span class="istickedoff">let once (apos, a) = do</span>
<span class="lineno"> 1100 </span><span class="spaces">                </span><span class="istickedoff">at &lt;- getFreshTyVar apos</span>
<span class="lineno"> 1101 </span><span class="spaces">                </span><span class="istickedoff">return (a, (Current, ConcreteType at))</span>
<span class="lineno"> 1102 </span><span class="spaces">          </span><span class="istickedoff">substs &lt;- mapM once as</span>
<span class="lineno"> 1103 </span><span class="spaces">          </span><span class="istickedoff">let t' = substituteTyVars' avail (Map.fromList substs) t</span>
<span class="lineno"> 1104 </span><span class="spaces">          </span><span class="istickedoff">return (Var pos x, t')</span>
<span class="lineno"> 1105 </span><span class="spaces">         </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt; do</span>
<span class="lineno"> 1106 </span><span class="spaces">          </span><span class="istickedoff">recordError pos $ &quot;Inaccessible variable: &quot; ++ show x ++ &quot; (&quot; ++ show pos ++ &quot;)&quot;</span>
<span class="lineno"> 1107 </span><span class="spaces">          </span><span class="istickedoff">let how = if lc == HideDeprecated then &quot;deprecated&quot; else &quot;experimental&quot;</span>
<span class="lineno"> 1108 </span><span class="spaces">          </span><span class="istickedoff">recordError pos $ &quot;This command is available only after running &quot; ++</span>
<span class="lineno"> 1109 </span><span class="spaces">                            </span><span class="istickedoff">&quot;`enable_&quot; ++ how ++ &quot;`.&quot;</span>
<span class="lineno"> 1110 </span><span class="spaces">          </span><span class="istickedoff">t' &lt;- getFreshTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno"> 1111 </span><span class="spaces">          </span><span class="istickedoff">return (<span class="nottickedoff">Var pos x</span>, t')</span>
<span class="lineno"> 1112 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1113 </span><span class="spaces">  </span><span class="istickedoff">Lambda pos mname pat body -&gt; do</span>
<span class="lineno"> 1114 </span><span class="spaces">      </span><span class="istickedoff">(typat, pat') &lt;- inferPattern <span class="nottickedoff">ln</span> ReadOnlyVar pat</span>
<span class="lineno"> 1115 </span><span class="spaces">      </span><span class="istickedoff">pushScope</span>
<span class="lineno"> 1116 </span><span class="spaces">      </span><span class="istickedoff">addPattern pat'</span>
<span class="lineno"> 1117 </span><span class="spaces">      </span><span class="istickedoff">(body', tybody) &lt;- inferExpr (ln, body)</span>
<span class="lineno"> 1118 </span><span class="spaces">      </span><span class="istickedoff">popScope</span>
<span class="lineno"> 1119 </span><span class="spaces">      </span><span class="istickedoff">let e' = Lambda <span class="nottickedoff">pos</span> mname pat' body'</span>
<span class="lineno"> 1120 </span><span class="spaces">          </span><span class="istickedoff">ty = tFun (PosInferred InfContext (getPos body)) typat tybody</span>
<span class="lineno"> 1121 </span><span class="spaces">      </span><span class="istickedoff">return (e', ty)</span>
<span class="lineno"> 1122 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1123 </span><span class="spaces">  </span><span class="istickedoff">Application pos f arg -&gt; do</span>
<span class="lineno"> 1124 </span><span class="spaces">      </span><span class="istickedoff">argtype &lt;- getFreshTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno"> 1125 </span><span class="spaces">      </span><span class="istickedoff">rettype &lt;- getFreshTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno"> 1126 </span><span class="spaces">      </span><span class="istickedoff">let ftype = tFun (PosInferred InfContext $ getPos f) argtype rettype</span>
<span class="lineno"> 1127 </span><span class="spaces">      </span><span class="istickedoff">-- Check f' first so that we complain about the arg (not the</span>
<span class="lineno"> 1128 </span><span class="spaces">      </span><span class="istickedoff">-- function) if they don't match. This is what everyone expects</span>
<span class="lineno"> 1129 </span><span class="spaces">      </span><span class="istickedoff">-- and doing it the other way is surprisingly confusing.</span>
<span class="lineno"> 1130 </span><span class="spaces">      </span><span class="istickedoff">f' &lt;- checkExpr ln f ftype</span>
<span class="lineno"> 1131 </span><span class="spaces">      </span><span class="istickedoff">arg' &lt;- checkExpr ln arg argtype</span>
<span class="lineno"> 1132 </span><span class="spaces">      </span><span class="istickedoff">return (Application pos f' arg', rettype)</span>
<span class="lineno"> 1133 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1134 </span><span class="spaces">  </span><span class="istickedoff">Let pos dg body -&gt; do</span>
<span class="lineno"> 1135 </span><span class="spaces">      </span><span class="istickedoff">dg' &lt;- inferDeclGroup ReadOnlyVar dg</span>
<span class="lineno"> 1136 </span><span class="spaces">      </span><span class="istickedoff">pushScope</span>
<span class="lineno"> 1137 </span><span class="spaces">      </span><span class="istickedoff">addDeclGroup <span class="nottickedoff">ReadOnlyVar</span> dg'</span>
<span class="lineno"> 1138 </span><span class="spaces">      </span><span class="istickedoff">(body', ty) &lt;- inferExpr (<span class="nottickedoff">ln</span>, body)</span>
<span class="lineno"> 1139 </span><span class="spaces">      </span><span class="istickedoff">popScope</span>
<span class="lineno"> 1140 </span><span class="spaces">      </span><span class="istickedoff">let e' = Let <span class="nottickedoff">pos</span> dg' body'</span>
<span class="lineno"> 1141 </span><span class="spaces">      </span><span class="istickedoff">return (e', ty)</span>
<span class="lineno"> 1142 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1143 </span><span class="spaces">  </span><span class="istickedoff">TSig _pos e t -&gt; do</span>
<span class="lineno"> 1144 </span><span class="spaces">      </span><span class="istickedoff">t' &lt;- checkType kindStar t</span>
<span class="lineno"> 1145 </span><span class="spaces">      </span><span class="istickedoff">(e',t'') &lt;- inferExpr (<span class="nottickedoff">ln</span>,e)</span>
<span class="lineno"> 1146 </span><span class="spaces">      </span><span class="istickedoff">unify ln t' (getPos e') t''</span>
<span class="lineno"> 1147 </span><span class="spaces">      </span><span class="istickedoff">return (e',t'')</span>
<span class="lineno"> 1148 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1149 </span><span class="spaces">  </span><span class="istickedoff">IfThenElse pos e1 e2 e3 -&gt; do</span>
<span class="lineno"> 1150 </span><span class="spaces">      </span><span class="istickedoff">e1' &lt;- checkExpr ln e1 (tBool (PosInferred InfContext $ getPos e1))</span>
<span class="lineno"> 1151 </span><span class="spaces">      </span><span class="istickedoff">(e2', t) &lt;- inferExpr (<span class="nottickedoff">ln</span>, e2)</span>
<span class="lineno"> 1152 </span><span class="spaces">      </span><span class="istickedoff">e3' &lt;- checkExpr ln e3 t</span>
<span class="lineno"> 1153 </span><span class="spaces">      </span><span class="istickedoff">return (IfThenElse <span class="nottickedoff">pos</span> e1' e2' e3', t)</span></span>
<span class="lineno"> 1154 </span>
<span class="lineno"> 1155 </span>--
<span class="lineno"> 1156 </span>-- Check the type of an expr, by inferring and then unifying the
<span class="lineno"> 1157 </span>-- result.
<span class="lineno"> 1158 </span>--
<span class="lineno"> 1159 </span>checkExpr :: ContextName -&gt; Expr -&gt; Type -&gt; TI OutExpr
<span class="lineno"> 1160 </span><span class="decl"><span class="istickedoff">checkExpr cname e t = do</span>
<span class="lineno"> 1161 </span><span class="spaces">    </span><span class="istickedoff">(e', t') &lt;- inferExpr (cname, e)</span>
<span class="lineno"> 1162 </span><span class="spaces">    </span><span class="istickedoff">unify cname t (getPos e') t'</span>
<span class="lineno"> 1163 </span><span class="spaces">    </span><span class="istickedoff">return e'</span></span>
<span class="lineno"> 1164 </span>
<span class="lineno"> 1165 </span>--
<span class="lineno"> 1166 </span>-- patterns
<span class="lineno"> 1167 </span>--
<span class="lineno"> 1168 </span>
<span class="lineno"> 1169 </span>-- Infer types for a pattern, producing fresh type variables as needed.
<span class="lineno"> 1170 </span>--
<span class="lineno"> 1171 </span>-- There may already be types in the pattern if there were explicit
<span class="lineno"> 1172 </span>-- type annotations in the input; if so don't throw them away.
<span class="lineno"> 1173 </span>--
<span class="lineno"> 1174 </span>-- If the enclosing context says &quot;rebindable&quot;, either
<span class="lineno"> 1175 </span>--    - the variable is not already present in the environment
<span class="lineno"> 1176 </span>--    - or it is present and already declared &quot;rebindable&quot;, in which
<span class="lineno"> 1177 </span>--      case it must have the same type.
<span class="lineno"> 1178 </span>inferPattern :: ContextName -&gt; Rebindable -&gt; Pattern -&gt; TI (Type, Pattern)
<span class="lineno"> 1179 </span><span class="decl"><span class="istickedoff">inferPattern cname rebindable pat =</span>
<span class="lineno"> 1180 </span><span class="spaces">  </span><span class="istickedoff">let resolveType pos mt = case mt of</span>
<span class="lineno"> 1181 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; getFreshTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno"> 1182 </span><span class="spaces">        </span><span class="istickedoff">Just t -&gt; checkType kindStar t</span>
<span class="lineno"> 1183 </span><span class="spaces">  </span><span class="istickedoff">in</span>
<span class="lineno"> 1184 </span><span class="spaces">  </span><span class="istickedoff">case pat of</span>
<span class="lineno"> 1185 </span><span class="spaces">    </span><span class="istickedoff">PWild pos mt -&gt;</span>
<span class="lineno"> 1186 </span><span class="spaces">      </span><span class="istickedoff">do t &lt;- resolveType <span class="nottickedoff">pos</span> mt</span>
<span class="lineno"> 1187 </span><span class="spaces">         </span><span class="istickedoff">return (t, PWild <span class="nottickedoff">pos</span> (Just t))</span>
<span class="lineno"> 1188 </span><span class="spaces">    </span><span class="istickedoff">PVar allpos xpos x mt -&gt;</span>
<span class="lineno"> 1189 </span><span class="spaces">      </span><span class="istickedoff">do t &lt;- resolveType <span class="nottickedoff">allpos</span> mt</span>
<span class="lineno"> 1190 </span><span class="spaces">         </span><span class="istickedoff">env &lt;- gets varEnv</span>
<span class="lineno"> 1191 </span><span class="spaces">         </span><span class="istickedoff">case ScopedMap.lookup x env of</span>
<span class="lineno"> 1192 </span><span class="spaces">             </span><span class="istickedoff">Nothing -&gt; pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 1193 </span><span class="spaces">             </span><span class="istickedoff">Just (prevpos, lc, prevrb, tyscheme) -&gt; case rebindable of</span>
<span class="lineno"> 1194 </span><span class="spaces">                 </span><span class="istickedoff">RebindableVar -&gt; do</span>
<span class="lineno"> 1195 </span><span class="spaces">                     </span><span class="istickedoff">let croak msg =</span>
<span class="lineno"> 1196 </span><span class="spaces">                           </span><span class="istickedoff">recordError xpos $ &quot;Cannot rebind &quot; ++</span>
<span class="lineno"> 1197 </span><span class="spaces">                                              </span><span class="istickedoff">Text.unpack x ++ &quot;: &quot; ++ msg</span>
<span class="lineno"> 1198 </span><span class="spaces">                     </span><span class="istickedoff">avail &lt;- asks primsAvail</span>
<span class="lineno"> 1199 </span><span class="spaces">                     </span><span class="istickedoff">when (not $ Set.member lc avail) $</span>
<span class="lineno"> 1200 </span><span class="spaces">                         </span><span class="istickedoff"><span class="nottickedoff">croak &quot;A previous binding exists but is hidden&quot;</span></span>
<span class="lineno"> 1201 </span><span class="spaces">                     </span><span class="istickedoff">oldt &lt;- case tyscheme of</span>
<span class="lineno"> 1202 </span><span class="spaces">                         </span><span class="istickedoff">Forall [] oldt' -&gt; pure oldt'</span>
<span class="lineno"> 1203 </span><span class="spaces">                         </span><span class="istickedoff">Forall (_ : _) _ -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno"> 1204 </span><span class="spaces">                             </span><span class="istickedoff"><span class="nottickedoff">croak &quot;Polymorphic objects cannot be rebound&quot;</span></span>
<span class="lineno"> 1205 </span><span class="spaces">                             </span><span class="istickedoff"><span class="nottickedoff">getErrorTyVar xpos</span></span>
<span class="lineno"> 1206 </span><span class="spaces">                     </span><span class="istickedoff">when (prevrb == ReadOnlyVar) $</span>
<span class="lineno"> 1207 </span><span class="spaces">                         </span><span class="istickedoff">croak &quot;Previous binding was not tagged 'rebindable'&quot;</span>
<span class="lineno"> 1208 </span><span class="spaces">                     </span><span class="istickedoff">unify <span class="nottickedoff">cname</span> oldt <span class="nottickedoff">prevpos</span> t</span>
<span class="lineno"> 1209 </span><span class="spaces">                 </span><span class="istickedoff">ReadOnlyVar -&gt; do</span>
<span class="lineno"> 1210 </span><span class="spaces">                     </span><span class="istickedoff">-- The ocaml-style behavior of being able to do</span>
<span class="lineno"> 1211 </span><span class="spaces">                     </span><span class="istickedoff">--    let x = 3;</span>
<span class="lineno"> 1212 </span><span class="spaces">                     </span><span class="istickedoff">--    let x = foo x;</span>
<span class="lineno"> 1213 </span><span class="spaces">                     </span><span class="istickedoff">--    let x = bar x;</span>
<span class="lineno"> 1214 </span><span class="spaces">                     </span><span class="istickedoff">-- to create successive versions of x is often</span>
<span class="lineno"> 1215 </span><span class="spaces">                     </span><span class="istickedoff">-- convenient, and an unconditional</span>
<span class="lineno"> 1216 </span><span class="spaces">                     </span><span class="istickedoff">-- warning defeats that. However, the historical</span>
<span class="lineno"> 1217 </span><span class="spaces">                     </span><span class="istickedoff">-- behavior of SAWScript (in certain contexts)</span>
<span class="lineno"> 1218 </span><span class="spaces">                     </span><span class="istickedoff">-- is to mutate x, such that</span>
<span class="lineno"> 1219 </span><span class="spaces">                     </span><span class="istickedoff">--     let x = 3;</span>
<span class="lineno"> 1220 </span><span class="spaces">                     </span><span class="istickedoff">--     let y = x;</span>
<span class="lineno"> 1221 </span><span class="spaces">                     </span><span class="istickedoff">--     let x = 4;</span>
<span class="lineno"> 1222 </span><span class="spaces">                     </span><span class="istickedoff">--     print y;</span>
<span class="lineno"> 1223 </span><span class="spaces">                     </span><span class="istickedoff">-- would print 4. Therefore, we warn aggressively</span>
<span class="lineno"> 1224 </span><span class="spaces">                     </span><span class="istickedoff">-- in case anyone was relying on the old</span>
<span class="lineno"> 1225 </span><span class="spaces">                     </span><span class="istickedoff">-- behavior.</span>
<span class="lineno"> 1226 </span><span class="spaces">                     </span><span class="istickedoff">--</span>
<span class="lineno"> 1227 </span><span class="spaces">                     </span><span class="istickedoff">-- FUTURE: we currently can't identify the scopes</span>
<span class="lineno"> 1228 </span><span class="spaces">                     </span><span class="istickedoff">-- that are involved; in the future we might want</span>
<span class="lineno"> 1229 </span><span class="spaces">                     </span><span class="istickedoff">-- to (a) issue this warning only for rebinds at</span>
<span class="lineno"> 1230 </span><span class="spaces">                     </span><span class="istickedoff">-- the syntactic top level, and (b) have a</span>
<span class="lineno"> 1231 </span><span class="spaces">                     </span><span class="istickedoff">-- different warning for locals that shadow</span>
<span class="lineno"> 1232 </span><span class="spaces">                     </span><span class="istickedoff">-- variables from outer scopes.</span>
<span class="lineno"> 1233 </span><span class="spaces">                     </span><span class="istickedoff">recordWarning xpos $ &quot;Redeclaration of &quot; ++ Text.unpack x</span>
<span class="lineno"> 1234 </span><span class="spaces">                     </span><span class="istickedoff">recordWarning prevpos $ &quot;Previous declaration was here&quot;</span>
<span class="lineno"> 1235 </span><span class="spaces">         </span><span class="istickedoff">return (t, PVar allpos xpos x (Just t))</span>
<span class="lineno"> 1236 </span><span class="spaces">    </span><span class="istickedoff">PTuple pos ps -&gt;</span>
<span class="lineno"> 1237 </span><span class="spaces">      </span><span class="istickedoff">do (ts, ps') &lt;- unzip &lt;$&gt; mapM (inferPattern <span class="nottickedoff">cname</span> rebindable) ps</span>
<span class="lineno"> 1238 </span><span class="spaces">         </span><span class="istickedoff">return (tTuple <span class="nottickedoff">(PosInferred InfTerm pos)</span> ts, PTuple <span class="nottickedoff">pos</span> ps')</span></span>
<span class="lineno"> 1239 </span>
<span class="lineno"> 1240 </span>-- Check the type of a pattern, by inferring and then unifying the
<span class="lineno"> 1241 </span>-- result.
<span class="lineno"> 1242 </span>checkPattern :: Rebindable -&gt; ContextName -&gt; Type -&gt; Pattern -&gt; TI Pattern
<span class="lineno"> 1243 </span><span class="decl"><span class="istickedoff">checkPattern rebindable cname t pat =</span>
<span class="lineno"> 1244 </span><span class="spaces">  </span><span class="istickedoff">do (pt, pat') &lt;- inferPattern <span class="nottickedoff">cname</span> rebindable pat</span>
<span class="lineno"> 1245 </span><span class="spaces">     </span><span class="istickedoff">unify cname t (getPos pat) pt</span>
<span class="lineno"> 1246 </span><span class="spaces">     </span><span class="istickedoff">return pat'</span></span>
<span class="lineno"> 1247 </span>
<span class="lineno"> 1248 </span>--
<span class="lineno"> 1249 </span>-- statements
<span class="lineno"> 1250 </span>--
<span class="lineno"> 1251 </span>
<span class="lineno"> 1252 </span>-- Add a typedef binding to the type environment.
<span class="lineno"> 1253 </span>--
<span class="lineno"> 1254 </span>-- The expansion (t) has been checked, so it's ok to panic if it
<span class="lineno"> 1255 </span>-- refers to something not visible in the environment.
<span class="lineno"> 1256 </span>addTypedef :: Name -&gt; Type -&gt; TI ()
<span class="lineno"> 1257 </span><span class="decl"><span class="istickedoff">addTypedef a ty = do</span>
<span class="lineno"> 1258 </span><span class="spaces">    </span><span class="istickedoff">avail &lt;- asks primsAvail</span>
<span class="lineno"> 1259 </span><span class="spaces">    </span><span class="istickedoff">env &lt;- gets tyEnv</span>
<span class="lineno"> 1260 </span><span class="spaces">    </span><span class="istickedoff">let ty' = substituteTyVars avail env ty</span>
<span class="lineno"> 1261 </span><span class="spaces">        </span><span class="istickedoff">env' = ScopedMap.insert a (Current, ConcreteType ty') env</span>
<span class="lineno"> 1262 </span><span class="spaces">    </span><span class="istickedoff">modify (\rw -&gt; rw { tyEnv = env' })</span></span>
<span class="lineno"> 1263 </span>
<span class="lineno"> 1264 </span>-- break a monadic type down into its monad and value types, if it is one
<span class="lineno"> 1265 </span>--
<span class="lineno"> 1266 </span>--    monadType (TopLevel Int) gives Just (TopLevel, Int)
<span class="lineno"> 1267 </span>--    monadType Int gives Nothing
<span class="lineno"> 1268 </span>--
<span class="lineno"> 1269 </span>monadType :: Type -&gt; Maybe (Type, Type)
<span class="lineno"> 1270 </span><span class="decl"><span class="istickedoff">monadType ty = case ty of</span>
<span class="lineno"> 1271 </span><span class="spaces">  </span><span class="istickedoff">TyCon _ BlockCon [ctx@(TyCon _ (ContextCon _) []), valty] -&gt;</span>
<span class="lineno"> 1272 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">Just (ctx, valty)</span></span>
<span class="lineno"> 1273 </span><span class="spaces">  </span><span class="istickedoff">TyCon _ BlockCon [ctx@(TyVar _ name), valty] | <span class="tickonlytrue">isMonad name</span> -&gt;</span>
<span class="lineno"> 1274 </span><span class="spaces">      </span><span class="istickedoff">Just (ctx, valty)</span>
<span class="lineno"> 1275 </span><span class="spaces">  </span><span class="istickedoff">-- We don't currently ever generate these types, but be future-proof</span>
<span class="lineno"> 1276 </span><span class="spaces">  </span><span class="istickedoff">TyCon pos (ContextCon ctx) [valty] -&gt;</span>
<span class="lineno"> 1277 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">Just (TyCon pos (ContextCon ctx) [], valty)</span></span>
<span class="lineno"> 1278 </span><span class="spaces">  </span><span class="istickedoff">-- and this one can't even be represented yet</span>
<span class="lineno"> 1279 </span><span class="spaces"></span><span class="istickedoff">--TyVar pos name [valty] | isMonad name -&gt;</span>
<span class="lineno"> 1280 </span><span class="spaces"></span><span class="istickedoff">--    Just (TyVar pos name, valty)</span>
<span class="lineno"> 1281 </span><span class="spaces">  </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 1282 </span><span class="spaces">      </span><span class="istickedoff">Nothing</span>
<span class="lineno"> 1283 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1284 </span><span class="spaces">    </span><span class="istickedoff">-- Baking in these strings is untidy. I'd worry more about it if</span>
<span class="lineno"> 1285 </span><span class="spaces">    </span><span class="istickedoff">-- this code were being used for real rather than as part of a</span>
<span class="lineno"> 1286 </span><span class="spaces">    </span><span class="istickedoff">-- temporary accomodation for compatibility purposes.</span>
<span class="lineno"> 1287 </span><span class="spaces">    </span><span class="istickedoff">isMonad &quot;LLVMSetup&quot; = True</span>
<span class="lineno"> 1288 </span><span class="spaces">    </span><span class="istickedoff">isMonad &quot;JVMSetup&quot; = <span class="nottickedoff">True</span></span>
<span class="lineno"> 1289 </span><span class="spaces">    </span><span class="istickedoff">isMonad &quot;MIRSetup&quot; = <span class="nottickedoff">True</span></span>
<span class="lineno"> 1290 </span><span class="spaces">    </span><span class="istickedoff">isMonad _ = <span class="nottickedoff">False</span></span></span>
<span class="lineno"> 1291 </span>
<span class="lineno"> 1292 </span>-- wrap an expression in &quot;return&quot;
<span class="lineno"> 1293 </span>wrapReturn :: Expr -&gt; Expr
<span class="lineno"> 1294 </span><span class="decl"><span class="istickedoff">wrapReturn e =</span>
<span class="lineno"> 1295 </span><span class="spaces">    </span><span class="istickedoff">let <span class="nottickedoff">ePos = getPos e</span></span>
<span class="lineno"> 1296 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">retPos = PosInternal &quot;&lt;implicitly inserted return&gt;&quot;</span></span>
<span class="lineno"> 1297 </span><span class="spaces">        </span><span class="istickedoff">ret = Var <span class="nottickedoff">retPos</span> &quot;return&quot;</span>
<span class="lineno"> 1298 </span><span class="spaces">    </span><span class="istickedoff">in</span>
<span class="lineno"> 1299 </span><span class="spaces">    </span><span class="istickedoff">Application <span class="nottickedoff">ePos</span> ret e</span></span>
<span class="lineno"> 1300 </span>
<span class="lineno"> 1301 </span>-- type inference for a single statement
<span class="lineno"> 1302 </span>--
<span class="lineno"> 1303 </span>-- the boolean is whether we're at the syntactic top level, which is used
<span class="lineno"> 1304 </span>-- for workaround logic for issue #2162
<span class="lineno"> 1305 </span>--
<span class="lineno"> 1306 </span>-- the passed-in position should be the position associated with the monad type
<span class="lineno"> 1307 </span>-- the first type argument (ctx) is the monad type for any binds that occur
<span class="lineno"> 1308 </span>--
<span class="lineno"> 1309 </span>-- Updates the environment and returns an updated statement.
<span class="lineno"> 1310 </span>inferStmt :: ContextName -&gt; Bool -&gt; Pos -&gt; Type -&gt; Stmt -&gt; TI Stmt
<span class="lineno"> 1311 </span><span class="decl"><span class="istickedoff">inferStmt cname atSyntacticTopLevel blockpos ctx s =</span>
<span class="lineno"> 1312 </span><span class="spaces">    </span><span class="istickedoff">case s of</span>
<span class="lineno"> 1313 </span><span class="spaces">        </span><span class="istickedoff">StmtBind spos pat e -&gt; do</span>
<span class="lineno"> 1314 </span><span class="spaces">            </span><span class="istickedoff">(pty, pat') &lt;- inferPattern <span class="nottickedoff">cname</span> ReadOnlyVar pat</span>
<span class="lineno"> 1315 </span><span class="spaces">            </span><span class="istickedoff">-- The expression should be of monad type. The</span>
<span class="lineno"> 1316 </span><span class="spaces">            </span><span class="istickedoff">-- straightforward way to proceed here is to unify both</span>
<span class="lineno"> 1317 </span><span class="spaces">            </span><span class="istickedoff">-- the monad type (ctx) and the result type expected by</span>
<span class="lineno"> 1318 </span><span class="spaces">            </span><span class="istickedoff">-- the pattern (pty), like this:</span>
<span class="lineno"> 1319 </span><span class="spaces">            </span><span class="istickedoff">--    e' &lt;- checkExpr cname e (tBlock blockpos ctx pty)</span>
<span class="lineno"> 1320 </span><span class="spaces">            </span><span class="istickedoff">--</span>
<span class="lineno"> 1321 </span><span class="spaces">            </span><span class="istickedoff">-- However, historically when at the syntactic top level</span>
<span class="lineno"> 1322 </span><span class="spaces">            </span><span class="istickedoff">-- (only), the monad type was left off, meaning that</span>
<span class="lineno"> 1323 </span><span class="spaces">            </span><span class="istickedoff">-- various incorrect forms were silently accepted. Fixing</span>
<span class="lineno"> 1324 </span><span class="spaces">            </span><span class="istickedoff">-- this in Dec 2024 triggered a lot of fallout, so for the</span>
<span class="lineno"> 1325 </span><span class="spaces">            </span><span class="istickedoff">-- time being we want to check for, warn about, and allow</span>
<span class="lineno"> 1326 </span><span class="spaces">            </span><span class="istickedoff">-- the following cases. (Again, only when at the syntactic</span>
<span class="lineno"> 1327 </span><span class="spaces">            </span><span class="istickedoff">-- top level. Which is not when in the TopLevel monad.)</span>
<span class="lineno"> 1328 </span><span class="spaces">            </span><span class="istickedoff">--    x &lt;- e for non-monadic e</span>
<span class="lineno"> 1329 </span><span class="spaces">            </span><span class="istickedoff">--    x &lt;- e for e in the wrong monad</span>
<span class="lineno"> 1330 </span><span class="spaces">            </span><span class="istickedoff">--</span>
<span class="lineno"> 1331 </span><span class="spaces">            </span><span class="istickedoff">-- These should be made errors again at some point, but</span>
<span class="lineno"> 1332 </span><span class="spaces">            </span><span class="istickedoff">-- definitely no earlier than the _second_ release after</span>
<span class="lineno"> 1333 </span><span class="spaces">            </span><span class="istickedoff">-- December 2024, as the first such release should include</span>
<span class="lineno"> 1334 </span><span class="spaces">            </span><span class="istickedoff">-- the warning behavior. Probably the explicit messages</span>
<span class="lineno"> 1335 </span><span class="spaces">            </span><span class="istickedoff">-- should then in turn not be removed for at least one</span>
<span class="lineno"> 1336 </span><span class="spaces">            </span><span class="istickedoff">-- further release. See #2167 and #2162.</span>
<span class="lineno"> 1337 </span><span class="spaces">            </span><span class="istickedoff">--</span>
<span class="lineno"> 1338 </span><span class="spaces">            </span><span class="istickedoff">-- To accomplish this, call inferExpr to get a type for</span>
<span class="lineno"> 1339 </span><span class="spaces">            </span><span class="istickedoff">-- the expression, and examine it. If the special cases</span>
<span class="lineno"> 1340 </span><span class="spaces">            </span><span class="istickedoff">-- apply, issue special-case warnings with explanations,</span>
<span class="lineno"> 1341 </span><span class="spaces">            </span><span class="istickedoff">-- unify the type with only the pattern type, and patch up</span>
<span class="lineno"> 1342 </span><span class="spaces">            </span><span class="istickedoff">-- the expression by wrapping it in &quot;return&quot;.  (The latter</span>
<span class="lineno"> 1343 </span><span class="spaces">            </span><span class="istickedoff">-- will restore the old behavior for both cases, so we</span>
<span class="lineno"> 1344 </span><span class="spaces">            </span><span class="istickedoff">-- don't need to also gunk up the interpreter to handle</span>
<span class="lineno"> 1345 </span><span class="spaces">            </span><span class="istickedoff">-- this problem.)</span>
<span class="lineno"> 1346 </span><span class="spaces">            </span><span class="istickedoff">--</span>
<span class="lineno"> 1347 </span><span class="spaces">            </span><span class="istickedoff">-- If the special cases don't apply, unify the result type</span>
<span class="lineno"> 1348 </span><span class="spaces">            </span><span class="istickedoff">-- with the complete type.</span>
<span class="lineno"> 1349 </span><span class="spaces">            </span><span class="istickedoff">(e', ty) &lt;- inferExpr (cname, e)</span>
<span class="lineno"> 1350 </span><span class="spaces">            </span><span class="istickedoff">ty' &lt;- applyCurrentSubst =&lt;&lt; resolveCurrentTypedefs ty</span>
<span class="lineno"> 1351 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1352 </span><span class="spaces">            </span><span class="istickedoff">-- The correct, restricted case</span>
<span class="lineno"> 1353 </span><span class="spaces">            </span><span class="istickedoff">let restrictToCorrect = do</span>
<span class="lineno"> 1354 </span><span class="spaces">                  </span><span class="istickedoff">-- unify the type of e with the expected monad and</span>
<span class="lineno"> 1355 </span><span class="spaces">                  </span><span class="istickedoff">-- pattern types</span>
<span class="lineno"> 1356 </span><span class="spaces">                  </span><span class="istickedoff">unify cname (tBlock blockpos ctx pty) (getPos e') ty</span>
<span class="lineno"> 1357 </span><span class="spaces">                  </span><span class="istickedoff">return e'</span>
<span class="lineno"> 1358 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1359 </span><span class="spaces">            </span><span class="istickedoff">-- The special case for non-monadic values</span>
<span class="lineno"> 1360 </span><span class="spaces">            </span><span class="istickedoff">let allowNonMonadic = do</span>
<span class="lineno"> 1361 </span><span class="spaces">                  </span><span class="istickedoff">recordWarning spos $ &quot;Monadic bind of non-monadic value; &quot; ++</span>
<span class="lineno"> 1362 </span><span class="spaces">                                       </span><span class="istickedoff">&quot;rewrite as let-binding or use return&quot;</span>
<span class="lineno"> 1363 </span><span class="spaces">                  </span><span class="istickedoff">recordWarning spos $ &quot;This will become an error in a &quot; ++</span>
<span class="lineno"> 1364 </span><span class="spaces">                                       </span><span class="istickedoff">&quot;future release of SAW&quot;</span>
<span class="lineno"> 1365 </span><span class="spaces">                  </span><span class="istickedoff">unify cname pty (getPos e') ty</span>
<span class="lineno"> 1366 </span><span class="spaces">                  </span><span class="istickedoff">-- Wrap the expression in &quot;return&quot; to correct the type</span>
<span class="lineno"> 1367 </span><span class="spaces">                  </span><span class="istickedoff">return $ wrapReturn e'</span>
<span class="lineno"> 1368 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1369 </span><span class="spaces">            </span><span class="istickedoff">-- The special case for the wrong monad</span>
<span class="lineno"> 1370 </span><span class="spaces">            </span><span class="istickedoff">let allowWrongMonad ctx' valty' = do</span>
<span class="lineno"> 1371 </span><span class="spaces">                  </span><span class="istickedoff">recordWarning spos $ &quot;Monadic bind with the wrong monad; &quot; ++</span>
<span class="lineno"> 1372 </span><span class="spaces">                                       </span><span class="istickedoff">&quot;found &quot; ++ pShow ctx' ++</span>
<span class="lineno"> 1373 </span><span class="spaces">                                       </span><span class="istickedoff">&quot; but expected &quot; ++ pShow ctx</span>
<span class="lineno"> 1374 </span><span class="spaces">                  </span><span class="istickedoff">recordWarning spos $ &quot;This creates the action but does &quot; ++</span>
<span class="lineno"> 1375 </span><span class="spaces">                                       </span><span class="istickedoff">&quot;not execute it; if you meant to do &quot; ++</span>
<span class="lineno"> 1376 </span><span class="spaces">                                       </span><span class="istickedoff">&quot;that, prefix the &quot; ++</span>
<span class="lineno"> 1377 </span><span class="spaces">                                       </span><span class="istickedoff">&quot;expression with return&quot;</span>
<span class="lineno"> 1378 </span><span class="spaces">                  </span><span class="istickedoff">recordWarning spos $ &quot;This will become an error in a &quot; ++</span>
<span class="lineno"> 1379 </span><span class="spaces">                                       </span><span class="istickedoff">&quot;future release of SAW&quot;</span>
<span class="lineno"> 1380 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1381 </span><span class="spaces">                  </span><span class="istickedoff">-- The historic behavior is that the pattern gets bound</span>
<span class="lineno"> 1382 </span><span class="spaces">                  </span><span class="istickedoff">-- to a value of type m t instead of type t. This means:</span>
<span class="lineno"> 1383 </span><span class="spaces">                  </span><span class="istickedoff">--    - we should unify pty, which is the type of the</span>
<span class="lineno"> 1384 </span><span class="spaces">                  </span><span class="istickedoff">--      pattern, with m t, which is tBlock ctx' valty'</span>
<span class="lineno"> 1385 </span><span class="spaces">                  </span><span class="istickedoff">--      (rather than tBlock ctx valty', which is the</span>
<span class="lineno"> 1386 </span><span class="spaces">                  </span><span class="istickedoff">--      type we should be getting)</span>
<span class="lineno"> 1387 </span><span class="spaces">                  </span><span class="istickedoff">--    - this will fail if the pattern includes a type</span>
<span class="lineno"> 1388 </span><span class="spaces">                  </span><span class="istickedoff">--      signature with a non-monad type, but that's ok</span>
<span class="lineno"> 1389 </span><span class="spaces">                  </span><span class="istickedoff">--      because that case also fails in old SAW</span>
<span class="lineno"> 1390 </span><span class="spaces">                  </span><span class="istickedoff">--    - we do _not_ need to update pty before returning</span>
<span class="lineno"> 1391 </span><span class="spaces">                  </span><span class="istickedoff">--      it out of inferStmt</span>
<span class="lineno"> 1392 </span><span class="spaces">                  </span><span class="istickedoff">--    - we _do_ need to wrap the expression in &quot;return&quot;</span>
<span class="lineno"> 1393 </span><span class="spaces">                  </span><span class="istickedoff">--      so that the ultimate results are well-typed and</span>
<span class="lineno"> 1394 </span><span class="spaces">                  </span><span class="istickedoff">--      happen in the TopLevel monad</span>
<span class="lineno"> 1395 </span><span class="spaces">                  </span><span class="istickedoff">unify cname pty (getPos e') (tBlock spos ctx' valty')</span>
<span class="lineno"> 1396 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1397 </span><span class="spaces">                  </span><span class="istickedoff">-- Wrap the expression in &quot;return&quot; to produce an</span>
<span class="lineno"> 1398 </span><span class="spaces">                  </span><span class="istickedoff">-- expression of type TopLevel (m t).</span>
<span class="lineno"> 1399 </span><span class="spaces">                  </span><span class="istickedoff">return $ wrapReturn e'</span>
<span class="lineno"> 1400 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1401 </span><span class="spaces">            </span><span class="istickedoff">-- Figure out which case applies.</span>
<span class="lineno"> 1402 </span><span class="spaces">            </span><span class="istickedoff">e'' &lt;-</span>
<span class="lineno"> 1403 </span><span class="spaces">                </span><span class="istickedoff">if not atSyntacticTopLevel then</span>
<span class="lineno"> 1404 </span><span class="spaces">                    </span><span class="istickedoff">restrictToCorrect</span>
<span class="lineno"> 1405 </span><span class="spaces">                </span><span class="istickedoff">else do</span>
<span class="lineno"> 1406 </span><span class="spaces">                    </span><span class="istickedoff">ok &lt;- matches (tBlock <span class="nottickedoff">blockpos</span> ctx pty) ty</span>
<span class="lineno"> 1407 </span><span class="spaces">                    </span><span class="istickedoff">if ok then</span>
<span class="lineno"> 1408 </span><span class="spaces">                        </span><span class="istickedoff">restrictToCorrect</span>
<span class="lineno"> 1409 </span><span class="spaces">                    </span><span class="istickedoff">else</span>
<span class="lineno"> 1410 </span><span class="spaces">                        </span><span class="istickedoff">case monadType ty' of</span>
<span class="lineno"> 1411 </span><span class="spaces">                            </span><span class="istickedoff">Just (ctx', valty') -&gt;</span>
<span class="lineno"> 1412 </span><span class="spaces">                               </span><span class="istickedoff">-- Allow it only for _ and a single var.</span>
<span class="lineno"> 1413 </span><span class="spaces">                               </span><span class="istickedoff">-- Binding elements of a tuple this way</span>
<span class="lineno"> 1414 </span><span class="spaces">                               </span><span class="istickedoff">-- failed typecheck in the old saw and</span>
<span class="lineno"> 1415 </span><span class="spaces">                               </span><span class="istickedoff">-- doesn't need to be allowed now.</span>
<span class="lineno"> 1416 </span><span class="spaces">                               </span><span class="istickedoff">case pat of</span>
<span class="lineno"> 1417 </span><span class="spaces">                                   </span><span class="istickedoff">PTuple _ _ -&gt; restrictToCorrect</span>
<span class="lineno"> 1418 </span><span class="spaces">                                   </span><span class="istickedoff">_ -&gt; allowWrongMonad ctx' valty'</span>
<span class="lineno"> 1419 </span><span class="spaces">                            </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1420 </span><span class="spaces">                               </span><span class="istickedoff">-- allow it only if actually binding something</span>
<span class="lineno"> 1421 </span><span class="spaces">                               </span><span class="istickedoff">-- (just proclaiming a value by itself is not a</span>
<span class="lineno"> 1422 </span><span class="spaces">                               </span><span class="istickedoff">-- case we need to worry about)</span>
<span class="lineno"> 1423 </span><span class="spaces">                               </span><span class="istickedoff">case pat of</span>
<span class="lineno"> 1424 </span><span class="spaces">                                   </span><span class="istickedoff">PWild _ _ -&gt; restrictToCorrect</span>
<span class="lineno"> 1425 </span><span class="spaces">                                   </span><span class="istickedoff">_ -&gt; allowNonMonadic</span>
<span class="lineno"> 1426 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1427 </span><span class="spaces">            </span><span class="istickedoff">let s' = StmtBind spos pat' e''</span>
<span class="lineno"> 1428 </span><span class="spaces">            </span><span class="istickedoff">addPattern pat'</span>
<span class="lineno"> 1429 </span><span class="spaces">            </span><span class="istickedoff">return s'</span>
<span class="lineno"> 1430 </span><span class="spaces">        </span><span class="istickedoff">StmtLet spos rebindable dg -&gt; do</span>
<span class="lineno"> 1431 </span><span class="spaces">            </span><span class="istickedoff">when (rebindable == RebindableVar &amp;&amp; not atSyntacticTopLevel) $ do</span>
<span class="lineno"> 1432 </span><span class="spaces">                </span><span class="istickedoff">recordError spos $ &quot;Invalid use of 'rebindable'&quot;</span>
<span class="lineno"> 1433 </span><span class="spaces">                </span><span class="istickedoff">recordError spos $ &quot;It is only allowed at the syntactic top level&quot;</span>
<span class="lineno"> 1434 </span><span class="spaces">            </span><span class="istickedoff">dg' &lt;- inferDeclGroup rebindable dg</span>
<span class="lineno"> 1435 </span><span class="spaces">            </span><span class="istickedoff">let s' = StmtLet <span class="nottickedoff">spos</span> rebindable dg'</span>
<span class="lineno"> 1436 </span><span class="spaces">            </span><span class="istickedoff">addDeclGroup rebindable dg'</span>
<span class="lineno"> 1437 </span><span class="spaces">            </span><span class="istickedoff">return s'</span>
<span class="lineno"> 1438 </span><span class="spaces">        </span><span class="istickedoff">StmtCode _allpos _spos _txt -&gt;</span>
<span class="lineno"> 1439 </span><span class="spaces">            </span><span class="istickedoff">return s</span>
<span class="lineno"> 1440 </span><span class="spaces">        </span><span class="istickedoff">StmtImport _spos _ -&gt;</span>
<span class="lineno"> 1441 </span><span class="spaces">            </span><span class="istickedoff">return s</span>
<span class="lineno"> 1442 </span><span class="spaces">        </span><span class="istickedoff">StmtInclude spos _ _ -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno"> 1443 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">-- Restrict include to TopLevel. This matches the prior</span></span>
<span class="lineno"> 1444 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">-- behavior when it was a builtin function rather than</span></span>
<span class="lineno"> 1445 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">-- syntax. FUTURE: consider relaxing the requirement.</span></span>
<span class="lineno"> 1446 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">let spos' = PosInferred InfTerm spos</span></span>
<span class="lineno"> 1447 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">let tm = TyCon spos' (ContextCon TopLevel) []</span></span>
<span class="lineno"> 1448 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">tx &lt;- getFreshTyVar spos</span></span>
<span class="lineno"> 1449 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">unify cname (tBlock blockpos ctx tx) spos (tBlock spos tm tx)</span></span>
<span class="lineno"> 1450 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">return s</span></span>
<span class="lineno"> 1451 </span><span class="spaces">        </span><span class="istickedoff">StmtTypedef allpos apos a ty -&gt; do</span>
<span class="lineno"> 1452 </span><span class="spaces">            </span><span class="istickedoff">ty' &lt;- checkType kindStar ty</span>
<span class="lineno"> 1453 </span><span class="spaces">            </span><span class="istickedoff">tyenv &lt;- gets tyEnv</span>
<span class="lineno"> 1454 </span><span class="spaces">            </span><span class="istickedoff">case ScopedMap.lookup a tyenv of</span>
<span class="lineno"> 1455 </span><span class="spaces">                </span><span class="istickedoff">Nothing -&gt; do</span>
<span class="lineno"> 1456 </span><span class="spaces">                    </span><span class="istickedoff">let s' = StmtTypedef <span class="nottickedoff">allpos</span> <span class="nottickedoff">apos</span> a ty'</span>
<span class="lineno"> 1457 </span><span class="spaces">                    </span><span class="istickedoff">addTypedef a ty'</span>
<span class="lineno"> 1458 </span><span class="spaces">                    </span><span class="istickedoff">return s'</span>
<span class="lineno"> 1459 </span><span class="spaces">                </span><span class="istickedoff">Just (lc, _expansion) -&gt; do</span>
<span class="lineno"> 1460 </span><span class="spaces">                    </span><span class="istickedoff">-- Prohibit redefining any type, even ones that</span>
<span class="lineno"> 1461 </span><span class="spaces">                    </span><span class="istickedoff">-- aren't visible. In principle it is ok to</span>
<span class="lineno"> 1462 </span><span class="spaces">                    </span><span class="istickedoff">-- redefine a type that isn't visible, since</span>
<span class="lineno"> 1463 </span><span class="spaces">                    </span><span class="istickedoff">-- existing references to it shouldn't be visible</span>
<span class="lineno"> 1464 </span><span class="spaces">                    </span><span class="istickedoff">-- either. But (a) that's not always true, there</span>
<span class="lineno"> 1465 </span><span class="spaces">                    </span><span class="istickedoff">-- have been bugs in the builtin list before; and</span>
<span class="lineno"> 1466 </span><span class="spaces">                    </span><span class="istickedoff">-- (b) it would require remembering permanently</span>
<span class="lineno"> 1467 </span><span class="spaces">                    </span><span class="istickedoff">-- that any corresponding future use of</span>
<span class="lineno"> 1468 </span><span class="spaces">                    </span><span class="istickedoff">-- enable_experimental or enable_deprecated must</span>
<span class="lineno"> 1469 </span><span class="spaces">                    </span><span class="istickedoff">-- be blocked.</span>
<span class="lineno"> 1470 </span><span class="spaces">                    </span><span class="istickedoff">avail &lt;- asks primsAvail</span>
<span class="lineno"> 1471 </span><span class="spaces">                    </span><span class="istickedoff">let addendum =</span>
<span class="lineno"> 1472 </span><span class="spaces">                          </span><span class="istickedoff">if Set.member lc avail then &quot;&quot;</span>
<span class="lineno"> 1473 </span><span class="spaces">                          </span><span class="istickedoff">else &quot; (which is not currently visible)&quot;</span>
<span class="lineno"> 1474 </span><span class="spaces">                    </span><span class="istickedoff">recordError allpos $ &quot;Redefinition of type &quot; ++</span>
<span class="lineno"> 1475 </span><span class="spaces">                                         </span><span class="istickedoff">Text.unpack a ++ addendum</span>
<span class="lineno"> 1476 </span><span class="spaces">                    </span><span class="istickedoff">-- FUTURE: print the position of the previous definition</span>
<span class="lineno"> 1477 </span><span class="spaces">                    </span><span class="istickedoff">-- (currently we don't keep it around)</span>
<span class="lineno"> 1478 </span><span class="spaces">                    </span><span class="istickedoff">return <span class="nottickedoff">s</span></span>
<span class="lineno"> 1479 </span><span class="spaces">        </span><span class="istickedoff">StmtPushdir _spos _ -&gt;</span>
<span class="lineno"> 1480 </span><span class="spaces">            </span><span class="istickedoff">return s</span>
<span class="lineno"> 1481 </span><span class="spaces">        </span><span class="istickedoff">StmtPopdir _spos -&gt;</span>
<span class="lineno"> 1482 </span><span class="spaces">            </span><span class="istickedoff">return s</span></span>
<span class="lineno"> 1483 </span>
<span class="lineno"> 1484 </span>-- Inference for a do-block.
<span class="lineno"> 1485 </span>--
<span class="lineno"> 1486 </span>-- The passed-in position should be the position for the whole
<span class="lineno"> 1487 </span>-- statement block.
<span class="lineno"> 1488 </span>--
<span class="lineno"> 1489 </span>-- The first type argument (ctx) is the monad type for the block.
<span class="lineno"> 1490 </span>--
<span class="lineno"> 1491 </span>-- The second type argument (ty) is the expected full result type for
<span class="lineno"> 1492 </span>-- the block (including the monad) to be unified with the result type
<span class="lineno"> 1493 </span>-- found.
<span class="lineno"> 1494 </span>--
<span class="lineno"> 1495 </span>inferBlock :: ContextName -&gt; Pos -&gt; Type -&gt; Type -&gt; ([Stmt], Expr) -&gt; TI ([OutStmt], OutExpr)
<span class="lineno"> 1496 </span><span class="decl"><span class="istickedoff">inferBlock cname blockpos ctx ty (stmts, lastexpr) = do</span>
<span class="lineno"> 1497 </span><span class="spaces">    </span><span class="istickedoff">let atSyntacticTopLevel = False</span>
<span class="lineno"> 1498 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1499 </span><span class="spaces">    </span><span class="istickedoff">-- Check the statements in order, left first.</span>
<span class="lineno"> 1500 </span><span class="spaces">    </span><span class="istickedoff">stmts' &lt;- mapM (inferStmt cname atSyntacticTopLevel <span class="nottickedoff">blockpos</span> ctx) stmts</span>
<span class="lineno"> 1501 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1502 </span><span class="spaces">    </span><span class="istickedoff">-- Check the final expression.</span>
<span class="lineno"> 1503 </span><span class="spaces">    </span><span class="istickedoff">-- This produces the result type for the block.</span>
<span class="lineno"> 1504 </span><span class="spaces">    </span><span class="istickedoff">(lastexpr', ty') &lt;- inferExpr (<span class="nottickedoff">cname</span>, lastexpr)</span>
<span class="lineno"> 1505 </span><span class="spaces">    </span><span class="istickedoff">unify <span class="nottickedoff">cname</span> ty <span class="nottickedoff">(getPos lastexpr)</span> ty'</span>
<span class="lineno"> 1506 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1507 </span><span class="spaces">    </span><span class="istickedoff">return (stmts', lastexpr')</span></span>
<span class="lineno"> 1508 </span>
<span class="lineno"> 1509 </span>-- Wrapper around inferStmt suitable for checking one statement at a
<span class="lineno"> 1510 </span>-- time. This is temporary scaffolding for the interpreter while
<span class="lineno"> 1511 </span>-- fixing it. (Currently the interpreter typechecks one statement at a
<span class="lineno"> 1512 </span>-- time when executing, even when not at the repl, and this involves
<span class="lineno"> 1513 </span>-- assorted messiness and technical debt. Eventually we'll get it into
<span class="lineno"> 1514 </span>-- a state where we can always just typecheck immediately after
<span class="lineno"> 1515 </span>-- parsing (including incrementally from the repl) but we're some
<span class="lineno"> 1516 </span>-- distance from that. In the meantime the first step is to get it to
<span class="lineno"> 1517 </span>-- typecheck one statement at a time without special-casing any of
<span class="lineno"> 1518 </span>-- them, and this is how it does that.
<span class="lineno"> 1519 </span>--
<span class="lineno"> 1520 </span>-- Run inferStmt and then apply the current substitution before
<span class="lineno"> 1521 </span>-- returning the updated statement. Note that currently the caller
<span class="lineno"> 1522 </span>-- will throw away the updated environment; the interpreter has its
<span class="lineno"> 1523 </span>-- own misbegotten logic for handling that in its own way. (Which
<span class="lineno"> 1524 </span>-- should be removed.)
<span class="lineno"> 1525 </span>inferSingleStmt :: ContextName -&gt; Pos -&gt; Type -&gt; Stmt -&gt; TI Stmt
<span class="lineno"> 1526 </span><span class="decl"><span class="istickedoff">inferSingleStmt cname pos ctx s = do</span>
<span class="lineno"> 1527 </span><span class="spaces">    </span><span class="istickedoff">-- currently we are always at the syntactic top level here because</span>
<span class="lineno"> 1528 </span><span class="spaces">    </span><span class="istickedoff">-- that's how the interpreter works</span>
<span class="lineno"> 1529 </span><span class="spaces">    </span><span class="istickedoff">let atSyntacticTopLevel = True</span>
<span class="lineno"> 1530 </span><span class="spaces">    </span><span class="istickedoff">s' &lt;- inferStmt cname atSyntacticTopLevel pos ctx s</span>
<span class="lineno"> 1531 </span><span class="spaces">    </span><span class="istickedoff">s'' &lt;- applyCurrentSubst s'</span>
<span class="lineno"> 1532 </span><span class="spaces">    </span><span class="istickedoff">return s''</span></span>
<span class="lineno"> 1533 </span>
<span class="lineno"> 1534 </span>--
<span class="lineno"> 1535 </span>-- decls
<span class="lineno"> 1536 </span>--
<span class="lineno"> 1537 </span>
<span class="lineno"> 1538 </span>-- Create a type schema for a list of mutually referential
<span class="lineno"> 1539 </span>-- declarations out of their free vars.
<span class="lineno"> 1540 </span>--
<span class="lineno"> 1541 </span>-- (This creates names for any remaining unification vars, so
<span class="lineno"> 1542 </span>-- potentially updates the expression.)
<span class="lineno"> 1543 </span>--
<span class="lineno"> 1544 </span>-- The &quot;foralls&quot; argument is a set of tyvars that were mentioned
<span class="lineno"> 1545 </span>-- explicitly and should be forall-bound.
<span class="lineno"> 1546 </span>generalize ::
<span class="lineno"> 1547 </span>    Map Name Pos -&gt; [Pattern] -&gt; [OutExpr] -&gt; [Type] -&gt;
<span class="lineno"> 1548 </span>    TI [(Pattern, OutExpr, Schema)]
<span class="lineno"> 1549 </span><span class="decl"><span class="istickedoff">generalize foralls pats0 es0 ts0 = do</span>
<span class="lineno"> 1550 </span><span class="spaces">    </span><span class="istickedoff">-- first, substitute away any resolved unification variables</span>
<span class="lineno"> 1551 </span><span class="spaces">    </span><span class="istickedoff">-- in both the expressions and types.</span>
<span class="lineno"> 1552 </span><span class="spaces">    </span><span class="istickedoff">pats &lt;- applyCurrentSubst pats0</span>
<span class="lineno"> 1553 </span><span class="spaces">    </span><span class="istickedoff">es &lt;- applyCurrentSubst es0</span>
<span class="lineno"> 1554 </span><span class="spaces">    </span><span class="istickedoff">ts &lt;- applyCurrentSubst ts0</span>
<span class="lineno"> 1555 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1556 </span><span class="spaces">    </span><span class="istickedoff">-- Extract lists of any unification vars and named type vars that</span>
<span class="lineno"> 1557 </span><span class="spaces">    </span><span class="istickedoff">-- still appear.</span>
<span class="lineno"> 1558 </span><span class="spaces">    </span><span class="istickedoff">let is0 = unifyVars ts</span>
<span class="lineno"> 1559 </span><span class="spaces">    </span><span class="istickedoff">let bs0 = namedTyVars ts</span>
<span class="lineno"> 1560 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1561 </span><span class="spaces">    </span><span class="istickedoff">-- Drop any unification vars and named type vars that we</span>
<span class="lineno"> 1562 </span><span class="spaces">    </span><span class="istickedoff">-- shouldn't forall-bind.</span>
<span class="lineno"> 1563 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno"> 1564 </span><span class="spaces">    </span><span class="istickedoff">-- For unification vars, any whose scope reaches beyond the</span>
<span class="lineno"> 1565 </span><span class="spaces">    </span><span class="istickedoff">-- current declaration should be left alone; they should only be</span>
<span class="lineno"> 1566 </span><span class="spaces">    </span><span class="istickedoff">-- bound when they eventually move out of scope. Get these by</span>
<span class="lineno"> 1567 </span><span class="spaces">    </span><span class="istickedoff">-- examining the types used in the right-hand sides of both the</span>
<span class="lineno"> 1568 </span><span class="spaces">    </span><span class="istickedoff">-- variable environment and the type environment.</span>
<span class="lineno"> 1569 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno"> 1570 </span><span class="spaces">    </span><span class="istickedoff">-- For named vars, exclude any that appear that appear as keys</span>
<span class="lineno"> 1571 </span><span class="spaces">    </span><span class="istickedoff">-- (on the left-hand side) of the type environment. Those are</span>
<span class="lineno"> 1572 </span><span class="spaces">    </span><span class="istickedoff">-- already defined.</span>
<span class="lineno"> 1573 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno"> 1574 </span><span class="spaces">    </span><span class="istickedoff">-- The only other named variables involved should be the set we</span>
<span class="lineno"> 1575 </span><span class="spaces">    </span><span class="istickedoff">-- explicitly intend to be forall-bound as passed in. Insert</span>
<span class="lineno"> 1576 </span><span class="spaces">    </span><span class="istickedoff">-- those, and favor their positions.</span>
<span class="lineno"> 1577 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno"> 1578 </span><span class="spaces">    </span><span class="istickedoff">-- It would be handy for scaling if we didn't have to examine</span>
<span class="lineno"> 1579 </span><span class="spaces">    </span><span class="istickedoff">-- the entire variable environment (on the grounds that there</span>
<span class="lineno"> 1580 </span><span class="spaces">    </span><span class="istickedoff">-- should be no loose unification vars at the top level where</span>
<span class="lineno"> 1581 </span><span class="spaces">    </span><span class="istickedoff">-- most definitions will come from) but (a) we don't have the</span>
<span class="lineno"> 1582 </span><span class="spaces">    </span><span class="istickedoff">-- structure to support that and (b) it is not absolutely clear</span>
<span class="lineno"> 1583 </span><span class="spaces">    </span><span class="istickedoff">-- that there isn't a way to get such loose unification vars,</span>
<span class="lineno"> 1584 </span><span class="spaces">    </span><span class="istickedoff">-- in which case we'd have to do something about it.</span>
<span class="lineno"> 1585 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno"> 1586 </span><span class="spaces">    </span><span class="istickedoff">-- This code also used to exclude named vars used on the</span>
<span class="lineno"> 1587 </span><span class="spaces">    </span><span class="istickedoff">-- right-hand side of the variable environment; this was to allow</span>
<span class="lineno"> 1588 </span><span class="spaces">    </span><span class="istickedoff">-- the use of otherwise undefined type names in the primitives</span>
<span class="lineno"> 1589 </span><span class="spaces">    </span><span class="istickedoff">-- table. There is no longer any need for such hackery, and</span>
<span class="lineno"> 1590 </span><span class="spaces">    </span><span class="istickedoff">-- undefined type names are not allowed to appear in the variable</span>
<span class="lineno"> 1591 </span><span class="spaces">    </span><span class="istickedoff">-- environment.</span>
<span class="lineno"> 1592 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno"> 1593 </span><span class="spaces">    </span><span class="istickedoff">-- FUTURE: we end up replacing the user's forall-bound names with</span>
<span class="lineno"> 1594 </span><span class="spaces">    </span><span class="istickedoff">-- generated names, and I'm not sure why. It seems like it</span>
<span class="lineno"> 1595 </span><span class="spaces">    </span><span class="istickedoff">-- shouldn't be possible the way the code is structured. But the</span>
<span class="lineno"> 1596 </span><span class="spaces">    </span><span class="istickedoff">-- type signatures are coming out correct (which they wouldn't if</span>
<span class="lineno"> 1597 </span><span class="spaces">    </span><span class="istickedoff">-- something were seriously wrong) and we aren't inappropriately</span>
<span class="lineno"> 1598 </span><span class="spaces">    </span><span class="istickedoff">-- unifying these vars with each other or with other things, so</span>
<span class="lineno"> 1599 </span><span class="spaces">    </span><span class="istickedoff">-- I'm not going to stress over it right now.</span>
<span class="lineno"> 1600 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1601 </span><span class="spaces">    </span><span class="istickedoff">envUnifyVars &lt;- unifyVarsInEnvs</span>
<span class="lineno"> 1602 </span><span class="spaces">    </span><span class="istickedoff">knownNamedVars &lt;- namedVarDefinitions</span>
<span class="lineno"> 1603 </span><span class="spaces">    </span><span class="istickedoff">let is1 = is0 Map.\\ envUnifyVars</span>
<span class="lineno"> 1604 </span><span class="spaces">    </span><span class="istickedoff">let bs1 = Map.union foralls $ Map.withoutKeys bs0 knownNamedVars</span>
<span class="lineno"> 1605 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1606 </span><span class="spaces">    </span><span class="istickedoff">-- convert to lists</span>
<span class="lineno"> 1607 </span><span class="spaces">    </span><span class="istickedoff">let is2 = Map.toList is1</span>
<span class="lineno"> 1608 </span><span class="spaces">    </span><span class="istickedoff">let bs2 = Map.toList bs1</span>
<span class="lineno"> 1609 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1610 </span><span class="spaces">    </span><span class="istickedoff">-- if the position is &quot;fresh&quot; turn it into &quot;inferred from term&quot;</span>
<span class="lineno"> 1611 </span><span class="spaces">    </span><span class="istickedoff">let <span class="nottickedoff">adjustPos pos = case pos of</span></span>
<span class="lineno"> 1612 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">PosInferred InfFresh pos' -&gt; PosInferred InfTerm pos'</span></span>
<span class="lineno"> 1613 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; pos</span></span>
<span class="lineno"> 1614 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1615 </span><span class="spaces">    </span><span class="istickedoff">-- generate names for the unification vars</span>
<span class="lineno"> 1616 </span><span class="spaces">    </span><span class="istickedoff">let is3 = [ (i, <span class="nottickedoff">adjustPos pos</span>, &quot;a.&quot; &lt;&gt; Text.pack (show i)) | (i, pos) &lt;- is2 ]</span>
<span class="lineno"> 1617 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1618 </span><span class="spaces">    </span><span class="istickedoff">-- build a substitution</span>
<span class="lineno"> 1619 </span><span class="spaces">    </span><span class="istickedoff">let s = substFromList [ (i, TyVar <span class="nottickedoff">pos</span> n) | (i, pos, n) &lt;- is3 ]</span>
<span class="lineno"> 1620 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1621 </span><span class="spaces">    </span><span class="istickedoff">-- get the names for the Forall</span>
<span class="lineno"> 1622 </span><span class="spaces">    </span><span class="istickedoff">let inames = [ (<span class="nottickedoff">pos</span>, n) | (_i, pos, n) &lt;- is3 ]</span>
<span class="lineno"> 1623 </span><span class="spaces">    </span><span class="istickedoff">let bnames = [ (<span class="nottickedoff">pos</span>, x) | (x, pos) &lt;- bs2 ]</span>
<span class="lineno"> 1624 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1625 </span><span class="spaces">    </span><span class="istickedoff">let mk pat e t =</span>
<span class="lineno"> 1626 </span><span class="spaces">          </span><span class="istickedoff">let pat' = appSubst <span class="nottickedoff">s</span> pat</span>
<span class="lineno"> 1627 </span><span class="spaces">              </span><span class="istickedoff">e' = appSubst <span class="nottickedoff">s</span> e</span>
<span class="lineno"> 1628 </span><span class="spaces">              </span><span class="istickedoff">t' = appSubst s t</span>
<span class="lineno"> 1629 </span><span class="spaces">          </span><span class="istickedoff">in</span>
<span class="lineno"> 1630 </span><span class="spaces">          </span><span class="istickedoff">(pat', e', Forall (inames ++ bnames) t')</span>
<span class="lineno"> 1631 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1632 </span><span class="spaces">    </span><span class="istickedoff">return $ zipWith3 mk pats es ts</span></span>
<span class="lineno"> 1633 </span>
<span class="lineno"> 1634 </span>
<span class="lineno"> 1635 </span>-- Check that a type is a function and isn't a plain value, in order
<span class="lineno"> 1636 </span>-- to reject recursive values in &quot;rec&quot; definitions. Otherwise they
<span class="lineno"> 1637 </span>-- crash the interpreter downstream. See issue #2203.
<span class="lineno"> 1638 </span>--
<span class="lineno"> 1639 </span>-- There are cases where it might be convenient to include a plain
<span class="lineno"> 1640 </span>-- value within a system of recursive declarations. For example, if
<span class="lineno"> 1641 </span>-- you have something like
<span class="lineno"> 1642 </span>--    rec foo x = ...
<span class="lineno"> 1643 </span>--    and foo0 = foo 0
<span class="lineno"> 1644 </span>--    and foo1 = foo 1
<span class="lineno"> 1645 </span>--    and bar x = ...
<span class="lineno"> 1646 </span>--    and bar0 = bar 0
<span class="lineno"> 1647 </span>--    and bar1 = bar 1
<span class="lineno"> 1648 </span>--    and baz x = ...
<span class="lineno"> 1649 </span>--    and baz0 = baz 0
<span class="lineno"> 1650 </span>--    and baz1 = baz 1
<span class="lineno"> 1651 </span>-- then depending on what the code is, it might be logically
<span class="lineno"> 1652 </span>-- reasonable to place the values like this and ugly to need to move
<span class="lineno"> 1653 </span>-- them out of the flow. If this ever comes up it might make sense to
<span class="lineno"> 1654 </span>-- loosen this check (e.g. to check whether the value is actually
<span class="lineno"> 1655 </span>-- recursive) and also fix the interpreter to not choke. However,
<span class="lineno"> 1656 </span>-- provided the values actually aren't recursive it is _possible_ to
<span class="lineno"> 1657 </span>-- move them out, so this is only worth chasing after given a fairly
<span class="lineno"> 1658 </span>-- compelling use case.
<span class="lineno"> 1659 </span>--
<span class="lineno"> 1660 </span>-- Note that actual recursively defined values are always bottom (in
<span class="lineno"> 1661 </span>-- the absence of mutable variables) and are best not allowed.
<span class="lineno"> 1662 </span>--
<span class="lineno"> 1663 </span>requireFunction :: Pos -&gt; Type -&gt; TI ()
<span class="lineno"> 1664 </span><span class="decl"><span class="istickedoff">requireFunction pos ty = do</span>
<span class="lineno"> 1665 </span><span class="spaces">    </span><span class="istickedoff">ty' &lt;- applyCurrentSubst =&lt;&lt; resolveCurrentTypedefs ty</span>
<span class="lineno"> 1666 </span><span class="spaces">    </span><span class="istickedoff">case ty' of</span>
<span class="lineno"> 1667 </span><span class="spaces">        </span><span class="istickedoff">TyCon _pos FunCon _args -&gt;</span>
<span class="lineno"> 1668 </span><span class="spaces">            </span><span class="istickedoff">return <span class="nottickedoff">()</span></span>
<span class="lineno"> 1669 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 1670 </span><span class="spaces">            </span><span class="istickedoff">recordError pos $ &quot;Only functions may be recursive.&quot;</span></span>
<span class="lineno"> 1671 </span>
<span class="lineno"> 1672 </span>-- | Type inference for a declaration.
<span class="lineno"> 1673 </span>--
<span class="lineno"> 1674 </span>-- Note that the type schema slot in Decl is always Nothing the way it
<span class="lineno"> 1675 </span>-- comes from the parser; if there's an explicit type annotation on
<span class="lineno"> 1676 </span>-- the declaration, it shows up as a type signature in the expression.
<span class="lineno"> 1677 </span>--
<span class="lineno"> 1678 </span>-- This function does _not_ update the variable environment to reflect
<span class="lineno"> 1679 </span>-- the declaration. The caller does that. XXX: this seems messy. (But
<span class="lineno"> 1680 </span>-- note that checkDecl is used by the :type REPL command, which
<span class="lineno"> 1681 </span>-- shouldn't update anything, so it's not open and shut.)
<span class="lineno"> 1682 </span>inferDecl :: Rebindable -&gt; Decl -&gt; TI Decl
<span class="lineno"> 1683 </span><span class="decl"><span class="istickedoff">inferDecl rebindable d@(Decl pos pat _ e) = do</span>
<span class="lineno"> 1684 </span><span class="spaces">    </span><span class="istickedoff">let cname = getPatternContext pat</span>
<span class="lineno"> 1685 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1686 </span><span class="spaces">    </span><span class="istickedoff">-- collect the free type variables</span>
<span class="lineno"> 1687 </span><span class="spaces">    </span><span class="istickedoff">foralls &lt;- inspectDeclFTVs d</span>
<span class="lineno"> 1688 </span><span class="spaces">    </span><span class="istickedoff">let foralls' = Map.map <span class="nottickedoff">(\(typos, _kind) -&gt; typos)</span> foralls</span>
<span class="lineno"> 1689 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1690 </span><span class="spaces">    </span><span class="istickedoff">-- Add abstract type variables for the foralls while we check the body.</span>
<span class="lineno"> 1691 </span><span class="spaces">    </span><span class="istickedoff">-- Note: this is a variable declaration. It doesn't add types; the types</span>
<span class="lineno"> 1692 </span><span class="spaces">    </span><span class="istickedoff">-- get forall-bound in the type scheme by the `generalize` call.</span>
<span class="lineno"> 1693 </span><span class="spaces">    </span><span class="istickedoff">pushScope</span>
<span class="lineno"> 1694 </span><span class="spaces">    </span><span class="istickedoff">addAbstractTyVars foralls</span>
<span class="lineno"> 1695 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1696 </span><span class="spaces">    </span><span class="istickedoff">-- Check the body and check the pattern against the body.</span>
<span class="lineno"> 1697 </span><span class="spaces">    </span><span class="istickedoff">(e', t) &lt;- inferExpr (cname, e)</span>
<span class="lineno"> 1698 </span><span class="spaces">    </span><span class="istickedoff">pat' &lt;- checkPattern rebindable cname t pat</span>
<span class="lineno"> 1699 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1700 </span><span class="spaces">    </span><span class="istickedoff">-- Use `generalize` to build the type scheme.</span>
<span class="lineno"> 1701 </span><span class="spaces">    </span><span class="istickedoff">~[(pat'', e1, s)] &lt;- generalize foralls' [pat'] [e'] [t]</span>
<span class="lineno"> 1702 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1703 </span><span class="spaces">    </span><span class="istickedoff">-- Drop the abstract type variables</span>
<span class="lineno"> 1704 </span><span class="spaces">    </span><span class="istickedoff">popScope</span>
<span class="lineno"> 1705 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1706 </span><span class="spaces">    </span><span class="istickedoff">-- Return the updated `Decl`</span>
<span class="lineno"> 1707 </span><span class="spaces">    </span><span class="istickedoff">return (Decl <span class="nottickedoff">pos</span> pat'' (Just s) e1)</span></span>
<span class="lineno"> 1708 </span>
<span class="lineno"> 1709 </span>-- | Type inference for a system of mutually recursive declarations.
<span class="lineno"> 1710 </span>--
<span class="lineno"> 1711 </span>-- Note that the type schema slot in the Decls is always Nothing as we
<span class="lineno"> 1712 </span>-- get them from the parser; if there's an explicit type annotation on
<span class="lineno"> 1713 </span>-- some or all of the declarations those shows up as type signatures
<span class="lineno"> 1714 </span>-- in the expressions.
<span class="lineno"> 1715 </span>--
<span class="lineno"> 1716 </span>-- This function does _not_ update the variable environment to reflect
<span class="lineno"> 1717 </span>-- the declaration. The caller does that. XXX: this is messy.
<span class="lineno"> 1718 </span>inferRecDecls :: [Decl] -&gt; TI [Decl]
<span class="lineno"> 1719 </span><span class="decl"><span class="istickedoff">inferRecDecls ds = do</span>
<span class="lineno"> 1720 </span><span class="spaces">    </span><span class="istickedoff">-- Get the patterns out of the decls. Pop out the first one for</span>
<span class="lineno"> 1721 </span><span class="spaces">    </span><span class="istickedoff">-- use as a reference name.</span>
<span class="lineno"> 1722 </span><span class="spaces">    </span><span class="istickedoff">let pats = map dPat ds</span>
<span class="lineno"> 1723 </span><span class="spaces">        </span><span class="istickedoff">firstPat =</span>
<span class="lineno"> 1724 </span><span class="spaces">          </span><span class="istickedoff">case pats of</span>
<span class="lineno"> 1725 </span><span class="spaces">            </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">panic &quot;inferRecDecls&quot; [</span></span>
<span class="lineno"> 1726 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">&quot;Empty list of declarations in recursive group&quot;</span></span>
<span class="lineno"> 1727 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1728 </span><span class="spaces">            </span><span class="istickedoff">p : _ -&gt; p</span>
<span class="lineno"> 1729 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">cname = getPatternContext firstPat</span></span>
<span class="lineno"> 1730 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1731 </span><span class="spaces">    </span><span class="istickedoff">-- Collect the free type variables.</span>
<span class="lineno"> 1732 </span><span class="spaces">    </span><span class="istickedoff">foralls &lt;- Map.unions &lt;$&gt; mapM inspectDeclFTVs ds</span>
<span class="lineno"> 1733 </span><span class="spaces">    </span><span class="istickedoff">let foralls' = Map.map <span class="nottickedoff">(\(typos, _kind) -&gt; typos)</span> foralls</span>
<span class="lineno"> 1734 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1735 </span><span class="spaces">    </span><span class="istickedoff">-- Add abstract type variables for the foralls while we check the</span>
<span class="lineno"> 1736 </span><span class="spaces">    </span><span class="istickedoff">-- bodies.</span>
<span class="lineno"> 1737 </span><span class="spaces">    </span><span class="istickedoff">pushScope</span>
<span class="lineno"> 1738 </span><span class="spaces">    </span><span class="istickedoff">addAbstractTyVars foralls</span>
<span class="lineno"> 1739 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1740 </span><span class="spaces">    </span><span class="istickedoff">-- Check the patterns first to get types.</span>
<span class="lineno"> 1741 </span><span class="spaces">    </span><span class="istickedoff">(_ts, pats') &lt;- unzip &lt;$&gt; mapM (inferPattern <span class="nottickedoff">cname</span> <span class="nottickedoff">ReadOnlyVar</span>) pats</span>
<span class="lineno"> 1742 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1743 </span><span class="spaces">    </span><span class="istickedoff">-- Check all the expressions in an environment that includes all</span>
<span class="lineno"> 1744 </span><span class="spaces">    </span><span class="istickedoff">-- the bound variables.</span>
<span class="lineno"> 1745 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno"> 1746 </span><span class="spaces">    </span><span class="istickedoff">-- FUTURE: we only need a second nested scope here because we run</span>
<span class="lineno"> 1747 </span><span class="spaces">    </span><span class="istickedoff">-- all the patterns through checkPattern a second time; if we do</span>
<span class="lineno"> 1748 </span><span class="spaces">    </span><span class="istickedoff">-- that after the addPatterns, every declaration is a &quot;duplicate&quot;</span>
<span class="lineno"> 1749 </span><span class="spaces">    </span><span class="istickedoff">-- and things go plop. It seems there ought to be a better way of</span>
<span class="lineno"> 1750 </span><span class="spaces">    </span><span class="istickedoff">-- handling all this that doesn't require visiting the patterns</span>
<span class="lineno"> 1751 </span><span class="spaces">    </span><span class="istickedoff">-- twice.</span>
<span class="lineno"> 1752 </span><span class="spaces">    </span><span class="istickedoff">pushScope</span>
<span class="lineno"> 1753 </span><span class="spaces">    </span><span class="istickedoff">addPatterns pats'</span>
<span class="lineno"> 1754 </span><span class="spaces">    </span><span class="istickedoff">let checkOneExpr (Decl _pos p _ e) = inferExpr (<span class="nottickedoff">getPatternContext p</span>, e)</span>
<span class="lineno"> 1755 </span><span class="spaces">    </span><span class="istickedoff">(es, tys) &lt;- unzip &lt;$&gt; mapM checkOneExpr ds</span>
<span class="lineno"> 1756 </span><span class="spaces">    </span><span class="istickedoff">popScope</span>
<span class="lineno"> 1757 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1758 </span><span class="spaces">    </span><span class="istickedoff">-- Only functions can be recursive. Check each participant.</span>
<span class="lineno"> 1759 </span><span class="spaces">    </span><span class="istickedoff">zipWithM_ (\d ty -&gt; requireFunction (getPos d) ty) ds tys</span>
<span class="lineno"> 1760 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1761 </span><span class="spaces">    </span><span class="istickedoff">-- pats' has already been checked once, which will have inserted</span>
<span class="lineno"> 1762 </span><span class="spaces">    </span><span class="istickedoff">-- unification vars for any missing types. Running it through</span>
<span class="lineno"> 1763 </span><span class="spaces">    </span><span class="istickedoff">-- again will have no further effect, so we can ignore the</span>
<span class="lineno"> 1764 </span><span class="spaces">    </span><span class="istickedoff">-- theoretically-updated-again patterns returned by checkPattern.</span>
<span class="lineno"> 1765 </span><span class="spaces">    </span><span class="istickedoff">sequence_ $ zipWith (checkPattern <span class="nottickedoff">ReadOnlyVar</span> (getPatternContext firstPat)) tys pats'</span>
<span class="lineno"> 1766 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1767 </span><span class="spaces">    </span><span class="istickedoff">-- Run generalize and get back a list of updated expressions and</span>
<span class="lineno"> 1768 </span><span class="spaces">    </span><span class="istickedoff">-- type schemes.</span>
<span class="lineno"> 1769 </span><span class="spaces">    </span><span class="istickedoff">patetys &lt;- generalize foralls' pats' es tys</span>
<span class="lineno"> 1770 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1771 </span><span class="spaces">    </span><span class="istickedoff">-- Drop the abstract type variables.</span>
<span class="lineno"> 1772 </span><span class="spaces">    </span><span class="istickedoff">popScope</span>
<span class="lineno"> 1773 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1774 </span><span class="spaces">    </span><span class="istickedoff">-- Generate the updated declarations.</span>
<span class="lineno"> 1775 </span><span class="spaces">    </span><span class="istickedoff">let rebuild pos (pat, e1, ty) = Decl <span class="nottickedoff">pos</span> pat (Just ty) e1</span>
<span class="lineno"> 1776 </span><span class="spaces">        </span><span class="istickedoff">ds' = zipWith rebuild (map <span class="nottickedoff">getPos</span> ds) patetys</span>
<span class="lineno"> 1777 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1778 </span><span class="spaces">    </span><span class="istickedoff">return ds'</span></span>
<span class="lineno"> 1779 </span>
<span class="lineno"> 1780 </span>-- Type inference for a decl group.
<span class="lineno"> 1781 </span>inferDeclGroup :: Rebindable -&gt; DeclGroup -&gt; TI DeclGroup
<span class="lineno"> 1782 </span><span class="decl"><span class="istickedoff">inferDeclGroup rebindable (NonRecursive d) = do</span>
<span class="lineno"> 1783 </span><span class="spaces">    </span><span class="istickedoff">d' &lt;- inferDecl rebindable d</span>
<span class="lineno"> 1784 </span><span class="spaces">    </span><span class="istickedoff">return (NonRecursive d')</span>
<span class="lineno"> 1785 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1786 </span><span class="spaces"></span><span class="istickedoff">inferDeclGroup rebindable (Recursive ds) = do</span>
<span class="lineno"> 1787 </span><span class="spaces">    </span><span class="istickedoff">-- The parser doesn't accept &quot;rec rebindable&quot; so panic if it appears.</span>
<span class="lineno"> 1788 </span><span class="spaces">    </span><span class="istickedoff">when (rebindable == RebindableVar) $</span>
<span class="lineno"> 1789 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">panic &quot;inferDeclGroup&quot; [</span></span>
<span class="lineno"> 1790 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot;Found 'rebindable' on a 'rec' declaration&quot;</span></span>
<span class="lineno"> 1791 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1792 </span><span class="spaces">    </span><span class="istickedoff">ds' &lt;- inferRecDecls ds</span>
<span class="lineno"> 1793 </span><span class="spaces">    </span><span class="istickedoff">return (Recursive ds')</span></span>
<span class="lineno"> 1794 </span>
<span class="lineno"> 1795 </span>--
<span class="lineno"> 1796 </span>-- types
<span class="lineno"> 1797 </span>--
<span class="lineno"> 1798 </span>
<span class="lineno"> 1799 </span>-- Look up a type constructor (in our fixed environment of hardcoded
<span class="lineno"> 1800 </span>-- types) and return its params as a list of kinds.
<span class="lineno"> 1801 </span>lookupTyCon :: TyCon -&gt; [Kind]
<span class="lineno"> 1802 </span><span class="decl"><span class="istickedoff">lookupTyCon tycon = case tycon of</span>
<span class="lineno"> 1803 </span><span class="spaces">    </span><span class="istickedoff">TupleCon n -&gt; genericTake n (repeat kindStar)</span>
<span class="lineno"> 1804 </span><span class="spaces">    </span><span class="istickedoff">ArrayCon -&gt; [kindStar]</span>
<span class="lineno"> 1805 </span><span class="spaces">    </span><span class="istickedoff">FunCon -&gt; [kindStar, kindStar]</span>
<span class="lineno"> 1806 </span><span class="spaces">    </span><span class="istickedoff">StringCon -&gt; []</span>
<span class="lineno"> 1807 </span><span class="spaces">    </span><span class="istickedoff">TermCon -&gt; []</span>
<span class="lineno"> 1808 </span><span class="spaces">    </span><span class="istickedoff">TypeCon -&gt; []</span>
<span class="lineno"> 1809 </span><span class="spaces">    </span><span class="istickedoff">BoolCon -&gt; []</span>
<span class="lineno"> 1810 </span><span class="spaces">    </span><span class="istickedoff">IntCon -&gt; []</span>
<span class="lineno"> 1811 </span><span class="spaces">    </span><span class="istickedoff">BlockCon -&gt; [kindStarToStar, kindStar]</span>
<span class="lineno"> 1812 </span><span class="spaces">    </span><span class="istickedoff">AIGCon -&gt; []</span>
<span class="lineno"> 1813 </span><span class="spaces">    </span><span class="istickedoff">CFGCon -&gt; []</span>
<span class="lineno"> 1814 </span><span class="spaces">    </span><span class="istickedoff">JVMSpecCon -&gt; []</span>
<span class="lineno"> 1815 </span><span class="spaces">    </span><span class="istickedoff">LLVMSpecCon -&gt; []</span>
<span class="lineno"> 1816 </span><span class="spaces">    </span><span class="istickedoff">MIRSpecCon -&gt; []</span>
<span class="lineno"> 1817 </span><span class="spaces">    </span><span class="istickedoff">ContextCon _ctx -&gt; [<span class="nottickedoff">kindStar</span>]</span></span>
<span class="lineno"> 1818 </span>
<span class="lineno"> 1819 </span>-- Check a type for validity and also for having the
<span class="lineno"> 1820 </span>-- correct kinding.
<span class="lineno"> 1821 </span>checkType :: Kind -&gt; Type -&gt; TI Type
<span class="lineno"> 1822 </span><span class="decl"><span class="istickedoff">checkType kind ty = case ty of</span>
<span class="lineno"> 1823 </span><span class="spaces">  </span><span class="istickedoff">TyCon pos tycon args -&gt; do</span>
<span class="lineno"> 1824 </span><span class="spaces">      </span><span class="istickedoff">-- First, look up the constructor.</span>
<span class="lineno"> 1825 </span><span class="spaces">      </span><span class="istickedoff">let params = lookupTyCon tycon</span>
<span class="lineno"> 1826 </span><span class="spaces">      </span><span class="istickedoff">let nparams = genericLength params</span>
<span class="lineno"> 1827 </span><span class="spaces">          </span><span class="istickedoff">nargs = genericLength args</span>
<span class="lineno"> 1828 </span><span class="spaces">          </span><span class="istickedoff">argsleft = kindNumArgs kind</span>
<span class="lineno"> 1829 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1830 </span><span class="spaces">      </span><span class="istickedoff">if <span class="tickonlyfalse">nargs &gt; nparams</span> then <span class="nottickedoff">do</span></span>
<span class="lineno"> 1831 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">-- XXX special case for BlockCon (remove along with BlockCon)</span></span>
<span class="lineno"> 1832 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">case (tycon, args) of</span></span>
<span class="lineno"> 1833 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">(BlockCon, arg : _) -&gt;</span></span>
<span class="lineno"> 1834 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">recordError pos (&quot;Too many type arguments for type &quot; ++</span></span>
<span class="lineno"> 1835 </span><span class="spaces">                                   </span><span class="istickedoff"><span class="nottickedoff">&quot;constructor &quot; ++ pShow arg ++</span></span>
<span class="lineno"> 1836 </span><span class="spaces">                                   </span><span class="istickedoff"><span class="nottickedoff">&quot;; found &quot; ++ show (nargs - 1) ++</span></span>
<span class="lineno"> 1837 </span><span class="spaces">                                   </span><span class="istickedoff"><span class="nottickedoff">&quot; but expected only &quot; ++ show (nparams - 1))</span></span>
<span class="lineno"> 1838 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">(_, _) -&gt;</span></span>
<span class="lineno"> 1839 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">recordError pos (&quot;Too many type arguments for type &quot; ++</span></span>
<span class="lineno"> 1840 </span><span class="spaces">                                   </span><span class="istickedoff"><span class="nottickedoff">&quot;constructor &quot; ++ pShow tycon ++</span></span>
<span class="lineno"> 1841 </span><span class="spaces">                                   </span><span class="istickedoff"><span class="nottickedoff">&quot;; found &quot; ++ show nargs ++</span></span>
<span class="lineno"> 1842 </span><span class="spaces">                                   </span><span class="istickedoff"><span class="nottickedoff">&quot; but expected only &quot; ++ show nparams)</span></span>
<span class="lineno"> 1843 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">getErrorTyVar pos</span></span>
<span class="lineno"> 1844 </span><span class="spaces">      </span><span class="istickedoff">else if nargs + argsleft /= nparams then do</span>
<span class="lineno"> 1845 </span><span class="spaces">          </span><span class="istickedoff">recordError pos (&quot;Kind mismatch: expected &quot; ++ pShow kind ++</span>
<span class="lineno"> 1846 </span><span class="spaces">                           </span><span class="istickedoff">&quot; but found &quot; ++ (pShow $ Kind (nparams - nargs)))</span>
<span class="lineno"> 1847 </span><span class="spaces">          </span><span class="istickedoff">getErrorTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno"> 1848 </span><span class="spaces">      </span><span class="istickedoff">else do</span>
<span class="lineno"> 1849 </span><span class="spaces">          </span><span class="istickedoff">-- note that this will ignore the extra params, and return</span>
<span class="lineno"> 1850 </span><span class="spaces">          </span><span class="istickedoff">-- a list of the same length as the args given</span>
<span class="lineno"> 1851 </span><span class="spaces">          </span><span class="istickedoff">args' &lt;- zipWithM checkType params args</span>
<span class="lineno"> 1852 </span><span class="spaces">          </span><span class="istickedoff">return $ TyCon pos tycon args'</span>
<span class="lineno"> 1853 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1854 </span><span class="spaces">  </span><span class="istickedoff">TyRecord pos fields -&gt; do</span>
<span class="lineno"> 1855 </span><span class="spaces">      </span><span class="istickedoff">if kind /= kindStar then do</span>
<span class="lineno"> 1856 </span><span class="spaces">          </span><span class="istickedoff">recordError pos (&quot;Kind mismatch: expected &quot; ++ pShow kind ++</span>
<span class="lineno"> 1857 </span><span class="spaces">                           </span><span class="istickedoff">&quot; but found &quot; ++ pShow kindStar)</span>
<span class="lineno"> 1858 </span><span class="spaces">          </span><span class="istickedoff">getErrorTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno"> 1859 </span><span class="spaces">      </span><span class="istickedoff">else do</span>
<span class="lineno"> 1860 </span><span class="spaces">          </span><span class="istickedoff">-- Someone upstream had better have checked for duplicate</span>
<span class="lineno"> 1861 </span><span class="spaces">          </span><span class="istickedoff">-- field names because we can't once the fields are loaded</span>
<span class="lineno"> 1862 </span><span class="spaces">          </span><span class="istickedoff">-- into a map. (XXX: someone hasn't)</span>
<span class="lineno"> 1863 </span><span class="spaces">          </span><span class="istickedoff">fields' &lt;- traverse (checkType kindStar) fields</span>
<span class="lineno"> 1864 </span><span class="spaces">          </span><span class="istickedoff">return $ TyRecord pos fields'</span>
<span class="lineno"> 1865 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1866 </span><span class="spaces">  </span><span class="istickedoff">TyVar pos x -&gt; do</span>
<span class="lineno"> 1867 </span><span class="spaces">      </span><span class="istickedoff">avail &lt;- asks primsAvail</span>
<span class="lineno"> 1868 </span><span class="spaces">      </span><span class="istickedoff">tyenv &lt;- gets tyEnv</span>
<span class="lineno"> 1869 </span><span class="spaces">      </span><span class="istickedoff">case ScopedMap.lookup x tyenv of</span>
<span class="lineno"> 1870 </span><span class="spaces">          </span><span class="istickedoff">Nothing -&gt; do</span>
<span class="lineno"> 1871 </span><span class="spaces">              </span><span class="istickedoff">recordError pos (&quot;Unbound type variable &quot; ++ Text.unpack x)</span>
<span class="lineno"> 1872 </span><span class="spaces">              </span><span class="istickedoff">getErrorTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno"> 1873 </span><span class="spaces">          </span><span class="istickedoff">Just (lc, ty')</span>
<span class="lineno"> 1874 </span><span class="spaces">           </span><span class="istickedoff">| Set.member lc avail -&gt; do</span>
<span class="lineno"> 1875 </span><span class="spaces">              </span><span class="istickedoff">when (isDeprecated lc) $</span>
<span class="lineno"> 1876 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">recordWarning pos $ &quot;Type is deprecated: &quot; &lt;&gt; Text.unpack x</span></span>
<span class="lineno"> 1877 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1878 </span><span class="spaces">              </span><span class="istickedoff">-- For typedefs, which appear here as ConcreteType</span>
<span class="lineno"> 1879 </span><span class="spaces">              </span><span class="istickedoff">-- expansions, assume ty' was checked when it was</span>
<span class="lineno"> 1880 </span><span class="spaces">              </span><span class="istickedoff">-- entered.</span>
<span class="lineno"> 1881 </span><span class="spaces">              </span><span class="istickedoff">--</span>
<span class="lineno"> 1882 </span><span class="spaces">              </span><span class="istickedoff">-- (If we entered it that's true, if it was in the</span>
<span class="lineno"> 1883 </span><span class="spaces">              </span><span class="istickedoff">-- initial environment we were given that depends on the</span>
<span class="lineno"> 1884 </span><span class="spaces">              </span><span class="istickedoff">-- interpreter not doing unfortunate things. This isn't</span>
<span class="lineno"> 1885 </span><span class="spaces">              </span><span class="istickedoff">-- currently seeming like a very good bet.)</span>
<span class="lineno"> 1886 </span><span class="spaces">              </span><span class="istickedoff">--</span>
<span class="lineno"> 1887 </span><span class="spaces">              </span><span class="istickedoff">-- For now at least we require typedefs to be kind *</span>
<span class="lineno"> 1888 </span><span class="spaces">              </span><span class="istickedoff">-- (they can't have parameters and the expansions are thus</span>
<span class="lineno"> 1889 </span><span class="spaces">              </span><span class="istickedoff">-- restricted) so just fail if we use one in a context</span>
<span class="lineno"> 1890 </span><span class="spaces">              </span><span class="istickedoff">-- expecting something else.</span>
<span class="lineno"> 1891 </span><span class="spaces">              </span><span class="istickedoff">--</span>
<span class="lineno"> 1892 </span><span class="spaces">              </span><span class="istickedoff">-- Abstract types may have any kind, because some are</span>
<span class="lineno"> 1893 </span><span class="spaces">              </span><span class="istickedoff">-- monads; we carry the kind around.</span>
<span class="lineno"> 1894 </span><span class="spaces">              </span><span class="istickedoff">-- </span>
<span class="lineno"> 1895 </span><span class="spaces">              </span><span class="istickedoff">let kindFound = case ty' of</span>
<span class="lineno"> 1896 </span><span class="spaces">                    </span><span class="istickedoff">ConcreteType _ -&gt; kindStar</span>
<span class="lineno"> 1897 </span><span class="spaces">                    </span><span class="istickedoff">AbstractType kf -&gt; kf</span>
<span class="lineno"> 1898 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1899 </span><span class="spaces">              </span><span class="istickedoff">if kind /= kindFound then do</span>
<span class="lineno"> 1900 </span><span class="spaces">                  </span><span class="istickedoff">recordError pos (&quot;Kind mismatch: expected &quot; ++ pShow kind ++</span>
<span class="lineno"> 1901 </span><span class="spaces">                                   </span><span class="istickedoff">&quot; but found &quot; ++ pShow kindFound)</span>
<span class="lineno"> 1902 </span><span class="spaces">                  </span><span class="istickedoff">getErrorTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno"> 1903 </span><span class="spaces">              </span><span class="istickedoff">else</span>
<span class="lineno"> 1904 </span><span class="spaces">                  </span><span class="istickedoff">-- We do _not_ want to expand typedefs when checking,</span>
<span class="lineno"> 1905 </span><span class="spaces">                  </span><span class="istickedoff">-- so return the original TyVar.</span>
<span class="lineno"> 1906 </span><span class="spaces">                  </span><span class="istickedoff">return ty</span>
<span class="lineno"> 1907 </span><span class="spaces">           </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt; do</span>
<span class="lineno"> 1908 </span><span class="spaces">                  </span><span class="istickedoff">recordError pos $ &quot;Inaccessible type: &quot; ++ show x</span>
<span class="lineno"> 1909 </span><span class="spaces">                  </span><span class="istickedoff">let how = if lc == HideDeprecated then &quot;deprecated&quot; else &quot;experimental&quot;</span>
<span class="lineno"> 1910 </span><span class="spaces">                  </span><span class="istickedoff">recordError pos $ &quot;This type is available only after running &quot; ++</span>
<span class="lineno"> 1911 </span><span class="spaces">                                    </span><span class="istickedoff">&quot;`enable_&quot; ++ how ++ &quot;`.&quot;</span>
<span class="lineno"> 1912 </span><span class="spaces">                  </span><span class="istickedoff">t' &lt;- getFreshTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno"> 1913 </span><span class="spaces">                  </span><span class="istickedoff">return <span class="nottickedoff">t'</span></span>
<span class="lineno"> 1914 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1915 </span><span class="spaces">  </span><span class="istickedoff">TyUnifyVar _pos _ix -&gt;</span>
<span class="lineno"> 1916 </span><span class="spaces">      </span><span class="istickedoff">-- for now at least we don't track the kinds of unification vars</span>
<span class="lineno"> 1917 </span><span class="spaces">      </span><span class="istickedoff">-- (types of mismatched kinds can't be the same types, so they</span>
<span class="lineno"> 1918 </span><span class="spaces">      </span><span class="istickedoff">-- won't ever unify, so the possible mischief is limited) and all</span>
<span class="lineno"> 1919 </span><span class="spaces">      </span><span class="istickedoff">-- possible unification var numbers are well formed, so we don't</span>
<span class="lineno"> 1920 </span><span class="spaces">      </span><span class="istickedoff">-- need to do anything.</span>
<span class="lineno"> 1921 </span><span class="spaces">      </span><span class="istickedoff">return ty</span></span>
<span class="lineno"> 1922 </span>
<span class="lineno"> 1923 </span>
<span class="lineno"> 1924 </span>------------------------------------------------------------
<span class="lineno"> 1925 </span>-- External interface
<span class="lineno"> 1926 </span>
<span class="lineno"> 1927 </span>-- Some short names for use in the signatures below
<span class="lineno"> 1928 </span>type MsgList = [(Pos, String)]
<span class="lineno"> 1929 </span>type Result a = (Either MsgList a, MsgList)
<span class="lineno"> 1930 </span>
<span class="lineno"> 1931 </span>-- Run the TI monad.
<span class="lineno"> 1932 </span>--
<span class="lineno"> 1933 </span>-- Note that the error and warning lists accumulate in reverse order
<span class="lineno"> 1934 </span>-- (later messages are consed onto the head of the list) so we
<span class="lineno"> 1935 </span>-- reverse on the way out.
<span class="lineno"> 1936 </span>runTIWithEnv :: Set PrimitiveLifecycle -&gt; VarEnv -&gt; TyEnv -&gt; TI a -&gt; (a, Subst, MsgList, MsgList)
<span class="lineno"> 1937 </span><span class="decl"><span class="istickedoff">runTIWithEnv avail env tenv m = (a, <span class="nottickedoff">subst rw'</span>, reverse $ errors rw', reverse $ warnings rw')</span>
<span class="lineno"> 1938 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1939 </span><span class="spaces">    </span><span class="istickedoff">m' = runReaderT (unTI m) (RO avail)</span>
<span class="lineno"> 1940 </span><span class="spaces">    </span><span class="istickedoff">rw = initialRW env tenv</span>
<span class="lineno"> 1941 </span><span class="spaces">    </span><span class="istickedoff">(a, rw') = runState m' rw</span></span>
<span class="lineno"> 1942 </span>
<span class="lineno"> 1943 </span>-- Run the TI monad and interpret/collect the results
<span class="lineno"> 1944 </span>-- (failure if any errors were produced)
<span class="lineno"> 1945 </span>evalTIWithEnv :: Set PrimitiveLifecycle -&gt; VarEnv -&gt; TyEnv -&gt; TI a -&gt; Result a
<span class="lineno"> 1946 </span><span class="decl"><span class="istickedoff">evalTIWithEnv avail env tenv m =</span>
<span class="lineno"> 1947 </span><span class="spaces">  </span><span class="istickedoff">case runTIWithEnv avail env tenv m of</span>
<span class="lineno"> 1948 </span><span class="spaces">    </span><span class="istickedoff">(res, _, [], warns) -&gt; (Right res, warns)</span>
<span class="lineno"> 1949 </span><span class="spaces">    </span><span class="istickedoff">(_, _, errs, warns) -&gt; (Left errs, warns)</span></span>
<span class="lineno"> 1950 </span>
<span class="lineno"> 1951 </span>-- | Check a single statement. (This is an external interface.)
<span class="lineno"> 1952 </span>--
<span class="lineno"> 1953 </span>-- The first two arguments are the starting variable and typedef
<span class="lineno"> 1954 </span>-- environments to use.
<span class="lineno"> 1955 </span>--
<span class="lineno"> 1956 </span>-- The third is a current position, and the fourth is the
<span class="lineno"> 1957 </span>-- context/monad type associated with the execution.
<span class="lineno"> 1958 </span>checkStmt :: Set PrimitiveLifecycle -&gt; VarEnv -&gt; TyEnv -&gt; Context -&gt; Stmt -&gt; Result Stmt
<span class="lineno"> 1959 </span><span class="decl"><span class="istickedoff">checkStmt avail env tenv ctx stmt =</span>
<span class="lineno"> 1960 </span><span class="spaces">    </span><span class="istickedoff">-- XXX: we shouldn't need this position here.</span>
<span class="lineno"> 1961 </span><span class="spaces">    </span><span class="istickedoff">-- The position is used for the following things:</span>
<span class="lineno"> 1962 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno"> 1963 </span><span class="spaces">    </span><span class="istickedoff">--    - to create cname, which is used as part of the error printing</span>
<span class="lineno"> 1964 </span><span class="spaces">    </span><span class="istickedoff">--      scheme, but is no longer particularly useful after recent</span>
<span class="lineno"> 1965 </span><span class="spaces">    </span><span class="istickedoff">--      improvements (especially here where it contains no real</span>
<span class="lineno"> 1966 </span><span class="spaces">    </span><span class="istickedoff">--      information) and should be removed;</span>
<span class="lineno"> 1967 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno"> 1968 </span><span class="spaces">    </span><span class="istickedoff">--    - to be the position associated with the monad context, which</span>
<span class="lineno"> 1969 </span><span class="spaces">    </span><span class="istickedoff">--      in a tidy world should just be PosRepl (as in, the only</span>
<span class="lineno"> 1970 </span><span class="spaces">    </span><span class="istickedoff">--      time we should be typechecking a single statement is when</span>
<span class="lineno"> 1971 </span><span class="spaces">    </span><span class="istickedoff">--      it was just typed interactively, and which monad we're in</span>
<span class="lineno"> 1972 </span><span class="spaces">    </span><span class="istickedoff">--      is a direct property of that context) but this is not</span>
<span class="lineno"> 1973 </span><span class="spaces">    </span><span class="istickedoff">--      currently true and will require a good bit of interpreter</span>
<span class="lineno"> 1974 </span><span class="spaces">    </span><span class="istickedoff">--      cleanup to make it true;</span>
<span class="lineno"> 1975 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno"> 1976 </span><span class="spaces">    </span><span class="istickedoff">--    - to pass to inferStmt, which also uses it as part of the</span>
<span class="lineno"> 1977 </span><span class="spaces">    </span><span class="istickedoff">--      position associated with the monad context. (This part is a</span>
<span class="lineno"> 1978 </span><span class="spaces">    </span><span class="istickedoff">--      result of BlockCon existing and can go away when BlockCon is</span>
<span class="lineno"> 1979 </span><span class="spaces">    </span><span class="istickedoff">--      removed.)</span>
<span class="lineno"> 1980 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno"> 1981 </span><span class="spaces">    </span><span class="istickedoff">-- XXX: using the position of the statement as the position</span>
<span class="lineno"> 1982 </span><span class="spaces">    </span><span class="istickedoff">-- associated with the monad context is not correct (or at least,</span>
<span class="lineno"> 1983 </span><span class="spaces">    </span><span class="istickedoff">-- will be confusing) and we should figure something else out if the</span>
<span class="lineno"> 1984 </span><span class="spaces">    </span><span class="istickedoff">-- interpreter cleanup doesn't come through soon. Note that</span>
<span class="lineno"> 1985 </span><span class="spaces">    </span><span class="istickedoff">-- currently we come through here only for syntactically top-level</span>
<span class="lineno"> 1986 </span><span class="spaces">    </span><span class="istickedoff">-- statements in the interpreter; these are TopLevel except when in</span>
<span class="lineno"> 1987 </span><span class="spaces">    </span><span class="istickedoff">-- the ProofScript repl. So perhaps we should use PosRepl when in</span>
<span class="lineno"> 1988 </span><span class="spaces">    </span><span class="istickedoff">-- ProofScript, and then either PosRepl or PosBuiltin for TopLevel?</span>
<span class="lineno"> 1989 </span><span class="spaces">    </span><span class="istickedoff">-- But we don't have a good way of knowing here whether we're</span>
<span class="lineno"> 1990 </span><span class="spaces">    </span><span class="istickedoff">-- actually in the repl.</span>
<span class="lineno"> 1991 </span><span class="spaces">    </span><span class="istickedoff">let pos = getPos stmt</span>
<span class="lineno"> 1992 </span><span class="spaces">        </span><span class="istickedoff">cname = case ctx of</span>
<span class="lineno"> 1993 </span><span class="spaces">            </span><span class="istickedoff">TopLevel -&gt; ContextName pos &quot;&lt;toplevel&gt;&quot;</span>
<span class="lineno"> 1994 </span><span class="spaces">            </span><span class="istickedoff">ProofScript -&gt; <span class="nottickedoff">ContextName pos &quot;&lt;proofscript&gt;&quot;</span></span>
<span class="lineno"> 1995 </span><span class="spaces">        </span><span class="istickedoff">ctxtype = TyCon pos (ContextCon ctx) []</span>
<span class="lineno"> 1996 </span><span class="spaces">    </span><span class="istickedoff">in</span>
<span class="lineno"> 1997 </span><span class="spaces">    </span><span class="istickedoff">evalTIWithEnv avail env tenv (inferSingleStmt cname pos ctxtype stmt)</span></span>
<span class="lineno"> 1998 </span>
<span class="lineno"> 1999 </span>-- | Check a single declaration. (This is an external interface.)
<span class="lineno"> 2000 </span>--
<span class="lineno"> 2001 </span>-- The first two arguments are the starting variable and typedef
<span class="lineno"> 2002 </span>-- environments to use.
<span class="lineno"> 2003 </span>checkDecl :: Set PrimitiveLifecycle -&gt; VarEnv -&gt; TyEnv -&gt; Decl -&gt; Result Decl
<span class="lineno"> 2004 </span><span class="decl"><span class="nottickedoff">checkDecl avail env tenv decl =</span>
<span class="lineno"> 2005 </span><span class="spaces">    </span><span class="nottickedoff">evalTIWithEnv avail env tenv (inferDecl ReadOnlyVar decl)</span></span>
<span class="lineno"> 2006 </span>
<span class="lineno"> 2007 </span>-- | Check a found type (first argument) against an expected type
<span class="lineno"> 2008 </span>--   (second argument) and return True if they can be unified.
<span class="lineno"> 2009 </span>--
<span class="lineno"> 2010 </span>--   Both types are schemes because that's what we need upstream.
<span class="lineno"> 2011 </span>--
<span class="lineno"> 2012 </span>--   (This is an external interface.)
<span class="lineno"> 2013 </span>typesMatch :: Set PrimitiveLifecycle -&gt; TyEnv -&gt; Schema -&gt; Schema -&gt; Bool
<span class="lineno"> 2014 </span><span class="decl"><span class="istickedoff">typesMatch avail tenv schema'found schema'expected =</span>
<span class="lineno"> 2015 </span><span class="spaces">  </span><span class="istickedoff">let unpack (Forall as ty) = do</span>
<span class="lineno"> 2016 </span><span class="spaces">        </span><span class="istickedoff">-- Generate unification vars for all the forall-bindings</span>
<span class="lineno"> 2017 </span><span class="spaces">        </span><span class="istickedoff">let generate (pos'a, a) = do</span>
<span class="lineno"> 2018 </span><span class="spaces">              </span><span class="istickedoff">ty'a &lt;- getFreshTyVar <span class="nottickedoff">pos'a</span></span>
<span class="lineno"> 2019 </span><span class="spaces">              </span><span class="istickedoff">return (a, (Current, ConcreteType ty'a))</span>
<span class="lineno"> 2020 </span><span class="spaces">        </span><span class="istickedoff">substs &lt;- mapM generate as</span>
<span class="lineno"> 2021 </span><span class="spaces">        </span><span class="istickedoff">-- Substitute them into the type</span>
<span class="lineno"> 2022 </span><span class="spaces">        </span><span class="istickedoff">let ty' = substituteTyVars' avail (Map.fromList substs) ty</span>
<span class="lineno"> 2023 </span><span class="spaces">        </span><span class="istickedoff">return ty'</span>
<span class="lineno"> 2024 </span><span class="spaces">      </span><span class="istickedoff">match = do</span>
<span class="lineno"> 2025 </span><span class="spaces">        </span><span class="istickedoff">-- Unpack the schemas and check if they match</span>
<span class="lineno"> 2026 </span><span class="spaces">        </span><span class="istickedoff">ty'found &lt;- unpack schema'found</span>
<span class="lineno"> 2027 </span><span class="spaces">        </span><span class="istickedoff">ty'expected &lt;- unpack schema'expected</span>
<span class="lineno"> 2028 </span><span class="spaces">        </span><span class="istickedoff">matches ty'found ty'expected</span>
<span class="lineno"> 2029 </span><span class="spaces">  </span><span class="istickedoff">in</span>
<span class="lineno"> 2030 </span><span class="spaces">  </span><span class="istickedoff">case evalTIWithEnv avail <span class="nottickedoff">ScopedMap.empty</span> tenv match of</span>
<span class="lineno"> 2031 </span><span class="spaces">    </span><span class="istickedoff">(Left _errors, _warnings) -&gt; <span class="nottickedoff">False</span>          -- not actually reachable</span>
<span class="lineno"> 2032 </span><span class="spaces">    </span><span class="istickedoff">(Right b, _warnings) -&gt; b</span></span>                   -- return match success/failure
<span class="lineno"> 2033 </span>
<span class="lineno"> 2034 </span>-- | Check a schema (type) as used when constructing the builtins
<span class="lineno"> 2035 </span>--   table. (This is an external interface.)
<span class="lineno"> 2036 </span>--
<span class="lineno"> 2037 </span>-- The first argument is the lifecycle context the type is being used
<span class="lineno"> 2038 </span>-- in. More on that below. The second is the typedef environment to
<span class="lineno"> 2039 </span>-- use. The third argument is the schema to check.
<span class="lineno"> 2040 </span>--
<span class="lineno"> 2041 </span>-- All types found should be of kind *.
<span class="lineno"> 2042 </span>--
<span class="lineno"> 2043 </span>-- Purely a validity check; there's no updates it can make to the
<span class="lineno"> 2044 </span>-- schema that are of use to the caller, on the assumption that the
<span class="lineno"> 2045 </span>-- caller doesn't want to do stuff with the schema before exiting on
<span class="lineno"> 2046 </span>-- errors, which it doesn't. Thus, just return unit and not an updated
<span class="lineno"> 2047 </span>-- schema.
<span class="lineno"> 2048 </span>--
<span class="lineno"> 2049 </span>-- (Otherwise we'd need to rerun `generalize` to build a new schema,
<span class="lineno"> 2050 </span>-- and that's a headache and not worthwhile given that the result
<span class="lineno"> 2051 </span>-- isn't going to be used.)
<span class="lineno"> 2052 </span>--
<span class="lineno"> 2053 </span>-- This is called for the types of objects that may themselves not be
<span class="lineno"> 2054 </span>-- visible, so rather than using the caller's set of visible lifecycle
<span class="lineno"> 2055 </span>-- states, construct the set based on the lifecycle state of the
<span class="lineno"> 2056 </span>-- declaration context. Deprecated objects can see equally or less
<span class="lineno"> 2057 </span>-- deprecated types; experimental objects can see experimental types;
<span class="lineno"> 2058 </span>-- everything can see current types.
<span class="lineno"> 2059 </span>--
<span class="lineno"> 2060 </span>checkSchema :: PrimitiveLifecycle -&gt; TyEnv -&gt; Schema -&gt; Result ()
<span class="lineno"> 2061 </span><span class="decl"><span class="istickedoff">checkSchema contextLC tyenv schema = do</span>
<span class="lineno"> 2062 </span><span class="spaces">  </span><span class="istickedoff">let check = do</span>
<span class="lineno"> 2063 </span><span class="spaces">        </span><span class="istickedoff">let Forall tyvars ty = schema</span>
<span class="lineno"> 2064 </span><span class="spaces">        </span><span class="istickedoff">-- Generate unification vars for all the forall-bindings</span>
<span class="lineno"> 2065 </span><span class="spaces">        </span><span class="istickedoff">let generate (pos'a, a) = do</span>
<span class="lineno"> 2066 </span><span class="spaces">              </span><span class="istickedoff">ty'a &lt;- getFreshTyVar <span class="nottickedoff">pos'a</span></span>
<span class="lineno"> 2067 </span><span class="spaces">              </span><span class="istickedoff">return (a, (Current, ConcreteType ty'a))</span>
<span class="lineno"> 2068 </span><span class="spaces">        </span><span class="istickedoff">substs &lt;- mapM generate tyvars</span>
<span class="lineno"> 2069 </span><span class="spaces">        </span><span class="istickedoff">-- Substitute them into the type</span>
<span class="lineno"> 2070 </span><span class="spaces">        </span><span class="istickedoff">let ty' = substituteTyVars' everythingAvailable (Map.fromList substs) ty</span>
<span class="lineno"> 2071 </span><span class="spaces">        </span><span class="istickedoff">-- The only way checking can return an updated type is if</span>
<span class="lineno"> 2072 </span><span class="spaces">        </span><span class="istickedoff">-- there's also an error, so discard the type</span>
<span class="lineno"> 2073 </span><span class="spaces">        </span><span class="istickedoff">_ &lt;- checkType kindStar ty'</span>
<span class="lineno"> 2074 </span><span class="spaces">        </span><span class="istickedoff">return ()</span>
<span class="lineno"> 2075 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2076 </span><span class="spaces">  </span><span class="istickedoff">let avail = Set.fromList $ case contextLC of</span>
<span class="lineno"> 2077 </span><span class="spaces">          </span><span class="istickedoff">Current -&gt; [Current]</span>
<span class="lineno"> 2078 </span><span class="spaces">          </span><span class="istickedoff">WarnDeprecated -&gt; [Current, WarnDeprecated]</span>
<span class="lineno"> 2079 </span><span class="spaces">          </span><span class="istickedoff">HideDeprecated -&gt; [Current, WarnDeprecated, HideDeprecated]</span>
<span class="lineno"> 2080 </span><span class="spaces">          </span><span class="istickedoff">Experimental -&gt; [Current, Experimental]</span>
<span class="lineno"> 2081 </span><span class="spaces">  </span><span class="istickedoff">evalTIWithEnv avail <span class="nottickedoff">ScopedMap.empty</span> tyenv check</span></span>
<span class="lineno"> 2082 </span>
<span class="lineno"> 2083 </span>-- | Check a schema (type) pattern as used by :search. (This is an
<span class="lineno"> 2084 </span>-- external interface.)
<span class="lineno"> 2085 </span>--
<span class="lineno"> 2086 </span>-- The first two arguments are the starting variable and typedef
<span class="lineno"> 2087 </span>-- environments to use. The third argument is the pattern.
<span class="lineno"> 2088 </span>--
<span class="lineno"> 2089 </span>-- Returns a possibly updated pattern.
<span class="lineno"> 2090 </span>--
<span class="lineno"> 2091 </span>checkSchemaPattern :: Set PrimitiveLifecycle -&gt; VarEnv -&gt; TyEnv -&gt; SchemaPattern -&gt; Result SchemaPattern
<span class="lineno"> 2092 </span><span class="decl"><span class="istickedoff">checkSchemaPattern _avail _env _tenv pat =</span>
<span class="lineno"> 2093 </span><span class="spaces">    </span><span class="istickedoff">-- For the time being, do nothing -- we specifically don't want it</span>
<span class="lineno"> 2094 </span><span class="spaces">    </span><span class="istickedoff">-- to reject unbound/free type variables (see Search.hs for a</span>
<span class="lineno"> 2095 </span><span class="spaces">    </span><span class="istickedoff">-- discussion of why) or underapplied type constructors, so the</span>
<span class="lineno"> 2096 </span><span class="spaces">    </span><span class="istickedoff">-- only check in checkType that makes sense to apply is the one</span>
<span class="lineno"> 2097 </span><span class="spaces">    </span><span class="istickedoff">-- for _overapplied_ type constructors, and that is (a) not</span>
<span class="lineno"> 2098 </span><span class="spaces">    </span><span class="istickedoff">-- critical (an overapplied type constructor will never match</span>
<span class="lineno"> 2099 </span><span class="spaces">    </span><span class="istickedoff">-- anything valid) and (b) as noted in checkType not currently</span>
<span class="lineno"> 2100 </span><span class="spaces">    </span><span class="istickedoff">-- actually reasonable because of limitations in the concrete</span>
<span class="lineno"> 2101 </span><span class="spaces">    </span><span class="istickedoff">-- syntax. Point (b) will probably change eventually, so we want</span>
<span class="lineno"> 2102 </span><span class="spaces">    </span><span class="istickedoff">-- to keep this hook and keep knowledge of its internals private</span>
<span class="lineno"> 2103 </span><span class="spaces">    </span><span class="istickedoff">-- here even though for now it's a nop.</span>
<span class="lineno"> 2104 </span><span class="spaces">    </span><span class="istickedoff">(Right pat, [])</span></span>
<span class="lineno"> 2105 </span>
<span class="lineno"> 2106 </span>
<span class="lineno"> 2107 </span>{-
<span class="lineno"> 2108 </span>Note [-Wincomplete-uni-patterns and irrefutable patterns]
<span class="lineno"> 2109 </span>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<span class="lineno"> 2110 </span>Various parts of SAW use irrefutable patterns in functions that assume that
<span class="lineno"> 2111 </span>their arguments have particular shapes. For example, inferDecl in this module
<span class="lineno"> 2112 </span>matches on ~[(e1,s)] with an irrefutable pattern because it assumes the
<span class="lineno"> 2113 </span>invariant that the list will have exactly one element. This lets inferDecl be
<span class="lineno"> 2114 </span>slightly lazier when evaluated.
<span class="lineno"> 2115 </span>
<span class="lineno"> 2116 </span>Unfortunately, this use of irrefutable patterns is at odds with the
<span class="lineno"> 2117 </span>-Wincomplete-uni-patterns warning. At present, -Wincomplete-uni-patterns will
<span class="lineno"> 2118 </span>produce a warning for any irrefutable pattern that does not cover all possible
<span class="lineno"> 2119 </span>data constructors. While we could rewrite functions like `inferDecl` to
<span class="lineno"> 2120 </span>explicitly provide a fall-through case, that would change its strictness
<span class="lineno"> 2121 </span>properties. As a result, we simply disable -Wincomplete-uni-patterns warnings
<span class="lineno"> 2122 </span>in each part of SAW that uses irrefutable patterns.
<span class="lineno"> 2123 </span>
<span class="lineno"> 2124 </span>Arguably, -Wincomplete-uni-patterns shouldn't be producing warnings for
<span class="lineno"> 2125 </span>irrefutable patterns at all. GHC issue #14800
<span class="lineno"> 2126 </span>(https://gitlab.haskell.org/ghc/ghc/-/issues/14800) proposes this idea.
<span class="lineno"> 2127 </span>If that issue is fixed in the future, we may want to reconsider whether we want
<span class="lineno"> 2128 </span>to disable -Wincomplete-uni-patterns.
<span class="lineno"> 2129 </span>-}

</pre>
</body>
</html>
