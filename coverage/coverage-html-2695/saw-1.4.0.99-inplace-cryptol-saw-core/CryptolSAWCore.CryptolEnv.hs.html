<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- |
<span class="lineno">    2 </span>Module      : CryptolSAWCore.CryptolEnv
<span class="lineno">    3 </span>Description : Context for interpreting Cryptol within SAW-Script.
<span class="lineno">    4 </span>License     : BSD3
<span class="lineno">    5 </span>Maintainer  : huffman
<span class="lineno">    6 </span>Stability   : provisional
<span class="lineno">    7 </span>-}
<span class="lineno">    8 </span>{-# LANGUAGE CPP #-}
<span class="lineno">    9 </span>{-# LANGUAGE ImplicitParams #-}
<span class="lineno">   10 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">   11 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">   12 </span>
<span class="lineno">   13 </span>module CryptolSAWCore.CryptolEnv
<span class="lineno">   14 </span>  ( ImportVisibility(..)
<span class="lineno">   15 </span>  , CryptolEnv(..)
<span class="lineno">   16 </span>  , initCryptolEnv
<span class="lineno">   17 </span>  , loadCryptolModule
<span class="lineno">   18 </span>  , bindCryptolModule
<span class="lineno">   19 </span>  , extractDefFromCryptolModule
<span class="lineno">   20 </span>  , combineCryptolEnv
<span class="lineno">   21 </span>  , importModule
<span class="lineno">   22 </span>  , bindTypedTerm
<span class="lineno">   23 </span>  , bindType
<span class="lineno">   24 </span>  , bindInteger
<span class="lineno">   25 </span>  , parseTypedTerm
<span class="lineno">   26 </span>  , pExprToTypedTerm
<span class="lineno">   27 </span>  , parseDecls
<span class="lineno">   28 </span>  , parseSchema
<span class="lineno">   29 </span>  , declareName
<span class="lineno">   30 </span>  , typeNoUser
<span class="lineno">   31 </span>  , schemaNoUser
<span class="lineno">   32 </span>  , translateExpr
<span class="lineno">   33 </span>  , getNamingEnv
<span class="lineno">   34 </span>  , getAllIfaceDecls
<span class="lineno">   35 </span>  , InputText(..)
<span class="lineno">   36 </span>  , lookupIn
<span class="lineno">   37 </span>  , resolveIdentifier
<span class="lineno">   38 </span>  , meSolverConfig
<span class="lineno">   39 </span>  , mkCryEnv
<span class="lineno">   40 </span>  , C.ImportPrimitiveOptions(..)
<span class="lineno">   41 </span>  , C.defaultPrimitiveOptions
<span class="lineno">   42 </span>  )
<span class="lineno">   43 </span>  where
<span class="lineno">   44 </span>
<span class="lineno">   45 </span>--import qualified Control.Exception as X
<span class="lineno">   46 </span>import Data.ByteString (ByteString)
<span class="lineno">   47 </span>import qualified Data.Text as Text
<span class="lineno">   48 </span>import Data.Map (Map)
<span class="lineno">   49 </span>import qualified Data.Map as Map
<span class="lineno">   50 </span>import qualified Data.Set as Set
<span class="lineno">   51 </span>import Data.Maybe (fromMaybe)
<span class="lineno">   52 </span>import Data.Text (Text, pack, splitOn)
<span class="lineno">   53 </span>import Control.Monad(when)
<span class="lineno">   54 </span>import GHC.Stack
<span class="lineno">   55 </span>
<span class="lineno">   56 </span>import System.Environment (lookupEnv)
<span class="lineno">   57 </span>import System.Environment.Executable (splitExecutablePath)
<span class="lineno">   58 </span>import System.FilePath ((&lt;/&gt;), normalise, joinPath, splitPath, splitSearchPath)
<span class="lineno">   59 </span>
<span class="lineno">   60 </span>import CryptolSAWCore.Panic
<span class="lineno">   61 </span>import SAWCore.Name (nameInfo)
<span class="lineno">   62 </span>import SAWCore.Recognizer (asConstant)
<span class="lineno">   63 </span>import SAWCore.SharedTerm (NameInfo, SharedContext, Term)
<span class="lineno">   64 </span>import SAWCore.Term.Pretty (showTerm)
<span class="lineno">   65 </span>
<span class="lineno">   66 </span>import qualified CryptolSAWCore.Cryptol as C
<span class="lineno">   67 </span>
<span class="lineno">   68 </span>import qualified Cryptol.Eval as E
<span class="lineno">   69 </span>import qualified Cryptol.Parser as P
<span class="lineno">   70 </span>import qualified Cryptol.Parser.AST as P
<span class="lineno">   71 </span>import qualified Cryptol.Parser.Position as P
<span class="lineno">   72 </span>import qualified Cryptol.TypeCheck as T
<span class="lineno">   73 </span>import qualified Cryptol.TypeCheck.AST as T
<span class="lineno">   74 </span>import qualified Cryptol.TypeCheck.Error as TE
<span class="lineno">   75 </span>import qualified Cryptol.TypeCheck.Infer as TI
<span class="lineno">   76 </span>import qualified Cryptol.TypeCheck.Kind as TK
<span class="lineno">   77 </span>import qualified Cryptol.TypeCheck.Monad as TM
<span class="lineno">   78 </span>import qualified Cryptol.TypeCheck.Interface as TIface
<span class="lineno">   79 </span>import qualified Cryptol.TypeCheck.Solver.SMT as SMT
<span class="lineno">   80 </span>--import qualified Cryptol.TypeCheck.PP as TP
<span class="lineno">   81 </span>
<span class="lineno">   82 </span>import qualified Cryptol.ModuleSystem as M
<span class="lineno">   83 </span>import qualified Cryptol.ModuleSystem.Base as MB
<span class="lineno">   84 </span>import qualified Cryptol.ModuleSystem.Env as ME
<span class="lineno">   85 </span>import qualified Cryptol.ModuleSystem.Exports as MEx
<span class="lineno">   86 </span>import qualified Cryptol.ModuleSystem.Interface as MI
<span class="lineno">   87 </span>import qualified Cryptol.ModuleSystem.Monad as MM
<span class="lineno">   88 </span>import qualified Cryptol.ModuleSystem.NamingEnv as MN
<span class="lineno">   89 </span>import qualified Cryptol.ModuleSystem.Name as MN
<span class="lineno">   90 </span>import qualified Cryptol.ModuleSystem.Renamer as MR
<span class="lineno">   91 </span>
<span class="lineno">   92 </span>import qualified Cryptol.Utils.Ident as C
<span class="lineno">   93 </span>
<span class="lineno">   94 </span>import Cryptol.Utils.PP hiding ((&lt;/&gt;))
<span class="lineno">   95 </span>import Cryptol.Utils.Ident (Ident, preludeName, arrayName, preludeReferenceName
<span class="lineno">   96 </span>                           , mkIdent, interactiveName, identText
<span class="lineno">   97 </span>                           , textToModName
<span class="lineno">   98 </span>                           , prelPrim)
<span class="lineno">   99 </span>import Cryptol.Utils.Logger (quietLogger)
<span class="lineno">  100 </span>
<span class="lineno">  101 </span>--import SAWScript.REPL.Monad (REPLException(..))
<span class="lineno">  102 </span>import CryptolSAWCore.TypedTerm
<span class="lineno">  103 </span>import Cryptol.ModuleSystem.Env (ModContextParams(NoParams))
<span class="lineno">  104 </span>-- import SAWCentral.AST (Located(getVal, locatedPos), Import(..))
<span class="lineno">  105 </span>
<span class="lineno">  106 </span>-- | Parse input, together with information about where it came from.
<span class="lineno">  107 </span>data InputText = InputText
<span class="lineno">  108 </span>  { <span class="istickedoff"><span class="decl"><span class="istickedoff">inpText</span></span></span> :: Text   -- ^ Parse this
<span class="lineno">  109 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">inpFile</span></span></span> :: String -- ^ It came from this file (or thing)
<span class="lineno">  110 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">inpLine</span></span></span> :: Int    -- ^ On this line number
<span class="lineno">  111 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">inpCol</span></span></span>  :: Int    -- ^ On this column number
<span class="lineno">  112 </span>  }
<span class="lineno">  113 </span>
<span class="lineno">  114 </span>
<span class="lineno">  115 </span>
<span class="lineno">  116 </span>--------------------------------------------------------------------------------
<span class="lineno">  117 </span>
<span class="lineno">  118 </span>-- | 'ImportVisibility' - Should a given import (see 'importModule')
<span class="lineno">  119 </span>-- result in all symbols being visible (as they are for focused
<span class="lineno">  120 </span>-- modules in the Cryptol REPL) or only public symbols?  Making all
<span class="lineno">  121 </span>-- symbols visible is useful for verification and code generation.
<span class="lineno">  122 </span>--
<span class="lineno">  123 </span>-- NOTE: this notion of public vs. private symbols is specific to
<span class="lineno">  124 </span>-- SAWScript and distinct from Cryptol's notion of private
<span class="lineno">  125 </span>-- definitions.
<span class="lineno">  126 </span>--
<span class="lineno">  127 </span>data ImportVisibility
<span class="lineno">  128 </span>  = OnlyPublic       -- ^ behaves like a normal Cryptol &quot;import&quot;
<span class="lineno">  129 </span>  | PublicAndPrivate -- ^ allows viewing of both &quot;private&quot; sections and (arbitrarily nested) submodules.
<span class="lineno">  130 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  131 </span>
<span class="lineno">  132 </span>
<span class="lineno">  133 </span>-- | The environment for capturing the Cryptol interpreter state as well as the
<span class="lineno">  134 </span>--   SAWCore translations and associated state.
<span class="lineno">  135 </span>--
<span class="lineno">  136 </span>data CryptolEnv = CryptolEnv
<span class="lineno">  137 </span>  { <span class="istickedoff"><span class="decl"><span class="istickedoff">eImports</span></span></span>    :: [(ImportVisibility, P.Import)]
<span class="lineno">  138 </span>                                        -- ^ Declarations of imported Cryptol modules
<span class="lineno">  139 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">eModuleEnv</span></span></span>  :: ME.ModuleEnv         -- ^ Imported modules, and state for the ModuleM monad
<span class="lineno">  140 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">eExtraNames</span></span></span> :: MR.NamingEnv         -- ^ Context for the Cryptol renamer
<span class="lineno">  141 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">eExtraTypes</span></span></span> :: Map T.Name T.Schema  -- ^ Cryptol types for extra names in scope
<span class="lineno">  142 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">eExtraTSyns</span></span></span> :: Map T.Name T.TySyn   -- ^ Extra Cryptol type synonyms in scope
<span class="lineno">  143 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">eTermEnv</span></span></span>    :: Map T.Name Term      -- ^ SAWCore terms for *all* names in scope
<span class="lineno">  144 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">ePrims</span></span></span>      :: Map C.PrimIdent Term -- ^ SAWCore terms for primitives
<span class="lineno">  145 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">ePrimTypes</span></span></span>  :: Map C.PrimIdent Term -- ^ SAWCore terms for primitive type names
<span class="lineno">  146 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">eFFITypes</span></span></span>   :: Map NameInfo T.FFI
<span class="lineno">  147 </span>    -- ^ FFI info for SAWCore names of Cryptol foreign functions
<span class="lineno">  148 </span>  }
<span class="lineno">  149 </span>
<span class="lineno">  150 </span>
<span class="lineno">  151 </span>-- Finding things --------------------------------------------------------------
<span class="lineno">  152 </span>
<span class="lineno">  153 </span>
<span class="lineno">  154 </span>-- | Lookup a name in a map containg Cryptol names.
<span class="lineno">  155 </span>-- The string corresponds to the Cryptol name we are looking for.
<span class="lineno">  156 </span>-- If it is unqualifed, then we return any entry associated with the given
<span class="lineno">  157 </span>-- name.  If the string is qualified (i.e., has @::@), then we only consider
<span class="lineno">  158 </span>-- entries from the module in the qualified.
<span class="lineno">  159 </span>-- The result is either the corresponding value, or a list of the
<span class="lineno">  160 </span>lookupIn :: Text -&gt; Map T.Name b -&gt; Either [T.Name] b
<span class="lineno">  161 </span><span class="decl"><span class="nottickedoff">lookupIn nm mp =</span>
<span class="lineno">  162 </span><span class="spaces">  </span><span class="nottickedoff">case [ x | x &lt;- Map.toList mp, matches (fst x) ] of</span>
<span class="lineno">  163 </span><span class="spaces">    </span><span class="nottickedoff">[ (_,v) ] -&gt; Right v</span>
<span class="lineno">  164 </span><span class="spaces">    </span><span class="nottickedoff">opts      -&gt; Left (map fst opts)</span>
<span class="lineno">  165 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  166 </span><span class="spaces">  </span><span class="nottickedoff">matches = nameMatcher nm</span></span>
<span class="lineno">  167 </span>
<span class="lineno">  168 </span>
<span class="lineno">  169 </span>-- | Parse a string into a function that will match names.
<span class="lineno">  170 </span>-- If the string is unqualified (i.e., no `::`), then we match all
<span class="lineno">  171 </span>-- names with the given identifier.  Otherwise, we only match the
<span class="lineno">  172 </span>-- ones in the module specified by the qualifier.
<span class="lineno">  173 </span>nameMatcher :: Text -&gt; T.Name -&gt; Bool
<span class="lineno">  174 </span><span class="decl"><span class="nottickedoff">nameMatcher xs =</span>
<span class="lineno">  175 </span><span class="spaces">    </span><span class="nottickedoff">case C.modNameChunksText (textToModName xs) of</span>
<span class="lineno">  176 </span><span class="spaces">      </span><span class="nottickedoff">[]  -&gt; const False</span>
<span class="lineno">  177 </span><span class="spaces">      </span><span class="nottickedoff">[x] -&gt; (x ==) . C.identText . MN.nameIdent</span>
<span class="lineno">  178 </span><span class="spaces">      </span><span class="nottickedoff">cs  -&gt; \n -&gt;</span>
<span class="lineno">  179 </span><span class="spaces">                </span><span class="nottickedoff">case MN.nameInfo n of</span>
<span class="lineno">  180 </span><span class="spaces">                  </span><span class="nottickedoff">MN.LocalName {} -&gt; False</span>
<span class="lineno">  181 </span><span class="spaces">                  </span><span class="nottickedoff">MN.GlobalName _ og -&gt;</span>
<span class="lineno">  182 </span><span class="spaces">                    </span><span class="nottickedoff">let (top,ns) = C.modPathSplit (C.ogModule og)</span>
<span class="lineno">  183 </span><span class="spaces">                    </span><span class="nottickedoff">in last cs == identText (C.ogName og) &amp;&amp;</span>
<span class="lineno">  184 </span><span class="spaces">                       </span><span class="nottickedoff">init cs == C.modNameChunksText top ++ map identText ns</span></span>
<span class="lineno">  185 </span>
<span class="lineno">  186 </span>-- Initialize ------------------------------------------------------------------
<span class="lineno">  187 </span>
<span class="lineno">  188 </span>-- | initCryptolEnv - Create initial CryptolEnv, this involves loading
<span class="lineno">  189 </span>--   the built-in modules (preludeName, arrayName,
<span class="lineno">  190 </span>--   preludeReferenceName) and translating them into SAWCore, and
<span class="lineno">  191 </span>--   putting them into scope.
<span class="lineno">  192 </span>--
<span class="lineno">  193 </span>--   NOTE: submodules in these built-in modules are supported in this code.
<span class="lineno">  194 </span>--
<span class="lineno">  195 </span>initCryptolEnv ::
<span class="lineno">  196 </span>  (?fileReader :: FilePath -&gt; IO ByteString) =&gt;
<span class="lineno">  197 </span>  SharedContext -&gt; IO CryptolEnv
<span class="lineno">  198 </span><span class="decl"><span class="istickedoff">initCryptolEnv sc = do</span>
<span class="lineno">  199 </span><span class="spaces">  </span><span class="istickedoff">modEnv0 &lt;- M.initialModuleEnv</span>
<span class="lineno">  200 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  201 </span><span class="spaces">  </span><span class="istickedoff">-- Set the Cryptol include path (TODO: we may want to do this differently)</span>
<span class="lineno">  202 </span><span class="spaces">  </span><span class="istickedoff">(binDir, _) &lt;- splitExecutablePath</span>
<span class="lineno">  203 </span><span class="spaces">  </span><span class="istickedoff">let instDir = normalise . joinPath . init . splitPath $ binDir</span>
<span class="lineno">  204 </span><span class="spaces">  </span><span class="istickedoff">mCryptolPath &lt;- lookupEnv &quot;CRYPTOLPATH&quot;</span>
<span class="lineno">  205 </span><span class="spaces">  </span><span class="istickedoff">let cryptolPaths =</span>
<span class="lineno">  206 </span><span class="spaces">        </span><span class="istickedoff">case mCryptolPath of</span>
<span class="lineno">  207 </span><span class="spaces">          </span><span class="istickedoff">Nothing -&gt; []</span>
<span class="lineno">  208 </span><span class="spaces">          </span><span class="istickedoff">Just path -&gt;</span>
<span class="lineno">  209 </span><span class="spaces"></span><span class="istickedoff">#if defined(mingw32_HOST_OS) || defined(__MINGW32__)</span>
<span class="lineno">  210 </span><span class="spaces">            </span><span class="istickedoff">-- Windows paths search from end to beginning</span>
<span class="lineno">  211 </span><span class="spaces">            </span><span class="istickedoff">reverse (splitSearchPath path)</span>
<span class="lineno">  212 </span><span class="spaces"></span><span class="istickedoff">#else</span>
<span class="lineno">  213 </span><span class="spaces">            </span><span class="istickedoff">splitSearchPath path</span>
<span class="lineno">  214 </span><span class="spaces"></span><span class="istickedoff">#endif</span>
<span class="lineno">  215 </span><span class="spaces">  </span><span class="istickedoff">let modEnv1 = modEnv0 { ME.meSearchPath = cryptolPaths ++</span>
<span class="lineno">  216 </span><span class="spaces">                           </span><span class="istickedoff">(instDir &lt;/&gt; &quot;lib&quot;) : ME.meSearchPath modEnv0 }</span>
<span class="lineno">  217 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  218 </span><span class="spaces">  </span><span class="istickedoff">-- Load Cryptol prelude and magic Array module</span>
<span class="lineno">  219 </span><span class="spaces">  </span><span class="istickedoff">(_, modEnv2) &lt;-</span>
<span class="lineno">  220 </span><span class="spaces">    </span><span class="istickedoff">liftModuleM modEnv1 $</span>
<span class="lineno">  221 </span><span class="spaces">      </span><span class="istickedoff">do _ &lt;- MB.loadModuleFrom False (MM.FromModule preludeName)</span>
<span class="lineno">  222 </span><span class="spaces">         </span><span class="istickedoff">_ &lt;- MB.loadModuleFrom False (MM.FromModule arrayName)</span>
<span class="lineno">  223 </span><span class="spaces">         </span><span class="istickedoff">return <span class="nottickedoff">()</span></span>
<span class="lineno">  224 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  225 </span><span class="spaces">  </span><span class="istickedoff">-- Load Cryptol reference implementations</span>
<span class="lineno">  226 </span><span class="spaces">  </span><span class="istickedoff">((_,refTop), modEnv3) &lt;-</span>
<span class="lineno">  227 </span><span class="spaces">    </span><span class="istickedoff">liftModuleM modEnv2 $</span>
<span class="lineno">  228 </span><span class="spaces">      </span><span class="istickedoff">MB.loadModuleFrom False (MM.FromModule preludeReferenceName)</span>
<span class="lineno">  229 </span><span class="spaces">  </span><span class="istickedoff">let refMod = T.tcTopEntityToModule refTop</span>
<span class="lineno">  230 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  231 </span><span class="spaces">  </span><span class="istickedoff">-- Set up reference implementation redirections</span>
<span class="lineno">  232 </span><span class="spaces">  </span><span class="istickedoff">let refDecls = T.mDecls refMod</span>
<span class="lineno">  233 </span><span class="spaces">  </span><span class="istickedoff">let nms = Set.toList (MI.ifsPublic (TIface.genIfaceNames refMod))</span>
<span class="lineno">  234 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  235 </span><span class="spaces">  </span><span class="istickedoff">let refPrims = Map.fromList</span>
<span class="lineno">  236 </span><span class="spaces">                  </span><span class="istickedoff">[ (prelPrim (identText (MN.nameIdent nm)), T.EWhere (T.EVar nm) refDecls)</span>
<span class="lineno">  237 </span><span class="spaces">                  </span><span class="istickedoff">| nm &lt;- nms ]</span>
<span class="lineno">  238 </span><span class="spaces">  </span><span class="istickedoff">let cryEnv0 = C.emptyEnv{ C.envRefPrims = refPrims }</span>
<span class="lineno">  239 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  240 </span><span class="spaces">  </span><span class="istickedoff">-- Generate SAWCore translations for all values in scope</span>
<span class="lineno">  241 </span><span class="spaces">  </span><span class="istickedoff">termEnv &lt;- genTermEnv sc modEnv3 cryEnv0</span>
<span class="lineno">  242 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  243 </span><span class="spaces">  </span><span class="istickedoff">-- The module names in P.Import are now Located, so give them an empty position.</span>
<span class="lineno">  244 </span><span class="spaces">  </span><span class="istickedoff">let preludeName' = P.Located P.emptyRange preludeName</span>
<span class="lineno">  245 </span><span class="spaces">      </span><span class="istickedoff">preludeReferenceName' = P.Located P.emptyRange preludeReferenceName</span>
<span class="lineno">  246 </span><span class="spaces">      </span><span class="istickedoff">arrayName' = P.Located P.emptyRange arrayName</span>
<span class="lineno">  247 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  248 </span><span class="spaces">  </span><span class="istickedoff">return CryptolEnv</span>
<span class="lineno">  249 </span><span class="spaces">    </span><span class="istickedoff">{ eImports    = [ (OnlyPublic, P.Import preludeName' Nothing Nothing Nothing <span class="nottickedoff">Nothing</span>)</span>
<span class="lineno">  250 </span><span class="spaces">                    </span><span class="istickedoff">, (OnlyPublic, P.Import preludeReferenceName' (Just preludeReferenceName) Nothing Nothing <span class="nottickedoff">Nothing</span>)</span>
<span class="lineno">  251 </span><span class="spaces">                    </span><span class="istickedoff">, (OnlyPublic, P.Import arrayName' Nothing Nothing Nothing <span class="nottickedoff">Nothing</span>)</span>
<span class="lineno">  252 </span><span class="spaces">                    </span><span class="istickedoff">]</span>
<span class="lineno">  253 </span><span class="spaces">    </span><span class="istickedoff">, eModuleEnv  = modEnv3</span>
<span class="lineno">  254 </span><span class="spaces">    </span><span class="istickedoff">, eExtraNames = mempty</span>
<span class="lineno">  255 </span><span class="spaces">    </span><span class="istickedoff">, eExtraTypes = Map.empty</span>
<span class="lineno">  256 </span><span class="spaces">    </span><span class="istickedoff">, eExtraTSyns = Map.empty</span>
<span class="lineno">  257 </span><span class="spaces">    </span><span class="istickedoff">, eTermEnv    = termEnv</span>
<span class="lineno">  258 </span><span class="spaces">    </span><span class="istickedoff">, ePrims      = <span class="nottickedoff">Map.empty</span></span>
<span class="lineno">  259 </span><span class="spaces">    </span><span class="istickedoff">, ePrimTypes  = <span class="nottickedoff">Map.empty</span></span>
<span class="lineno">  260 </span><span class="spaces">    </span><span class="istickedoff">, eFFITypes   = Map.empty</span>
<span class="lineno">  261 </span><span class="spaces">    </span><span class="istickedoff">}</span></span>
<span class="lineno">  262 </span>
<span class="lineno">  263 </span>-- | Translate all declarations in all loaded modules to SAWCore terms
<span class="lineno">  264 </span>--   NOTE: used only for initialization code.
<span class="lineno">  265 </span>
<span class="lineno">  266 </span>genTermEnv :: SharedContext -&gt; ME.ModuleEnv -&gt; C.Env -&gt; IO (Map T.Name Term)
<span class="lineno">  267 </span><span class="decl"><span class="istickedoff">genTermEnv sc modEnv cryEnv0 = do</span>
<span class="lineno">  268 </span><span class="spaces">  </span><span class="istickedoff">let declGroups = concatMap T.mDecls</span>
<span class="lineno">  269 </span><span class="spaces">                 </span><span class="istickedoff">$ filter (not . T.isParametrizedModule)</span>
<span class="lineno">  270 </span><span class="spaces">                 </span><span class="istickedoff">$ ME.loadedModules modEnv</span>
<span class="lineno">  271 </span><span class="spaces">      </span><span class="istickedoff">nominals   = loadedNonParamNominalTypes modEnv</span>
<span class="lineno">  272 </span><span class="spaces">  </span><span class="istickedoff">cryEnv1 &lt;- C.genCodeForNominalTypes sc nominals cryEnv0</span>
<span class="lineno">  273 </span><span class="spaces">  </span><span class="istickedoff">cryEnv2 &lt;- C.importTopLevelDeclGroups sc <span class="nottickedoff">C.defaultPrimitiveOptions</span> cryEnv1 declGroups</span>
<span class="lineno">  274 </span><span class="spaces">  </span><span class="istickedoff">return (C.envE cryEnv2)</span></span>
<span class="lineno">  275 </span>
<span class="lineno">  276 </span>
<span class="lineno">  277 </span>-- Parse -----------------------------------------------------------------------
<span class="lineno">  278 </span>
<span class="lineno">  279 </span>ioParseExpr :: InputText -&gt; IO (P.Expr P.PName)
<span class="lineno">  280 </span><span class="decl"><span class="istickedoff">ioParseExpr = ioParseGeneric P.parseExprWith</span></span>
<span class="lineno">  281 </span>
<span class="lineno">  282 </span>ioParseDecls :: InputText -&gt; IO [P.Decl P.PName]
<span class="lineno">  283 </span><span class="decl"><span class="istickedoff">ioParseDecls = ioParseGeneric P.parseDeclsWith</span></span>
<span class="lineno">  284 </span>
<span class="lineno">  285 </span>ioParseSchema :: InputText -&gt; IO (P.Schema P.PName)
<span class="lineno">  286 </span><span class="decl"><span class="istickedoff">ioParseSchema = ioParseGeneric P.parseSchemaWith</span></span>
<span class="lineno">  287 </span>
<span class="lineno">  288 </span>ioParseGeneric ::
<span class="lineno">  289 </span>  (P.Config -&gt; Text -&gt; Either P.ParseError a) -&gt; InputText -&gt; IO a
<span class="lineno">  290 </span><span class="decl"><span class="istickedoff">ioParseGeneric parse inp = ioParseResult (parse cfg str)</span>
<span class="lineno">  291 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  292 </span><span class="spaces">  </span><span class="istickedoff">cfg = P.defaultConfig { P.cfgSource = inpFile inp }</span>
<span class="lineno">  293 </span><span class="spaces">  </span><span class="istickedoff">-- XXX this is kind of gross; maybe sometime we get a second parser</span>
<span class="lineno">  294 </span><span class="spaces">  </span><span class="istickedoff">-- entry point that takes a start position... (this is saw-script #2175)</span>
<span class="lineno">  295 </span><span class="spaces">  </span><span class="istickedoff">str = Text.concat [ Text.replicate (inpLine inp - 1) &quot;\n&quot;</span>
<span class="lineno">  296 </span><span class="spaces">                    </span><span class="istickedoff">, Text.replicate (inpCol inp - 1) &quot; &quot;</span>
<span class="lineno">  297 </span><span class="spaces">                    </span><span class="istickedoff">, inpText inp ]</span></span>
<span class="lineno">  298 </span>
<span class="lineno">  299 </span>ioParseResult :: Either P.ParseError a -&gt; IO a
<span class="lineno">  300 </span><span class="decl"><span class="istickedoff">ioParseResult res = case res of</span>
<span class="lineno">  301 </span><span class="spaces">  </span><span class="istickedoff">Right a -&gt; return a</span>
<span class="lineno">  302 </span><span class="spaces">  </span><span class="istickedoff">Left e  -&gt; <span class="nottickedoff">fail $ &quot;Cryptol parse error:\n&quot; ++ show (P.ppError e)</span></span></span> -- X.throwIO (ParseError e)
<span class="lineno">  303 </span>
<span class="lineno">  304 </span>
<span class="lineno">  305 </span>-- NamingEnv and Related -------------------------------------------------------
<span class="lineno">  306 </span>
<span class="lineno">  307 </span>-- | @'getNamingEnv' env@ - get the full 'MR.NamingEnv' based on all the 'eImports'
<span class="lineno">  308 </span>
<span class="lineno">  309 </span>getNamingEnv :: CryptolEnv -&gt; MR.NamingEnv
<span class="lineno">  310 </span><span class="decl"><span class="istickedoff">getNamingEnv env =</span>
<span class="lineno">  311 </span><span class="spaces">  </span><span class="istickedoff">eExtraNames env</span>
<span class="lineno">  312 </span><span class="spaces">  </span><span class="istickedoff">`MR.shadowing`</span>
<span class="lineno">  313 </span><span class="spaces">  </span><span class="istickedoff">(mconcat $ map</span>
<span class="lineno">  314 </span><span class="spaces">               </span><span class="istickedoff">(importToNamingEnv (eModuleEnv env))</span>
<span class="lineno">  315 </span><span class="spaces">               </span><span class="istickedoff">(eImports env)</span>
<span class="lineno">  316 </span><span class="spaces">  </span><span class="istickedoff">)</span></span>
<span class="lineno">  317 </span>
<span class="lineno">  318 </span>importToNamingEnv :: ME.ModuleEnv
<span class="lineno">  319 </span>                  -&gt; (ImportVisibility, T.Import)
<span class="lineno">  320 </span>                  -&gt; MR.NamingEnv
<span class="lineno">  321 </span><span class="decl"><span class="istickedoff">importToNamingEnv modEnv (vis,imprt) =</span>
<span class="lineno">  322 </span><span class="spaces">    </span><span class="istickedoff">MN.interpImportEnv imprt -- adjust for qualified imports</span>
<span class="lineno">  323 </span><span class="spaces">  </span><span class="istickedoff">$ adjustVisible            -- adjust if OnlyPublic names</span>
<span class="lineno">  324 </span><span class="spaces">  </span><span class="istickedoff">$ ME.mctxNames mctx        -- namingEnv for PublicAndPrivate</span>
<span class="lineno">  325 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  326 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  327 </span><span class="spaces">  </span><span class="istickedoff">mctx = modContextOf' (P.ImpTop $ P.thing $ T.iModule imprt)</span>
<span class="lineno">  328 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  329 </span><span class="spaces">  </span><span class="istickedoff">adjustVisible = case vis of</span>
<span class="lineno">  330 </span><span class="spaces">    </span><span class="istickedoff">PublicAndPrivate -&gt; id</span>
<span class="lineno">  331 </span><span class="spaces">    </span><span class="istickedoff">OnlyPublic       -&gt;</span>
<span class="lineno">  332 </span><span class="spaces">      </span><span class="istickedoff">\env' -&gt; MN.filterUNames (`Set.member` ME.mctxExported mctx) env'</span>
<span class="lineno">  333 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  334 </span><span class="spaces">  </span><span class="istickedoff">modContextOf' fm =</span>
<span class="lineno">  335 </span><span class="spaces">    </span><span class="istickedoff">case ME.modContextOf fm modEnv of</span>
<span class="lineno">  336 </span><span class="spaces">      </span><span class="istickedoff">Just c  -&gt; c</span>
<span class="lineno">  337 </span><span class="spaces">      </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">panic &quot;getNamingEnv&quot;</span></span>
<span class="lineno">  338 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">[&quot;expecting module to be loaded: &quot;</span></span>
<span class="lineno">  339 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">&lt;&gt; Text.pack (show (pp fm))]</span></span></span>
<span class="lineno">  340 </span>
<span class="lineno">  341 </span>
<span class="lineno">  342 </span>getAllIfaceDecls :: ME.ModuleEnv -&gt; M.IfaceDecls
<span class="lineno">  343 </span><span class="decl"><span class="istickedoff">getAllIfaceDecls me =</span>
<span class="lineno">  344 </span><span class="spaces">  </span><span class="istickedoff">mconcat</span>
<span class="lineno">  345 </span><span class="spaces">    </span><span class="istickedoff">(map (MI.ifDefines . ME.lmInterface)</span>
<span class="lineno">  346 </span><span class="spaces">         </span><span class="istickedoff">(ME.getLoadedModules (ME.meLoadedModules me)))</span></span>
<span class="lineno">  347 </span>
<span class="lineno">  348 </span>-- | Like Cryptol's 'ME.loadedNominalTypes', except that it only returns
<span class="lineno">  349 </span>-- nominal types from non-parameterized modules, which are currently the only
<span class="lineno">  350 </span>-- types of modules that SAW can import.
<span class="lineno">  351 </span>loadedNonParamNominalTypes :: ME.ModuleEnv -&gt; Map MN.Name T.NominalType
<span class="lineno">  352 </span><span class="decl"><span class="istickedoff">loadedNonParamNominalTypes menv =</span>
<span class="lineno">  353 </span><span class="spaces">  </span><span class="istickedoff">Map.unions $</span>
<span class="lineno">  354 </span><span class="spaces">    </span><span class="istickedoff">map (MI.ifNominalTypes . MI.ifDefines . ME.lmInterface)</span>
<span class="lineno">  355 </span><span class="spaces">        </span><span class="istickedoff">(ME.lmLoadedModules (ME.meLoadedModules menv))</span></span>
<span class="lineno">  356 </span>
<span class="lineno">  357 </span>-- Typecheck -------------------------------------------------------------------
<span class="lineno">  358 </span>
<span class="lineno">  359 </span>runInferOutput :: TM.InferOutput a -&gt; MM.ModuleM a
<span class="lineno">  360 </span><span class="decl"><span class="istickedoff">runInferOutput out =</span>
<span class="lineno">  361 </span><span class="spaces">  </span><span class="istickedoff">case out of</span>
<span class="lineno">  362 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  363 </span><span class="spaces">    </span><span class="istickedoff">TM.InferOK nm warns seeds supply o -&gt;</span>
<span class="lineno">  364 </span><span class="spaces">      </span><span class="istickedoff">do MM.setNameSeeds seeds</span>
<span class="lineno">  365 </span><span class="spaces">         </span><span class="istickedoff">MM.setSupply supply</span>
<span class="lineno">  366 </span><span class="spaces">         </span><span class="istickedoff">MM.typeCheckWarnings <span class="nottickedoff">nm</span> warns</span>
<span class="lineno">  367 </span><span class="spaces">         </span><span class="istickedoff">return o</span>
<span class="lineno">  368 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  369 </span><span class="spaces">    </span><span class="istickedoff">TM.InferFailed nm warns errs -&gt;</span>
<span class="lineno">  370 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">do MM.typeCheckWarnings nm warns</span></span>
<span class="lineno">  371 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">MM.typeCheckingFailed nm errs</span></span></span>
<span class="lineno">  372 </span>
<span class="lineno">  373 </span>-- Translate -------------------------------------------------------------------
<span class="lineno">  374 </span>
<span class="lineno">  375 </span>mkCryEnv ::
<span class="lineno">  376 </span>  (?fileReader :: FilePath -&gt; IO ByteString) =&gt;
<span class="lineno">  377 </span>  CryptolEnv -&gt; IO C.Env
<span class="lineno">  378 </span><span class="decl"><span class="istickedoff">mkCryEnv env =</span>
<span class="lineno">  379 </span><span class="spaces">  </span><span class="istickedoff">do let modEnv = eModuleEnv env</span>
<span class="lineno">  380 </span><span class="spaces">     </span><span class="istickedoff">let ifaceDecls = getAllIfaceDecls modEnv</span>
<span class="lineno">  381 </span><span class="spaces">     </span><span class="istickedoff">(types, _) &lt;-</span>
<span class="lineno">  382 </span><span class="spaces">       </span><span class="istickedoff">liftModuleM modEnv $</span>
<span class="lineno">  383 </span><span class="spaces">       </span><span class="istickedoff">do prims &lt;- MB.getPrimMap</span>
<span class="lineno">  384 </span><span class="spaces">          </span><span class="istickedoff">-- noIfaceParams because we don't support translating functors yet</span>
<span class="lineno">  385 </span><span class="spaces">          </span><span class="istickedoff">infInp &lt;- MB.genInferInput <span class="nottickedoff">P.emptyRange</span> prims NoParams ifaceDecls</span>
<span class="lineno">  386 </span><span class="spaces">          </span><span class="istickedoff">let newtypeCons = Map.fromList</span>
<span class="lineno">  387 </span><span class="spaces">                              </span><span class="istickedoff">[ con</span>
<span class="lineno">  388 </span><span class="spaces">                              </span><span class="istickedoff">| nt &lt;- Map.elems (TM.inpNominalTypes infInp)</span>
<span class="lineno">  389 </span><span class="spaces">                              </span><span class="istickedoff">, con &lt;- T.nominalTypeConTypes nt</span>
<span class="lineno">  390 </span><span class="spaces">                              </span><span class="istickedoff">]</span>
<span class="lineno">  391 </span><span class="spaces">          </span><span class="istickedoff">pure (newtypeCons `Map.union` TM.inpVars infInp)</span>
<span class="lineno">  392 </span><span class="spaces">     </span><span class="istickedoff">let types' = Map.union (eExtraTypes env) types</span>
<span class="lineno">  393 </span><span class="spaces">     </span><span class="istickedoff">let terms = eTermEnv env</span>
<span class="lineno">  394 </span><span class="spaces">     </span><span class="istickedoff">let cryEnv = C.emptyEnv</span>
<span class="lineno">  395 </span><span class="spaces">           </span><span class="istickedoff">{ C.envE = terms</span>
<span class="lineno">  396 </span><span class="spaces">           </span><span class="istickedoff">, C.envC = types'</span>
<span class="lineno">  397 </span><span class="spaces">           </span><span class="istickedoff">, C.envPrims = <span class="nottickedoff">ePrims env</span></span>
<span class="lineno">  398 </span><span class="spaces">           </span><span class="istickedoff">, C.envPrimTypes = <span class="nottickedoff">ePrimTypes env</span></span>
<span class="lineno">  399 </span><span class="spaces">           </span><span class="istickedoff">}</span>
<span class="lineno">  400 </span><span class="spaces">     </span><span class="istickedoff">return cryEnv</span></span>
<span class="lineno">  401 </span>
<span class="lineno">  402 </span>translateExpr ::
<span class="lineno">  403 </span>  (?fileReader :: FilePath -&gt; IO ByteString) =&gt;
<span class="lineno">  404 </span>  SharedContext -&gt; CryptolEnv -&gt; T.Expr -&gt; IO Term
<span class="lineno">  405 </span><span class="decl"><span class="istickedoff">translateExpr sc env expr =</span>
<span class="lineno">  406 </span><span class="spaces">  </span><span class="istickedoff">do cryEnv &lt;- mkCryEnv env</span>
<span class="lineno">  407 </span><span class="spaces">     </span><span class="istickedoff">C.importExpr sc cryEnv expr</span></span>
<span class="lineno">  408 </span>
<span class="lineno">  409 </span>translateDeclGroups ::
<span class="lineno">  410 </span>  (?fileReader :: FilePath -&gt; IO ByteString) =&gt;
<span class="lineno">  411 </span>  SharedContext -&gt; CryptolEnv -&gt; [T.DeclGroup] -&gt; IO CryptolEnv
<span class="lineno">  412 </span><span class="decl"><span class="istickedoff">translateDeclGroups sc env dgs =</span>
<span class="lineno">  413 </span><span class="spaces">  </span><span class="istickedoff">do cryEnv  &lt;- mkCryEnv env</span>
<span class="lineno">  414 </span><span class="spaces">     </span><span class="istickedoff">cryEnv' &lt;- C.importTopLevelDeclGroups sc <span class="nottickedoff">C.defaultPrimitiveOptions</span> cryEnv dgs</span>
<span class="lineno">  415 </span><span class="spaces">     </span><span class="istickedoff">let decls = concatMap T.groupDecls dgs</span>
<span class="lineno">  416 </span><span class="spaces">     </span><span class="istickedoff">let names = map T.dName decls</span>
<span class="lineno">  417 </span><span class="spaces">     </span><span class="istickedoff">let newTypes = Map.fromList [ (T.dName d, T.dSignature d) | d &lt;- decls ]</span>
<span class="lineno">  418 </span><span class="spaces">     </span><span class="istickedoff">let addName name = MR.shadowing (MN.singletonNS C.NSValue (P.mkUnqual (MN.nameIdent name)) name)</span>
<span class="lineno">  419 </span><span class="spaces">     </span><span class="istickedoff">return env</span>
<span class="lineno">  420 </span><span class="spaces">           </span><span class="istickedoff">{ eExtraNames = foldr addName (eExtraNames env) names</span>
<span class="lineno">  421 </span><span class="spaces">           </span><span class="istickedoff">, eExtraTypes = Map.union (eExtraTypes env) newTypes</span>
<span class="lineno">  422 </span><span class="spaces">           </span><span class="istickedoff">, eTermEnv    = C.envE cryEnv'</span>
<span class="lineno">  423 </span><span class="spaces">           </span><span class="istickedoff">}</span></span>
<span class="lineno">  424 </span>
<span class="lineno">  425 </span>--------------------------------------------------------------------------------
<span class="lineno">  426 </span>
<span class="lineno">  427 </span>
<span class="lineno">  428 </span>combineCryptolEnv :: CryptolEnv -&gt; CryptolEnv -&gt; IO CryptolEnv
<span class="lineno">  429 </span><span class="decl"><span class="istickedoff">combineCryptolEnv chkEnv newEnv =</span>
<span class="lineno">  430 </span><span class="spaces">  </span><span class="istickedoff">do let <span class="nottickedoff">newMEnv = eModuleEnv newEnv</span></span>
<span class="lineno">  431 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">chkMEnv = eModuleEnv chkEnv</span></span>
<span class="lineno">  432 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">menv' = chkMEnv{ ME.meNameSeeds = ME.meNameSeeds newMEnv }</span></span>
<span class="lineno">  433 </span><span class="spaces">     </span><span class="istickedoff">return <span class="nottickedoff">chkEnv{ eModuleEnv = menv' }</span></span></span>
<span class="lineno">  434 </span>
<span class="lineno">  435 </span>
<span class="lineno">  436 </span>checkNotParameterized :: T.Module -&gt; IO ()
<span class="lineno">  437 </span><span class="decl"><span class="istickedoff">checkNotParameterized m =</span>
<span class="lineno">  438 </span><span class="spaces">  </span><span class="istickedoff">when (T.isParametrizedModule m) $</span>
<span class="lineno">  439 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">fail $ unlines [ &quot;Cannot load parameterized modules directly.&quot;</span></span>
<span class="lineno">  440 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">, &quot;Either use a ` import, or make a module instantiation.&quot;</span></span>
<span class="lineno">  441 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno">  442 </span>
<span class="lineno">  443 </span>-- FIXME: Code duplication, these two functions are highly similar:
<span class="lineno">  444 </span>--   - loadCryptolModule
<span class="lineno">  445 </span>--   - importModule
<span class="lineno">  446 </span>-- - TODO: &quot;common up&quot; the common code per #2569.
<span class="lineno">  447 </span>
<span class="lineno">  448 </span>-- | loadCryptolModule - load a cryptol module and return a handle to
<span class="lineno">  449 </span>-- the `CryptolModule`.  The contents of the module are not imported.
<span class="lineno">  450 </span>--
<span class="lineno">  451 </span>-- This is used to implement the &quot;cryptol_load&quot; primitive in which a
<span class="lineno">  452 </span>-- handle to the module is returned and can be bound to a SAWScript
<span class="lineno">  453 </span>-- variable.
<span class="lineno">  454 </span>
<span class="lineno">  455 </span>loadCryptolModule ::
<span class="lineno">  456 </span>  (?fileReader :: FilePath -&gt; IO ByteString) =&gt;
<span class="lineno">  457 </span>  SharedContext -&gt;
<span class="lineno">  458 </span>  CryptolEnv -&gt;
<span class="lineno">  459 </span>  FilePath -&gt;
<span class="lineno">  460 </span>  IO (CryptolModule, CryptolEnv)
<span class="lineno">  461 </span><span class="decl"><span class="istickedoff">loadCryptolModule sc env path = do</span>
<span class="lineno">  462 </span><span class="spaces">  </span><span class="istickedoff">let modEnv = eModuleEnv env</span>
<span class="lineno">  463 </span><span class="spaces">  </span><span class="istickedoff">(mtop, modEnv') &lt;- liftModuleM modEnv $</span>
<span class="lineno">  464 </span><span class="spaces">                       </span><span class="istickedoff">MB.loadModuleByPath True path</span>
<span class="lineno">  465 </span><span class="spaces">  </span><span class="istickedoff">m &lt;- case mtop of</span>
<span class="lineno">  466 </span><span class="spaces">         </span><span class="istickedoff">T.TCTopModule mod' -&gt; pure mod'</span>
<span class="lineno">  467 </span><span class="spaces">         </span><span class="istickedoff">T.TCTopSignature {} -&gt;</span>
<span class="lineno">  468 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">fail $</span></span>
<span class="lineno">  469 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">&quot;Expected a module, but &quot; ++ show path ++ &quot; is an interface.&quot;</span></span>
<span class="lineno">  470 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  471 </span><span class="spaces">  </span><span class="istickedoff">checkNotParameterized m</span>
<span class="lineno">  472 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  473 </span><span class="spaces">  </span><span class="istickedoff">-- NOTE: unclear what's happening here!</span>
<span class="lineno">  474 </span><span class="spaces">  </span><span class="istickedoff">--   - FIXME: understand and doc.</span>
<span class="lineno">  475 </span><span class="spaces">  </span><span class="istickedoff">--   - `m` not used (directly) but translating the modEnv'</span>
<span class="lineno">  476 </span><span class="spaces">  </span><span class="istickedoff">--   - this behavior is not in `importModule`</span>
<span class="lineno">  477 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  478 </span><span class="spaces">  </span><span class="istickedoff">let ifaceDecls = getAllIfaceDecls modEnv'</span>
<span class="lineno">  479 </span><span class="spaces">  </span><span class="istickedoff">(types, modEnv'') &lt;- liftModuleM modEnv' $ do</span>
<span class="lineno">  480 </span><span class="spaces">    </span><span class="istickedoff">do prims &lt;- MB.getPrimMap</span>
<span class="lineno">  481 </span><span class="spaces">                  </span><span class="istickedoff">-- generate the primitive map; a monad reader</span>
<span class="lineno">  482 </span><span class="spaces">       </span><span class="istickedoff">TM.inpVars `fmap`</span>
<span class="lineno">  483 </span><span class="spaces">         </span><span class="istickedoff">MB.genInferInput <span class="nottickedoff">P.emptyRange</span> prims NoParams ifaceDecls</span>
<span class="lineno">  484 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  485 </span><span class="spaces">         </span><span class="istickedoff">-- NOTE: inpVars are the variables that are in scope.</span>
<span class="lineno">  486 </span><span class="spaces">         </span><span class="istickedoff">-- FIXME: we are possibly doing unnecessary computation here (see</span>
<span class="lineno">  487 </span><span class="spaces">         </span><span class="istickedoff">--        source code for MB.getPrimMap and MB.genInferInput.)</span>
<span class="lineno">  488 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  489 </span><span class="spaces">     </span><span class="istickedoff">-- FIXME: it appears (need to verify) that modEnv'' == modEnv'</span>
<span class="lineno">  490 </span><span class="spaces">     </span><span class="istickedoff">--   if this true, we can simplify and move this section</span>
<span class="lineno">  491 </span><span class="spaces">     </span><span class="istickedoff">--   into `mkCryptolModule`.</span>
<span class="lineno">  492 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  493 </span><span class="spaces">  </span><span class="istickedoff">-- Regenerate SharedTerm environment:</span>
<span class="lineno">  494 </span><span class="spaces">  </span><span class="istickedoff">let oldModNames = map ME.lmName</span>
<span class="lineno">  495 </span><span class="spaces">                  </span><span class="istickedoff">$ ME.lmLoadedModules</span>
<span class="lineno">  496 </span><span class="spaces">                  </span><span class="istickedoff">$ ME.meLoadedModules modEnv</span>
<span class="lineno">  497 </span><span class="spaces">      </span><span class="istickedoff">isNew m'    = T.mName m' `notElem` oldModNames</span>
<span class="lineno">  498 </span><span class="spaces">      </span><span class="istickedoff">newModules  = filter isNew</span>
<span class="lineno">  499 </span><span class="spaces">                  </span><span class="istickedoff">$ map ME.lmModule</span>
<span class="lineno">  500 </span><span class="spaces">                  </span><span class="istickedoff">$ ME.lmLoadedModules</span>
<span class="lineno">  501 </span><span class="spaces">                  </span><span class="istickedoff">$ ME.meLoadedModules modEnv''</span>
<span class="lineno">  502 </span><span class="spaces">      </span><span class="istickedoff">newDeclGroups = concatMap T.mDecls newModules</span>
<span class="lineno">  503 </span><span class="spaces">      </span><span class="istickedoff">newNominal    = Map.difference (loadedNonParamNominalTypes modEnv')</span>
<span class="lineno">  504 </span><span class="spaces">                                     </span><span class="istickedoff">(loadedNonParamNominalTypes modEnv)</span>
<span class="lineno">  505 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  506 </span><span class="spaces">  </span><span class="istickedoff">newTermEnv &lt;-</span>
<span class="lineno">  507 </span><span class="spaces">    </span><span class="istickedoff">do oldCryEnv &lt;- mkCryEnv env</span>
<span class="lineno">  508 </span><span class="spaces">       </span><span class="istickedoff">cEnv &lt;- C.genCodeForNominalTypes <span class="nottickedoff">sc</span> newNominal oldCryEnv</span>
<span class="lineno">  509 </span><span class="spaces">       </span><span class="istickedoff">newCryEnv &lt;- C.importTopLevelDeclGroups</span>
<span class="lineno">  510 </span><span class="spaces">                      </span><span class="istickedoff">sc <span class="nottickedoff">C.defaultPrimitiveOptions</span> cEnv newDeclGroups</span>
<span class="lineno">  511 </span><span class="spaces">       </span><span class="istickedoff">return (C.envE newCryEnv)</span>
<span class="lineno">  512 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  513 </span><span class="spaces">  </span><span class="istickedoff">cryptolModule &lt;- mkCryptolModule m types newTermEnv</span>
<span class="lineno">  514 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  515 </span><span class="spaces">  </span><span class="istickedoff">-- NOTE: Bringing the module-handle into {{-}} scope is not handled</span>
<span class="lineno">  516 </span><span class="spaces">  </span><span class="istickedoff">--       here; it is done rather in `bindCryptolModule`, ONLY if the</span>
<span class="lineno">  517 </span><span class="spaces">  </span><span class="istickedoff">--       user binds the `cryptolModule` returned here at the saw</span>
<span class="lineno">  518 </span><span class="spaces">  </span><span class="istickedoff">--       command line.</span>
<span class="lineno">  519 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  520 </span><span class="spaces">  </span><span class="istickedoff">return ( cryptolModule</span>
<span class="lineno">  521 </span><span class="spaces">         </span><span class="istickedoff">, env { eModuleEnv = modEnv''</span>
<span class="lineno">  522 </span><span class="spaces">               </span><span class="istickedoff">, eTermEnv   = <span class="nottickedoff">newTermEnv</span></span>
<span class="lineno">  523 </span><span class="spaces">               </span><span class="istickedoff">, eFFITypes  = <span class="nottickedoff">updateFFITypes m newTermEnv (eFFITypes env)</span></span>
<span class="lineno">  524 </span><span class="spaces">               </span><span class="istickedoff">}</span>
<span class="lineno">  525 </span><span class="spaces">             </span><span class="istickedoff">-- NOTE here the difference between this function and</span>
<span class="lineno">  526 </span><span class="spaces">             </span><span class="istickedoff">-- `importModule`:</span>
<span class="lineno">  527 </span><span class="spaces">             </span><span class="istickedoff">--  1. the `eImports` field is not updated, as</span>
<span class="lineno">  528 </span><span class="spaces">             </span><span class="istickedoff">--     this module (as a whole) is not being</span>
<span class="lineno">  529 </span><span class="spaces">             </span><span class="istickedoff">--     brought into scope inside {{ }} constructs.</span>
<span class="lineno">  530 </span><span class="spaces">             </span><span class="istickedoff">--  2. modEnv'' vs modEnv' (which may not be different, see</span>
<span class="lineno">  531 </span><span class="spaces">             </span><span class="istickedoff">--     notes above).</span>
<span class="lineno">  532 </span><span class="spaces">         </span><span class="istickedoff">)</span></span>
<span class="lineno">  533 </span>
<span class="lineno">  534 </span>-- | mkCryptolModule
<span class="lineno">  535 </span>--
<span class="lineno">  536 </span>-- FIXME:
<span class="lineno">  537 </span>--   - This incorrectly excludes both submodules and their contents from
<span class="lineno">  538 </span>--     the NamingEnvs in `CryptolModule`
<span class="lineno">  539 </span>
<span class="lineno">  540 </span>--   - Regarding the CLI API: the `CryptolModule` type is exposed to
<span class="lineno">  541 </span>--     the SAWScript CLI, is this necessary?
<span class="lineno">  542 </span>
<span class="lineno">  543 </span>mkCryptolModule :: T.Module
<span class="lineno">  544 </span>                -&gt; Map MN.Name T.Schema
<span class="lineno">  545 </span>                -&gt; Map MN.Name Term
<span class="lineno">  546 </span>                -&gt; IO CryptolModule
<span class="lineno">  547 </span><span class="decl"><span class="istickedoff">mkCryptolModule m types newTermEnv =</span>
<span class="lineno">  548 </span><span class="spaces">  </span><span class="istickedoff">do</span>
<span class="lineno">  549 </span><span class="spaces">  </span><span class="istickedoff">let names = MEx.exported C.NSValue (T.mExports m) -- :: Set T.Name</span>
<span class="lineno">  550 </span><span class="spaces">  </span><span class="istickedoff">return $</span>
<span class="lineno">  551 </span><span class="spaces">    </span><span class="istickedoff">CryptolModule</span>
<span class="lineno">  552 </span><span class="spaces">      </span><span class="istickedoff">-- create type synonym Map, keep only the exports:</span>
<span class="lineno">  553 </span><span class="spaces">      </span><span class="istickedoff">(Map.filterWithKey</span>
<span class="lineno">  554 </span><span class="spaces">         </span><span class="istickedoff">(\k _ -&gt; Set.member k (MEx.exported C.NSType (T.mExports m)))</span>
<span class="lineno">  555 </span><span class="spaces">         </span><span class="istickedoff">(T.mTySyns m)</span>
<span class="lineno">  556 </span><span class="spaces">      </span><span class="istickedoff">)</span>
<span class="lineno">  557 </span><span class="spaces">        </span><span class="istickedoff">-- FIXME: TODO: ensure type synonym in submodule is included.</span>
<span class="lineno">  558 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  559 </span><span class="spaces">      </span><span class="istickedoff">-- create the map of symbols:</span>
<span class="lineno">  560 </span><span class="spaces">      </span><span class="istickedoff">( Map.filterWithKey (\k _ -&gt; Set.member k names)</span>
<span class="lineno">  561 </span><span class="spaces">      </span><span class="istickedoff">$ Map.intersectionWith</span>
<span class="lineno">  562 </span><span class="spaces">           </span><span class="istickedoff">(\t x -&gt; TypedTerm (TypedTermSchema <span class="nottickedoff">t</span>) <span class="nottickedoff">x</span>)</span>
<span class="lineno">  563 </span><span class="spaces">           </span><span class="istickedoff">types          -- NOTE: only use of this variable.</span>
<span class="lineno">  564 </span><span class="spaces">           </span><span class="istickedoff">newTermEnv</span>
<span class="lineno">  565 </span><span class="spaces">      </span><span class="istickedoff">)</span></span>
<span class="lineno">  566 </span>
<span class="lineno">  567 </span>updateFFITypes :: T.Module -&gt; Map MN.Name Term -&gt; Map NameInfo T.FFI -&gt; Map NameInfo T.FFI
<span class="lineno">  568 </span><span class="decl"><span class="istickedoff">updateFFITypes m eTermEnv' eFFITypes' =</span>
<span class="lineno">  569 </span><span class="spaces">  </span><span class="istickedoff">foldr (\(nm, ty) -&gt; Map.insert (getNameInfo nm) ty)</span>
<span class="lineno">  570 </span><span class="spaces">                       </span><span class="istickedoff">eFFITypes'</span>
<span class="lineno">  571 </span><span class="spaces">                       </span><span class="istickedoff">(T.findForeignDecls m)</span>
<span class="lineno">  572 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  573 </span><span class="spaces">  </span><span class="istickedoff">getNameInfo nm =</span>
<span class="lineno">  574 </span><span class="spaces">    </span><span class="istickedoff">case Map.lookup nm eTermEnv' of</span>
<span class="lineno">  575 </span><span class="spaces">      </span><span class="istickedoff">Just tm -&gt;</span>
<span class="lineno">  576 </span><span class="spaces">        </span><span class="istickedoff">case asConstant tm of</span>
<span class="lineno">  577 </span><span class="spaces">          </span><span class="istickedoff">Just n -&gt; nameInfo n</span>
<span class="lineno">  578 </span><span class="spaces">          </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  579 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">panic &quot;updateFFITypes&quot; [</span></span>
<span class="lineno">  580 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">&quot;SAWCore term of Cryptol name is not Constant&quot;,</span></span>
<span class="lineno">  581 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">&quot;Name: &quot; &lt;&gt; Text.pack (show nm),</span></span>
<span class="lineno">  582 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">&quot;Term: &quot; &lt;&gt; Text.pack (showTerm tm)</span></span>
<span class="lineno">  583 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  584 </span><span class="spaces">      </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  585 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">panic &quot;updateFFITypes&quot; [</span></span>
<span class="lineno">  586 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot;Cannot find foreign function in term environment: &quot; &lt;&gt; Text.pack (show nm)</span></span>
<span class="lineno">  587 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno">  588 </span>
<span class="lineno">  589 </span>-- | bindCryptolModule - ad hoc function called when `D &lt;-cryptol_load` is seen
<span class="lineno">  590 </span>--     on the command line.
<span class="lineno">  591 </span>--
<span class="lineno">  592 </span>--   FIXME:
<span class="lineno">  593 </span>--    - submodules are not handled correctly below.
<span class="lineno">  594 </span>--    - the code is duplicating functionality that we have with `importModule`
<span class="lineno">  595 </span>--   TODO:
<span class="lineno">  596 </span>--    - new design in PR #2593 (addressing issue #2569) should replace
<span class="lineno">  597 </span>--      this function so that the fundamental work is done via `importModule`.
<span class="lineno">  598 </span>
<span class="lineno">  599 </span>bindCryptolModule :: (P.ModName, CryptolModule) -&gt; CryptolEnv -&gt; CryptolEnv
<span class="lineno">  600 </span><span class="decl"><span class="istickedoff">bindCryptolModule (modName, CryptolModule sm tm) env =</span>
<span class="lineno">  601 </span><span class="spaces">  </span><span class="istickedoff">env { eExtraNames = flip (foldr addName) (Map.keys tm') $</span>
<span class="lineno">  602 </span><span class="spaces">                      </span><span class="istickedoff">flip (foldr addTSyn) (Map.keys sm) $</span>
<span class="lineno">  603 </span><span class="spaces">                      </span><span class="istickedoff">flip (foldr addSubModule) (Map.keys tm') $</span>
<span class="lineno">  604 </span><span class="spaces">                      </span><span class="istickedoff">eExtraNames env</span>
<span class="lineno">  605 </span><span class="spaces">      </span><span class="istickedoff">, eExtraTSyns = <span class="nottickedoff">Map.union sm (eExtraTSyns env)</span></span>
<span class="lineno">  606 </span><span class="spaces">      </span><span class="istickedoff">, eExtraTypes = <span class="nottickedoff">Map.union (fmap fst tm') (eExtraTypes env)</span></span>
<span class="lineno">  607 </span><span class="spaces">      </span><span class="istickedoff">, eTermEnv    = <span class="nottickedoff">Map.union (fmap snd tm') (eTermEnv env)</span></span>
<span class="lineno">  608 </span><span class="spaces">      </span><span class="istickedoff">}</span>
<span class="lineno">  609 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  610 </span><span class="spaces">    </span><span class="istickedoff">-- | `tm'` is the typed terms from `tm` that have Cryptol schemas</span>
<span class="lineno">  611 </span><span class="spaces">    </span><span class="istickedoff">tm' = Map.mapMaybe f tm</span>
<span class="lineno">  612 </span><span class="spaces">          </span><span class="istickedoff">where</span>
<span class="lineno">  613 </span><span class="spaces">          </span><span class="istickedoff">f (TypedTerm (TypedTermSchema s) x) = Just <span class="nottickedoff">(s,x)</span></span>
<span class="lineno">  614 </span><span class="spaces">          </span><span class="istickedoff">f _                                 = <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  615 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  616 </span><span class="spaces">    </span><span class="istickedoff">addName name = MN.shadowing (MN.singletonNS C.NSValue (P.mkQual modName (MN.nameIdent name)) <span class="nottickedoff">name</span>)</span>
<span class="lineno">  617 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  618 </span><span class="spaces">    </span><span class="istickedoff">addSubModule name = MN.shadowing (MN.singletonNS C.NSModule (P.mkQual modName (MN.nameIdent name)) <span class="nottickedoff">name</span>)</span>
<span class="lineno">  619 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  620 </span><span class="spaces">    </span><span class="istickedoff">addTSyn name = MN.shadowing (MN.singletonNS C.NSType (P.mkQual modName (MN.nameIdent name)) <span class="nottickedoff">name</span>)</span></span>
<span class="lineno">  621 </span>
<span class="lineno">  622 </span>-- | NOTE: this is only used in the &quot;cryptol_extract&quot; primitive.
<span class="lineno">  623 </span>extractDefFromCryptolModule :: CryptolModule -&gt; Text -&gt; IO TypedTerm
<span class="lineno">  624 </span><span class="decl"><span class="nottickedoff">extractDefFromCryptolModule (CryptolModule _ tm) name =</span>
<span class="lineno">  625 </span><span class="spaces">  </span><span class="nottickedoff">case Map.lookup (mkIdent name) (Map.mapKeys MN.nameIdent tm) of</span>
<span class="lineno">  626 </span><span class="spaces">    </span><span class="nottickedoff">Just t  -&gt; return t</span>
<span class="lineno">  627 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; fail $ Text.unpack $ &quot;Binding not found: &quot; &lt;&gt; name</span></span>
<span class="lineno">  628 </span>               -- FIXME: unfortunate we have lost the name of the module.
<span class="lineno">  629 </span>
<span class="lineno">  630 </span>    -- FIXME: bug: we can't access definitions in submodules.
<span class="lineno">  631 </span>    -- FIXME: this is ad hoc, somehow invoke parse for name, or the like?
<span class="lineno">  632 </span>
<span class="lineno">  633 </span>
<span class="lineno">  634 </span>--------------------------------------------------------------------------------
<span class="lineno">  635 </span>
<span class="lineno">  636 </span>-- | @'importModule' sc env src as vis imps@ - extend the Cryptol
<span class="lineno">  637 </span>--   environment with a module.  Closely mirrors the sawscript command &quot;import&quot;.
<span class="lineno">  638 </span>--
<span class="lineno">  639 </span>-- NOTE:
<span class="lineno">  640 </span>--  - the module can be qualified or not (per 'as' argument).  per
<span class="lineno">  641 </span>--  - 'vis' we can import public definitions or *all* (i.e., internal
<span class="lineno">  642 </span>--    and public) definitions.
<span class="lineno">  643 </span>
<span class="lineno">  644 </span>importModule ::
<span class="lineno">  645 </span>  (?fileReader :: FilePath -&gt; IO ByteString) =&gt;
<span class="lineno">  646 </span>  SharedContext             {- ^ Shared context for creating terms -} -&gt;
<span class="lineno">  647 </span>  CryptolEnv                {- ^ Extend this environment -} -&gt;
<span class="lineno">  648 </span>  Either FilePath P.ModName {- ^ Where to find the module -} -&gt;
<span class="lineno">  649 </span>  Maybe P.ModName           {- ^ Name qualifier -} -&gt;
<span class="lineno">  650 </span>  ImportVisibility          {- ^ What visibility to give symbols from this module -} -&gt;
<span class="lineno">  651 </span>  Maybe P.ImportSpec        {- ^ What to import -} -&gt;
<span class="lineno">  652 </span>  IO CryptolEnv
<span class="lineno">  653 </span><span class="decl"><span class="istickedoff">importModule sc env src as vis imps = do</span>
<span class="lineno">  654 </span><span class="spaces">  </span><span class="istickedoff">let modEnv = eModuleEnv env</span>
<span class="lineno">  655 </span><span class="spaces">  </span><span class="istickedoff">(mtop, modEnv') &lt;- liftModuleM modEnv $</span>
<span class="lineno">  656 </span><span class="spaces">    </span><span class="istickedoff">case src of</span>
<span class="lineno">  657 </span><span class="spaces">      </span><span class="istickedoff">Left path -&gt; MB.loadModuleByPath True path</span>
<span class="lineno">  658 </span><span class="spaces">      </span><span class="istickedoff">Right mn  -&gt; snd &lt;$&gt; MB.loadModuleFrom True (MM.FromModule mn)</span>
<span class="lineno">  659 </span><span class="spaces">  </span><span class="istickedoff">m &lt;- case mtop of</span>
<span class="lineno">  660 </span><span class="spaces">         </span><span class="istickedoff">T.TCTopModule mod'  -&gt; pure mod'</span>
<span class="lineno">  661 </span><span class="spaces">         </span><span class="istickedoff">T.TCTopSignature {} -&gt;</span>
<span class="lineno">  662 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">fail &quot;Expected a module but found an interface.&quot;</span></span>
<span class="lineno">  663 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  664 </span><span class="spaces">  </span><span class="istickedoff">checkNotParameterized m</span>
<span class="lineno">  665 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  666 </span><span class="spaces">  </span><span class="istickedoff">-- Regenerate SharedTerm environment:</span>
<span class="lineno">  667 </span><span class="spaces">  </span><span class="istickedoff">let oldModNames   = map ME.lmName</span>
<span class="lineno">  668 </span><span class="spaces">                    </span><span class="istickedoff">$ ME.lmLoadedModules</span>
<span class="lineno">  669 </span><span class="spaces">                    </span><span class="istickedoff">$ ME.meLoadedModules modEnv</span>
<span class="lineno">  670 </span><span class="spaces">      </span><span class="istickedoff">isNew m'      = T.mName m' `notElem` oldModNames</span>
<span class="lineno">  671 </span><span class="spaces">      </span><span class="istickedoff">newModules    = filter isNew</span>
<span class="lineno">  672 </span><span class="spaces">                    </span><span class="istickedoff">$ map ME.lmModule</span>
<span class="lineno">  673 </span><span class="spaces">                    </span><span class="istickedoff">$ ME.lmLoadedModules</span>
<span class="lineno">  674 </span><span class="spaces">                    </span><span class="istickedoff">$ ME.meLoadedModules modEnv'</span>
<span class="lineno">  675 </span><span class="spaces">      </span><span class="istickedoff">newDeclGroups = concatMap T.mDecls newModules</span>
<span class="lineno">  676 </span><span class="spaces">      </span><span class="istickedoff">newNominal    = Map.difference (loadedNonParamNominalTypes modEnv')</span>
<span class="lineno">  677 </span><span class="spaces">                                     </span><span class="istickedoff">(loadedNonParamNominalTypes modEnv)</span>
<span class="lineno">  678 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  679 </span><span class="spaces">  </span><span class="istickedoff">newTermEnv &lt;-</span>
<span class="lineno">  680 </span><span class="spaces">    </span><span class="istickedoff">do oldCryEnv &lt;- mkCryEnv env</span>
<span class="lineno">  681 </span><span class="spaces">       </span><span class="istickedoff">cEnv      &lt;- C.genCodeForNominalTypes sc newNominal oldCryEnv</span>
<span class="lineno">  682 </span><span class="spaces">       </span><span class="istickedoff">newCryEnv &lt;- C.importTopLevelDeclGroups</span>
<span class="lineno">  683 </span><span class="spaces">                      </span><span class="istickedoff">sc <span class="nottickedoff">C.defaultPrimitiveOptions</span> cEnv newDeclGroups</span>
<span class="lineno">  684 </span><span class="spaces">       </span><span class="istickedoff">return (C.envE newCryEnv)</span>
<span class="lineno">  685 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  686 </span><span class="spaces">  </span><span class="istickedoff">let newImport = (vis, P.Import { T.iModule= locate $ T.mName m</span>
<span class="lineno">  687 </span><span class="spaces">                                 </span><span class="istickedoff">, T.iAs    = as</span>
<span class="lineno">  688 </span><span class="spaces">                                 </span><span class="istickedoff">, T.iSpec  = imps</span>
<span class="lineno">  689 </span><span class="spaces">                                 </span><span class="istickedoff">, T.iInst  = Nothing</span>
<span class="lineno">  690 </span><span class="spaces">                                 </span><span class="istickedoff">, T.iDoc   = <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  691 </span><span class="spaces">                                 </span><span class="istickedoff">}</span>
<span class="lineno">  692 </span><span class="spaces">                  </span><span class="istickedoff">)</span>
<span class="lineno">  693 </span><span class="spaces">      </span><span class="istickedoff">-- XXX: it would be better to have the real position, but it</span>
<span class="lineno">  694 </span><span class="spaces">      </span><span class="istickedoff">-- seems to have been thrown away on the Cryptol side.</span>
<span class="lineno">  695 </span><span class="spaces">      </span><span class="istickedoff">locate x = P.Located P.emptyRange x</span>
<span class="lineno">  696 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  697 </span><span class="spaces">  </span><span class="istickedoff">return $</span>
<span class="lineno">  698 </span><span class="spaces">    </span><span class="istickedoff">env{ eModuleEnv = modEnv'</span>
<span class="lineno">  699 </span><span class="spaces">       </span><span class="istickedoff">, eTermEnv   = newTermEnv</span>
<span class="lineno">  700 </span><span class="spaces">       </span><span class="istickedoff">, eFFITypes  = updateFFITypes m newTermEnv (eFFITypes env)</span>
<span class="lineno">  701 </span><span class="spaces">       </span><span class="istickedoff">, eImports   = newImport : eImports env</span>
<span class="lineno">  702 </span><span class="spaces">       </span><span class="istickedoff">}</span></span>
<span class="lineno">  703 </span>
<span class="lineno">  704 </span>bindIdent :: Ident -&gt; CryptolEnv -&gt; (T.Name, CryptolEnv)
<span class="lineno">  705 </span><span class="decl"><span class="istickedoff">bindIdent ident env = (name, env')</span>
<span class="lineno">  706 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  707 </span><span class="spaces">    </span><span class="istickedoff">modEnv = eModuleEnv env</span>
<span class="lineno">  708 </span><span class="spaces">    </span><span class="istickedoff">supply = ME.meSupply modEnv</span>
<span class="lineno">  709 </span><span class="spaces">    </span><span class="istickedoff">fixity = Nothing</span>
<span class="lineno">  710 </span><span class="spaces">    </span><span class="istickedoff">(name, supply') = MN.mkDeclared</span>
<span class="lineno">  711 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">C.NSValue</span></span>
<span class="lineno">  712 </span><span class="spaces">                        </span><span class="istickedoff">(C.TopModule interactiveName)</span>
<span class="lineno">  713 </span><span class="spaces">                        </span><span class="istickedoff">MN.UserName</span>
<span class="lineno">  714 </span><span class="spaces">                        </span><span class="istickedoff">ident fixity P.emptyRange supply</span>
<span class="lineno">  715 </span><span class="spaces">    </span><span class="istickedoff">modEnv' = modEnv { ME.meSupply = supply' }</span>
<span class="lineno">  716 </span><span class="spaces">    </span><span class="istickedoff">env' = env { eModuleEnv = modEnv' }</span></span>
<span class="lineno">  717 </span>
<span class="lineno">  718 </span>bindTypedTerm :: (Ident, TypedTerm) -&gt; CryptolEnv -&gt; CryptolEnv
<span class="lineno">  719 </span><span class="decl"><span class="istickedoff">bindTypedTerm (ident, TypedTerm (TypedTermSchema schema) trm) env =</span>
<span class="lineno">  720 </span><span class="spaces">  </span><span class="istickedoff">env' { eExtraNames = MR.shadowing (MN.singletonNS C.NSValue pname name)</span>
<span class="lineno">  721 </span><span class="spaces">                                    </span><span class="istickedoff">(eExtraNames env)</span>
<span class="lineno">  722 </span><span class="spaces">       </span><span class="istickedoff">, eExtraTypes = Map.insert name schema (eExtraTypes env)</span>
<span class="lineno">  723 </span><span class="spaces">       </span><span class="istickedoff">, eTermEnv    = Map.insert name trm (eTermEnv env)</span>
<span class="lineno">  724 </span><span class="spaces">       </span><span class="istickedoff">}</span>
<span class="lineno">  725 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  726 </span><span class="spaces">    </span><span class="istickedoff">pname = P.mkUnqual ident</span>
<span class="lineno">  727 </span><span class="spaces">    </span><span class="istickedoff">(name, env') = bindIdent ident env</span>
<span class="lineno">  728 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  729 </span><span class="spaces"></span><span class="istickedoff">-- Only bind terms that have Cryptol schemas</span>
<span class="lineno">  730 </span><span class="spaces"></span><span class="istickedoff">bindTypedTerm _ env = env</span></span>
<span class="lineno">  731 </span>
<span class="lineno">  732 </span>
<span class="lineno">  733 </span>bindType :: (Ident, T.Schema) -&gt; CryptolEnv -&gt; CryptolEnv
<span class="lineno">  734 </span><span class="decl"><span class="nottickedoff">bindType (ident, T.Forall [] [] ty) env =</span>
<span class="lineno">  735 </span><span class="spaces">  </span><span class="nottickedoff">env' { eExtraNames = MR.shadowing (MN.singletonNS C.NSType pname name) (eExtraNames env)</span>
<span class="lineno">  736 </span><span class="spaces">       </span><span class="nottickedoff">, eExtraTSyns = Map.insert name tysyn (eExtraTSyns env)</span>
<span class="lineno">  737 </span><span class="spaces">       </span><span class="nottickedoff">}</span>
<span class="lineno">  738 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  739 </span><span class="spaces">    </span><span class="nottickedoff">pname = P.mkUnqual ident</span>
<span class="lineno">  740 </span><span class="spaces">    </span><span class="nottickedoff">(name, env') = bindIdent ident env</span>
<span class="lineno">  741 </span><span class="spaces">    </span><span class="nottickedoff">tysyn = T.TySyn name [] [] ty Nothing</span>
<span class="lineno">  742 </span><span class="spaces"></span><span class="nottickedoff">bindType _ env = env</span></span> -- only monomorphic types may be bound
<span class="lineno">  743 </span>
<span class="lineno">  744 </span>bindInteger :: (Ident, Integer) -&gt; CryptolEnv -&gt; CryptolEnv
<span class="lineno">  745 </span><span class="decl"><span class="istickedoff">bindInteger (ident, n) env =</span>
<span class="lineno">  746 </span><span class="spaces">  </span><span class="istickedoff">env' { eExtraNames = MR.shadowing (MN.singletonNS C.NSType pname name) (eExtraNames env)</span>
<span class="lineno">  747 </span><span class="spaces">       </span><span class="istickedoff">, eExtraTSyns = Map.insert name tysyn (eExtraTSyns env)</span>
<span class="lineno">  748 </span><span class="spaces">       </span><span class="istickedoff">}</span>
<span class="lineno">  749 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  750 </span><span class="spaces">    </span><span class="istickedoff">pname = P.mkUnqual ident</span>
<span class="lineno">  751 </span><span class="spaces">    </span><span class="istickedoff">(name, env') = bindIdent <span class="nottickedoff">ident</span> env</span>
<span class="lineno">  752 </span><span class="spaces">    </span><span class="istickedoff">tysyn = T.TySyn <span class="nottickedoff">name</span> [] [] (T.tNum n) Nothing</span></span>
<span class="lineno">  753 </span>
<span class="lineno">  754 </span>--------------------------------------------------------------------------------
<span class="lineno">  755 </span>
<span class="lineno">  756 </span>meSolverConfig :: ME.ModuleEnv -&gt; TM.SolverConfig
<span class="lineno">  757 </span><span class="decl"><span class="istickedoff">meSolverConfig env = TM.defaultSolverConfig (ME.meSearchPath env)</span></span>
<span class="lineno">  758 </span>
<span class="lineno">  759 </span>resolveIdentifier ::
<span class="lineno">  760 </span>  (HasCallStack, ?fileReader :: FilePath -&gt; IO ByteString) =&gt;
<span class="lineno">  761 </span>  CryptolEnv -&gt; Text -&gt; IO (Maybe T.Name)
<span class="lineno">  762 </span><span class="decl"><span class="istickedoff">resolveIdentifier env nm =</span>
<span class="lineno">  763 </span><span class="spaces">  </span><span class="istickedoff">case splitOn (pack &quot;::&quot;) nm of</span>
<span class="lineno">  764 </span><span class="spaces">    </span><span class="istickedoff">[]  -&gt; <span class="nottickedoff">pure Nothing</span></span>
<span class="lineno">  765 </span><span class="spaces">           </span><span class="istickedoff">-- FIXME: shouldn't this be error?</span>
<span class="lineno">  766 </span><span class="spaces">    </span><span class="istickedoff">[i] -&gt; doResolve (P.UnQual (C.mkIdent i))</span>
<span class="lineno">  767 </span><span class="spaces">    </span><span class="istickedoff">xs  -&gt; <span class="nottickedoff">let (qs,i) = (init xs, last xs)</span></span>
<span class="lineno">  768 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">in  doResolve (P.Qual (C.packModName qs) (C.mkIdent i))</span></span>
<span class="lineno">  769 </span><span class="spaces">    </span><span class="istickedoff">-- FIXME: Is there no function that parses Text into PName?</span>
<span class="lineno">  770 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  771 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  772 </span><span class="spaces">  </span><span class="istickedoff">modEnv = eModuleEnv env</span>
<span class="lineno">  773 </span><span class="spaces">  </span><span class="istickedoff">nameEnv = getNamingEnv env</span>
<span class="lineno">  774 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  775 </span><span class="spaces">  </span><span class="istickedoff">doResolve pnm =</span>
<span class="lineno">  776 </span><span class="spaces">    </span><span class="istickedoff">SMT.withSolver (return <span class="nottickedoff">()</span>) (meSolverConfig modEnv) $ \solver -&gt;</span>
<span class="lineno">  777 </span><span class="spaces">    </span><span class="istickedoff">do let minp = MM.ModuleInput {</span>
<span class="lineno">  778 </span><span class="spaces">               </span><span class="istickedoff">MM.minpCallStacks = <span class="nottickedoff">True</span>,</span>
<span class="lineno">  779 </span><span class="spaces">               </span><span class="istickedoff">MM.minpSaveRenamed = <span class="nottickedoff">False</span>,</span>
<span class="lineno">  780 </span><span class="spaces">               </span><span class="istickedoff">MM.minpEvalOpts = <span class="nottickedoff">pure defaultEvalOpts</span>,</span>
<span class="lineno">  781 </span><span class="spaces">               </span><span class="istickedoff">MM.minpByteReader = <span class="nottickedoff">?fileReader</span>,</span>
<span class="lineno">  782 </span><span class="spaces">               </span><span class="istickedoff">MM.minpModuleEnv = modEnv,</span>
<span class="lineno">  783 </span><span class="spaces">               </span><span class="istickedoff">MM.minpTCSolver = <span class="nottickedoff">solver</span></span>
<span class="lineno">  784 </span><span class="spaces">           </span><span class="istickedoff">}</span>
<span class="lineno">  785 </span><span class="spaces">       </span><span class="istickedoff">(res, _ws) &lt;- MM.runModuleM minp $</span>
<span class="lineno">  786 </span><span class="spaces">          </span><span class="istickedoff">MM.interactive (MB.rename interactiveName nameEnv (MR.renameVar MR.NameUse pnm))</span>
<span class="lineno">  787 </span><span class="spaces">       </span><span class="istickedoff">case res of</span>
<span class="lineno">  788 </span><span class="spaces">         </span><span class="istickedoff">Left _ -&gt; pure Nothing</span>
<span class="lineno">  789 </span><span class="spaces">         </span><span class="istickedoff">Right (x,_) -&gt; pure (Just x)</span></span>
<span class="lineno">  790 </span>
<span class="lineno">  791 </span>
<span class="lineno">  792 </span>parseTypedTerm ::
<span class="lineno">  793 </span>  (HasCallStack, ?fileReader :: FilePath -&gt; IO ByteString) =&gt;
<span class="lineno">  794 </span>  SharedContext -&gt; CryptolEnv -&gt; InputText -&gt; IO TypedTerm
<span class="lineno">  795 </span><span class="decl"><span class="istickedoff">parseTypedTerm sc env input = do</span>
<span class="lineno">  796 </span><span class="spaces">  </span><span class="istickedoff">-- Parse:</span>
<span class="lineno">  797 </span><span class="spaces">  </span><span class="istickedoff">pexpr &lt;- ioParseExpr input</span>
<span class="lineno">  798 </span><span class="spaces">  </span><span class="istickedoff">-- Translate:</span>
<span class="lineno">  799 </span><span class="spaces">  </span><span class="istickedoff">pExprToTypedTerm sc env pexpr</span></span>
<span class="lineno">  800 </span>
<span class="lineno">  801 </span>pExprToTypedTerm ::
<span class="lineno">  802 </span>  (?fileReader :: FilePath -&gt; IO ByteString) =&gt;
<span class="lineno">  803 </span>  SharedContext -&gt; CryptolEnv -&gt; P.Expr P.PName -&gt; IO TypedTerm
<span class="lineno">  804 </span><span class="decl"><span class="istickedoff">pExprToTypedTerm sc env pexpr = do</span>
<span class="lineno">  805 </span><span class="spaces">  </span><span class="istickedoff">let modEnv = eModuleEnv env</span>
<span class="lineno">  806 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  807 </span><span class="spaces">  </span><span class="istickedoff">((expr, schema), modEnv') &lt;- liftModuleM modEnv $ do</span>
<span class="lineno">  808 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  809 </span><span class="spaces">    </span><span class="istickedoff">-- Eliminate patterns:</span>
<span class="lineno">  810 </span><span class="spaces">    </span><span class="istickedoff">npe &lt;- MM.interactive (MB.noPat pexpr)</span>
<span class="lineno">  811 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  812 </span><span class="spaces">    </span><span class="istickedoff">let nameEnv = getNamingEnv env</span>
<span class="lineno">  813 </span><span class="spaces">    </span><span class="istickedoff">let npe' = MR.rename npe</span>
<span class="lineno">  814 </span><span class="spaces">    </span><span class="istickedoff">re &lt;- MM.interactive (MB.rename interactiveName nameEnv npe')</span>
<span class="lineno">  815 </span><span class="spaces">      </span><span class="istickedoff">-- NOTE: if a name is not in scope, it is reported here.</span>
<span class="lineno">  816 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  817 </span><span class="spaces">    </span><span class="istickedoff">-- Infer types</span>
<span class="lineno">  818 </span><span class="spaces">    </span><span class="istickedoff">let ifDecls = getAllIfaceDecls modEnv</span>
<span class="lineno">  819 </span><span class="spaces">    </span><span class="istickedoff">let range = fromMaybe P.emptyRange (P.getLoc re)</span>
<span class="lineno">  820 </span><span class="spaces">    </span><span class="istickedoff">prims &lt;- MB.getPrimMap</span>
<span class="lineno">  821 </span><span class="spaces">    </span><span class="istickedoff">-- noIfaceParams because we don't support functors yet</span>
<span class="lineno">  822 </span><span class="spaces">    </span><span class="istickedoff">tcEnv &lt;- MB.genInferInput range prims NoParams ifDecls</span>
<span class="lineno">  823 </span><span class="spaces">    </span><span class="istickedoff">let tcEnv' = tcEnv { TM.inpVars = Map.union (eExtraTypes env) (TM.inpVars tcEnv)</span>
<span class="lineno">  824 </span><span class="spaces">                       </span><span class="istickedoff">, TM.inpTSyns = Map.union (eExtraTSyns env) (TM.inpTSyns tcEnv)</span>
<span class="lineno">  825 </span><span class="spaces">                       </span><span class="istickedoff">}</span>
<span class="lineno">  826 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  827 </span><span class="spaces">    </span><span class="istickedoff">out &lt;- MM.io (T.tcExpr re tcEnv')</span>
<span class="lineno">  828 </span><span class="spaces">    </span><span class="istickedoff">MM.interactive (runInferOutput out)</span>
<span class="lineno">  829 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  830 </span><span class="spaces">  </span><span class="istickedoff">let env' = env { eModuleEnv = modEnv' }</span>
<span class="lineno">  831 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  832 </span><span class="spaces">  </span><span class="istickedoff">-- Translate</span>
<span class="lineno">  833 </span><span class="spaces">  </span><span class="istickedoff">trm &lt;- translateExpr sc env' expr</span>
<span class="lineno">  834 </span><span class="spaces">  </span><span class="istickedoff">return (TypedTerm (TypedTermSchema schema) trm)</span></span>
<span class="lineno">  835 </span>
<span class="lineno">  836 </span>parseDecls ::
<span class="lineno">  837 </span>  (?fileReader :: FilePath -&gt; IO ByteString) =&gt;
<span class="lineno">  838 </span>  SharedContext -&gt; CryptolEnv -&gt; InputText -&gt; IO CryptolEnv
<span class="lineno">  839 </span><span class="decl"><span class="istickedoff">parseDecls sc env input = do</span>
<span class="lineno">  840 </span><span class="spaces">  </span><span class="istickedoff">let modEnv = eModuleEnv env</span>
<span class="lineno">  841 </span><span class="spaces">  </span><span class="istickedoff">let ifaceDecls = getAllIfaceDecls modEnv</span>
<span class="lineno">  842 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  843 </span><span class="spaces">  </span><span class="istickedoff">-- Parse</span>
<span class="lineno">  844 </span><span class="spaces">  </span><span class="istickedoff">(decls :: [P.Decl P.PName]) &lt;- ioParseDecls input</span>
<span class="lineno">  845 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  846 </span><span class="spaces">  </span><span class="istickedoff">(tmodule, modEnv') &lt;- liftModuleM modEnv $ do</span>
<span class="lineno">  847 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  848 </span><span class="spaces">    </span><span class="istickedoff">-- Eliminate patterns</span>
<span class="lineno">  849 </span><span class="spaces">    </span><span class="istickedoff">(npdecls :: [P.Decl P.PName]) &lt;- MM.interactive (MB.noPat decls)</span>
<span class="lineno">  850 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  851 </span><span class="spaces">    </span><span class="istickedoff">-- Convert from 'Decl' to 'TopDecl' so that types will be generalized</span>
<span class="lineno">  852 </span><span class="spaces">    </span><span class="istickedoff">let topdecls = [ P.Decl (P.TopLevel P.Public Nothing d) | d &lt;- npdecls ]</span>
<span class="lineno">  853 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  854 </span><span class="spaces">    </span><span class="istickedoff">-- Resolve names</span>
<span class="lineno">  855 </span><span class="spaces">    </span><span class="istickedoff">(_nenv, rdecls) &lt;- MM.interactive (MB.rename interactiveName (getNamingEnv env) (MR.renameTopDecls interactiveName topdecls))</span>
<span class="lineno">  856 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  857 </span><span class="spaces">    </span><span class="istickedoff">-- Create a Module to contain the declarations</span>
<span class="lineno">  858 </span><span class="spaces">    </span><span class="istickedoff">let rmodule = P.Module { P.mName = P.Located P.emptyRange interactiveName</span>
<span class="lineno">  859 </span><span class="spaces">                           </span><span class="istickedoff">, P.mDef  = P.NormalModule rdecls</span>
<span class="lineno">  860 </span><span class="spaces">                           </span><span class="istickedoff">, P.mInScope = <span class="nottickedoff">mempty</span></span>
<span class="lineno">  861 </span><span class="spaces">                           </span><span class="istickedoff">, P.mDocTop = Nothing</span>
<span class="lineno">  862 </span><span class="spaces">                           </span><span class="istickedoff">}</span>
<span class="lineno">  863 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  864 </span><span class="spaces">    </span><span class="istickedoff">-- Infer types</span>
<span class="lineno">  865 </span><span class="spaces">    </span><span class="istickedoff">let <span class="nottickedoff">range = fromMaybe P.emptyRange (P.getLoc rdecls)</span></span>
<span class="lineno">  866 </span><span class="spaces">    </span><span class="istickedoff">prims &lt;- MB.getPrimMap</span>
<span class="lineno">  867 </span><span class="spaces">    </span><span class="istickedoff">-- noIfaceParams because we don't support functors yet</span>
<span class="lineno">  868 </span><span class="spaces">    </span><span class="istickedoff">tcEnv &lt;- MB.genInferInput <span class="nottickedoff">range</span> prims NoParams ifaceDecls</span>
<span class="lineno">  869 </span><span class="spaces">    </span><span class="istickedoff">let tcEnv' = tcEnv { TM.inpVars = Map.union (eExtraTypes env) (TM.inpVars tcEnv)</span>
<span class="lineno">  870 </span><span class="spaces">                       </span><span class="istickedoff">, TM.inpTSyns = Map.union (eExtraTSyns env) (TM.inpTSyns tcEnv)</span>
<span class="lineno">  871 </span><span class="spaces">                       </span><span class="istickedoff">}</span>
<span class="lineno">  872 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  873 </span><span class="spaces">    </span><span class="istickedoff">out &lt;- MM.io (TM.runInferM tcEnv' (TI.inferTopModule rmodule))</span>
<span class="lineno">  874 </span><span class="spaces">    </span><span class="istickedoff">tmodule &lt;- MM.interactive (runInferOutput out)</span>
<span class="lineno">  875 </span><span class="spaces">    </span><span class="istickedoff">m &lt;- case tmodule of</span>
<span class="lineno">  876 </span><span class="spaces">           </span><span class="istickedoff">T.TCTopModule m -&gt; pure m</span>
<span class="lineno">  877 </span><span class="spaces">           </span><span class="istickedoff">T.TCTopSignature {} -&gt;</span>
<span class="lineno">  878 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">fail &quot;Expected a module, but found an interface.&quot;</span></span>
<span class="lineno">  879 </span><span class="spaces">    </span><span class="istickedoff">return m</span>
<span class="lineno">  880 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  881 </span><span class="spaces">  </span><span class="istickedoff">-- Add new type synonyms and their name bindings to the environment</span>
<span class="lineno">  882 </span><span class="spaces">  </span><span class="istickedoff">let syns' = Map.union (eExtraTSyns env) (T.mTySyns tmodule)</span>
<span class="lineno">  883 </span><span class="spaces">  </span><span class="istickedoff">let addName name = MR.shadowing (MN.singletonNS C.NSType (P.mkUnqual (MN.nameIdent name)) <span class="nottickedoff">name</span>)</span>
<span class="lineno">  884 </span><span class="spaces">  </span><span class="istickedoff">let names' = foldr addName (eExtraNames env) (Map.keys (T.mTySyns tmodule))</span>
<span class="lineno">  885 </span><span class="spaces">  </span><span class="istickedoff">let env' = env { eModuleEnv = modEnv', eExtraNames = names', eExtraTSyns = syns' }</span>
<span class="lineno">  886 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  887 </span><span class="spaces">  </span><span class="istickedoff">-- Translate</span>
<span class="lineno">  888 </span><span class="spaces">  </span><span class="istickedoff">let dgs = T.mDecls tmodule</span>
<span class="lineno">  889 </span><span class="spaces">  </span><span class="istickedoff">translateDeclGroups sc env' dgs</span></span>
<span class="lineno">  890 </span>
<span class="lineno">  891 </span>parseSchema ::
<span class="lineno">  892 </span>  (?fileReader :: FilePath -&gt; IO ByteString) =&gt;
<span class="lineno">  893 </span>  CryptolEnv -&gt; InputText -&gt; IO T.Schema
<span class="lineno">  894 </span><span class="decl"><span class="istickedoff">parseSchema env input = do</span>
<span class="lineno">  895 </span><span class="spaces">  </span><span class="istickedoff">let modEnv = eModuleEnv env</span>
<span class="lineno">  896 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  897 </span><span class="spaces">  </span><span class="istickedoff">-- Parse</span>
<span class="lineno">  898 </span><span class="spaces">  </span><span class="istickedoff">pschema &lt;- ioParseSchema input</span>
<span class="lineno">  899 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  900 </span><span class="spaces">  </span><span class="istickedoff">fmap fst $ liftModuleM modEnv $ do</span>
<span class="lineno">  901 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  902 </span><span class="spaces">    </span><span class="istickedoff">-- Resolve names</span>
<span class="lineno">  903 </span><span class="spaces">    </span><span class="istickedoff">let nameEnv = getNamingEnv env</span>
<span class="lineno">  904 </span><span class="spaces">    </span><span class="istickedoff">rschema &lt;- MM.interactive (MB.rename interactiveName nameEnv (MR.rename pschema))</span>
<span class="lineno">  905 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  906 </span><span class="spaces">    </span><span class="istickedoff">let ifDecls = getAllIfaceDecls modEnv</span>
<span class="lineno">  907 </span><span class="spaces">    </span><span class="istickedoff">let <span class="nottickedoff">range = fromMaybe P.emptyRange (P.getLoc rschema)</span></span>
<span class="lineno">  908 </span><span class="spaces">    </span><span class="istickedoff">prims &lt;- MB.getPrimMap</span>
<span class="lineno">  909 </span><span class="spaces">    </span><span class="istickedoff">-- noIfaceParams because we don't support functors yet</span>
<span class="lineno">  910 </span><span class="spaces">    </span><span class="istickedoff">tcEnv &lt;- MB.genInferInput <span class="nottickedoff">range</span> prims NoParams ifDecls</span>
<span class="lineno">  911 </span><span class="spaces">    </span><span class="istickedoff">let tcEnv' = tcEnv { TM.inpTSyns = Map.union (eExtraTSyns env) (TM.inpTSyns tcEnv) }</span>
<span class="lineno">  912 </span><span class="spaces">    </span><span class="istickedoff">let infer =</span>
<span class="lineno">  913 </span><span class="spaces">          </span><span class="istickedoff">case rschema of</span>
<span class="lineno">  914 </span><span class="spaces">            </span><span class="istickedoff">P.Forall [] [] t _ -&gt; do</span>
<span class="lineno">  915 </span><span class="spaces">              </span><span class="istickedoff">let k = Nothing -- allow either kind KNum or KType</span>
<span class="lineno">  916 </span><span class="spaces">              </span><span class="istickedoff">(t', goals) &lt;- TM.collectGoals $ TK.checkType t k</span>
<span class="lineno">  917 </span><span class="spaces">              </span><span class="istickedoff">return (T.Forall [] [] t', goals)</span>
<span class="lineno">  918 </span><span class="spaces">            </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">TK.checkSchema TM.AllowWildCards rschema</span></span>
<span class="lineno">  919 </span><span class="spaces">    </span><span class="istickedoff">out &lt;- MM.io (TM.runInferM tcEnv' infer)</span>
<span class="lineno">  920 </span><span class="spaces">    </span><span class="istickedoff">(schema, _goals) &lt;- MM.interactive (runInferOutput out)</span>
<span class="lineno">  921 </span><span class="spaces">    </span><span class="istickedoff">--mapM_ (MM.io . print . TP.ppWithNames TP.emptyNameMap) goals</span>
<span class="lineno">  922 </span><span class="spaces">    </span><span class="istickedoff">return (schemaNoUser schema)</span></span>
<span class="lineno">  923 </span>
<span class="lineno">  924 </span>declareName ::
<span class="lineno">  925 </span>  (?fileReader :: FilePath -&gt; IO ByteString) =&gt;
<span class="lineno">  926 </span>  CryptolEnv -&gt; P.ModName -&gt; Text -&gt; IO (T.Name, CryptolEnv)
<span class="lineno">  927 </span><span class="decl"><span class="nottickedoff">declareName env mname input = do</span>
<span class="lineno">  928 </span><span class="spaces">  </span><span class="nottickedoff">let pname = P.mkUnqual (mkIdent input)</span>
<span class="lineno">  929 </span><span class="spaces">  </span><span class="nottickedoff">let modEnv = eModuleEnv env</span>
<span class="lineno">  930 </span><span class="spaces">  </span><span class="nottickedoff">(cname, modEnv') &lt;-</span>
<span class="lineno">  931 </span><span class="spaces">    </span><span class="nottickedoff">liftModuleM modEnv $ MM.interactive $</span>
<span class="lineno">  932 </span><span class="spaces">    </span><span class="nottickedoff">MN.liftSupply (MN.mkDeclared C.NSValue (C.TopModule mname) MN.UserName (P.getIdent pname) Nothing P.emptyRange)</span>
<span class="lineno">  933 </span><span class="spaces">  </span><span class="nottickedoff">let env' = env { eModuleEnv = modEnv' }</span>
<span class="lineno">  934 </span><span class="spaces">  </span><span class="nottickedoff">return (cname, env')</span></span>
<span class="lineno">  935 </span>
<span class="lineno">  936 </span>typeNoUser :: T.Type -&gt; T.Type
<span class="lineno">  937 </span><span class="decl"><span class="istickedoff">typeNoUser t =</span>
<span class="lineno">  938 </span><span class="spaces">  </span><span class="istickedoff">case t of</span>
<span class="lineno">  939 </span><span class="spaces">    </span><span class="istickedoff">T.TCon tc ts   -&gt; T.TCon tc (map typeNoUser ts)</span>
<span class="lineno">  940 </span><span class="spaces">    </span><span class="istickedoff">T.TVar {}      -&gt; <span class="nottickedoff">t</span></span>
<span class="lineno">  941 </span><span class="spaces">    </span><span class="istickedoff">T.TUser _ _ ty -&gt; typeNoUser ty</span>
<span class="lineno">  942 </span><span class="spaces">    </span><span class="istickedoff">T.TRec fields  -&gt; <span class="nottickedoff">T.TRec (fmap typeNoUser fields)</span></span>
<span class="lineno">  943 </span><span class="spaces">    </span><span class="istickedoff">T.TNominal nt ts -&gt; <span class="nottickedoff">T.TNominal nt (fmap typeNoUser ts)</span></span></span>
<span class="lineno">  944 </span>
<span class="lineno">  945 </span>schemaNoUser :: T.Schema -&gt; T.Schema
<span class="lineno">  946 </span><span class="decl"><span class="istickedoff">schemaNoUser (T.Forall params props ty) = T.Forall params props (typeNoUser ty)</span></span>
<span class="lineno">  947 </span>
<span class="lineno">  948 </span>------------------------------------------------------------
<span class="lineno">  949 </span>
<span class="lineno">  950 </span>liftModuleM ::
<span class="lineno">  951 </span>  (?fileReader :: FilePath -&gt; IO ByteString) =&gt;
<span class="lineno">  952 </span>  ME.ModuleEnv -&gt; MM.ModuleM a -&gt; IO (a, ME.ModuleEnv)
<span class="lineno">  953 </span><span class="decl"><span class="istickedoff">liftModuleM env m =</span>
<span class="lineno">  954 </span><span class="spaces">  </span><span class="istickedoff">do let minp solver = MM.ModuleInput {</span>
<span class="lineno">  955 </span><span class="spaces">             </span><span class="istickedoff">MM.minpCallStacks = True,</span>
<span class="lineno">  956 </span><span class="spaces">             </span><span class="istickedoff">MM.minpSaveRenamed = False,</span>
<span class="lineno">  957 </span><span class="spaces">             </span><span class="istickedoff">MM.minpEvalOpts = pure defaultEvalOpts,</span>
<span class="lineno">  958 </span><span class="spaces">             </span><span class="istickedoff">MM.minpByteReader = ?fileReader,</span>
<span class="lineno">  959 </span><span class="spaces">             </span><span class="istickedoff">MM.minpModuleEnv = env,</span>
<span class="lineno">  960 </span><span class="spaces">             </span><span class="istickedoff">MM.minpTCSolver = solver</span>
<span class="lineno">  961 </span><span class="spaces">         </span><span class="istickedoff">}</span>
<span class="lineno">  962 </span><span class="spaces">     </span><span class="istickedoff">SMT.withSolver (return <span class="nottickedoff">()</span>) (meSolverConfig env) $ \solver -&gt;</span>
<span class="lineno">  963 </span><span class="spaces">       </span><span class="istickedoff">MM.runModuleM (minp solver) m &gt;&gt;= moduleCmdResult</span></span>
<span class="lineno">  964 </span>
<span class="lineno">  965 </span>defaultEvalOpts :: E.EvalOpts
<span class="lineno">  966 </span><span class="decl"><span class="istickedoff">defaultEvalOpts = E.EvalOpts quietLogger <span class="nottickedoff">E.defaultPPOpts</span></span></span>
<span class="lineno">  967 </span>
<span class="lineno">  968 </span>moduleCmdResult :: M.ModuleRes a -&gt; IO (a, ME.ModuleEnv)
<span class="lineno">  969 </span><span class="decl"><span class="istickedoff">moduleCmdResult (res, ws) = do</span>
<span class="lineno">  970 </span><span class="spaces">  </span><span class="istickedoff">mapM_ (print . pp) (concatMap suppressDefaulting ws)</span>
<span class="lineno">  971 </span><span class="spaces">  </span><span class="istickedoff">case res of</span>
<span class="lineno">  972 </span><span class="spaces">    </span><span class="istickedoff">Right (a, me) -&gt; return (a, me)</span>
<span class="lineno">  973 </span><span class="spaces">    </span><span class="istickedoff">Left err      -&gt; fail $ &quot;Cryptol error:\n&quot; ++ show (pp err) -- X.throwIO (ModuleSystemError err)</span>
<span class="lineno">  974 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  975 </span><span class="spaces">    </span><span class="istickedoff">-- If all warnings are about type defaults, pretend there are no warnings at</span>
<span class="lineno">  976 </span><span class="spaces">    </span><span class="istickedoff">-- all to avoid displaying an empty warning container.</span>
<span class="lineno">  977 </span><span class="spaces">    </span><span class="istickedoff">suppressDefaulting :: MM.ModuleWarning -&gt; [MM.ModuleWarning]</span>
<span class="lineno">  978 </span><span class="spaces">    </span><span class="istickedoff">suppressDefaulting w =</span>
<span class="lineno">  979 </span><span class="spaces">      </span><span class="istickedoff">case w of</span>
<span class="lineno">  980 </span><span class="spaces">        </span><span class="istickedoff">MM.RenamerWarnings xs -&gt; [MM.RenamerWarnings xs]</span>
<span class="lineno">  981 </span><span class="spaces">        </span><span class="istickedoff">MM.TypeCheckWarnings nm xs -&gt;</span>
<span class="lineno">  982 </span><span class="spaces">          </span><span class="istickedoff">case filter (notDefaulting . snd) xs of</span>
<span class="lineno">  983 </span><span class="spaces">            </span><span class="istickedoff">[] -&gt; []</span>
<span class="lineno">  984 </span><span class="spaces">            </span><span class="istickedoff">xs' -&gt; [MM.TypeCheckWarnings <span class="nottickedoff">nm</span> xs']</span>
<span class="lineno">  985 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  986 </span><span class="spaces">    </span><span class="istickedoff">notDefaulting :: TE.Warning -&gt; Bool</span>
<span class="lineno">  987 </span><span class="spaces">    </span><span class="istickedoff">notDefaulting (TE.DefaultingTo {}) = False</span>
<span class="lineno">  988 </span><span class="spaces">    </span><span class="istickedoff">notDefaulting _ = True</span></span>

</pre>
</body>
</html>
