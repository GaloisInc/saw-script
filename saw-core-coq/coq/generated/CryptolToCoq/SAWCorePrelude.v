
(** Mandatory imports from saw-core-coq *)
From Coq Require Import Lists.List.
From Coq Require Import String.
From Coq Require Import Vectors.Vector.
From CryptolToCoq Require Import SAWCoreScaffolding.
From CryptolToCoq Require Import SAWCoreVectorsAsCoqVectors.
Import ListNotations.

(** Post-preamble section specified by you *)


(** Code generated by saw-core-coq *)

Module SAWCorePrelude.

(* Prelude.id was skipped *)

(* Prelude.fix was skipped *)

(* Prelude.UnitType was skipped *)

(* Prelude.UnitType__rec was skipped *)

(* Prelude.PairType was skipped *)

Definition pair_example : forall (a : Type), forall (b : Type), a -> b -> SAWCoreScaffolding.PairType a b :=
  fun (a : Type) (b : Type) (x : a) (y : b) => SAWCoreScaffolding.PairValue a b x y.

(* Prelude.Pair__rec was skipped *)

Definition Pair_fst : forall (a : Type), forall (b : Type), SAWCoreScaffolding.PairType a b -> a :=
  fun (a : Type) (b : Type) => SAWCoreScaffolding.Pair__rec a b (fun (p : SAWCoreScaffolding.PairType a b) => a) (fun (x : a) (y : b) => x).

Definition Pair_snd : forall (a : Type), forall (b : Type), SAWCoreScaffolding.PairType a b -> b :=
  fun (a : Type) (b : Type) => SAWCoreScaffolding.Pair__rec a b (fun (p : SAWCoreScaffolding.PairType a b) => b) (fun (x : a) (y : b) => y).

(* Prelude.fst was skipped *)

(* Prelude.snd was skipped *)

Definition uncurry : forall (a : Type), forall (b : Type), forall (c : Type), forall (f : a -> b -> c), prod a b -> c :=
  fun (a : Type) (b : Type) (c : Type) (f : a -> b -> c) (x : prod a b) => f (SAWCoreScaffolding.fst x) (SAWCoreScaffolding.snd x).

(* Prelude.String was skipped *)

(* Prelude.error was skipped *)

(* Prelude.EmptyType was skipped *)

(* Prelude.EmptyType__rec was skipped *)

(* Prelude.RecordType was skipped *)

(* Prelude.RecordType__rec was skipped *)

(* Prelude.Eq was skipped *)

(* Prelude.Eq__rec was skipped *)

Definition eq_cong : forall (t : Type), forall (x : t), forall (y : t), SAWCoreScaffolding.Eq t x y -> forall (u : Type), forall (f : t -> u), SAWCoreScaffolding.Eq u (f x) (f y) :=
  fun (t : Type) (x : t) (y : t) (eq : SAWCoreScaffolding.Eq t x y) (u : Type) (f : t -> u) => SAWCoreScaffolding.Eq__rec t x (fun (y' : t) (eq' : SAWCoreScaffolding.Eq t x y') => SAWCoreScaffolding.Eq u (f x) (f y')) (SAWCoreScaffolding.Refl u (f x)) y eq.

Definition sym : forall (a : Type), forall (x : a), forall (y : a), SAWCoreScaffolding.Eq a x y -> SAWCoreScaffolding.Eq a y x :=
  fun (a : Type) (x : a) (y : a) (eq : SAWCoreScaffolding.Eq a x y) => SAWCoreScaffolding.Eq__rec a x (fun (y' : a) (eq' : SAWCoreScaffolding.Eq a x y') => SAWCoreScaffolding.Eq a y' x) (SAWCoreScaffolding.Refl a x) y eq.

Definition trans : forall (a : Type), forall (x : a), forall (y : a), forall (z : a), SAWCoreScaffolding.Eq a x y -> SAWCoreScaffolding.Eq a y z -> SAWCoreScaffolding.Eq a x z :=
  fun (a : Type) (x : a) (y : a) (z : a) (eq1 : SAWCoreScaffolding.Eq a x y) (eq2 : SAWCoreScaffolding.Eq a y z) => SAWCoreScaffolding.Eq__rec a y (fun (y' : a) (eq' : SAWCoreScaffolding.Eq a y y') => SAWCoreScaffolding.Eq a x y') eq1 z eq2.

Definition trans2 : forall (a : Type), forall (x : a), forall (y : a), forall (z : a), SAWCoreScaffolding.Eq a x z -> SAWCoreScaffolding.Eq a y z -> SAWCoreScaffolding.Eq a x y :=
  fun (a : Type) (x : a) (y : a) (z : a) (eq1 : SAWCoreScaffolding.Eq a x z) (eq2 : SAWCoreScaffolding.Eq a y z) => trans a x z y eq1 (sym a y z eq2).

Definition trans4 : forall (a : Type), forall (w : a), forall (x : a), forall (y : a), forall (z : a), SAWCoreScaffolding.Eq a w x -> SAWCoreScaffolding.Eq a x y -> SAWCoreScaffolding.Eq a y z -> SAWCoreScaffolding.Eq a w z :=
  fun (a : Type) (w : a) (x : a) (y : a) (z : a) (eq1 : SAWCoreScaffolding.Eq a w x) (eq2 : SAWCoreScaffolding.Eq a x y) (eq3 : SAWCoreScaffolding.Eq a y z) => trans a w x z eq1 (trans a x y z eq2 eq3).

Definition eq_inv_map : forall (a : Type), forall (b : Type), forall (a1 : a), forall (a2 : a), SAWCoreScaffolding.Eq a a1 a2 -> forall (f1 : a -> b), forall (f2 : a -> b), SAWCoreScaffolding.Eq b (f1 a2) (f2 a2) -> SAWCoreScaffolding.Eq b (f1 a1) (f2 a1) :=
  fun (a : Type) (b : Type) (a1 : a) (a2 : a) (eq_a : SAWCoreScaffolding.Eq a a1 a2) (f1 : a -> b) (f2 : a -> b) (eq_f : SAWCoreScaffolding.Eq b (f1 a2) (f2 a2)) => let var__0   := f2 a1 in
  let var__1   := f1 a2 in
  trans b (f1 a1) var__1 var__0 (eq_cong a a1 a2 eq_a b f1) (trans b var__1 (f2 a2) var__0 eq_f (eq_cong a a2 a1 (sym a a1 a2 eq_a) b f2)).

(* Prelude.unsafeAssert was skipped *)

(* Prelude.coerce was skipped *)

(* Prelude.coerce__def was skipped *)

(* Prelude.coerce__eq was skipped *)

(* Prelude.rcoerce was skipped *)

(* Prelude.unsafeCoerce was skipped *)

(* Prelude.unsafeCoerce_same was skipped *)

Definition piCong0 : forall (r : Type), forall (x : Type), forall (y : Type), SAWCoreScaffolding.Eq Type x y -> SAWCoreScaffolding.Eq Type (x -> r) (y -> r) :=
  fun (r : Type) (x : Type) (y : Type) (eq : SAWCoreScaffolding.Eq Type x y) => SAWCoreScaffolding.Eq__rec Type x (fun (y' : Type) (eq' : SAWCoreScaffolding.Eq Type x y') => SAWCoreScaffolding.Eq Type (x -> r) (y' -> r)) (SAWCoreScaffolding.Refl Type (x -> r)) y eq.

Definition piCong1 : forall (r : Type), forall (x : Type), forall (y : Type), SAWCoreScaffolding.Eq Type x y -> SAWCoreScaffolding.Eq Type (r -> x) (r -> y) :=
  fun (r : Type) (x : Type) (y : Type) (eq : SAWCoreScaffolding.Eq Type x y) => SAWCoreScaffolding.Eq__rec Type x (fun (y' : Type) (eq' : SAWCoreScaffolding.Eq Type x y') => SAWCoreScaffolding.Eq Type (r -> x) (r -> y')) (SAWCoreScaffolding.Refl Type (r -> x)) y eq.

Inductive Bit : Type :=
| Bit1 : Bit
| Bit0 : Bit
.

Definition Bit__rec : forall (p : Bit -> Type), p Bit1 -> p Bit0 -> forall (b : Bit), p b :=
  fun (p : Bit -> Type) (f1 : p Bit1) (f2 : p Bit0) (b : Bit) => SAWCorePrelude.Bit_rect p f1 f2 b.

(* Prelude.Bool was skipped *)

(* Prelude.True was skipped *)

(* Prelude.False was skipped *)

(* Prelude.iteDep was skipped *)

(* Prelude.iteDep_True was skipped *)

(* Prelude.iteDep_False was skipped *)

(* Prelude.ite was skipped *)

(* Prelude.ite_eq_iteDep was skipped *)

Definition ite_true : forall (a : Type), forall (x : a), forall (y : a), SAWCoreScaffolding.Eq a (if SAWCoreScaffolding.true then x else y) x :=
  fun (a : Type) (x : a) (y : a) => trans a (if SAWCoreScaffolding.true then x else y) (SAWCoreScaffolding.iteDep (fun (b : SAWCoreScaffolding.Bool) => a) SAWCoreScaffolding.true x y) x (SAWCoreScaffolding.ite_eq_iteDep a SAWCoreScaffolding.true x y) (SAWCoreScaffolding.iteDep_True (fun (_1 : SAWCoreScaffolding.Bool) => a) x y).

Definition ite_false : forall (a : Type), forall (x : a), forall (y : a), SAWCoreScaffolding.Eq a (if SAWCoreScaffolding.false then x else y) y :=
  fun (a : Type) (x : a) (y : a) => trans a (if SAWCoreScaffolding.false then x else y) (SAWCoreScaffolding.iteDep (fun (b : SAWCoreScaffolding.Bool) => a) SAWCoreScaffolding.false x y) y (SAWCoreScaffolding.ite_eq_iteDep a SAWCoreScaffolding.false x y) (SAWCoreScaffolding.iteDep_False (fun (_1 : SAWCoreScaffolding.Bool) => a) x y).

Definition bool2bit : SAWCoreScaffolding.Bool -> Bit :=
  fun (b : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.iteDep (fun (_1 : SAWCoreScaffolding.Bool) => Bit) b Bit1 Bit0.

Definition bool2bit_True : SAWCoreScaffolding.Eq Bit (bool2bit SAWCoreScaffolding.true) Bit1 :=
  SAWCoreScaffolding.iteDep_True (fun (_1 : SAWCoreScaffolding.Bool) => Bit) Bit1 Bit0.

Definition bool2bit_False : SAWCoreScaffolding.Eq Bit (bool2bit SAWCoreScaffolding.false) Bit0 :=
  SAWCoreScaffolding.iteDep_False (fun (_1 : SAWCoreScaffolding.Bool) => Bit) Bit1 Bit0.

Definition bit2bool : Bit -> SAWCoreScaffolding.Bool :=
  Bit__rec (fun (_1 : Bit) => SAWCoreScaffolding.Bool) SAWCoreScaffolding.true SAWCoreScaffolding.false.

Definition bit2bool_Bit1 : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (bit2bool Bit1) SAWCoreScaffolding.true :=
  SAWCoreScaffolding.Refl SAWCoreScaffolding.Bool SAWCoreScaffolding.true.

Definition bit2bool_Bit0 : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (bit2bool Bit0) SAWCoreScaffolding.false :=
  SAWCoreScaffolding.Refl SAWCoreScaffolding.Bool SAWCoreScaffolding.false.

(* Prelude.not was skipped *)

(* Prelude.not__eq was skipped *)

(* Prelude.and was skipped *)

(* Prelude.and__eq was skipped *)

(* Prelude.or was skipped *)

(* Prelude.or__eq was skipped *)

(* Prelude.xor was skipped *)

(* Prelude.xor__eq was skipped *)

(* Prelude.boolEq was skipped *)

(* Prelude.boolEq__eq was skipped *)

Definition implies : SAWCoreScaffolding.Bool -> SAWCoreScaffolding.Bool -> SAWCoreScaffolding.Bool :=
  fun (a : SAWCoreScaffolding.Bool) (b : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.or (SAWCoreScaffolding.not a) b.

Definition implies__eq : forall (a : SAWCoreScaffolding.Bool), forall (b : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (implies a b) (SAWCoreScaffolding.or (SAWCoreScaffolding.not a) b) :=
  fun (a : SAWCoreScaffolding.Bool) (b : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Refl SAWCoreScaffolding.Bool (implies a b).

Definition unitEq : SAWCoreScaffolding.UnitType -> SAWCoreScaffolding.UnitType -> SAWCoreScaffolding.Bool :=
  fun (_1 : SAWCoreScaffolding.UnitType) (_2 : SAWCoreScaffolding.UnitType) => SAWCoreScaffolding.true.

Definition pairEq : forall (a : Type), forall (b : Type), (a -> a -> SAWCoreScaffolding.Bool) -> (b -> b -> SAWCoreScaffolding.Bool) -> prod a b -> prod a b -> SAWCoreScaffolding.Bool :=
  fun (a : Type) (b : Type) (f : a -> a -> SAWCoreScaffolding.Bool) (g : b -> b -> SAWCoreScaffolding.Bool) (x : prod a b) (y : prod a b) => SAWCoreScaffolding.and (f (SAWCoreScaffolding.fst x) (SAWCoreScaffolding.fst y)) (g (SAWCoreScaffolding.snd x) (SAWCoreScaffolding.snd y)).

Definition not_True : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.not SAWCoreScaffolding.true) SAWCoreScaffolding.false :=
  trans SAWCoreScaffolding.Bool (SAWCoreScaffolding.not SAWCoreScaffolding.true) (if SAWCoreScaffolding.true then SAWCoreScaffolding.false else SAWCoreScaffolding.true) SAWCoreScaffolding.false (SAWCoreScaffolding.not__eq SAWCoreScaffolding.true) (ite_true SAWCoreScaffolding.Bool SAWCoreScaffolding.false SAWCoreScaffolding.true).

Definition not_False : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.not SAWCoreScaffolding.false) SAWCoreScaffolding.true :=
  trans SAWCoreScaffolding.Bool (SAWCoreScaffolding.not SAWCoreScaffolding.false) (if SAWCoreScaffolding.false then SAWCoreScaffolding.false else SAWCoreScaffolding.true) SAWCoreScaffolding.true (SAWCoreScaffolding.not__eq SAWCoreScaffolding.false) (ite_false SAWCoreScaffolding.Bool SAWCoreScaffolding.false SAWCoreScaffolding.true).

Definition not_not : forall (x : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.not (SAWCoreScaffolding.not x)) x :=
  fun (x : SAWCoreScaffolding.Bool) => let var__0   := SAWCoreScaffolding.not SAWCoreScaffolding.true in
  let var__1   := not_True in
  let var__2   := SAWCoreScaffolding.not SAWCoreScaffolding.false in
  let var__3   := not_False in
  SAWCoreScaffolding.iteDep (fun (b : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.not (SAWCoreScaffolding.not b)) b) x (trans SAWCoreScaffolding.Bool (SAWCoreScaffolding.not var__0) var__2 SAWCoreScaffolding.true (eq_cong SAWCoreScaffolding.Bool var__0 SAWCoreScaffolding.false var__1 SAWCoreScaffolding.Bool SAWCoreScaffolding.not) var__3) (trans SAWCoreScaffolding.Bool (SAWCoreScaffolding.not var__2) var__0 SAWCoreScaffolding.false (eq_cong SAWCoreScaffolding.Bool var__2 SAWCoreScaffolding.true var__3 SAWCoreScaffolding.Bool SAWCoreScaffolding.not) var__1).

Definition and_True1 : forall (x : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.and SAWCoreScaffolding.true x) x :=
  fun (x : SAWCoreScaffolding.Bool) => trans SAWCoreScaffolding.Bool (SAWCoreScaffolding.and SAWCoreScaffolding.true x) (if SAWCoreScaffolding.true then x else SAWCoreScaffolding.false) x (SAWCoreScaffolding.and__eq SAWCoreScaffolding.true x) (ite_true SAWCoreScaffolding.Bool x SAWCoreScaffolding.false).

Definition and_False1 : forall (x : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.and SAWCoreScaffolding.false x) SAWCoreScaffolding.false :=
  fun (x : SAWCoreScaffolding.Bool) => trans SAWCoreScaffolding.Bool (SAWCoreScaffolding.and SAWCoreScaffolding.false x) (if SAWCoreScaffolding.false then x else SAWCoreScaffolding.false) SAWCoreScaffolding.false (SAWCoreScaffolding.and__eq SAWCoreScaffolding.false x) (ite_false SAWCoreScaffolding.Bool x SAWCoreScaffolding.false).

Definition and_True2 : forall (x : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.and x SAWCoreScaffolding.true) x :=
  fun (x : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.iteDep (fun (b : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.and b SAWCoreScaffolding.true) b) x (and_True1 SAWCoreScaffolding.true) (and_False1 SAWCoreScaffolding.true).

Definition and_False2 : forall (x : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.and x SAWCoreScaffolding.false) SAWCoreScaffolding.false :=
  fun (x : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.iteDep (fun (b : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.and b SAWCoreScaffolding.false) SAWCoreScaffolding.false) x (and_True1 SAWCoreScaffolding.false) (and_False1 SAWCoreScaffolding.false).

Definition and_assoc : forall (x : SAWCoreScaffolding.Bool), forall (y : SAWCoreScaffolding.Bool), forall (z : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.and x (SAWCoreScaffolding.and y z)) (SAWCoreScaffolding.and (SAWCoreScaffolding.and x y) z) :=
  fun (x : SAWCoreScaffolding.Bool) (y : SAWCoreScaffolding.Bool) (z : SAWCoreScaffolding.Bool) => let var__0   := SAWCoreScaffolding.and x in
  let var__1   := SAWCoreScaffolding.and y SAWCoreScaffolding.true in
  let var__2   := SAWCoreScaffolding.and y SAWCoreScaffolding.false in
  let var__3   := SAWCoreScaffolding.and x y in
  let var__4   := SAWCoreScaffolding.and x var__2 in
  SAWCoreScaffolding.iteDep (fun (b : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.and x (SAWCoreScaffolding.and y b)) (SAWCoreScaffolding.and (SAWCoreScaffolding.and x y) b)) z (trans2 SAWCoreScaffolding.Bool (SAWCoreScaffolding.and x var__1) (SAWCoreScaffolding.and var__3 SAWCoreScaffolding.true) var__3 (eq_cong SAWCoreScaffolding.Bool var__1 y (and_True2 y) SAWCoreScaffolding.Bool var__0) (and_True2 var__3)) (trans2 SAWCoreScaffolding.Bool var__4 (SAWCoreScaffolding.and var__3 SAWCoreScaffolding.false) SAWCoreScaffolding.false (trans SAWCoreScaffolding.Bool var__4 (SAWCoreScaffolding.and x SAWCoreScaffolding.false) SAWCoreScaffolding.false (eq_cong SAWCoreScaffolding.Bool var__2 SAWCoreScaffolding.false (and_False2 y) SAWCoreScaffolding.Bool var__0) (and_False2 x)) (and_False2 var__3)).

Definition and_idem : forall (x : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.and x x) x :=
  fun (x : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.iteDep (fun (b : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.and b b) b) x (and_True1 SAWCoreScaffolding.true) (and_False1 SAWCoreScaffolding.false).

Definition or_True1 : forall (x : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.or SAWCoreScaffolding.true x) SAWCoreScaffolding.true :=
  fun (x : SAWCoreScaffolding.Bool) => trans SAWCoreScaffolding.Bool (SAWCoreScaffolding.or SAWCoreScaffolding.true x) (if SAWCoreScaffolding.true then SAWCoreScaffolding.true else x) SAWCoreScaffolding.true (SAWCoreScaffolding.or__eq SAWCoreScaffolding.true x) (ite_true SAWCoreScaffolding.Bool SAWCoreScaffolding.true x).

Definition or_False1 : forall (x : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.or SAWCoreScaffolding.false x) x :=
  fun (x : SAWCoreScaffolding.Bool) => trans SAWCoreScaffolding.Bool (SAWCoreScaffolding.or SAWCoreScaffolding.false x) (if SAWCoreScaffolding.false then SAWCoreScaffolding.true else x) x (SAWCoreScaffolding.or__eq SAWCoreScaffolding.false x) (ite_false SAWCoreScaffolding.Bool SAWCoreScaffolding.true x).

Definition or_True2 : forall (x : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.or x SAWCoreScaffolding.true) SAWCoreScaffolding.true :=
  fun (x : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.iteDep (fun (b : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.or b SAWCoreScaffolding.true) SAWCoreScaffolding.true) x (or_True1 SAWCoreScaffolding.true) (or_False1 SAWCoreScaffolding.true).

Definition or_False2 : forall (x : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.or x SAWCoreScaffolding.false) x :=
  fun (x : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.iteDep (fun (b : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.or b SAWCoreScaffolding.false) b) x (or_True1 SAWCoreScaffolding.false) (or_False1 SAWCoreScaffolding.false).

Definition or_assoc : forall (x : SAWCoreScaffolding.Bool), forall (y : SAWCoreScaffolding.Bool), forall (z : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.or x (SAWCoreScaffolding.or y z)) (SAWCoreScaffolding.or (SAWCoreScaffolding.or x y) z) :=
  fun (x : SAWCoreScaffolding.Bool) (y : SAWCoreScaffolding.Bool) (z : SAWCoreScaffolding.Bool) => let var__0   := SAWCoreScaffolding.or x in
  let var__1   := SAWCoreScaffolding.or y SAWCoreScaffolding.true in
  let var__2   := SAWCoreScaffolding.or y SAWCoreScaffolding.false in
  let var__3   := SAWCoreScaffolding.or x y in
  let var__4   := SAWCoreScaffolding.or x var__1 in
  SAWCoreScaffolding.iteDep (fun (b : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.or x (SAWCoreScaffolding.or y b)) (SAWCoreScaffolding.or (SAWCoreScaffolding.or x y) b)) z (trans2 SAWCoreScaffolding.Bool var__4 (SAWCoreScaffolding.or var__3 SAWCoreScaffolding.true) SAWCoreScaffolding.true (trans SAWCoreScaffolding.Bool var__4 (SAWCoreScaffolding.or x SAWCoreScaffolding.true) SAWCoreScaffolding.true (eq_cong SAWCoreScaffolding.Bool var__1 SAWCoreScaffolding.true (or_True2 y) SAWCoreScaffolding.Bool var__0) (or_True2 x)) (or_True2 var__3)) (trans2 SAWCoreScaffolding.Bool (SAWCoreScaffolding.or x var__2) (SAWCoreScaffolding.or var__3 SAWCoreScaffolding.false) var__3 (eq_cong SAWCoreScaffolding.Bool var__2 y (or_False2 y) SAWCoreScaffolding.Bool var__0) (or_False2 var__3)).

Definition or_idem : forall (x : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.or x x) x :=
  fun (x : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.iteDep (fun (b : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.or b b) b) x (or_True1 SAWCoreScaffolding.true) (or_False1 SAWCoreScaffolding.false).

Definition implies_True1 : forall (x : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (implies SAWCoreScaffolding.true x) x :=
  fun (x : SAWCoreScaffolding.Bool) => let var__0   := SAWCoreScaffolding.not SAWCoreScaffolding.true in
  trans SAWCoreScaffolding.Bool (SAWCoreScaffolding.or var__0 x) (SAWCoreScaffolding.or SAWCoreScaffolding.false x) x (eq_cong SAWCoreScaffolding.Bool var__0 SAWCoreScaffolding.false not_True SAWCoreScaffolding.Bool (fun (y : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.or y x)) (or_False1 x).

Definition implies_False1 : forall (x : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (implies SAWCoreScaffolding.false x) SAWCoreScaffolding.true :=
  fun (x : SAWCoreScaffolding.Bool) => let var__0   := SAWCoreScaffolding.not SAWCoreScaffolding.false in
  trans SAWCoreScaffolding.Bool (SAWCoreScaffolding.or var__0 x) (SAWCoreScaffolding.or SAWCoreScaffolding.true x) SAWCoreScaffolding.true (eq_cong SAWCoreScaffolding.Bool var__0 SAWCoreScaffolding.true not_False SAWCoreScaffolding.Bool (fun (y : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.or y x)) (or_True1 x).

Definition true_implies : forall (x : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (implies SAWCoreScaffolding.true x) x :=
  fun (x : SAWCoreScaffolding.Bool) => implies_True1 x.

Definition xor_True1 : forall (x : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.xor SAWCoreScaffolding.true x) (SAWCoreScaffolding.not x) :=
  fun (x : SAWCoreScaffolding.Bool) => let var__0   := SAWCoreScaffolding.not x in
  trans SAWCoreScaffolding.Bool (SAWCoreScaffolding.xor SAWCoreScaffolding.true x) (if SAWCoreScaffolding.true then var__0 else x) var__0 (SAWCoreScaffolding.xor__eq SAWCoreScaffolding.true x) (ite_true SAWCoreScaffolding.Bool var__0 x).

Definition xor_False1 : forall (x : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.xor SAWCoreScaffolding.false x) x :=
  fun (x : SAWCoreScaffolding.Bool) => let var__0   := SAWCoreScaffolding.not x in
  trans SAWCoreScaffolding.Bool (SAWCoreScaffolding.xor SAWCoreScaffolding.false x) (if SAWCoreScaffolding.false then var__0 else x) x (SAWCoreScaffolding.xor__eq SAWCoreScaffolding.false x) (ite_false SAWCoreScaffolding.Bool var__0 x).

Definition xor_False2 : forall (x : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.xor x SAWCoreScaffolding.false) x :=
  fun (x : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.iteDep (fun (b : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.xor b SAWCoreScaffolding.false) b) x (trans SAWCoreScaffolding.Bool (SAWCoreScaffolding.xor SAWCoreScaffolding.true SAWCoreScaffolding.false) (SAWCoreScaffolding.not SAWCoreScaffolding.false) SAWCoreScaffolding.true (xor_True1 SAWCoreScaffolding.false) not_False) (xor_False1 SAWCoreScaffolding.false).

Definition xor_True2 : forall (x : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.xor x SAWCoreScaffolding.true) (SAWCoreScaffolding.not x) :=
  fun (x : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.iteDep (fun (b : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.xor b SAWCoreScaffolding.true) (SAWCoreScaffolding.not b)) x (xor_True1 SAWCoreScaffolding.true) (trans2 SAWCoreScaffolding.Bool (SAWCoreScaffolding.xor SAWCoreScaffolding.false SAWCoreScaffolding.true) (SAWCoreScaffolding.not SAWCoreScaffolding.false) SAWCoreScaffolding.true (xor_False1 SAWCoreScaffolding.true) not_False).

Definition xor_same : forall (x : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.xor x x) SAWCoreScaffolding.false :=
  fun (x : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.iteDep (fun (b : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.xor b b) SAWCoreScaffolding.false) x (trans SAWCoreScaffolding.Bool (SAWCoreScaffolding.xor SAWCoreScaffolding.true SAWCoreScaffolding.true) (SAWCoreScaffolding.not SAWCoreScaffolding.true) SAWCoreScaffolding.false (xor_True1 SAWCoreScaffolding.true) not_True) (xor_False1 SAWCoreScaffolding.false).

Definition boolEq_True1 : forall (x : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.boolEq SAWCoreScaffolding.true x) x :=
  fun (x : SAWCoreScaffolding.Bool) => let var__0   := SAWCoreScaffolding.not x in
  trans SAWCoreScaffolding.Bool (SAWCoreScaffolding.boolEq SAWCoreScaffolding.true x) (if SAWCoreScaffolding.true then x else var__0) x (SAWCoreScaffolding.boolEq__eq SAWCoreScaffolding.true x) (ite_true SAWCoreScaffolding.Bool x var__0).

Definition boolEq_False1 : forall (x : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.boolEq SAWCoreScaffolding.false x) (SAWCoreScaffolding.not x) :=
  fun (x : SAWCoreScaffolding.Bool) => let var__0   := SAWCoreScaffolding.not x in
  trans SAWCoreScaffolding.Bool (SAWCoreScaffolding.boolEq SAWCoreScaffolding.false x) (if SAWCoreScaffolding.false then x else var__0) var__0 (SAWCoreScaffolding.boolEq__eq SAWCoreScaffolding.false x) (ite_false SAWCoreScaffolding.Bool x var__0).

Definition boolEq_True2 : forall (x : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.boolEq x SAWCoreScaffolding.true) x :=
  fun (x : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.iteDep (fun (b : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.boolEq b SAWCoreScaffolding.true) b) x (boolEq_True1 SAWCoreScaffolding.true) (trans SAWCoreScaffolding.Bool (SAWCoreScaffolding.boolEq SAWCoreScaffolding.false SAWCoreScaffolding.true) (SAWCoreScaffolding.not SAWCoreScaffolding.true) SAWCoreScaffolding.false (boolEq_False1 SAWCoreScaffolding.true) not_True).

Definition boolEq_False2 : forall (x : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.boolEq x SAWCoreScaffolding.false) (SAWCoreScaffolding.not x) :=
  fun (x : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.iteDep (fun (b : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.boolEq b SAWCoreScaffolding.false) (SAWCoreScaffolding.not b)) x (trans2 SAWCoreScaffolding.Bool (SAWCoreScaffolding.boolEq SAWCoreScaffolding.true SAWCoreScaffolding.false) (SAWCoreScaffolding.not SAWCoreScaffolding.true) SAWCoreScaffolding.false (boolEq_True1 SAWCoreScaffolding.false) not_True) (boolEq_False1 SAWCoreScaffolding.false).

Definition boolEq_same : forall (x : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.boolEq x x) SAWCoreScaffolding.true :=
  fun (x : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.iteDep (fun (b : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.boolEq b b) SAWCoreScaffolding.true) x (boolEq_True1 SAWCoreScaffolding.true) (trans SAWCoreScaffolding.Bool (SAWCoreScaffolding.boolEq SAWCoreScaffolding.false SAWCoreScaffolding.false) (SAWCoreScaffolding.not SAWCoreScaffolding.false) SAWCoreScaffolding.true (boolEq_False1 SAWCoreScaffolding.false) not_False).

Definition not_or : forall (x : SAWCoreScaffolding.Bool), forall (y : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.not (SAWCoreScaffolding.or x y)) (SAWCoreScaffolding.and (SAWCoreScaffolding.not x) (SAWCoreScaffolding.not y)) :=
  fun (x : SAWCoreScaffolding.Bool) (y : SAWCoreScaffolding.Bool) => let var__0   := SAWCoreScaffolding.not y in
  let var__1   := SAWCoreScaffolding.not SAWCoreScaffolding.true in
  let var__2   := not_True in
  let var__3   := SAWCoreScaffolding.not SAWCoreScaffolding.false in
  let var__4   := SAWCoreScaffolding.or SAWCoreScaffolding.true y in
  let var__5   := SAWCoreScaffolding.or SAWCoreScaffolding.false y in
  let var__6   := SAWCoreScaffolding.not var__4 in
  let var__7   := SAWCoreScaffolding.and var__1 var__0 in
  let var__8   := SAWCoreScaffolding.and SAWCoreScaffolding.false var__0 in
  let var__9   := fun (z : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.and z (SAWCoreScaffolding.not y) in
  let var__10   := SAWCoreScaffolding.and var__3 var__0 in
  SAWCoreScaffolding.iteDep (fun (b : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.not (SAWCoreScaffolding.or b y)) (SAWCoreScaffolding.and (SAWCoreScaffolding.not b) (SAWCoreScaffolding.not y))) x (trans SAWCoreScaffolding.Bool var__6 SAWCoreScaffolding.false var__7 (trans SAWCoreScaffolding.Bool var__6 var__1 SAWCoreScaffolding.false (eq_cong SAWCoreScaffolding.Bool var__4 SAWCoreScaffolding.true (or_True1 y) SAWCoreScaffolding.Bool SAWCoreScaffolding.not) var__2) (trans SAWCoreScaffolding.Bool SAWCoreScaffolding.false var__8 var__7 (sym SAWCoreScaffolding.Bool var__8 SAWCoreScaffolding.false (and_False1 var__0)) (eq_cong SAWCoreScaffolding.Bool SAWCoreScaffolding.false var__1 (sym SAWCoreScaffolding.Bool var__1 SAWCoreScaffolding.false var__2) SAWCoreScaffolding.Bool var__9))) (trans SAWCoreScaffolding.Bool (SAWCoreScaffolding.not var__5) var__0 var__10 (eq_cong SAWCoreScaffolding.Bool var__5 y (or_False1 y) SAWCoreScaffolding.Bool SAWCoreScaffolding.not) (sym SAWCoreScaffolding.Bool var__10 var__0 (trans SAWCoreScaffolding.Bool var__10 (SAWCoreScaffolding.and SAWCoreScaffolding.true var__0) var__0 (eq_cong SAWCoreScaffolding.Bool var__3 SAWCoreScaffolding.true not_False SAWCoreScaffolding.Bool var__9) (and_True1 var__0)))).

Definition not_and : forall (x : SAWCoreScaffolding.Bool), forall (y : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.not (SAWCoreScaffolding.and x y)) (SAWCoreScaffolding.or (SAWCoreScaffolding.not x) (SAWCoreScaffolding.not y)) :=
  fun (x : SAWCoreScaffolding.Bool) (y : SAWCoreScaffolding.Bool) => let var__0   := SAWCoreScaffolding.not y in
  let var__1   := SAWCoreScaffolding.not SAWCoreScaffolding.true in
  let var__2   := SAWCoreScaffolding.not SAWCoreScaffolding.false in
  let var__3   := not_False in
  let var__4   := SAWCoreScaffolding.and SAWCoreScaffolding.true y in
  let var__5   := SAWCoreScaffolding.and SAWCoreScaffolding.false y in
  let var__6   := SAWCoreScaffolding.or var__1 var__0 in
  let var__7   := fun (z : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.or z (SAWCoreScaffolding.not y) in
  let var__8   := SAWCoreScaffolding.not var__5 in
  let var__9   := SAWCoreScaffolding.or var__2 var__0 in
  let var__10   := SAWCoreScaffolding.or SAWCoreScaffolding.true var__0 in
  SAWCoreScaffolding.iteDep (fun (b : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.not (SAWCoreScaffolding.and b y)) (SAWCoreScaffolding.or (SAWCoreScaffolding.not b) (SAWCoreScaffolding.not y))) x (trans SAWCoreScaffolding.Bool (SAWCoreScaffolding.not var__4) var__0 var__6 (eq_cong SAWCoreScaffolding.Bool var__4 y (and_True1 y) SAWCoreScaffolding.Bool SAWCoreScaffolding.not) (sym SAWCoreScaffolding.Bool var__6 var__0 (trans SAWCoreScaffolding.Bool var__6 (SAWCoreScaffolding.or SAWCoreScaffolding.false var__0) var__0 (eq_cong SAWCoreScaffolding.Bool var__1 SAWCoreScaffolding.false not_True SAWCoreScaffolding.Bool var__7) (or_False1 var__0)))) (trans SAWCoreScaffolding.Bool var__8 SAWCoreScaffolding.true var__9 (trans SAWCoreScaffolding.Bool var__8 var__2 SAWCoreScaffolding.true (eq_cong SAWCoreScaffolding.Bool var__5 SAWCoreScaffolding.false (and_False1 y) SAWCoreScaffolding.Bool SAWCoreScaffolding.not) var__3) (trans SAWCoreScaffolding.Bool SAWCoreScaffolding.true var__10 var__9 (sym SAWCoreScaffolding.Bool var__10 SAWCoreScaffolding.true (or_True1 var__0)) (eq_cong SAWCoreScaffolding.Bool SAWCoreScaffolding.true var__2 (sym SAWCoreScaffolding.Bool var__2 SAWCoreScaffolding.true var__3) SAWCoreScaffolding.Bool var__7))).

Definition ite_not : forall (a : Type), forall (b : SAWCoreScaffolding.Bool), forall (x : a), forall (y : a), SAWCoreScaffolding.Eq a (if SAWCoreScaffolding.not b then x else y) (if b then y else x) :=
  fun (a : Type) (b : SAWCoreScaffolding.Bool) (x : a) (y : a) => let var__0   := SAWCoreScaffolding.not SAWCoreScaffolding.true in
  let var__1   := SAWCoreScaffolding.not SAWCoreScaffolding.false in
  let var__2   := if var__0 then x else y in
  let var__3   := if SAWCoreScaffolding.true then y else x in
  let var__4   := fun (z : SAWCoreScaffolding.Bool) => if z then x else y in
  let var__5   := if var__1 then x else y in
  let var__6   := if SAWCoreScaffolding.false then y else x in
  SAWCoreScaffolding.iteDep (fun (b' : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq a (if SAWCoreScaffolding.not b' then x else y) (if b' then y else x)) b (trans a var__2 y var__3 (trans a var__2 (if SAWCoreScaffolding.false then x else y) y (eq_cong SAWCoreScaffolding.Bool var__0 SAWCoreScaffolding.false not_True a var__4) (ite_false a x y)) (sym a var__3 y (ite_true a y x))) (trans a var__5 x var__6 (trans a var__5 (if SAWCoreScaffolding.true then x else y) x (eq_cong SAWCoreScaffolding.Bool var__1 SAWCoreScaffolding.true not_False a var__4) (ite_true a x y)) (sym a var__6 x (ite_false a y x))).

Definition ite_nest1 : forall (a : Type), forall (b : SAWCoreScaffolding.Bool), forall (x : a), forall (y : a), forall (z : a), SAWCoreScaffolding.Eq a (if b then if b then x else y else z) (if b then x else z) :=
  fun (a : Type) (b : SAWCoreScaffolding.Bool) (x : a) (y : a) (z : a) => let var__0   := if SAWCoreScaffolding.false then x else z in
  let var__1   := if SAWCoreScaffolding.false then x else y in
  let var__2   := if SAWCoreScaffolding.true then x else z in
  let var__3   := if SAWCoreScaffolding.true then x else y in
  let var__4   := if SAWCoreScaffolding.true then var__3 else z in
  SAWCoreScaffolding.iteDep (fun (b' : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq a (if b' then if b' then x else y else z) (if b' then x else z)) b (trans a var__4 x var__2 (trans a var__4 var__3 x (ite_true a var__3 z) (ite_true a x y)) (sym a var__2 x (ite_true a x z))) (trans a (if SAWCoreScaffolding.false then var__1 else z) z var__0 (ite_false a var__1 z) (sym a var__0 z (ite_false a x z))).

Definition ite_nest2 : forall (a : Type), forall (b : SAWCoreScaffolding.Bool), forall (x : a), forall (y : a), forall (z : a), SAWCoreScaffolding.Eq a (if b then x else if b then y else z) (if b then x else z) :=
  fun (a : Type) (b : SAWCoreScaffolding.Bool) (x : a) (y : a) (z : a) => let var__0   := if SAWCoreScaffolding.true then y else z in
  let var__1   := if SAWCoreScaffolding.false then y else z in
  let var__2   := if SAWCoreScaffolding.false then x else z in
  let var__3   := if SAWCoreScaffolding.true then x else z in
  let var__4   := if SAWCoreScaffolding.false then x else var__1 in
  SAWCoreScaffolding.iteDep (fun (b' : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq a (if b' then x else if b' then y else z) (if b' then x else z)) b (trans a (if SAWCoreScaffolding.true then x else var__0) x var__3 (ite_true a x var__0) (sym a var__3 x (ite_true a x z))) (trans a var__4 z var__2 (trans a var__4 var__1 z (ite_false a x var__1) (ite_false a y z)) (sym a var__2 z (ite_false a x z))).

(* Prelude.ite_bit was skipped *)

Definition ite_bit_false_1 : forall (b : SAWCoreScaffolding.Bool), forall (c : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (if b then SAWCoreScaffolding.false else c) (SAWCoreScaffolding.and (SAWCoreScaffolding.not b) c) :=
  fun (b : SAWCoreScaffolding.Bool) (c : SAWCoreScaffolding.Bool) => let var__0   := SAWCoreScaffolding.not SAWCoreScaffolding.true in
  let var__1   := SAWCoreScaffolding.not SAWCoreScaffolding.false in
  let var__2   := SAWCoreScaffolding.and var__0 c in
  let var__3   := fun (z : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.and z c in
  let var__4   := SAWCoreScaffolding.and var__1 c in
  SAWCoreScaffolding.iteDep (fun (b' : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (if b' then SAWCoreScaffolding.false else c) (SAWCoreScaffolding.and (SAWCoreScaffolding.not b') c)) b (trans SAWCoreScaffolding.Bool (if SAWCoreScaffolding.true then SAWCoreScaffolding.false else c) SAWCoreScaffolding.false var__2 (ite_true SAWCoreScaffolding.Bool SAWCoreScaffolding.false c) (sym SAWCoreScaffolding.Bool var__2 SAWCoreScaffolding.false (trans SAWCoreScaffolding.Bool var__2 (SAWCoreScaffolding.and SAWCoreScaffolding.false c) SAWCoreScaffolding.false (eq_cong SAWCoreScaffolding.Bool var__0 SAWCoreScaffolding.false not_True SAWCoreScaffolding.Bool var__3) (and_False1 c)))) (trans SAWCoreScaffolding.Bool (if SAWCoreScaffolding.false then SAWCoreScaffolding.false else c) c var__4 (ite_false SAWCoreScaffolding.Bool SAWCoreScaffolding.false c) (sym SAWCoreScaffolding.Bool var__4 c (trans SAWCoreScaffolding.Bool var__4 (SAWCoreScaffolding.and SAWCoreScaffolding.true c) c (eq_cong SAWCoreScaffolding.Bool var__1 SAWCoreScaffolding.true not_False SAWCoreScaffolding.Bool var__3) (and_True1 c)))).

Definition ite_bit_true_1 : forall (b : SAWCoreScaffolding.Bool), forall (c : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (if b then SAWCoreScaffolding.true else c) (SAWCoreScaffolding.or b c) :=
  fun (b : SAWCoreScaffolding.Bool) (c : SAWCoreScaffolding.Bool) => let var__0   := SAWCoreScaffolding.or SAWCoreScaffolding.true c in
  let var__1   := SAWCoreScaffolding.or SAWCoreScaffolding.false c in
  SAWCoreScaffolding.iteDep (fun (b' : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (if b' then SAWCoreScaffolding.true else c) (SAWCoreScaffolding.or b' c)) b (trans SAWCoreScaffolding.Bool (if SAWCoreScaffolding.true then SAWCoreScaffolding.true else c) SAWCoreScaffolding.true var__0 (ite_true SAWCoreScaffolding.Bool SAWCoreScaffolding.true c) (sym SAWCoreScaffolding.Bool var__0 SAWCoreScaffolding.true (or_True1 c))) (trans SAWCoreScaffolding.Bool (if SAWCoreScaffolding.false then SAWCoreScaffolding.true else c) c var__1 (ite_false SAWCoreScaffolding.Bool SAWCoreScaffolding.true c) (sym SAWCoreScaffolding.Bool var__1 c (or_False1 c))).

Definition ite_fold_not : forall (b : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (if b then SAWCoreScaffolding.false else SAWCoreScaffolding.true) (SAWCoreScaffolding.not b) :=
  fun (b : SAWCoreScaffolding.Bool) => let var__0   := SAWCoreScaffolding.not SAWCoreScaffolding.true in
  let var__1   := SAWCoreScaffolding.not SAWCoreScaffolding.false in
  SAWCoreScaffolding.iteDep (fun (b' : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (if b' then SAWCoreScaffolding.false else SAWCoreScaffolding.true) (SAWCoreScaffolding.not b')) b (trans SAWCoreScaffolding.Bool (if SAWCoreScaffolding.true then SAWCoreScaffolding.false else SAWCoreScaffolding.true) SAWCoreScaffolding.false var__0 (ite_true SAWCoreScaffolding.Bool SAWCoreScaffolding.false SAWCoreScaffolding.true) (sym SAWCoreScaffolding.Bool var__0 SAWCoreScaffolding.false not_True)) (trans SAWCoreScaffolding.Bool (if SAWCoreScaffolding.false then SAWCoreScaffolding.false else SAWCoreScaffolding.true) SAWCoreScaffolding.true var__1 (ite_false SAWCoreScaffolding.Bool SAWCoreScaffolding.false SAWCoreScaffolding.true) (sym SAWCoreScaffolding.Bool var__1 SAWCoreScaffolding.true not_False)).

Definition ite_eq : forall (a : Type), forall (b : SAWCoreScaffolding.Bool), forall (x : a), SAWCoreScaffolding.Eq a (if b then x else x) x :=
  fun (a : Type) (b : SAWCoreScaffolding.Bool) (x : a) => SAWCoreScaffolding.iteDep (fun (b' : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq a (if b' then x else x) x) b (ite_true a x x) (ite_false a x x).

Definition or_triv1 : forall (x : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.or x (SAWCoreScaffolding.not x)) SAWCoreScaffolding.true :=
  fun (x : SAWCoreScaffolding.Bool) => let var__0   := SAWCoreScaffolding.not SAWCoreScaffolding.false in
  SAWCoreScaffolding.iteDep (fun (b : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.or b (SAWCoreScaffolding.not b)) SAWCoreScaffolding.true) x (or_True1 (SAWCoreScaffolding.not SAWCoreScaffolding.true)) (trans SAWCoreScaffolding.Bool (SAWCoreScaffolding.or SAWCoreScaffolding.false var__0) var__0 SAWCoreScaffolding.true (or_False1 var__0) not_False).

Definition or_triv2 : forall (x : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.or (SAWCoreScaffolding.not x) x) SAWCoreScaffolding.true :=
  fun (x : SAWCoreScaffolding.Bool) => let var__0   := SAWCoreScaffolding.not SAWCoreScaffolding.false in
  SAWCoreScaffolding.iteDep (fun (b : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.or (SAWCoreScaffolding.not b) b) SAWCoreScaffolding.true) x (or_True2 (SAWCoreScaffolding.not SAWCoreScaffolding.true)) (trans SAWCoreScaffolding.Bool (SAWCoreScaffolding.or var__0 SAWCoreScaffolding.false) var__0 SAWCoreScaffolding.true (or_False2 var__0) not_False).

Definition and_triv1 : forall (x : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.and x (SAWCoreScaffolding.not x)) SAWCoreScaffolding.false :=
  fun (x : SAWCoreScaffolding.Bool) => let var__0   := SAWCoreScaffolding.not SAWCoreScaffolding.true in
  SAWCoreScaffolding.iteDep (fun (b : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.and b (SAWCoreScaffolding.not b)) SAWCoreScaffolding.false) x (trans SAWCoreScaffolding.Bool (SAWCoreScaffolding.and SAWCoreScaffolding.true var__0) var__0 SAWCoreScaffolding.false (and_True1 var__0) not_True) (and_False1 (SAWCoreScaffolding.not SAWCoreScaffolding.false)).

Definition and_triv2 : forall (x : SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.and (SAWCoreScaffolding.not x) x) SAWCoreScaffolding.false :=
  fun (x : SAWCoreScaffolding.Bool) => let var__0   := SAWCoreScaffolding.not SAWCoreScaffolding.true in
  SAWCoreScaffolding.iteDep (fun (b : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreScaffolding.and (SAWCoreScaffolding.not b) b) SAWCoreScaffolding.false) x (trans SAWCoreScaffolding.Bool (SAWCoreScaffolding.and var__0 SAWCoreScaffolding.true) var__0 SAWCoreScaffolding.false (and_True2 var__0) not_True) (and_False2 (SAWCoreScaffolding.not SAWCoreScaffolding.false)).

Definition EqTrue : SAWCoreScaffolding.Bool -> Prop :=
  fun (x : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool x SAWCoreScaffolding.true.

Definition TrueI : EqTrue SAWCoreScaffolding.true :=
  SAWCoreScaffolding.Refl SAWCoreScaffolding.Bool SAWCoreScaffolding.true.

Definition andI : forall (x : SAWCoreScaffolding.Bool), forall (y : SAWCoreScaffolding.Bool), EqTrue x -> EqTrue y -> EqTrue (SAWCoreScaffolding.and x y) :=
  fun (x : SAWCoreScaffolding.Bool) (y : SAWCoreScaffolding.Bool) (p : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool x SAWCoreScaffolding.true) (q : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool y SAWCoreScaffolding.true) => trans4 SAWCoreScaffolding.Bool (SAWCoreScaffolding.and x y) (SAWCoreScaffolding.and x SAWCoreScaffolding.true) x SAWCoreScaffolding.true (eq_cong SAWCoreScaffolding.Bool y SAWCoreScaffolding.true q SAWCoreScaffolding.Bool (SAWCoreScaffolding.and x)) (and_True2 x) p.

Definition impliesI : forall (x : SAWCoreScaffolding.Bool), forall (y : SAWCoreScaffolding.Bool), (EqTrue x -> EqTrue y) -> EqTrue (implies x y) :=
  fun (x : SAWCoreScaffolding.Bool) (y : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.iteDep (fun (x1 : SAWCoreScaffolding.Bool) => (EqTrue x1 -> EqTrue y) -> EqTrue (implies x1 y)) x (fun (H : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.true -> SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool y SAWCoreScaffolding.true) => trans SAWCoreScaffolding.Bool (implies SAWCoreScaffolding.true y) y SAWCoreScaffolding.true (implies_True1 y) (H TrueI)) (fun (_1 : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.false SAWCoreScaffolding.true -> SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool y SAWCoreScaffolding.true) => implies_False1 y).

Inductive Either (s : Type) (t : Type) : Type :=
| Left : s -> Either s t
| Right : t -> Either s t
.

Definition Either__rec : forall (s : Type), forall (t : Type), forall (p : Either s t -> Type), (forall (l : s), p (Left s t l)) -> (forall (r : t), p (Right s t r)) -> forall (e : Either s t), p e :=
  fun (s : Type) (t : Type) (p : Either s t -> Type) (f1 : forall (l : s), p (Left s t l)) (f2 : forall (r : t), p (Right s t r)) (e : Either s t) => SAWCorePrelude.Either_rect s t p f1 f2 e.

Definition either : forall (a : Type), forall (b : Type), forall (c : Type), (a -> c) -> (b -> c) -> Either a b -> c :=
  fun (a : Type) (b : Type) (c : Type) (f : a -> c) (g : b -> c) (e : Either a b) => Either__rec a b (fun (p : Either a b) => c) f g e.

Definition eitherCong0 : forall (t : Type), forall (x : Type), forall (y : Type), SAWCoreScaffolding.Eq Type x y -> SAWCoreScaffolding.Eq Type (Either x t) (Either y t) :=
  fun (t : Type) (x : Type) (y : Type) (eq : SAWCoreScaffolding.Eq Type x y) => eq_cong Type x y eq Type (fun (y' : Type) => Either y' t).

Definition eitherCong1 : forall (t : Type), forall (x : Type), forall (y : Type), SAWCoreScaffolding.Eq Type x y -> SAWCoreScaffolding.Eq Type (Either t x) (Either t y) :=
  fun (t : Type) (x : Type) (y : Type) (eq : SAWCoreScaffolding.Eq Type x y) => eq_cong Type x y eq Type (fun (y' : Type) => Either t y').

Definition boolToEither : SAWCoreScaffolding.Bool -> Either (unit : Type) (unit : Type) :=
  fun (b : SAWCoreScaffolding.Bool) => if b then Left (unit : Type) (unit : Type) tt else Right (unit : Type) (unit : Type) tt.

Inductive Maybe (a : Type) : Type :=
| Nothing :  Maybe a
| Just : a -> Maybe a
.

Definition Maybe__rec : forall (a : Type), forall (p : Maybe a -> Type), p (Nothing a) -> (forall (x : a), p (Just a x)) -> forall (m : Maybe a), p m :=
  fun (a : Type) (p : Maybe a -> Type) (f1 : p (Nothing a)) (f2 : forall (x : a), p (Just a x)) (m : Maybe a) => SAWCorePrelude.Maybe_rect a p f1 f2 m.

Definition maybe : forall (a : Type), forall (b : Type), b -> (a -> b) -> Maybe a -> b :=
  fun (a : Type) (b : Type) (f1 : b) (f2 : a -> b) (m : Maybe a) => Maybe__rec a (fun (m' : Maybe a) => b) f1 f2 m.

(* Prelude.Nat was skipped *)

Definition Nat__rec : forall (p : SAWCoreScaffolding.Nat -> Type), p SAWCoreScaffolding.Zero -> (forall (n : SAWCoreScaffolding.Nat), p n -> p (SAWCoreScaffolding.Succ n)) -> forall (n : SAWCoreScaffolding.Nat), p n :=
  fun (p : SAWCoreScaffolding.Nat -> Type) (f1 : p 0) (f2 : forall (n : SAWCoreScaffolding.Nat), p n -> p (SAWCoreScaffolding.Succ n)) (n : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Nat_rect p f1 f2 n.

Definition Nat_cases : forall (a : Type), a -> (SAWCoreScaffolding.Nat -> a -> a) -> SAWCoreScaffolding.Nat -> a :=
  fun (a : Type) (f1 : a) (f2 : SAWCoreScaffolding.Nat -> a -> a) (n : SAWCoreScaffolding.Nat) => Nat__rec (fun (n1 : SAWCoreScaffolding.Nat) => a) f1 f2 n.

Definition Nat_cases2 : forall (a : Type), (SAWCoreScaffolding.Nat -> a) -> (SAWCoreScaffolding.Nat -> a) -> (SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Nat -> a -> a) -> SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Nat -> a :=
  fun (a : Type) (f1 : SAWCoreScaffolding.Nat -> a) (f2 : SAWCoreScaffolding.Nat -> a) (f3 : SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Nat -> a -> a) (n : SAWCoreScaffolding.Nat) (m : SAWCoreScaffolding.Nat) => Nat__rec (fun (n1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Nat -> a) f1 (fun (n1 : SAWCoreScaffolding.Nat) (f_rec : SAWCoreScaffolding.Nat -> a) (m1 : SAWCoreScaffolding.Nat) => Nat__rec (fun (m' : SAWCoreScaffolding.Nat) => a) (f2 n1) (fun (m' : SAWCoreScaffolding.Nat) (frec' : a) => f3 n1 m' (f_rec m')) m1) n m.

Definition eqNat : SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Nat -> Type :=
  fun (x : SAWCoreScaffolding.Nat) (y : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Nat x y.

Definition eqNatSucc : forall (x : SAWCoreScaffolding.Nat), forall (y : SAWCoreScaffolding.Nat), eqNat x y -> eqNat (SAWCoreScaffolding.Succ x) (SAWCoreScaffolding.Succ y) :=
  fun (x : SAWCoreScaffolding.Nat) (y : SAWCoreScaffolding.Nat) (eq : SAWCoreScaffolding.Eq SAWCoreScaffolding.Nat x y) => eq_cong SAWCoreScaffolding.Nat x y eq SAWCoreScaffolding.Nat (fun (n : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Succ n).

Definition pred : SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Nat :=
  fun (x : SAWCoreScaffolding.Nat) => Nat_cases SAWCoreScaffolding.Nat SAWCoreScaffolding.Zero (fun (n : SAWCoreScaffolding.Nat) (m : SAWCoreScaffolding.Nat) => n) x.

Definition eqNatPrec : forall (x : SAWCoreScaffolding.Nat), forall (y : SAWCoreScaffolding.Nat), eqNat (SAWCoreScaffolding.Succ x) (SAWCoreScaffolding.Succ y) -> eqNat x y :=
  fun (x : SAWCoreScaffolding.Nat) (y : SAWCoreScaffolding.Nat) (eq' : SAWCoreScaffolding.Eq SAWCoreScaffolding.Nat (SAWCoreScaffolding.Succ x) (SAWCoreScaffolding.Succ y)) => eq_cong SAWCoreScaffolding.Nat (SAWCoreScaffolding.Succ x) (SAWCoreScaffolding.Succ y) eq' SAWCoreScaffolding.Nat pred.

Inductive IsLeNat (n : SAWCoreScaffolding.Nat) : forall (_1 : SAWCoreScaffolding.Nat), Prop :=
| IsLeNat_base :  IsLeNat n n
| IsLeNat_succ : forall (m : SAWCoreScaffolding.Nat), IsLeNat n m -> IsLeNat n (SAWCoreScaffolding.Succ m)
.

Definition IsLtNat : SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Nat -> Prop :=
  fun (m : SAWCoreScaffolding.Nat) (n : SAWCoreScaffolding.Nat) => IsLeNat (SAWCoreScaffolding.Succ m) n.

Axiom natCompareLe : forall (m : SAWCoreScaffolding.Nat), forall (n : SAWCoreScaffolding.Nat), Either (IsLtNat m n) (IsLeNat n m) .

Axiom proveEqNat : forall (m : SAWCoreScaffolding.Nat), forall (n : SAWCoreScaffolding.Nat), Maybe (SAWCoreScaffolding.Eq SAWCoreScaffolding.Nat m n) .

Axiom proveLeNat : forall (x : SAWCoreScaffolding.Nat), forall (y : SAWCoreScaffolding.Nat), Maybe (IsLeNat x y) .

Definition proveLtNat : forall (x : SAWCoreScaffolding.Nat), forall (y : SAWCoreScaffolding.Nat), Maybe (IsLtNat x y) :=
  fun (x : SAWCoreScaffolding.Nat) (y : SAWCoreScaffolding.Nat) => proveLeNat (SAWCoreScaffolding.Succ x) y.

Definition addNat : SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Nat :=
  fun (x : SAWCoreScaffolding.Nat) (y : SAWCoreScaffolding.Nat) => Nat_cases SAWCoreScaffolding.Nat y (fun (_1 : SAWCoreScaffolding.Nat) (prev_sum : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Succ prev_sum) x.

Definition eqNatAdd0 : forall (x : SAWCoreScaffolding.Nat), eqNat (addNat x 0) x :=
  fun (x : SAWCoreScaffolding.Nat) => Nat__rec (fun (n : SAWCoreScaffolding.Nat) => eqNat (addNat n 0) n) (SAWCoreScaffolding.Refl SAWCoreScaffolding.Nat 0) (fun (n : SAWCoreScaffolding.Nat) => eqNatSucc (addNat n 0) n) x.

Definition eqNatAddS : forall (x : SAWCoreScaffolding.Nat), forall (y : SAWCoreScaffolding.Nat), eqNat (addNat x (SAWCoreScaffolding.Succ y)) (SAWCoreScaffolding.Succ (addNat x y)) :=
  fun (x : SAWCoreScaffolding.Nat) (y : SAWCoreScaffolding.Nat) => Nat__rec (fun (x' : SAWCoreScaffolding.Nat) => forall (y' : SAWCoreScaffolding.Nat), eqNat (addNat x' (SAWCoreScaffolding.Succ y')) (SAWCoreScaffolding.Succ (addNat x' y'))) (fun (y' : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Refl SAWCoreScaffolding.Nat (SAWCoreScaffolding.Succ y')) (fun (x' : SAWCoreScaffolding.Nat) (eqF : forall (y' : SAWCoreScaffolding.Nat), SAWCoreScaffolding.Eq SAWCoreScaffolding.Nat (SAWCoreScaffolding.Nat_rect (fun (n : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Nat) (SAWCoreScaffolding.Succ y') (fun (_1 : SAWCoreScaffolding.Nat) (prev_sum : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Succ prev_sum) x') (SAWCoreScaffolding.Succ (addNat x' y'))) (y' : SAWCoreScaffolding.Nat) => eqNatSucc (addNat x' (SAWCoreScaffolding.Succ y')) (SAWCoreScaffolding.Succ (addNat x' y')) (eqF y')) x y.

Definition eqNatAddComm : forall (x : SAWCoreScaffolding.Nat), forall (y : SAWCoreScaffolding.Nat), eqNat (addNat x y) (addNat y x) :=
  fun (x : SAWCoreScaffolding.Nat) (y : SAWCoreScaffolding.Nat) => Nat__rec (fun (y' : SAWCoreScaffolding.Nat) => forall (x' : SAWCoreScaffolding.Nat), eqNat (addNat x' y') (addNat y' x')) (fun (x' : SAWCoreScaffolding.Nat) => eqNatAdd0 x') (fun (y' : SAWCoreScaffolding.Nat) (eqF : forall (x' : SAWCoreScaffolding.Nat), let var__0   := fun (n : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Nat in
  let var__1   := fun (_1 : SAWCoreScaffolding.Nat) (prev_sum : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Succ prev_sum in
  SAWCoreScaffolding.Eq SAWCoreScaffolding.Nat (SAWCoreScaffolding.Nat_rect var__0 y' var__1 x') (SAWCoreScaffolding.Nat_rect var__0 x' var__1 y')) (x' : SAWCoreScaffolding.Nat) => let var__0   := addNat y' x' in
  let var__1   := addNat x' y' in
  trans SAWCoreScaffolding.Nat (addNat x' (SAWCoreScaffolding.Succ y')) (SAWCoreScaffolding.Succ var__1) (SAWCoreScaffolding.Succ var__0) (eqNatAddS x' y') (eqNatSucc var__1 var__0 (eqF x'))) y x.

Definition addNat_assoc : forall (x : SAWCoreScaffolding.Nat), forall (y : SAWCoreScaffolding.Nat), forall (z : SAWCoreScaffolding.Nat), eqNat (addNat x (addNat y z)) (addNat (addNat x y) z) :=
  fun (x : SAWCoreScaffolding.Nat) (y : SAWCoreScaffolding.Nat) (z : SAWCoreScaffolding.Nat) => Nat__rec (fun (x' : SAWCoreScaffolding.Nat) => eqNat (addNat x' (addNat y z)) (addNat (addNat x' y) z)) (SAWCoreScaffolding.Refl SAWCoreScaffolding.Nat (addNat y z)) (fun (x' : SAWCoreScaffolding.Nat) (eq : SAWCoreScaffolding.Eq SAWCoreScaffolding.Nat (SAWCoreScaffolding.Nat_rect (fun (n : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Nat) (addNat y z) (fun (_1 : SAWCoreScaffolding.Nat) (prev_sum : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Succ prev_sum) x') (SAWCoreScaffolding.Nat_rect (fun (n : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Nat) z (fun (_1 : SAWCoreScaffolding.Nat) (prev_sum : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Succ prev_sum) (SAWCoreScaffolding.Nat_rect (fun (n : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Nat) y (fun (_1 : SAWCoreScaffolding.Nat) (prev_sum : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Succ prev_sum) x'))) => eqNatSucc (addNat x' (addNat y z)) (addNat (addNat x' y) z) eq) x.

Definition mulNat : SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Nat :=
  fun (x : SAWCoreScaffolding.Nat) (y : SAWCoreScaffolding.Nat) => Nat__rec (fun (x' : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Nat) 0 (fun (x' : SAWCoreScaffolding.Nat) (prod : SAWCoreScaffolding.Nat) => addNat y prod) x.

Definition equal0Nat : SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Bool :=
  fun (n : SAWCoreScaffolding.Nat) => Nat_cases SAWCoreScaffolding.Bool SAWCoreScaffolding.true (fun (n1 : SAWCoreScaffolding.Nat) (b : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.false) n.

Definition equalNat : SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Bool :=
  fun (x : SAWCoreScaffolding.Nat) (y : SAWCoreScaffolding.Nat) => Nat_cases (SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Bool) equal0Nat (fun (n' : SAWCoreScaffolding.Nat) (eqN : SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Bool) (m : SAWCoreScaffolding.Nat) => Nat_cases SAWCoreScaffolding.Bool SAWCoreScaffolding.false (fun (m' : SAWCoreScaffolding.Nat) (b : SAWCoreScaffolding.Bool) => eqN m') m) x y.

Definition ltNat : SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Bool :=
  fun (x : SAWCoreScaffolding.Nat) (y : SAWCoreScaffolding.Nat) => Nat_cases2 SAWCoreScaffolding.Bool (fun (x' : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.false) (fun (y' : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.true) (fun (y' : SAWCoreScaffolding.Nat) (x' : SAWCoreScaffolding.Nat) (lt_mn : SAWCoreScaffolding.Bool) => lt_mn) y x.

Definition subNat : SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Nat :=
  fun (x : SAWCoreScaffolding.Nat) (y : SAWCoreScaffolding.Nat) => Nat_cases2 SAWCoreScaffolding.Nat (fun (x' : SAWCoreScaffolding.Nat) => x') (fun (y' : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Zero) (fun (y' : SAWCoreScaffolding.Nat) (x' : SAWCoreScaffolding.Nat) (sub_xy : SAWCoreScaffolding.Nat) => sub_xy) y x.

Definition minNat : SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Nat :=
  fun (x : SAWCoreScaffolding.Nat) (y : SAWCoreScaffolding.Nat) => Nat_cases2 SAWCoreScaffolding.Nat (fun (y' : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Zero) (fun (x' : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Zero) (fun (x' : SAWCoreScaffolding.Nat) (y' : SAWCoreScaffolding.Nat) (min_xy : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Succ min_xy) x y.

Definition maxNat : SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Nat :=
  fun (x : SAWCoreScaffolding.Nat) (y : SAWCoreScaffolding.Nat) => Nat_cases2 SAWCoreScaffolding.Nat (fun (y' : SAWCoreScaffolding.Nat) => y') (fun (x' : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Succ x') (fun (x' : SAWCoreScaffolding.Nat) (y' : SAWCoreScaffolding.Nat) (max_xy : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Succ max_xy) x y.

(* Prelude.widthNat was skipped *)

Definition expNat : SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Nat :=
  fun (b : SAWCoreScaffolding.Nat) (e : SAWCoreScaffolding.Nat) => Nat_cases SAWCoreScaffolding.Nat 1 (fun (e' : SAWCoreScaffolding.Nat) (exp_b_e : SAWCoreScaffolding.Nat) => mulNat b exp_b_e) e.

(* Prelude.divModNat was skipped *)

Definition divNat : SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Nat :=
  fun (x : SAWCoreScaffolding.Nat) (y : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.fst (SAWCoreScaffolding.divModNat x y).

Definition modNat : SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Nat -> SAWCoreScaffolding.Nat :=
  fun (x : SAWCoreScaffolding.Nat) (y : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.snd (SAWCoreScaffolding.divModNat x y).

Definition natCase : forall (p : SAWCoreScaffolding.Nat -> Type), p SAWCoreScaffolding.Zero -> (forall (n : SAWCoreScaffolding.Nat), p (SAWCoreScaffolding.Succ n)) -> forall (n : SAWCoreScaffolding.Nat), p n :=
  fun (p : SAWCoreScaffolding.Nat -> Type) (z : p 0) (s : forall (n : SAWCoreScaffolding.Nat), p (SAWCoreScaffolding.Succ n)) => Nat__rec p z (fun (n : SAWCoreScaffolding.Nat) (r : p n) => s n).

Definition if0Nat : forall (a : Type), SAWCoreScaffolding.Nat -> a -> a -> a :=
  fun (a : Type) (n : SAWCoreScaffolding.Nat) (x : a) (y : a) => natCase (fun (_1 : SAWCoreScaffolding.Nat) => a) x (fun (_1 : SAWCoreScaffolding.Nat) => y) n.

Axiom expByNat : forall (a : Type), a -> (a -> a -> a) -> a -> SAWCoreScaffolding.Nat -> a .

(* Prelude.equalString was skipped *)

(* Prelude.Vec was skipped *)

(* Prelude.gen was skipped *)

Axiom head : forall (n : SAWCoreScaffolding.Nat), forall (a : Type), SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) a -> a .

Axiom tail : forall (n : SAWCoreScaffolding.Nat), forall (a : Type), SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) a -> SAWCoreVectorsAsCoqVectors.Vec n a .

(* Prelude.atWithDefault was skipped *)

Definition sawAt : forall (n : SAWCoreScaffolding.Nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, SAWCoreVectorsAsCoqVectors.Vec n a -> SAWCoreScaffolding.Nat -> a :=
  fun (n : SAWCoreScaffolding.Nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (v : SAWCoreVectorsAsCoqVectors.Vec n a) (i : SAWCoreScaffolding.Nat) => SAWCoreVectorsAsCoqVectors.atWithDefault n a (SAWCoreScaffolding.error a "at: index out of bounds"%string) v i.

(* Prelude.EmptyVec was skipped *)

Definition ConsVec : forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, a -> forall (n : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec n a -> SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) a :=
  fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (x : a) (n : SAWCoreScaffolding.Nat) (v : SAWCoreVectorsAsCoqVectors.Vec n a) => SAWCoreVectorsAsCoqVectors.gen (SAWCoreScaffolding.Succ n) a (Nat_cases a x (fun (i : SAWCoreScaffolding.Nat) (a' : a) => SAWCorePrelude.sawAt n a v i)).

Definition upd : forall (n : SAWCoreScaffolding.Nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, SAWCoreVectorsAsCoqVectors.Vec n a -> SAWCoreScaffolding.Nat -> a -> SAWCoreVectorsAsCoqVectors.Vec n a :=
  fun (n : SAWCoreScaffolding.Nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (v : SAWCoreVectorsAsCoqVectors.Vec n a) (j : SAWCoreScaffolding.Nat) (x : a) => SAWCoreVectorsAsCoqVectors.gen n a (fun (i : SAWCoreScaffolding.Nat) => if equalNat i j then x else SAWCorePrelude.sawAt n a v i).

Definition map : forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (b : Type), (a -> b) -> forall (n : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec n a -> SAWCoreVectorsAsCoqVectors.Vec n b :=
  fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (b : Type) (f : a -> b) (n : SAWCoreScaffolding.Nat) (v : SAWCoreVectorsAsCoqVectors.Vec n a) => SAWCoreVectorsAsCoqVectors.gen n b (fun (i : SAWCoreScaffolding.Nat) => f (SAWCorePrelude.sawAt n a v i)).

Definition zipWith : forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (b : Type), forall {Inh_b : SAWCoreScaffolding.Inhabited b}, forall (c : Type), (a -> b -> c) -> forall (n : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec n a -> SAWCoreVectorsAsCoqVectors.Vec n b -> SAWCoreVectorsAsCoqVectors.Vec n c :=
  fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (b : Type) {Inh_b : SAWCoreScaffolding.Inhabited b} (c : Type) (f : a -> b -> c) (n : SAWCoreScaffolding.Nat) (x : SAWCoreVectorsAsCoqVectors.Vec n a) (y : SAWCoreVectorsAsCoqVectors.Vec n b) => SAWCoreVectorsAsCoqVectors.gen n c (fun (i : SAWCoreScaffolding.Nat) => f (SAWCorePrelude.sawAt n a x i) (SAWCorePrelude.sawAt n b y i)).

Definition replicate : forall (n : SAWCoreScaffolding.Nat), forall (a : Type), a -> SAWCoreVectorsAsCoqVectors.Vec n a :=
  fun (n : SAWCoreScaffolding.Nat) (a : Type) (x : a) => SAWCoreVectorsAsCoqVectors.gen n a (fun (_1 : SAWCoreScaffolding.Nat) => x).

Definition single : forall (a : Type), a -> SAWCoreVectorsAsCoqVectors.Vec 1 a :=
  replicate 1.

(* Prelude.at_single was skipped *)


Fixpoint zip (a b : sort 0) (m n : Nat) (xs : Vec m a) (ys : Vec n b)
  : Vec (minNat m n) (a * b) :=
  match
    xs in Vector.t _ m'
    return Vector.t _ (minNat m' n)
  with
  | Vector.nil => Vector.nil _
  | Vector.cons x pm xs =>
    match
      ys in Vector.t _ n'
      return Vector.t _ (minNat (S pm) n')
    with
    | Vector.nil => Vector.nil _
    | Vector.cons y pm' ys => Vector.cons _ (x, y) _ (zip _ _ _ _ xs ys)
    end
  end
.

(* Prelude.foldr was skipped *)

(* Prelude.foldl was skipped *)

Definition reverse : forall (n : SAWCoreScaffolding.Nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, SAWCoreVectorsAsCoqVectors.Vec n a -> SAWCoreVectorsAsCoqVectors.Vec n a :=
  fun (n : SAWCoreScaffolding.Nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (xs : SAWCoreVectorsAsCoqVectors.Vec n a) => SAWCoreVectorsAsCoqVectors.gen n a (fun (i : SAWCoreScaffolding.Nat) => SAWCorePrelude.sawAt n a xs (subNat (subNat n 1) i)).

Definition transpose : forall (m : SAWCoreScaffolding.Nat), forall (n : SAWCoreScaffolding.Nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, SAWCoreVectorsAsCoqVectors.Vec m (SAWCoreVectorsAsCoqVectors.Vec n a) -> SAWCoreVectorsAsCoqVectors.Vec n (SAWCoreVectorsAsCoqVectors.Vec m a) :=
  fun (m : SAWCoreScaffolding.Nat) (n : SAWCoreScaffolding.Nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (xss : SAWCoreVectorsAsCoqVectors.Vec m (SAWCoreVectorsAsCoqVectors.Vec n a)) => SAWCoreVectorsAsCoqVectors.gen n (SAWCoreVectorsAsCoqVectors.Vec m a) (fun (j : SAWCoreScaffolding.Nat) => SAWCoreVectorsAsCoqVectors.gen m a (fun (i : SAWCoreScaffolding.Nat) => SAWCorePrelude.sawAt n a (SAWCorePrelude.sawAt m (SAWCoreVectorsAsCoqVectors.Vec n a) xss i) j)).

Definition vecEq : forall (n : SAWCoreScaffolding.Nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, (a -> a -> SAWCoreScaffolding.Bool) -> SAWCoreVectorsAsCoqVectors.Vec n a -> SAWCoreVectorsAsCoqVectors.Vec n a -> SAWCoreScaffolding.Bool :=
  fun (n : SAWCoreScaffolding.Nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (eqFn : a -> a -> SAWCoreScaffolding.Bool) (x : SAWCoreVectorsAsCoqVectors.Vec n a) (y : SAWCoreVectorsAsCoqVectors.Vec n a) => SAWCoreVectorsAsCoqVectors.foldr SAWCoreScaffolding.Bool SAWCoreScaffolding.Bool n SAWCoreScaffolding.and SAWCoreScaffolding.true (zipWith a a SAWCoreScaffolding.Bool eqFn n x y).

Definition take : forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (m : SAWCoreScaffolding.Nat), forall (n : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec (addNat m n) a -> SAWCoreVectorsAsCoqVectors.Vec m a :=
  fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (m : SAWCoreScaffolding.Nat) (n : SAWCoreScaffolding.Nat) (v : SAWCoreVectorsAsCoqVectors.Vec (addNat m n) a) => SAWCoreVectorsAsCoqVectors.gen m a (fun (i : SAWCoreScaffolding.Nat) => SAWCorePrelude.sawAt (addNat m n) a v i).

Definition vecCong : forall (a : Type), forall (m : SAWCoreScaffolding.Nat), forall (n : SAWCoreScaffolding.Nat), SAWCoreScaffolding.Eq SAWCoreScaffolding.Nat m n -> SAWCoreScaffolding.Eq Type (SAWCoreVectorsAsCoqVectors.Vec m a) (SAWCoreVectorsAsCoqVectors.Vec n a) :=
  fun (a : Type) (m : SAWCoreScaffolding.Nat) (n : SAWCoreScaffolding.Nat) (eq : SAWCoreScaffolding.Eq SAWCoreScaffolding.Nat m n) => eq_cong SAWCoreScaffolding.Nat m n eq Type (fun (i : SAWCoreScaffolding.Nat) => SAWCoreVectorsAsCoqVectors.Vec i a).

(* Prelude.coerceVec was skipped *)

(* Prelude.take0 was skipped *)

Definition drop : forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (m : SAWCoreScaffolding.Nat), forall (n : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec (addNat m n) a -> SAWCoreVectorsAsCoqVectors.Vec n a :=
  fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (m : SAWCoreScaffolding.Nat) (n : SAWCoreScaffolding.Nat) (v : SAWCoreVectorsAsCoqVectors.Vec (addNat m n) a) => SAWCoreVectorsAsCoqVectors.gen n a (fun (i : SAWCoreScaffolding.Nat) => SAWCorePrelude.sawAt (addNat m n) a v (addNat m i)).

(* Prelude.drop0 was skipped *)

Definition slice : forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (m : SAWCoreScaffolding.Nat), forall (n : SAWCoreScaffolding.Nat), forall (o : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec (addNat (addNat m n) o) a -> SAWCoreVectorsAsCoqVectors.Vec n a :=
  fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (m : SAWCoreScaffolding.Nat) (n : SAWCoreScaffolding.Nat) (o : SAWCoreScaffolding.Nat) (v : SAWCoreVectorsAsCoqVectors.Vec (addNat (addNat m n) o) a) => drop a m n (take a (addNat m n) o v).

Definition join : forall (m : SAWCoreScaffolding.Nat), forall (n : SAWCoreScaffolding.Nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, SAWCoreVectorsAsCoqVectors.Vec m (SAWCoreVectorsAsCoqVectors.Vec n a) -> SAWCoreVectorsAsCoqVectors.Vec (mulNat m n) a :=
  fun (m : SAWCoreScaffolding.Nat) (n : SAWCoreScaffolding.Nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (v : SAWCoreVectorsAsCoqVectors.Vec m (SAWCoreVectorsAsCoqVectors.Vec n a)) => SAWCoreVectorsAsCoqVectors.gen (mulNat m n) a (fun (i : SAWCoreScaffolding.Nat) => SAWCorePrelude.sawAt n a (SAWCorePrelude.sawAt m (SAWCoreVectorsAsCoqVectors.Vec n a) v (divNat i n)) (modNat i n)).

Definition split : forall (m : SAWCoreScaffolding.Nat), forall (n : SAWCoreScaffolding.Nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, SAWCoreVectorsAsCoqVectors.Vec (mulNat m n) a -> SAWCoreVectorsAsCoqVectors.Vec m (SAWCoreVectorsAsCoqVectors.Vec n a) :=
  fun (m : SAWCoreScaffolding.Nat) (n : SAWCoreScaffolding.Nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (v : SAWCoreVectorsAsCoqVectors.Vec (mulNat m n) a) => SAWCoreVectorsAsCoqVectors.gen m (SAWCoreVectorsAsCoqVectors.Vec n a) (fun (i : SAWCoreScaffolding.Nat) => SAWCoreVectorsAsCoqVectors.gen n a (fun (j : SAWCoreScaffolding.Nat) => SAWCorePrelude.sawAt (mulNat m n) a v (addNat (mulNat i n) j))).

Definition append : forall (m : SAWCoreScaffolding.Nat), forall (n : SAWCoreScaffolding.Nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, SAWCoreVectorsAsCoqVectors.Vec m a -> SAWCoreVectorsAsCoqVectors.Vec n a -> SAWCoreVectorsAsCoqVectors.Vec (addNat m n) a :=
  fun (m : SAWCoreScaffolding.Nat) (n : SAWCoreScaffolding.Nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (x : SAWCoreVectorsAsCoqVectors.Vec m a) (y : SAWCoreVectorsAsCoqVectors.Vec n a) => SAWCoreVectorsAsCoqVectors.gen (addNat m n) a (fun (i : SAWCoreScaffolding.Nat) => if ltNat i m then SAWCorePrelude.sawAt m a x i else SAWCorePrelude.sawAt n a y (subNat i m)).

(* Prelude.rotateL was skipped *)

(* Prelude.rotateR was skipped *)

(* Prelude.shiftL was skipped *)

(* Prelude.shiftR was skipped *)

Definition joinLittleEndian : forall (m : SAWCoreScaffolding.Nat), forall (n : SAWCoreScaffolding.Nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, SAWCoreVectorsAsCoqVectors.Vec m (SAWCoreVectorsAsCoqVectors.Vec n a) -> SAWCoreVectorsAsCoqVectors.Vec (mulNat m n) a :=
  fun (m : SAWCoreScaffolding.Nat) (n : SAWCoreScaffolding.Nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (v : SAWCoreVectorsAsCoqVectors.Vec m (SAWCoreVectorsAsCoqVectors.Vec n a)) => join m n a (reverse m (SAWCoreVectorsAsCoqVectors.Vec n a) v).

Definition splitLittleEndian : forall (m : SAWCoreScaffolding.Nat), forall (n : SAWCoreScaffolding.Nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, SAWCoreVectorsAsCoqVectors.Vec (mulNat m n) a -> SAWCoreVectorsAsCoqVectors.Vec m (SAWCoreVectorsAsCoqVectors.Vec n a) :=
  fun (m : SAWCoreScaffolding.Nat) (n : SAWCoreScaffolding.Nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (v : SAWCoreVectorsAsCoqVectors.Vec (mulNat m n) a) => reverse m (SAWCoreVectorsAsCoqVectors.Vec n a) (split m n a v).

Definition msb : forall (n : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) SAWCoreScaffolding.Bool -> SAWCoreScaffolding.Bool :=
  fun (n : SAWCoreScaffolding.Nat) (v : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) SAWCoreScaffolding.Bool) => SAWCorePrelude.sawAt (SAWCoreScaffolding.Succ n) SAWCoreScaffolding.Bool v 0.

Definition lsb : forall (n : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) SAWCoreScaffolding.Bool -> SAWCoreScaffolding.Bool :=
  fun (n : SAWCoreScaffolding.Nat) (v : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) SAWCoreScaffolding.Bool) => SAWCorePrelude.sawAt (SAWCoreScaffolding.Succ n) SAWCoreScaffolding.Bool v n.

(* Prelude.bvNat was skipped *)

(* Prelude.bvToNat was skipped *)

Axiom bvNat_bvToNat_id : forall (n : SAWCoreScaffolding.Nat), forall (x : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq (SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (SAWCoreVectorsAsCoqVectors.bvNat n (SAWCoreVectorsAsCoqVectors.bvToNat n x)) x .

Definition bvAt : forall (n : SAWCoreScaffolding.Nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (w : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec n a -> SAWCoreVectorsAsCoqVectors.Vec w SAWCoreScaffolding.Bool -> a :=
  fun (n : SAWCoreScaffolding.Nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (w : SAWCoreScaffolding.Nat) (xs : SAWCoreVectorsAsCoqVectors.Vec n a) (i : SAWCoreVectorsAsCoqVectors.Vec w SAWCoreScaffolding.Bool) => SAWCorePrelude.sawAt n a xs (SAWCoreVectorsAsCoqVectors.bvToNat w i).

Definition bvUpd : forall (n : SAWCoreScaffolding.Nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (w : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec n a -> SAWCoreVectorsAsCoqVectors.Vec w SAWCoreScaffolding.Bool -> a -> SAWCoreVectorsAsCoqVectors.Vec n a :=
  fun (n : SAWCoreScaffolding.Nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (w : SAWCoreScaffolding.Nat) (xs : SAWCoreVectorsAsCoqVectors.Vec n a) (i : SAWCoreVectorsAsCoqVectors.Vec w SAWCoreScaffolding.Bool) (y : a) => upd n a xs (SAWCoreVectorsAsCoqVectors.bvToNat w i) y.

Definition bvRotateL : forall (n : SAWCoreScaffolding.Nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (w : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec n a -> SAWCoreVectorsAsCoqVectors.Vec w SAWCoreScaffolding.Bool -> SAWCoreVectorsAsCoqVectors.Vec n a :=
  fun (n : SAWCoreScaffolding.Nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (w : SAWCoreScaffolding.Nat) (xs : SAWCoreVectorsAsCoqVectors.Vec n a) (i : SAWCoreVectorsAsCoqVectors.Vec w SAWCoreScaffolding.Bool) => SAWCoreVectorsAsCoqVectors.rotateL n a xs (SAWCoreVectorsAsCoqVectors.bvToNat w i).

Definition bvRotateR : forall (n : SAWCoreScaffolding.Nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (w : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec n a -> SAWCoreVectorsAsCoqVectors.Vec w SAWCoreScaffolding.Bool -> SAWCoreVectorsAsCoqVectors.Vec n a :=
  fun (n : SAWCoreScaffolding.Nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (w : SAWCoreScaffolding.Nat) (xs : SAWCoreVectorsAsCoqVectors.Vec n a) (i : SAWCoreVectorsAsCoqVectors.Vec w SAWCoreScaffolding.Bool) => SAWCoreVectorsAsCoqVectors.rotateR n a xs (SAWCoreVectorsAsCoqVectors.bvToNat w i).

Definition bvShiftL : forall (n : SAWCoreScaffolding.Nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (w : SAWCoreScaffolding.Nat), a -> SAWCoreVectorsAsCoqVectors.Vec n a -> SAWCoreVectorsAsCoqVectors.Vec w SAWCoreScaffolding.Bool -> SAWCoreVectorsAsCoqVectors.Vec n a :=
  fun (n : SAWCoreScaffolding.Nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (w : SAWCoreScaffolding.Nat) (z : a) (xs : SAWCoreVectorsAsCoqVectors.Vec n a) (i : SAWCoreVectorsAsCoqVectors.Vec w SAWCoreScaffolding.Bool) => SAWCoreVectorsAsCoqVectors.shiftL n a z xs (SAWCoreVectorsAsCoqVectors.bvToNat w i).

Definition bvShiftR : forall (n : SAWCoreScaffolding.Nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (w : SAWCoreScaffolding.Nat), a -> SAWCoreVectorsAsCoqVectors.Vec n a -> SAWCoreVectorsAsCoqVectors.Vec w SAWCoreScaffolding.Bool -> SAWCoreVectorsAsCoqVectors.Vec n a :=
  fun (n : SAWCoreScaffolding.Nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (w : SAWCoreScaffolding.Nat) (z : a) (xs : SAWCoreVectorsAsCoqVectors.Vec n a) (i : SAWCoreVectorsAsCoqVectors.Vec w SAWCoreScaffolding.Bool) => SAWCoreVectorsAsCoqVectors.shiftR n a z xs (SAWCoreVectorsAsCoqVectors.bvToNat w i).

Definition bvSShiftR : forall (n : SAWCoreScaffolding.Nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (w : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) a -> SAWCoreVectorsAsCoqVectors.Vec w SAWCoreScaffolding.Bool -> SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) a :=
  fun (n : SAWCoreScaffolding.Nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (w : SAWCoreScaffolding.Nat) (xs : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) a) (i : SAWCoreVectorsAsCoqVectors.Vec w SAWCoreScaffolding.Bool) => let var__0   := SAWCoreScaffolding.Succ n in
  bvShiftR var__0 a w (SAWCorePrelude.sawAt var__0 a xs 0) xs i.

(* Prelude.bvAdd was skipped *)

(* Prelude.bvugt was skipped *)

(* Prelude.bvuge was skipped *)

(* Prelude.bvult was skipped *)

(* Prelude.bvule was skipped *)

(* Prelude.bvsgt was skipped *)

(* Prelude.bvsge was skipped *)

(* Prelude.bvslt was skipped *)

(* Prelude.bvsle was skipped *)

(* Prelude.bvPopcount was skipped *)

(* Prelude.bvCountLeadingZeros was skipped *)

(* Prelude.bvCountTrailingZeros was skipped *)

(* Prelude.bvForall was skipped *)

Definition bvCarry : forall (n : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> SAWCoreScaffolding.Bool :=
  fun (n : SAWCoreScaffolding.Nat) (x : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (y : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) => SAWCoreVectorsAsCoqVectors.bvult n (SAWCoreVectorsAsCoqVectors.bvAdd n x y) x.

Definition bvSCarry : forall (n : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) SAWCoreScaffolding.Bool -> SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) SAWCoreScaffolding.Bool -> SAWCoreScaffolding.Bool :=
  fun (n : SAWCoreScaffolding.Nat) (x : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) SAWCoreScaffolding.Bool) (y : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) SAWCoreScaffolding.Bool) => let var__0   := msb n x in
  SAWCoreScaffolding.and (SAWCoreScaffolding.boolEq var__0 (msb n y)) (SAWCoreScaffolding.xor var__0 (msb n (SAWCoreVectorsAsCoqVectors.bvAdd (SAWCoreScaffolding.Succ n) x y))).

Definition bvAddWithCarry : forall (n : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> prod SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) :=
  fun (n : SAWCoreScaffolding.Nat) (x : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (y : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) => pair (bvCarry n x y) (SAWCoreVectorsAsCoqVectors.bvAdd n x y).

(* Prelude.bvAddZeroL was skipped *)

(* Prelude.bvAddZeroR was skipped *)

(* Prelude.bvNeg was skipped *)

(* Prelude.bvSub was skipped *)

Definition bvSBorrow : forall (n : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) SAWCoreScaffolding.Bool -> SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) SAWCoreScaffolding.Bool -> SAWCoreScaffolding.Bool :=
  fun (n : SAWCoreScaffolding.Nat) (x : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) SAWCoreScaffolding.Bool) (y : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) SAWCoreScaffolding.Bool) => let var__0   := msb n x in
  SAWCoreScaffolding.and (SAWCoreScaffolding.xor var__0 (msb n y)) (SAWCoreScaffolding.xor var__0 (msb n (SAWCoreVectorsAsCoqVectors.bvSub (SAWCoreScaffolding.Succ n) x y))).

(* Prelude.bvMul was skipped *)

(* Prelude.bvLg2 was skipped *)

(* Prelude.bvUDiv was skipped *)

(* Prelude.bvURem was skipped *)

(* Prelude.bvSDiv was skipped *)

(* Prelude.bvSRem was skipped *)

(* Prelude.bvShl was skipped *)

(* Prelude.bvShr was skipped *)

(* Prelude.bvSShr was skipped *)

(* Prelude.bvShiftL_bvShl was skipped *)

(* Prelude.bvShiftR_bvShr was skipped *)

Definition bvZipWith : (SAWCoreScaffolding.Bool -> SAWCoreScaffolding.Bool -> SAWCoreScaffolding.Bool) -> forall (n : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool :=
  zipWith SAWCoreScaffolding.Bool SAWCoreScaffolding.Bool SAWCoreScaffolding.Bool.

Definition bvNot : forall (n : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool :=
  map SAWCoreScaffolding.Bool SAWCoreScaffolding.Bool SAWCoreScaffolding.not.

Definition bvAnd : forall (n : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool :=
  bvZipWith SAWCoreScaffolding.and.

Definition bvOr : forall (n : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool :=
  bvZipWith SAWCoreScaffolding.or.

Definition bvXor : forall (n : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool :=
  bvZipWith SAWCoreScaffolding.xor.

Definition bvEq : forall (n : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> SAWCoreScaffolding.Bool :=
  fun (n : SAWCoreScaffolding.Nat) (x : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (y : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) => vecEq n SAWCoreScaffolding.Bool SAWCoreScaffolding.boolEq x y.

(* Prelude.bvEq_refl was skipped *)

(* Prelude.equalNat_bv was skipped *)

Definition bvBool : forall (n : SAWCoreScaffolding.Nat), SAWCoreScaffolding.Bool -> SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool :=
  fun (n : SAWCoreScaffolding.Nat) (b : SAWCoreScaffolding.Bool) => if b then SAWCoreVectorsAsCoqVectors.bvNat n 1 else SAWCoreVectorsAsCoqVectors.bvNat n 0.

Definition bvNe : forall (n : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> SAWCoreScaffolding.Bool :=
  fun (n : SAWCoreScaffolding.Nat) (x : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (y : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) => SAWCoreScaffolding.not (bvEq n x y).

Definition bvNonzero : forall (n : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> SAWCoreScaffolding.Bool :=
  fun (n : SAWCoreScaffolding.Nat) (x : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) => bvNe n x (SAWCoreVectorsAsCoqVectors.bvNat n 0).

Definition bvTrunc : forall (m : SAWCoreScaffolding.Nat), forall (n : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec (addNat m n) SAWCoreScaffolding.Bool -> SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool :=
  drop SAWCoreScaffolding.Bool.

Definition bvUExt : forall (m : SAWCoreScaffolding.Nat), forall (n : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> SAWCoreVectorsAsCoqVectors.Vec (addNat m n) SAWCoreScaffolding.Bool :=
  fun (m : SAWCoreScaffolding.Nat) (n : SAWCoreScaffolding.Nat) (x : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) => append m n SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvNat m 0) x.

Definition replicateBool : forall (n : SAWCoreScaffolding.Nat), SAWCoreScaffolding.Bool -> SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool :=
  fun (n : SAWCoreScaffolding.Nat) (b : SAWCoreScaffolding.Bool) => let var__0   := SAWCoreVectorsAsCoqVectors.bvNat n 0 in
  if b then bvNot n var__0 else var__0.

Definition bvSExt : forall (m : SAWCoreScaffolding.Nat), forall (n : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) SAWCoreScaffolding.Bool -> SAWCoreVectorsAsCoqVectors.Vec (addNat m (SAWCoreScaffolding.Succ n)) SAWCoreScaffolding.Bool :=
  fun (m : SAWCoreScaffolding.Nat) (n : SAWCoreScaffolding.Nat) (x : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) SAWCoreScaffolding.Bool) => append m (SAWCoreScaffolding.Succ n) SAWCoreScaffolding.Bool (replicateBool m (msb n x)) x.

Inductive Stream (a : Type) : Type :=
| MkStream : (SAWCoreScaffolding.Nat -> a) -> Stream a
.

Instance Inhabited_Stream (a:Type) (Ha:Inhabited a) : Inhabited (Stream a) := MkInhabited (Stream a) (MkStream a (fun _ => inhabitant)).
Definition Stream__rec : forall (a : Type), forall (p : Stream a -> Type), (forall (f : SAWCoreScaffolding.Nat -> a), p (MkStream a f)) -> forall (str : Stream a), p str :=
  fun (a : Type) (p : Stream a -> Type) (f1 : forall (f : SAWCoreScaffolding.Nat -> a), p (MkStream a f)) (str : Stream a) => SAWCorePrelude.Stream_rect a p f1 str.

Definition streamUpd : forall (a : Type), Stream a -> SAWCoreScaffolding.Nat -> a -> Stream a :=
  fun (a : Type) (strm : Stream a) (i : SAWCoreScaffolding.Nat) (y : a) => Stream__rec a (fun (strm' : Stream a) => Stream a) (fun (s : SAWCoreScaffolding.Nat -> a) => MkStream a (fun (j : SAWCoreScaffolding.Nat) => if equalNat i j then y else s j)) strm.

Definition bvStreamUpd : forall (a : Type), forall (w : SAWCoreScaffolding.Nat), Stream a -> SAWCoreVectorsAsCoqVectors.Vec w SAWCoreScaffolding.Bool -> a -> Stream a :=
  fun (a : Type) (w : SAWCoreScaffolding.Nat) (xs : Stream a) (i : SAWCoreVectorsAsCoqVectors.Vec w SAWCoreScaffolding.Bool) (y : a) => streamUpd a xs (SAWCoreVectorsAsCoqVectors.bvToNat w i) y.

Definition streamGet : forall (a : Type), Stream a -> SAWCoreScaffolding.Nat -> a :=
  fun (a : Type) (strm : Stream a) (i : SAWCoreScaffolding.Nat) => Stream__rec a (fun (strm' : Stream a) => a) (fun (s : SAWCoreScaffolding.Nat -> a) => s i) strm.

Definition streamConst : forall (a : Type), a -> Stream a :=
  fun (a : Type) (x : a) => MkStream a (fun (i : SAWCoreScaffolding.Nat) => x).

Definition streamMap : forall (a : Type), forall (b : Type), (a -> b) -> Stream a -> Stream b :=
  fun (a : Type) (b : Type) (f : a -> b) (xs : Stream a) => MkStream b (fun (i : SAWCoreScaffolding.Nat) => f (streamGet a xs i)).

Definition streamMap2 : forall (a : Type), forall (b : Type), forall (c : Type), (a -> b -> c) -> Stream a -> Stream b -> Stream c :=
  fun (a : Type) (b : Type) (c : Type) (f : a -> b -> c) (xs : Stream a) (ys : Stream b) => MkStream c (fun (i : SAWCoreScaffolding.Nat) => f (streamGet a xs i) (streamGet b ys i)).

Definition streamTake : forall (a : Type), forall (n : SAWCoreScaffolding.Nat), Stream a -> SAWCoreVectorsAsCoqVectors.Vec n a :=
  fun (a : Type) (n : SAWCoreScaffolding.Nat) (xs : Stream a) => SAWCoreVectorsAsCoqVectors.gen n a (fun (i : SAWCoreScaffolding.Nat) => streamGet a xs i).

Definition streamDrop : forall (a : Type), forall (n : SAWCoreScaffolding.Nat), Stream a -> Stream a :=
  fun (a : Type) (n : SAWCoreScaffolding.Nat) (xs : Stream a) => MkStream a (fun (i : SAWCoreScaffolding.Nat) => streamGet a xs (addNat n i)).

Definition streamAppend : forall (a : Type), forall (n : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec n a -> Stream a -> Stream a :=
  fun (a : Type) (n : SAWCoreScaffolding.Nat) (xs : SAWCoreVectorsAsCoqVectors.Vec n a) (ys : Stream a) => MkStream a (fun (i : SAWCoreScaffolding.Nat) => SAWCoreVectorsAsCoqVectors.atWithDefault n a (streamGet a ys (subNat i n)) xs i).

Definition streamJoin : forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (n : SAWCoreScaffolding.Nat), Stream (SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) a) -> Stream a :=
  fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (n : SAWCoreScaffolding.Nat) (s : Stream (SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) a)) => MkStream a (fun (i : SAWCoreScaffolding.Nat) => let var__0   := SAWCoreScaffolding.Succ n in
  SAWCorePrelude.sawAt var__0 a (streamGet (SAWCoreVectorsAsCoqVectors.Vec var__0 a) s (divNat i var__0)) (modNat i var__0)).

Definition streamSplit : forall (a : Type), forall (n : SAWCoreScaffolding.Nat), Stream a -> Stream (SAWCoreVectorsAsCoqVectors.Vec n a) :=
  fun (a : Type) (n : SAWCoreScaffolding.Nat) (xs : Stream a) => MkStream (SAWCoreVectorsAsCoqVectors.Vec n a) (fun (i : SAWCoreScaffolding.Nat) => SAWCoreVectorsAsCoqVectors.gen n a (fun (j : SAWCoreScaffolding.Nat) => streamGet a xs (addNat (mulNat i n) j))).

Definition streamShiftL : forall (a : Type), Stream a -> SAWCoreScaffolding.Nat -> Stream a :=
  fun (a : Type) (xs : Stream a) (i : SAWCoreScaffolding.Nat) => streamDrop a i xs.

Definition streamShiftR : forall (a : Type), a -> Stream a -> SAWCoreScaffolding.Nat -> Stream a :=
  fun (a : Type) (z : a) (xs : Stream a) (i : SAWCoreScaffolding.Nat) => streamAppend a i (replicate i a z) xs.

(* Prelude.Integer was skipped *)

(* Prelude.intAdd was skipped *)

(* Prelude.intSub was skipped *)

(* Prelude.intMul was skipped *)

(* Prelude.intDiv was skipped *)

(* Prelude.intMod was skipped *)

(* Prelude.intMin was skipped *)

(* Prelude.intMax was skipped *)

(* Prelude.intNeg was skipped *)

(* Prelude.intAbs was skipped *)

(* Prelude.intEq was skipped *)

(* Prelude.intLe was skipped *)

(* Prelude.intLt was skipped *)

(* Prelude.intToNat was skipped *)

(* Prelude.natToInt was skipped *)

(* Prelude.intToBv was skipped *)

(* Prelude.bvToInt was skipped *)

(* Prelude.sbvToInt was skipped *)

(* Prelude.IntMod was skipped *)

(* Prelude.toIntMod was skipped *)

(* Prelude.fromIntMod was skipped *)

(* Prelude.intModEq was skipped *)

(* Prelude.intModAdd was skipped *)

(* Prelude.intModSub was skipped *)

(* Prelude.intModMul was skipped *)

(* Prelude.intModNeg was skipped *)

Definition updNatFun : forall (a : Type), (SAWCoreScaffolding.Nat -> a) -> SAWCoreScaffolding.Nat -> a -> SAWCoreScaffolding.Nat -> a :=
  fun (a : Type) (f : SAWCoreScaffolding.Nat -> a) (i : SAWCoreScaffolding.Nat) (v : a) (x : SAWCoreScaffolding.Nat) => if equalNat i x then v else f x.

Definition updBvFun : forall (n : SAWCoreScaffolding.Nat), forall (a : Type), (SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> a) -> SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> a -> SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> a :=
  fun (n : SAWCoreScaffolding.Nat) (a : Type) (f : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> a) (i : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (v : a) (x : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) => if bvEq n i x then v else f x.

(* Prelude.Float was skipped *)

(* Prelude.mkFloat was skipped *)

(* Prelude.Double was skipped *)

(* Prelude.mkDouble was skipped *)

(* Prelude.Sigma was skipped *)

(* Prelude.Sigma__rec was skipped *)

(* Prelude.Sigma_proj1 was skipped *)

(* Prelude.Sigma_proj2 was skipped *)

Definition uncurrySigma : forall (a : Type), forall (b : a -> Type), forall (c : Type), (forall (pa : a), b pa -> c) -> @sigT a b -> c :=
  fun (a : Type) (b : a -> Type) (c : Type) => @sigT_rect a b (fun (_1 : @sigT a b) => c).

(* Prelude.List was skipped *)

(* Prelude.List__rec was skipped *)

Definition unfoldList : forall (a : Type), @Datatypes.list a -> Either (unit : Type) (prod a (@Datatypes.list a)) :=
  fun (a : Type) (l : @Datatypes.list a) => let var__0   := @Datatypes.list a in
  @Datatypes.list_rect a (fun (_1 : var__0) => Either (unit : Type) (prod a (@Datatypes.list a))) (Left (unit : Type) (prod a var__0) tt) (fun (x : a) (l1 : @Datatypes.list a) (_1 : Either (unit : Type) (prod a (@Datatypes.list a))) => Right (unit : Type) (prod a (@Datatypes.list a)) (pair x l1)) l.

Definition foldList : forall (a : Type), Either (unit : Type) (prod a (@Datatypes.list a)) -> @Datatypes.list a :=
  fun (a : Type) => let var__0   := @Datatypes.list a in
  let var__1   := prod a var__0 in
  either (unit : Type) var__1 var__0 (fun (_1 : unit : Type) => @Datatypes.nil a) (fun (tup : var__1) => @Datatypes.cons a (SAWCoreScaffolding.fst tup) (SAWCoreScaffolding.snd tup)).

Inductive ListSort : Type :=
| LS_Nil : ListSort
| LS_Cons : Type -> ListSort -> ListSort
.

Definition ListSort__rec : forall (P : ListSort -> Type), P LS_Nil -> (forall (A : Type), forall (l : ListSort), P l -> P (LS_Cons A l)) -> forall (l : ListSort), P l :=
  fun (P : ListSort -> Type) (f1 : P LS_Nil) (f2 : forall (A : Type), forall (l : ListSort), P l -> P (LS_Cons A l)) (l : ListSort) => SAWCorePrelude.ListSort_rect P f1 f2 l.

Definition listSortGet : ListSort -> SAWCoreScaffolding.Nat -> Type :=
  ListSort__rec (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)).

Definition listSortDrop : ListSort -> SAWCoreScaffolding.Nat -> ListSort :=
  ListSort__rec (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> ListSort) (fun (_1 : SAWCoreScaffolding.Nat) => LS_Nil) (fun (_1 : Type) (Ds : ListSort) (rec : SAWCoreScaffolding.Nat -> ListSort) => Nat_cases ListSort Ds (fun (n : SAWCoreScaffolding.Nat) (_2 : ListSort) => rec n)).

Inductive W64List : Type :=
| W64Nil : W64List
| W64Cons : SAWCoreVectorsAsCoqVectors.Vec 64 SAWCoreScaffolding.Bool -> W64List -> W64List
.

Definition unfoldedW64List : Type :=
  Either (unit : Type) (prod (@sigT (SAWCoreVectorsAsCoqVectors.Vec 64 SAWCoreScaffolding.Bool) (fun (_1 : SAWCoreVectorsAsCoqVectors.Vec 64 SAWCoreScaffolding.Bool) => unit : Type)) (prod W64List (unit : Type))).

Definition unfoldW64List : W64List -> unfoldedW64List :=
  fun (l : W64List) => let var__0   := SAWCoreVectorsAsCoqVectors.Vec 64 SAWCoreScaffolding.Bool in
  SAWCorePrelude.W64List_rect (fun (_1 : W64List) => unfoldedW64List) (Left (unit : Type) (prod (@sigT var__0 (fun (_1 : var__0) => unit : Type)) (prod W64List (unit : Type))) tt) (fun (bv : var__0) (l' : W64List) (_1 : Either (unit : Type) (prod (@sigT var__0 (fun (_1 : var__0) => unit : Type)) (prod W64List (unit : Type)))) => let var__1   := SAWCoreVectorsAsCoqVectors.Vec 64 SAWCoreScaffolding.Bool in
  let var__2   := fun (_2 : var__1) => unit : Type in
  Right (unit : Type) (prod (@sigT var__1 var__2) (prod W64List (unit : Type))) (pair (@existT var__1 var__2 bv tt) (pair l' tt))) l.

Definition foldW64List : unfoldedW64List -> W64List :=
  either (unit : Type) (prod (@sigT (SAWCoreVectorsAsCoqVectors.Vec 64 SAWCoreScaffolding.Bool) (fun (_1 : SAWCoreVectorsAsCoqVectors.Vec 64 SAWCoreScaffolding.Bool) => unit : Type)) (prod W64List (unit : Type))) W64List (fun (_1 : unit : Type) => W64Nil) (fun (bv_l : prod (@sigT (SAWCoreVectorsAsCoqVectors.Vec 64 SAWCoreScaffolding.Bool) (fun (_1 : SAWCoreVectorsAsCoqVectors.Vec 64 SAWCoreScaffolding.Bool) => unit : Type)) (prod W64List (unit : Type))) => let var__0   := SAWCoreVectorsAsCoqVectors.Vec 64 SAWCoreScaffolding.Bool in
  W64Cons (@projT1 var__0 (fun (_1 : var__0) => unit : Type) (SAWCoreScaffolding.fst bv_l)) (SAWCoreScaffolding.fst (SAWCoreScaffolding.snd bv_l))).

Axiom bvEqWithProof : forall (n : SAWCoreScaffolding.Nat), forall (v1 : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (v2 : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), Maybe (SAWCoreScaffolding.Eq (SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) v1 v2) .

Definition bvultWithProof : forall (n : SAWCoreScaffolding.Nat), forall (v1 : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (v2 : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), Maybe (SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvult n v1 v2) SAWCoreScaffolding.true) :=
  fun (n : SAWCoreScaffolding.Nat) (v1 : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (v2 : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) => SAWCoreScaffolding.iteDep (fun (b : SAWCoreScaffolding.Bool) => Maybe (SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool b SAWCoreScaffolding.true)) (SAWCoreVectorsAsCoqVectors.bvult n v1 v2) (Just (SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.true) (SAWCoreScaffolding.Refl SAWCoreScaffolding.Bool SAWCoreScaffolding.true)) (Nothing (SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.false SAWCoreScaffolding.true)).

Definition bvuleWithProof : forall (n : SAWCoreScaffolding.Nat), forall (v1 : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (v2 : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), Maybe (SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvule n v1 v2) SAWCoreScaffolding.true) :=
  fun (n : SAWCoreScaffolding.Nat) (v1 : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (v2 : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) => SAWCoreScaffolding.iteDep (fun (b : SAWCoreScaffolding.Bool) => Maybe (SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool b SAWCoreScaffolding.true)) (SAWCoreVectorsAsCoqVectors.bvule n v1 v2) (Just (SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.true) (SAWCoreScaffolding.Refl SAWCoreScaffolding.Bool SAWCoreScaffolding.true)) (Nothing (SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.false SAWCoreScaffolding.true)).

Axiom bvEqToEqNat : forall (n : SAWCoreScaffolding.Nat), forall (v1 : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (v2 : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq (SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) v1 v2 -> eqNat (SAWCoreVectorsAsCoqVectors.bvToNat n v1) (SAWCoreVectorsAsCoqVectors.bvToNat n v2) .

Axiom bvultToIsLtNat : forall (n : SAWCoreScaffolding.Nat), forall (v1 : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (v2 : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvult n v1 v2) SAWCoreScaffolding.true -> IsLtNat (SAWCoreVectorsAsCoqVectors.bvToNat n v1) (SAWCoreVectorsAsCoqVectors.bvToNat n v2) .

Axiom genWithProof : forall (n : SAWCoreScaffolding.Nat), forall (a : Type), (forall (i : SAWCoreScaffolding.Nat), IsLtNat i n -> a) -> SAWCoreVectorsAsCoqVectors.Vec n a .

Axiom atWithProof : forall (n : SAWCoreScaffolding.Nat), forall (a : Type), SAWCoreVectorsAsCoqVectors.Vec n a -> forall (i : SAWCoreScaffolding.Nat), IsLtNat i n -> a .

Axiom updWithProof : forall (n : SAWCoreScaffolding.Nat), forall (a : Type), SAWCoreVectorsAsCoqVectors.Vec n a -> forall (i : SAWCoreScaffolding.Nat), a -> IsLtNat i n -> SAWCoreVectorsAsCoqVectors.Vec n a .

Axiom sliceWithProof : forall (a : Type), forall (n : SAWCoreScaffolding.Nat), forall (off : SAWCoreScaffolding.Nat), forall (len : SAWCoreScaffolding.Nat), IsLeNat (addNat off len) n -> SAWCoreVectorsAsCoqVectors.Vec n a -> SAWCoreVectorsAsCoqVectors.Vec len a .

Axiom updSliceWithProof : forall (a : Type), forall (n : SAWCoreScaffolding.Nat), forall (off : SAWCoreScaffolding.Nat), forall (len : SAWCoreScaffolding.Nat), IsLeNat (addNat off len) n -> SAWCoreVectorsAsCoqVectors.Vec n a -> SAWCoreVectorsAsCoqVectors.Vec len a -> SAWCoreVectorsAsCoqVectors.Vec n a .

Definition is_bvult : forall (n : SAWCoreScaffolding.Nat), forall (x : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (y : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), Prop :=
  fun (n : SAWCoreScaffolding.Nat) (x : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (y : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvult n x y) SAWCoreScaffolding.true.

Definition is_bvule : forall (n : SAWCoreScaffolding.Nat), forall (x : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (y : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), Prop :=
  fun (n : SAWCoreScaffolding.Nat) (x : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (y : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvule n x y) SAWCoreScaffolding.true.

Axiom not_bvult_zero : forall (n : SAWCoreScaffolding.Nat), forall (x : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvult n x (SAWCoreVectorsAsCoqVectors.bvNat n 0)) SAWCoreScaffolding.false .

Axiom trans_bvult_bvule : forall (n : SAWCoreScaffolding.Nat), forall (x : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (y : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (z : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), is_bvult n x y -> is_bvule n y z -> is_bvult n x z .

Axiom bvult_sub_add_bvult : forall (n : SAWCoreScaffolding.Nat), forall (x : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (y : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (z : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), is_bvule n y z -> is_bvult n x (SAWCoreVectorsAsCoqVectors.bvSub n z y) -> is_bvult n (SAWCoreVectorsAsCoqVectors.bvAdd n y x) z .

Axiom bvult_sum_bvult_sub : forall (n : SAWCoreScaffolding.Nat), forall (x : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (y : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (z : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), is_bvult n x (SAWCoreVectorsAsCoqVectors.bvAdd n y z) -> SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvult n x y) SAWCoreScaffolding.false -> is_bvult n (SAWCoreVectorsAsCoqVectors.bvSub n x y) z .

Axiom IsLtNat_to_bvult : forall (n : SAWCoreScaffolding.Nat), forall (x : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (i : SAWCoreScaffolding.Nat), IsLtNat i (SAWCoreVectorsAsCoqVectors.bvToNat n x) -> is_bvult n (SAWCoreVectorsAsCoqVectors.bvNat n i) x .

Axiom bvult_to_IsLtNat : forall (n : SAWCoreScaffolding.Nat), forall (x : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (i : SAWCoreScaffolding.Nat), is_bvult n (SAWCoreVectorsAsCoqVectors.bvNat n i) x -> IsLtNat i (SAWCoreVectorsAsCoqVectors.bvToNat n x) .

Definition BVVec : forall (n : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> Type -> Type :=
  fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) => SAWCoreVectorsAsCoqVectors.Vec (SAWCoreVectorsAsCoqVectors.bvToNat n len).

Definition genBVVec : forall (n : SAWCoreScaffolding.Nat), forall (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (a : Type), (forall (i : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), is_bvult n i len -> a) -> BVVec n len a :=
  fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (a : Type) (f : forall (i : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvult n i len) SAWCoreScaffolding.true -> a) => genWithProof (SAWCoreVectorsAsCoqVectors.bvToNat n len) a (fun (i : SAWCoreScaffolding.Nat) (pf : IsLeNat (SAWCoreScaffolding.Succ i) (SAWCoreVectorsAsCoqVectors.bvToNat n len)) => f (SAWCoreVectorsAsCoqVectors.bvNat n i) (IsLtNat_to_bvult n len i pf)).

Definition genBVVecFromVec : forall (m : SAWCoreScaffolding.Nat), forall (a : Type), SAWCoreVectorsAsCoqVectors.Vec m a -> a -> forall (n : SAWCoreScaffolding.Nat), forall (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), BVVec n len a :=
  fun (m : SAWCoreScaffolding.Nat) (a : Type) (v : SAWCoreVectorsAsCoqVectors.Vec m a) (def : a) (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) => genBVVec n len a (fun (i : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (_1 : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvult n i len) SAWCoreScaffolding.true) => SAWCoreVectorsAsCoqVectors.atWithDefault m a def v (SAWCoreVectorsAsCoqVectors.bvToNat n i)).

Definition efq : forall (a : Type), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false -> a :=
  fun (a : Type) (contra : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) => let var__0   := if SAWCoreScaffolding.true then unit : Type else a in
  SAWCoreScaffolding.coerce (unit : Type) a (trans Type (unit : Type) var__0 a (sym Type var__0 (unit : Type) (ite_true Type (unit : Type) a)) (trans Type var__0 (if SAWCoreScaffolding.false then unit : Type else a) a (eq_cong SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false contra Type (fun (b : SAWCoreScaffolding.Bool) => if b then unit : Type else a)) (ite_false Type (unit : Type) a))) tt.

Definition emptyBVVec : forall (n : SAWCoreScaffolding.Nat), forall (a : Type), BVVec n (SAWCoreVectorsAsCoqVectors.bvNat n 0) a :=
  fun (n : SAWCoreScaffolding.Nat) (a : Type) => genBVVec n (SAWCoreVectorsAsCoqVectors.bvNat n 0) a (fun (i : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (pf : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvult n i (SAWCoreVectorsAsCoqVectors.bvNat n 0)) SAWCoreScaffolding.true) => let var__0   := SAWCoreVectorsAsCoqVectors.bvult n i (SAWCoreVectorsAsCoqVectors.bvNat n 0) in
  efq a (trans SAWCoreScaffolding.Bool SAWCoreScaffolding.true var__0 SAWCoreScaffolding.false (sym SAWCoreScaffolding.Bool var__0 SAWCoreScaffolding.true pf) (not_bvult_zero n i))).

Definition repeatBVVec : forall (n : SAWCoreScaffolding.Nat), forall (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (a : Type), a -> BVVec n len a :=
  fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (a : Type) (x : a) => genBVVec n len a (fun (i : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (_1 : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvult n i len) SAWCoreScaffolding.true) => x).

Definition singletonBVVec : forall (n : SAWCoreScaffolding.Nat), forall (a : Type), a -> BVVec n (SAWCoreVectorsAsCoqVectors.bvNat n 1) a :=
  fun (n : SAWCoreScaffolding.Nat) (a : Type) (x : a) => repeatBVVec n (SAWCoreVectorsAsCoqVectors.bvNat n 1) a x.

Definition atBVVec : forall (n : SAWCoreScaffolding.Nat), forall (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (a : Type), BVVec n len a -> forall (ix : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), is_bvult n ix len -> a :=
  fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (a : Type) (x : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreVectorsAsCoqVectors.bvToNat n len) a) (ix : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (pf : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvult n ix len) SAWCoreScaffolding.true) => let var__0   := SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool in
  let var__1   := SAWCoreVectorsAsCoqVectors.bvToNat n ix in
  let var__2   := SAWCoreVectorsAsCoqVectors.bvNat n var__1 in
  atWithProof (SAWCoreVectorsAsCoqVectors.bvToNat n len) a x var__1 (bvult_to_IsLtNat n len var__1 (trans SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvult n var__2 len) (SAWCoreVectorsAsCoqVectors.bvult n ix len) SAWCoreScaffolding.true (eq_cong var__0 var__2 ix (bvNat_bvToNat_id n ix) SAWCoreScaffolding.Bool (fun (y : var__0) => SAWCoreVectorsAsCoqVectors.bvult n y len)) pf)).

Axiom at_gen_BVVec : forall (n : SAWCoreScaffolding.Nat), forall (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (a : Type), forall (f : forall (i : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), is_bvult n i len -> a), forall (ix : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (pf : is_bvult n ix len), SAWCoreScaffolding.Eq a (atBVVec n len a (genBVVec n len a f) ix pf) (f ix pf) .

Axiom gen_at_BVVec : forall (n : SAWCoreScaffolding.Nat), forall (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (a : Type), forall (x : BVVec n len a), SAWCoreScaffolding.Eq (BVVec n len a) (genBVVec n len a (atBVVec n len a x)) x .

Definition updBVVec : forall (n : SAWCoreScaffolding.Nat), forall (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (a : Type), BVVec n len a -> forall (ix : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), a -> BVVec n len a :=
  fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (a : Type) (v : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreVectorsAsCoqVectors.bvToNat n len) a) (ix : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (elem : a) => genBVVec n len a (fun (i : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (pf : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvult n i len) SAWCoreScaffolding.true) => if bvEq n i ix then elem else atBVVec n len a v i pf).

Definition adjustBVVec : forall (n : SAWCoreScaffolding.Nat), forall (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (a : Type), BVVec n len a -> (a -> a) -> SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> BVVec n len a :=
  fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (a : Type) (v : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreVectorsAsCoqVectors.bvToNat n len) a) (f : a -> a) (ix : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) => genBVVec n len a (fun (i : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (pf : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvult n i len) SAWCoreScaffolding.true) => let var__0   := atBVVec n len a v i pf in
  if bvEq n i ix then f var__0 else var__0).

Definition takeBVVec : forall (n : SAWCoreScaffolding.Nat), forall (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (a : Type), forall (i : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), is_bvule n i len -> BVVec n len a -> BVVec n i a :=
  fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (a : Type) (i : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (pf : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvule n i len) SAWCoreScaffolding.true) (v : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreVectorsAsCoqVectors.bvToNat n len) a) => genBVVec n i a (fun (j : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (pf2 : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvult n j i) SAWCoreScaffolding.true) => atBVVec n len a v j (trans_bvult_bvule n j i len pf2 pf)).

Definition dropBVVec : forall (n : SAWCoreScaffolding.Nat), forall (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (a : Type), forall (i : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), is_bvule n i len -> BVVec n len a -> BVVec n (SAWCoreVectorsAsCoqVectors.bvSub n len i) a :=
  fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (a : Type) (i : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (pf : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvule n i len) SAWCoreScaffolding.true) (v : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreVectorsAsCoqVectors.bvToNat n len) a) => genBVVec n (SAWCoreVectorsAsCoqVectors.bvSub n len i) a (fun (j : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (pf2 : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvult n j (SAWCoreVectorsAsCoqVectors.bvSub n len i)) SAWCoreScaffolding.true) => atBVVec n len a v (SAWCoreVectorsAsCoqVectors.bvAdd n i j) (bvult_sub_add_bvult n j i len pf pf2)).

Definition sliceBVVec : forall (n : SAWCoreScaffolding.Nat), forall (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (a : Type), forall (start' : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (len' : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), is_bvule n start' len -> is_bvule n len' (SAWCoreVectorsAsCoqVectors.bvSub n len start') -> BVVec n len a -> BVVec n len' a :=
  fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (a : Type) (start' : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (len' : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (pf1 : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvule n start' len) SAWCoreScaffolding.true) (pf2 : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvule n len' (SAWCoreVectorsAsCoqVectors.bvSub n len start')) SAWCoreScaffolding.true) (v : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreVectorsAsCoqVectors.bvToNat n len) a) => takeBVVec n (SAWCoreVectorsAsCoqVectors.bvSub n len start') a len' pf2 (dropBVVec n len a start' pf1 v).

Definition updSliceBVVec : forall (n : SAWCoreScaffolding.Nat), forall (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (a : Type), BVVec n len a -> forall (start' : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (len' : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), BVVec n len' a -> BVVec n len a :=
  fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (a : Type) (v : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreVectorsAsCoqVectors.bvToNat n len) a) (start' : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (len' : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (v_sub : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreVectorsAsCoqVectors.bvToNat n len') a) => genBVVec n len a (fun (i : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (pf : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvult n i len) SAWCoreScaffolding.true) => let var__0   := SAWCoreVectorsAsCoqVectors.bvSub n i start' in
  let var__1   := atBVVec n len a v i pf in
  if SAWCoreVectorsAsCoqVectors.bvule n start' i then maybe (is_bvult n var__0 len') a var__1 (fun (pf_sub : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvult n var__0 len') SAWCoreScaffolding.true) => atBVVec n len' a v_sub (SAWCoreVectorsAsCoqVectors.bvSub n i start') pf_sub) (bvultWithProof n var__0 len') else var__1).

Definition appendBVVec : forall (n : SAWCoreScaffolding.Nat), forall (len1 : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (len2 : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (a : Type), BVVec n len1 a -> BVVec n len2 a -> BVVec n (SAWCoreVectorsAsCoqVectors.bvAdd n len1 len2) a :=
  fun (n : SAWCoreScaffolding.Nat) (len1 : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (len2 : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (a : Type) (v1 : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreVectorsAsCoqVectors.bvToNat n len1) a) (v2 : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreVectorsAsCoqVectors.bvToNat n len2) a) => genBVVec n (SAWCoreVectorsAsCoqVectors.bvAdd n len1 len2) a (fun (i : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (pf12 : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvult n i (SAWCoreVectorsAsCoqVectors.bvAdd n len1 len2)) SAWCoreScaffolding.true) => let var__0   := SAWCoreVectorsAsCoqVectors.bvult n i len1 in
  SAWCoreScaffolding.iteDep (fun (b : SAWCoreScaffolding.Bool) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvult n i len1) b -> a) var__0 (fun (pf1 : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool var__0 SAWCoreScaffolding.true) => atBVVec n len1 a v1 i pf1) (fun (not_pf1 : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool var__0 SAWCoreScaffolding.false) => atBVVec n len2 a v2 (SAWCoreVectorsAsCoqVectors.bvSub n i len1) (bvult_sum_bvult_sub n i len1 len2 pf12 not_pf1)) (SAWCoreScaffolding.Refl SAWCoreScaffolding.Bool var__0)).

Inductive IRTDesc (As : ListSort) : Type :=
| IRT_varD : SAWCoreScaffolding.Nat -> IRTDesc As
| IRT_mu : IRTDesc As -> IRTDesc As
| IRT_Either : IRTDesc As -> IRTDesc As -> IRTDesc As
| IRT_prod : IRTDesc As -> IRTDesc As -> IRTDesc As
| IRT_sigT : forall (i : SAWCoreScaffolding.Nat), (listSortGet As i -> IRTDesc As) -> IRTDesc As
| IRT_BVVec : forall (n : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> forall (D : IRTDesc As), IRTDesc As
| IRT_unit :  IRTDesc As
| IRT_empty :  IRTDesc As
| IRT_varT : forall (i : SAWCoreScaffolding.Nat), IRTDesc As
.

Definition IRTDesc__rec : forall (As : ListSort), forall (P : IRTDesc As -> Type), (forall (i : SAWCoreScaffolding.Nat), P (IRT_varD As i)) -> (forall (D : IRTDesc As), P D -> P (IRT_mu As D)) -> (forall (Dl : IRTDesc As), P Dl -> forall (Dr : IRTDesc As), P Dr -> P (IRT_Either As Dl Dr)) -> (forall (Dl : IRTDesc As), P Dl -> forall (Dr : IRTDesc As), P Dr -> P (IRT_prod As Dl Dr)) -> (forall (i : SAWCoreScaffolding.Nat), forall (Df : listSortGet As i -> IRTDesc As), (forall (a : listSortGet As i), P (Df a)) -> P (IRT_sigT As i Df)) -> (forall (n : SAWCoreScaffolding.Nat), forall (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (D : IRTDesc As), P D -> P (IRT_BVVec As n len D)) -> P (IRT_unit As) -> P (IRT_empty As) -> (forall (i : SAWCoreScaffolding.Nat), P (IRT_varT As i)) -> forall (D : IRTDesc As), P D :=
  fun (As : ListSort) (P : IRTDesc As -> Type) (f1 : forall (i : SAWCoreScaffolding.Nat), P (IRT_varD As i)) (f2 : forall (D : IRTDesc As), P D -> P (IRT_mu As D)) (f3 : forall (Dl : IRTDesc As), P Dl -> forall (Dr : IRTDesc As), P Dr -> P (IRT_Either As Dl Dr)) (f4 : forall (Dl : IRTDesc As), P Dl -> forall (Dr : IRTDesc As), P Dr -> P (IRT_prod As Dl Dr)) (f5 : forall (i : SAWCoreScaffolding.Nat), forall (Df : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i -> IRTDesc As), (forall (a : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i), P (Df a)) -> P (IRT_sigT As i Df)) (f6 : forall (n : SAWCoreScaffolding.Nat), forall (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (D : IRTDesc As), P D -> P (IRT_BVVec As n len D)) (f7 : P (IRT_unit As)) (f8 : P (IRT_empty As)) (f9 : forall (i : SAWCoreScaffolding.Nat), P (IRT_varT As i)) (D : IRTDesc As) => SAWCorePrelude.IRTDesc_rect As P f1 f2 f3 f4 f5 f6 f7 f8 f9 D.

Inductive IRTSubsts (As : ListSort) : Type :=
| IRTs_Nil :  IRTSubsts As
| IRTs_Cons : IRTDesc As -> IRTSubsts As -> IRTSubsts As
.

Definition IRTSubsts__rec : forall (As : ListSort), forall (P : IRTSubsts As -> Type), P (IRTs_Nil As) -> (forall (D : IRTDesc As), forall (Ds : IRTSubsts As), P Ds -> P (IRTs_Cons As D Ds)) -> forall (Ds : IRTSubsts As), P Ds :=
  fun (As : ListSort) (P : IRTSubsts As -> Type) (f1 : P (IRTs_Nil As)) (f2 : forall (D : IRTDesc As), forall (Ds : IRTSubsts As), P Ds -> P (IRTs_Cons As D Ds)) (Ds : IRTSubsts As) => SAWCorePrelude.IRTSubsts_rect As P f1 f2 Ds.

Definition atIRTs : forall (As : ListSort), IRTSubsts As -> SAWCoreScaffolding.Nat -> IRTDesc As :=
  fun (As : ListSort) => IRTSubsts__rec As (fun (_1 : IRTSubsts As) => SAWCoreScaffolding.Nat -> IRTDesc As) (fun (_1 : SAWCoreScaffolding.Nat) => IRT_empty As) (fun (D : IRTDesc As) (_1 : IRTSubsts As) (rec : SAWCoreScaffolding.Nat -> IRTDesc As) => Nat_cases (IRTDesc As) D (fun (n : SAWCoreScaffolding.Nat) (_2 : IRTDesc As) => rec n)).

Definition dropIRTs : forall (As : ListSort), IRTSubsts As -> SAWCoreScaffolding.Nat -> IRTSubsts As :=
  fun (As : ListSort) => IRTSubsts__rec As (fun (_1 : IRTSubsts As) => SAWCoreScaffolding.Nat -> IRTSubsts As) (fun (_1 : SAWCoreScaffolding.Nat) => IRTs_Nil As) (fun (_1 : IRTDesc As) (Ds : IRTSubsts As) (rec : SAWCoreScaffolding.Nat -> IRTSubsts As) => Nat_cases (IRTSubsts As) Ds (fun (n : SAWCoreScaffolding.Nat) (_2 : IRTSubsts As) => rec n)).

Inductive IRT (As : ListSort) : forall (_1 : IRTSubsts As), forall (_2 : IRTDesc As), Type :=
| IRT_elemD : forall (Ds : IRTSubsts As), forall (i : SAWCoreScaffolding.Nat), IRT As (dropIRTs As Ds (SAWCoreScaffolding.Succ i)) (atIRTs As Ds i) -> IRT As Ds (IRT_varD As i)
| IRT_fold : forall (Ds : IRTSubsts As), forall (D : IRTDesc As), IRT As (IRTs_Cons As (IRT_mu As D) Ds) D -> IRT As Ds (IRT_mu As D)
| IRT_Left : forall (Ds : IRTSubsts As), forall (Dl : IRTDesc As), forall (Dr : IRTDesc As), IRT As Ds Dl -> IRT As Ds (IRT_Either As Dl Dr)
| IRT_Right : forall (Ds : IRTSubsts As), forall (Dl : IRTDesc As), forall (Dr : IRTDesc As), IRT As Ds Dr -> IRT As Ds (IRT_Either As Dl Dr)
| IRT_pair : forall (Ds : IRTSubsts As), forall (Dl : IRTDesc As), forall (Dr : IRTDesc As), IRT As Ds Dl -> IRT As Ds Dr -> IRT As Ds (IRT_prod As Dl Dr)
| IRT_existT : forall (Ds : IRTSubsts As), forall (i : SAWCoreScaffolding.Nat), forall (Df : listSortGet As i -> IRTDesc As), forall (a : listSortGet As i), IRT As Ds (Df a) -> IRT As Ds (IRT_sigT As i Df)
| IRT_genBVVec : forall (Ds : IRTSubsts As), forall (n : SAWCoreScaffolding.Nat), forall (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (D : IRTDesc As), (forall (i : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), is_bvult n i len -> IRT As Ds D) -> IRT As Ds (IRT_BVVec As n len D)
| IRT_tt : forall (Ds : IRTSubsts As), IRT As Ds (IRT_unit As)
| IRT_elemT : forall (Ds : IRTSubsts As), forall (i : SAWCoreScaffolding.Nat), listSortGet As i -> IRT As Ds (IRT_varT As i)
.

Definition IRT__rec : forall (As : ListSort), forall (P : forall (Ds : IRTSubsts As), forall (D : IRTDesc As), IRT As Ds D -> Type), (forall (Ds : IRTSubsts As), forall (i : SAWCoreScaffolding.Nat), forall (x : IRT As (dropIRTs As Ds (SAWCoreScaffolding.Succ i)) (atIRTs As Ds i)), P (dropIRTs As Ds (SAWCoreScaffolding.Succ i)) (atIRTs As Ds i) x -> P Ds (IRT_varD As i) (IRT_elemD As Ds i x)) -> (forall (Ds : IRTSubsts As), forall (D : IRTDesc As), forall (x : IRT As (IRTs_Cons As (IRT_mu As D) Ds) D), P (IRTs_Cons As (IRT_mu As D) Ds) D x -> P Ds (IRT_mu As D) (IRT_fold As Ds D x)) -> (forall (Ds : IRTSubsts As), forall (Dl : IRTDesc As), forall (Dr : IRTDesc As), forall (xl : IRT As Ds Dl), P Ds Dl xl -> P Ds (IRT_Either As Dl Dr) (IRT_Left As Ds Dl Dr xl)) -> (forall (Ds : IRTSubsts As), forall (Dl : IRTDesc As), forall (Dr : IRTDesc As), forall (xr : IRT As Ds Dr), P Ds Dr xr -> P Ds (IRT_Either As Dl Dr) (IRT_Right As Ds Dl Dr xr)) -> (forall (Ds : IRTSubsts As), forall (Dl : IRTDesc As), forall (Dr : IRTDesc As), forall (xl : IRT As Ds Dl), P Ds Dl xl -> forall (xr : IRT As Ds Dr), P Ds Dr xr -> P Ds (IRT_prod As Dl Dr) (IRT_pair As Ds Dl Dr xl xr)) -> (forall (Ds : IRTSubsts As), forall (i : SAWCoreScaffolding.Nat), forall (Df : listSortGet As i -> IRTDesc As), forall (a : listSortGet As i), forall (xf : IRT As Ds (Df a)), P Ds (Df a) xf -> P Ds (IRT_sigT As i Df) (IRT_existT As Ds i Df a xf)) -> (forall (Ds : IRTSubsts As), forall (n : SAWCoreScaffolding.Nat), forall (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (D : IRTDesc As), forall (xg : forall (i : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), is_bvult n i len -> IRT As Ds D), (forall (i : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (pf : is_bvult n i len), P Ds D (xg i pf)) -> P Ds (IRT_BVVec As n len D) (IRT_genBVVec As Ds n len D xg)) -> (forall (Ds : IRTSubsts As), P Ds (IRT_unit As) (IRT_tt As Ds)) -> (forall (Ds : IRTSubsts As), forall (i : SAWCoreScaffolding.Nat), forall (a : listSortGet As i), P Ds (IRT_varT As i) (IRT_elemT As Ds i a)) -> forall (Ds : IRTSubsts As), forall (D : IRTDesc As), forall (x : IRT As Ds D), P Ds D x :=
  fun (As : ListSort) (P : forall (Ds : IRTSubsts As), forall (D : IRTDesc As), IRT As Ds D -> Type) (f1 : forall (Ds : IRTSubsts As), forall (i : SAWCoreScaffolding.Nat), forall (x : IRT As (SAWCorePrelude.IRTSubsts_rect As (fun (_1 : IRTSubsts As) => SAWCoreScaffolding.Nat -> IRTSubsts As) (fun (_1 : SAWCoreScaffolding.Nat) => IRTs_Nil As) (fun (_1 : IRTDesc As) (Ds1 : IRTSubsts As) (rec : SAWCoreScaffolding.Nat -> IRTSubsts As) => Nat_cases (IRTSubsts As) Ds1 (fun (n : SAWCoreScaffolding.Nat) (_2 : IRTSubsts As) => rec n)) Ds (SAWCoreScaffolding.Succ i)) (SAWCorePrelude.IRTSubsts_rect As (fun (_1 : IRTSubsts As) => SAWCoreScaffolding.Nat -> IRTDesc As) (fun (_1 : SAWCoreScaffolding.Nat) => IRT_empty As) (fun (D : IRTDesc As) (_1 : IRTSubsts As) (rec : SAWCoreScaffolding.Nat -> IRTDesc As) => Nat_cases (IRTDesc As) D (fun (n : SAWCoreScaffolding.Nat) (_2 : IRTDesc As) => rec n)) Ds i)), P (dropIRTs As Ds (SAWCoreScaffolding.Succ i)) (atIRTs As Ds i) x -> P Ds (IRT_varD As i) (IRT_elemD As Ds i x)) (f2 : forall (Ds : IRTSubsts As), forall (D : IRTDesc As), forall (x : IRT As (IRTs_Cons As (IRT_mu As D) Ds) D), P (IRTs_Cons As (IRT_mu As D) Ds) D x -> P Ds (IRT_mu As D) (IRT_fold As Ds D x)) (f3 : forall (Ds : IRTSubsts As), forall (Dl : IRTDesc As), forall (Dr : IRTDesc As), forall (xl : IRT As Ds Dl), P Ds Dl xl -> P Ds (IRT_Either As Dl Dr) (IRT_Left As Ds Dl Dr xl)) (f4 : forall (Ds : IRTSubsts As), forall (Dl : IRTDesc As), forall (Dr : IRTDesc As), forall (xr : IRT As Ds Dr), P Ds Dr xr -> P Ds (IRT_Either As Dl Dr) (IRT_Right As Ds Dl Dr xr)) (f5 : forall (Ds : IRTSubsts As), forall (Dl : IRTDesc As), forall (Dr : IRTDesc As), forall (xl : IRT As Ds Dl), P Ds Dl xl -> forall (xr : IRT As Ds Dr), P Ds Dr xr -> P Ds (IRT_prod As Dl Dr) (IRT_pair As Ds Dl Dr xl xr)) (f6 : forall (Ds : IRTSubsts As), forall (i : SAWCoreScaffolding.Nat), forall (Df : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i -> IRTDesc As), forall (a : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i), forall (xf : IRT As Ds (Df a)), P Ds (Df a) xf -> P Ds (IRT_sigT As i Df) (IRT_existT As Ds i Df a xf)) (f7 : forall (Ds : IRTSubsts As), forall (n : SAWCoreScaffolding.Nat), forall (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (D : IRTDesc As), forall (xg : forall (i : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvult n i len) SAWCoreScaffolding.true -> IRT As Ds D), (forall (i : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (pf : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvult n i len) SAWCoreScaffolding.true), P Ds D (xg i pf)) -> P Ds (IRT_BVVec As n len D) (IRT_genBVVec As Ds n len D xg)) (f8 : forall (Ds : IRTSubsts As), P Ds (IRT_unit As) (IRT_tt As Ds)) (f9 : forall (Ds : IRTSubsts As), forall (i : SAWCoreScaffolding.Nat), forall (a : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i), P Ds (IRT_varT As i) (IRT_elemT As Ds i a)) (Ds : IRTSubsts As) (D : IRTDesc As) (x : IRT As Ds D) => SAWCorePrelude.IRT_rect As P f1 f2 f3 f4 f5 f6 f7 f8 f9 Ds D x.

Definition UnfoldedIRT : forall (As : ListSort), IRTSubsts As -> IRTDesc As -> Type :=
  fun (As : ListSort) (Ds : IRTSubsts As) (D : IRTDesc As) => let var__0   := IRTDesc As in
  let var__1   := IRTSubsts As in
  IRTDesc__rec As (fun (_1 : var__0) => IRTSubsts As -> Type) (fun (i : SAWCoreScaffolding.Nat) (Ds1 : IRTSubsts As) => IRT As (dropIRTs As Ds1 (SAWCoreScaffolding.Succ i)) (atIRTs As Ds1 i)) (fun (D1 : var__0) (rec : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => rec (IRTs_Cons As (IRT_mu As D1) Ds1)) (fun (_1 : var__0) (recl : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => Either (recl Ds1) (recr Ds1)) (fun (_1 : var__0) (recl : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => prod (recl Ds1) (recr Ds1)) (fun (i : SAWCoreScaffolding.Nat) (_1 : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i -> IRTDesc As) (recf : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i -> IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => @sigT (listSortGet As i) (fun (a : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i) => recf a Ds1)) (fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (_1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => BVVec n len (rec Ds1)) (fun (_1 : var__1) => unit : Type) (fun (_1 : var__1) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (i : SAWCoreScaffolding.Nat) (_1 : IRTSubsts As) => listSortGet As i) D Ds.

Definition unfoldIRT : forall (As : ListSort), forall (Ds : IRTSubsts As), forall (D : IRTDesc As), IRT As Ds D -> UnfoldedIRT As Ds D :=
  fun (As : ListSort) => let var__0   := IRTSubsts As in
  IRT__rec As (fun (Ds : var__0) (D : IRTDesc As) (_1 : IRT As Ds D) => UnfoldedIRT As Ds D) (fun (Ds : var__0) (i : SAWCoreScaffolding.Nat) (x : IRT As (SAWCorePrelude.IRTSubsts_rect As (fun (_1 : IRTSubsts As) => SAWCoreScaffolding.Nat -> IRTSubsts As) (fun (_1 : SAWCoreScaffolding.Nat) => IRTs_Nil As) (fun (_1 : IRTDesc As) (Ds1 : IRTSubsts As) (rec : SAWCoreScaffolding.Nat -> IRTSubsts As) => Nat_cases (IRTSubsts As) Ds1 (fun (n : SAWCoreScaffolding.Nat) (_2 : IRTSubsts As) => rec n)) Ds (SAWCoreScaffolding.Succ i)) (SAWCorePrelude.IRTSubsts_rect As (fun (_1 : IRTSubsts As) => SAWCoreScaffolding.Nat -> IRTDesc As) (fun (_1 : SAWCoreScaffolding.Nat) => IRT_empty As) (fun (D : IRTDesc As) (_1 : IRTSubsts As) (rec : SAWCoreScaffolding.Nat -> IRTDesc As) => Nat_cases (IRTDesc As) D (fun (n : SAWCoreScaffolding.Nat) (_2 : IRTDesc As) => rec n)) Ds i)) (_1 : SAWCorePrelude.IRTDesc_rect As (fun (_1 : IRTDesc As) => IRTSubsts As -> Type) (fun (i1 : SAWCoreScaffolding.Nat) (Ds1 : IRTSubsts As) => IRT As (dropIRTs As Ds1 (SAWCoreScaffolding.Succ i1)) (atIRTs As Ds1 i1)) (fun (D : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => rec (IRTs_Cons As (IRT_mu As D) Ds1)) (fun (_1 : IRTDesc As) (recl : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => Either (recl Ds1) (recr Ds1)) (fun (_1 : IRTDesc As) (recl : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => prod (recl Ds1) (recr Ds1)) (fun (i1 : SAWCoreScaffolding.Nat) (_1 : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i1 -> IRTDesc As) (recf : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i1 -> IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => @sigT (listSortGet As i1) (fun (a : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i1) => recf a Ds1)) (fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (_1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => BVVec n len (rec Ds1)) (fun (_1 : IRTSubsts As) => unit : Type) (fun (_1 : IRTSubsts As) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (i1 : SAWCoreScaffolding.Nat) (_1 : IRTSubsts As) => listSortGet As i1) (SAWCorePrelude.IRTSubsts_rect As (fun (_1 : IRTSubsts As) => SAWCoreScaffolding.Nat -> IRTDesc As) (fun (_1 : SAWCoreScaffolding.Nat) => IRT_empty As) (fun (D : IRTDesc As) (_1 : IRTSubsts As) (rec : SAWCoreScaffolding.Nat -> IRTDesc As) => Nat_cases (IRTDesc As) D (fun (n : SAWCoreScaffolding.Nat) (_2 : IRTDesc As) => rec n)) Ds i) (dropIRTs As Ds (SAWCoreScaffolding.Succ i))) => x) (fun (Ds : var__0) (D : IRTDesc As) (_1 : IRT As (IRTs_Cons As (IRT_mu As D) Ds) D) (rec : SAWCorePrelude.IRTDesc_rect As (fun (_2 : IRTDesc As) => IRTSubsts As -> Type) (fun (i : SAWCoreScaffolding.Nat) (Ds1 : IRTSubsts As) => IRT As (dropIRTs As Ds1 (SAWCoreScaffolding.Succ i)) (atIRTs As Ds1 i)) (fun (D1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => rec (IRTs_Cons As (IRT_mu As D1) Ds1)) (fun (_2 : IRTDesc As) (recl : IRTSubsts As -> Type) (_3 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => Either (recl Ds1) (recr Ds1)) (fun (_2 : IRTDesc As) (recl : IRTSubsts As -> Type) (_3 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => prod (recl Ds1) (recr Ds1)) (fun (i : SAWCoreScaffolding.Nat) (_2 : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i -> IRTDesc As) (recf : SAWCorePrelude.ListSort_rect (fun (_3 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_3 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_3 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_4 : Type) => rec n)) As i -> IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => @sigT (listSortGet As i) (fun (a : SAWCorePrelude.ListSort_rect (fun (_3 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_3 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_3 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_4 : Type) => rec n)) As i) => recf a Ds1)) (fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (_2 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => BVVec n len (rec Ds1)) (fun (_2 : IRTSubsts As) => unit : Type) (fun (_2 : IRTSubsts As) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (i : SAWCoreScaffolding.Nat) (_2 : IRTSubsts As) => listSortGet As i) D (IRTs_Cons As (IRT_mu As D) Ds)) => rec) (fun (Ds : var__0) (Dl : IRTDesc As) (Dr : IRTDesc As) (_1 : IRT As Ds Dl) (recl : SAWCorePrelude.IRTDesc_rect As (fun (_2 : IRTDesc As) => IRTSubsts As -> Type) (fun (i : SAWCoreScaffolding.Nat) (Ds1 : IRTSubsts As) => IRT As (dropIRTs As Ds1 (SAWCoreScaffolding.Succ i)) (atIRTs As Ds1 i)) (fun (D : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => rec (IRTs_Cons As (IRT_mu As D) Ds1)) (fun (_2 : IRTDesc As) (recl : IRTSubsts As -> Type) (_3 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => Either (recl Ds1) (recr Ds1)) (fun (_2 : IRTDesc As) (recl : IRTSubsts As -> Type) (_3 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => prod (recl Ds1) (recr Ds1)) (fun (i : SAWCoreScaffolding.Nat) (_2 : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i -> IRTDesc As) (recf : SAWCorePrelude.ListSort_rect (fun (_3 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_3 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_3 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_4 : Type) => rec n)) As i -> IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => @sigT (listSortGet As i) (fun (a : SAWCorePrelude.ListSort_rect (fun (_3 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_3 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_3 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_4 : Type) => rec n)) As i) => recf a Ds1)) (fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (_2 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => BVVec n len (rec Ds1)) (fun (_2 : IRTSubsts As) => unit : Type) (fun (_2 : IRTSubsts As) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (i : SAWCoreScaffolding.Nat) (_2 : IRTSubsts As) => listSortGet As i) Dl Ds) => Left (UnfoldedIRT As Ds Dl) (UnfoldedIRT As Ds Dr) recl) (fun (Ds : var__0) (Dl : IRTDesc As) (Dr : IRTDesc As) (_1 : IRT As Ds Dr) (recr : SAWCorePrelude.IRTDesc_rect As (fun (_2 : IRTDesc As) => IRTSubsts As -> Type) (fun (i : SAWCoreScaffolding.Nat) (Ds1 : IRTSubsts As) => IRT As (dropIRTs As Ds1 (SAWCoreScaffolding.Succ i)) (atIRTs As Ds1 i)) (fun (D : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => rec (IRTs_Cons As (IRT_mu As D) Ds1)) (fun (_2 : IRTDesc As) (recl : IRTSubsts As -> Type) (_3 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => Either (recl Ds1) (recr Ds1)) (fun (_2 : IRTDesc As) (recl : IRTSubsts As -> Type) (_3 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => prod (recl Ds1) (recr Ds1)) (fun (i : SAWCoreScaffolding.Nat) (_2 : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i -> IRTDesc As) (recf : SAWCorePrelude.ListSort_rect (fun (_3 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_3 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_3 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_4 : Type) => rec n)) As i -> IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => @sigT (listSortGet As i) (fun (a : SAWCorePrelude.ListSort_rect (fun (_3 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_3 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_3 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_4 : Type) => rec n)) As i) => recf a Ds1)) (fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (_2 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => BVVec n len (rec Ds1)) (fun (_2 : IRTSubsts As) => unit : Type) (fun (_2 : IRTSubsts As) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (i : SAWCoreScaffolding.Nat) (_2 : IRTSubsts As) => listSortGet As i) Dr Ds) => Right (UnfoldedIRT As Ds Dl) (UnfoldedIRT As Ds Dr) recr) (fun (Ds : var__0) (Dl : IRTDesc As) (Dr : IRTDesc As) (_1 : IRT As Ds Dl) (recl : SAWCorePrelude.IRTDesc_rect As (fun (_2 : IRTDesc As) => IRTSubsts As -> Type) (fun (i : SAWCoreScaffolding.Nat) (Ds1 : IRTSubsts As) => IRT As (dropIRTs As Ds1 (SAWCoreScaffolding.Succ i)) (atIRTs As Ds1 i)) (fun (D : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => rec (IRTs_Cons As (IRT_mu As D) Ds1)) (fun (_2 : IRTDesc As) (recl : IRTSubsts As -> Type) (_3 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => Either (recl Ds1) (recr Ds1)) (fun (_2 : IRTDesc As) (recl : IRTSubsts As -> Type) (_3 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => prod (recl Ds1) (recr Ds1)) (fun (i : SAWCoreScaffolding.Nat) (_2 : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i -> IRTDesc As) (recf : SAWCorePrelude.ListSort_rect (fun (_3 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_3 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_3 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_4 : Type) => rec n)) As i -> IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => @sigT (listSortGet As i) (fun (a : SAWCorePrelude.ListSort_rect (fun (_3 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_3 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_3 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_4 : Type) => rec n)) As i) => recf a Ds1)) (fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (_2 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => BVVec n len (rec Ds1)) (fun (_2 : IRTSubsts As) => unit : Type) (fun (_2 : IRTSubsts As) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (i : SAWCoreScaffolding.Nat) (_2 : IRTSubsts As) => listSortGet As i) Dl Ds) (_2 : IRT As Ds Dr) (recr : SAWCorePrelude.IRTDesc_rect As (fun (_3 : IRTDesc As) => IRTSubsts As -> Type) (fun (i : SAWCoreScaffolding.Nat) (Ds1 : IRTSubsts As) => IRT As (dropIRTs As Ds1 (SAWCoreScaffolding.Succ i)) (atIRTs As Ds1 i)) (fun (D : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => rec (IRTs_Cons As (IRT_mu As D) Ds1)) (fun (_3 : IRTDesc As) (recl1 : IRTSubsts As -> Type) (_4 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => Either (recl1 Ds1) (recr Ds1)) (fun (_3 : IRTDesc As) (recl1 : IRTSubsts As -> Type) (_4 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => prod (recl1 Ds1) (recr Ds1)) (fun (i : SAWCoreScaffolding.Nat) (_3 : SAWCorePrelude.ListSort_rect (fun (_3 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_3 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_3 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_4 : Type) => rec n)) As i -> IRTDesc As) (recf : SAWCorePrelude.ListSort_rect (fun (_4 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_4 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_4 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_5 : Type) => rec n)) As i -> IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => @sigT (listSortGet As i) (fun (a : SAWCorePrelude.ListSort_rect (fun (_4 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_4 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_4 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_5 : Type) => rec n)) As i) => recf a Ds1)) (fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (_3 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => BVVec n len (rec Ds1)) (fun (_3 : IRTSubsts As) => unit : Type) (fun (_3 : IRTSubsts As) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (i : SAWCoreScaffolding.Nat) (_3 : IRTSubsts As) => listSortGet As i) Dr Ds) => pair recl recr) (fun (Ds : var__0) (i : SAWCoreScaffolding.Nat) (Df : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i -> IRTDesc As) (a : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i) (_1 : IRT As Ds (Df a)) (recf : SAWCorePrelude.IRTDesc_rect As (fun (_2 : IRTDesc As) => IRTSubsts As -> Type) (fun (i1 : SAWCoreScaffolding.Nat) (Ds1 : IRTSubsts As) => IRT As (dropIRTs As Ds1 (SAWCoreScaffolding.Succ i1)) (atIRTs As Ds1 i1)) (fun (D : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => rec (IRTs_Cons As (IRT_mu As D) Ds1)) (fun (_2 : IRTDesc As) (recl : IRTSubsts As -> Type) (_3 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => Either (recl Ds1) (recr Ds1)) (fun (_2 : IRTDesc As) (recl : IRTSubsts As -> Type) (_3 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => prod (recl Ds1) (recr Ds1)) (fun (i1 : SAWCoreScaffolding.Nat) (_2 : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i1 -> IRTDesc As) (recf : SAWCorePrelude.ListSort_rect (fun (_3 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_3 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_3 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_4 : Type) => rec n)) As i1 -> IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => @sigT (listSortGet As i1) (fun (a1 : SAWCorePrelude.ListSort_rect (fun (_3 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_3 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_3 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_4 : Type) => rec n)) As i1) => recf a1 Ds1)) (fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (_2 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => BVVec n len (rec Ds1)) (fun (_2 : IRTSubsts As) => unit : Type) (fun (_2 : IRTSubsts As) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (i1 : SAWCoreScaffolding.Nat) (_2 : IRTSubsts As) => listSortGet As i1) (Df a) Ds) => @existT (listSortGet As i) (fun (a1 : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i) => UnfoldedIRT As Ds (Df a1)) a recf) (fun (Ds : var__0) (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (D : IRTDesc As) (_1 : forall (i : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvult n i len) SAWCoreScaffolding.true -> IRT As Ds D) (recg : forall (i : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvult n i len) SAWCoreScaffolding.true -> let var__1   := IRTDesc As in
  let var__2   := IRTSubsts As in
  SAWCorePrelude.IRTDesc_rect As (fun (_3 : var__1) => IRTSubsts As -> Type) (fun (i1 : SAWCoreScaffolding.Nat) (Ds1 : IRTSubsts As) => IRT As (dropIRTs As Ds1 (SAWCoreScaffolding.Succ i1)) (atIRTs As Ds1 i1)) (fun (D1 : var__1) (rec : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => rec (IRTs_Cons As (IRT_mu As D1) Ds1)) (fun (_3 : var__1) (recl : IRTSubsts As -> Type) (_4 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => Either (recl Ds1) (recr Ds1)) (fun (_3 : var__1) (recl : IRTSubsts As -> Type) (_4 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => prod (recl Ds1) (recr Ds1)) (fun (i1 : SAWCoreScaffolding.Nat) (_3 : SAWCorePrelude.ListSort_rect (fun (_3 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_3 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_3 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n1 : SAWCoreScaffolding.Nat) (_4 : Type) => rec n1)) As i1 -> IRTDesc As) (recf : SAWCorePrelude.ListSort_rect (fun (_4 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_4 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_4 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n1 : SAWCoreScaffolding.Nat) (_5 : Type) => rec n1)) As i1 -> IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => @sigT (listSortGet As i1) (fun (a : SAWCorePrelude.ListSort_rect (fun (_4 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_4 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_4 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n1 : SAWCoreScaffolding.Nat) (_5 : Type) => rec n1)) As i1) => recf a Ds1)) (fun (n1 : SAWCoreScaffolding.Nat) (len1 : SAWCoreVectorsAsCoqVectors.Vec n1 SAWCoreScaffolding.Bool) (_3 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds1 : IRTSubsts As) => BVVec n1 len1 (rec Ds1)) (fun (_3 : var__2) => unit : Type) (fun (_3 : var__2) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (i1 : SAWCoreScaffolding.Nat) (_3 : IRTSubsts As) => listSortGet As i1) D Ds) => genBVVec n len (UnfoldedIRT As Ds D) recg) (fun (Ds : var__0) => tt) (fun (Ds : var__0) (i : SAWCoreScaffolding.Nat) (a : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i) => a).

Definition foldIRT : forall (As : ListSort), forall (Ds : IRTSubsts As), forall (D : IRTDesc As), UnfoldedIRT As Ds D -> IRT As Ds D :=
  fun (As : ListSort) (Ds : IRTSubsts As) (D : IRTDesc As) => let var__0   := IRTDesc As in
  let var__1   := IRTSubsts As in
  IRTDesc__rec As (fun (D1 : var__0) => forall (Ds1 : IRTSubsts As), UnfoldedIRT As Ds1 D1 -> IRT As Ds1 D1) (fun (i : SAWCoreScaffolding.Nat) (Ds1 : IRTSubsts As) (x : IRT As (SAWCorePrelude.IRTSubsts_rect As (fun (_1 : IRTSubsts As) => SAWCoreScaffolding.Nat -> IRTSubsts As) (fun (_1 : SAWCoreScaffolding.Nat) => IRTs_Nil As) (fun (_1 : IRTDesc As) (Ds2 : IRTSubsts As) (rec : SAWCoreScaffolding.Nat -> IRTSubsts As) => Nat_cases (IRTSubsts As) Ds2 (fun (n : SAWCoreScaffolding.Nat) (_2 : IRTSubsts As) => rec n)) Ds1 (SAWCoreScaffolding.Succ i)) (SAWCorePrelude.IRTSubsts_rect As (fun (_1 : IRTSubsts As) => SAWCoreScaffolding.Nat -> IRTDesc As) (fun (_1 : SAWCoreScaffolding.Nat) => IRT_empty As) (fun (D1 : IRTDesc As) (_1 : IRTSubsts As) (rec : SAWCoreScaffolding.Nat -> IRTDesc As) => Nat_cases (IRTDesc As) D1 (fun (n : SAWCoreScaffolding.Nat) (_2 : IRTDesc As) => rec n)) Ds1 i)) => IRT_elemD As Ds1 i x) (fun (D1 : var__0) (rec : forall (Ds1 : IRTSubsts As), SAWCorePrelude.IRTDesc_rect As (fun (_1 : IRTDesc As) => IRTSubsts As -> Type) (fun (i : SAWCoreScaffolding.Nat) (Ds2 : IRTSubsts As) => IRT As (dropIRTs As Ds2 (SAWCoreScaffolding.Succ i)) (atIRTs As Ds2 i)) (fun (D2 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => rec (IRTs_Cons As (IRT_mu As D2) Ds2)) (fun (_1 : IRTDesc As) (recl : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => Either (recl Ds2) (recr Ds2)) (fun (_1 : IRTDesc As) (recl : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => prod (recl Ds2) (recr Ds2)) (fun (i : SAWCoreScaffolding.Nat) (_1 : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i -> IRTDesc As) (recf : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i -> IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => @sigT (listSortGet As i) (fun (a : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i) => recf a Ds2)) (fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (_1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => BVVec n len (rec Ds2)) (fun (_1 : IRTSubsts As) => unit : Type) (fun (_1 : IRTSubsts As) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (i : SAWCoreScaffolding.Nat) (_1 : IRTSubsts As) => listSortGet As i) D1 Ds1 -> IRT As Ds1 D1) (Ds1 : IRTSubsts As) (x : SAWCorePrelude.IRTDesc_rect As (fun (_1 : IRTDesc As) => IRTSubsts As -> Type) (fun (i : SAWCoreScaffolding.Nat) (Ds2 : IRTSubsts As) => IRT As (dropIRTs As Ds2 (SAWCoreScaffolding.Succ i)) (atIRTs As Ds2 i)) (fun (D2 : IRTDesc As) (rec1 : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => rec1 (IRTs_Cons As (IRT_mu As D2) Ds2)) (fun (_1 : IRTDesc As) (recl : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => Either (recl Ds2) (recr Ds2)) (fun (_1 : IRTDesc As) (recl : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => prod (recl Ds2) (recr Ds2)) (fun (i : SAWCoreScaffolding.Nat) (_1 : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec1 : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec1 n)) As i -> IRTDesc As) (recf : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec1 : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec1 n)) As i -> IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => @sigT (listSortGet As i) (fun (a : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec1 : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec1 n)) As i) => recf a Ds2)) (fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (_1 : IRTDesc As) (rec1 : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => BVVec n len (rec1 Ds2)) (fun (_1 : IRTSubsts As) => unit : Type) (fun (_1 : IRTSubsts As) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (i : SAWCoreScaffolding.Nat) (_1 : IRTSubsts As) => listSortGet As i) D1 (IRTs_Cons As (IRT_mu As D1) Ds1)) => IRT_fold As Ds1 D1 (rec (IRTs_Cons As (IRT_mu As D1) Ds1) x)) (fun (Dl : var__0) (recl : forall (Ds1 : IRTSubsts As), SAWCorePrelude.IRTDesc_rect As (fun (_1 : IRTDesc As) => IRTSubsts As -> Type) (fun (i : SAWCoreScaffolding.Nat) (Ds2 : IRTSubsts As) => IRT As (dropIRTs As Ds2 (SAWCoreScaffolding.Succ i)) (atIRTs As Ds2 i)) (fun (D1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => rec (IRTs_Cons As (IRT_mu As D1) Ds2)) (fun (_1 : IRTDesc As) (recl : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => Either (recl Ds2) (recr Ds2)) (fun (_1 : IRTDesc As) (recl : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => prod (recl Ds2) (recr Ds2)) (fun (i : SAWCoreScaffolding.Nat) (_1 : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i -> IRTDesc As) (recf : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i -> IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => @sigT (listSortGet As i) (fun (a : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i) => recf a Ds2)) (fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (_1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => BVVec n len (rec Ds2)) (fun (_1 : IRTSubsts As) => unit : Type) (fun (_1 : IRTSubsts As) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (i : SAWCoreScaffolding.Nat) (_1 : IRTSubsts As) => listSortGet As i) Dl Ds1 -> IRT As Ds1 Dl) (Dr : IRTDesc As) (recr : forall (Ds1 : IRTSubsts As), SAWCorePrelude.IRTDesc_rect As (fun (_1 : IRTDesc As) => IRTSubsts As -> Type) (fun (i : SAWCoreScaffolding.Nat) (Ds2 : IRTSubsts As) => IRT As (dropIRTs As Ds2 (SAWCoreScaffolding.Succ i)) (atIRTs As Ds2 i)) (fun (D1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => rec (IRTs_Cons As (IRT_mu As D1) Ds2)) (fun (_1 : IRTDesc As) (recl1 : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => Either (recl1 Ds2) (recr Ds2)) (fun (_1 : IRTDesc As) (recl1 : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => prod (recl1 Ds2) (recr Ds2)) (fun (i : SAWCoreScaffolding.Nat) (_1 : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i -> IRTDesc As) (recf : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i -> IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => @sigT (listSortGet As i) (fun (a : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i) => recf a Ds2)) (fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (_1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => BVVec n len (rec Ds2)) (fun (_1 : IRTSubsts As) => unit : Type) (fun (_1 : IRTSubsts As) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (i : SAWCoreScaffolding.Nat) (_1 : IRTSubsts As) => listSortGet As i) Dr Ds1 -> IRT As Ds1 Dr) (Ds1 : IRTSubsts As) (x : Either (SAWCorePrelude.IRTDesc_rect As (fun (_1 : IRTDesc As) => IRTSubsts As -> Type) (fun (i : SAWCoreScaffolding.Nat) (Ds2 : IRTSubsts As) => IRT As (dropIRTs As Ds2 (SAWCoreScaffolding.Succ i)) (atIRTs As Ds2 i)) (fun (D1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => rec (IRTs_Cons As (IRT_mu As D1) Ds2)) (fun (_1 : IRTDesc As) (recl1 : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr1 : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => Either (recl1 Ds2) (recr1 Ds2)) (fun (_1 : IRTDesc As) (recl1 : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr1 : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => prod (recl1 Ds2) (recr1 Ds2)) (fun (i : SAWCoreScaffolding.Nat) (_1 : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i -> IRTDesc As) (recf : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i -> IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => @sigT (listSortGet As i) (fun (a : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i) => recf a Ds2)) (fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (_1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => BVVec n len (rec Ds2)) (fun (_1 : IRTSubsts As) => unit : Type) (fun (_1 : IRTSubsts As) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (i : SAWCoreScaffolding.Nat) (_1 : IRTSubsts As) => listSortGet As i) Dl Ds1) (SAWCorePrelude.IRTDesc_rect As (fun (_1 : IRTDesc As) => IRTSubsts As -> Type) (fun (i : SAWCoreScaffolding.Nat) (Ds2 : IRTSubsts As) => IRT As (dropIRTs As Ds2 (SAWCoreScaffolding.Succ i)) (atIRTs As Ds2 i)) (fun (D1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => rec (IRTs_Cons As (IRT_mu As D1) Ds2)) (fun (_1 : IRTDesc As) (recl1 : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr1 : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => Either (recl1 Ds2) (recr1 Ds2)) (fun (_1 : IRTDesc As) (recl1 : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr1 : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => prod (recl1 Ds2) (recr1 Ds2)) (fun (i : SAWCoreScaffolding.Nat) (_1 : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i -> IRTDesc As) (recf : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i -> IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => @sigT (listSortGet As i) (fun (a : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i) => recf a Ds2)) (fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (_1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => BVVec n len (rec Ds2)) (fun (_1 : IRTSubsts As) => unit : Type) (fun (_1 : IRTSubsts As) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (i : SAWCoreScaffolding.Nat) (_1 : IRTSubsts As) => listSortGet As i) Dr Ds1)) => let var__2   := IRTDesc As in
  let var__3   := IRTSubsts As in
  let var__4   := SAWCorePrelude.IRTDesc_rect As (fun (_1 : var__2) => IRTSubsts As -> Type) (fun (i : SAWCoreScaffolding.Nat) (Ds2 : IRTSubsts As) => IRT As (dropIRTs As Ds2 (SAWCoreScaffolding.Succ i)) (atIRTs As Ds2 i)) (fun (D1 : var__2) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => rec (IRTs_Cons As (IRT_mu As D1) Ds2)) (fun (_1 : var__2) (recl1 : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr1 : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => Either (recl1 Ds2) (recr1 Ds2)) (fun (_1 : var__2) (recl1 : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr1 : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => prod (recl1 Ds2) (recr1 Ds2)) (fun (i : SAWCoreScaffolding.Nat) (_1 : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i -> IRTDesc As) (recf : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i -> IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => @sigT (listSortGet As i) (fun (a : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i) => recf a Ds2)) (fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (_1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => BVVec n len (rec Ds2)) (fun (_1 : var__3) => unit : Type) (fun (_1 : var__3) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (i : SAWCoreScaffolding.Nat) (_1 : IRTSubsts As) => listSortGet As i) in
  either (UnfoldedIRT As Ds1 Dl) (UnfoldedIRT As Ds1 Dr) (IRT As Ds1 (IRT_Either As Dl Dr)) (fun (xl : var__4 Dl Ds1) => IRT_Left As Ds1 Dl Dr (recl Ds1 xl)) (fun (xr : var__4 Dr Ds1) => IRT_Right As Ds1 Dl Dr (recr Ds1 xr)) x) (fun (Dl : var__0) (recl : forall (Ds1 : IRTSubsts As), SAWCorePrelude.IRTDesc_rect As (fun (_1 : IRTDesc As) => IRTSubsts As -> Type) (fun (i : SAWCoreScaffolding.Nat) (Ds2 : IRTSubsts As) => IRT As (dropIRTs As Ds2 (SAWCoreScaffolding.Succ i)) (atIRTs As Ds2 i)) (fun (D1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => rec (IRTs_Cons As (IRT_mu As D1) Ds2)) (fun (_1 : IRTDesc As) (recl : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => Either (recl Ds2) (recr Ds2)) (fun (_1 : IRTDesc As) (recl : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => prod (recl Ds2) (recr Ds2)) (fun (i : SAWCoreScaffolding.Nat) (_1 : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i -> IRTDesc As) (recf : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i -> IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => @sigT (listSortGet As i) (fun (a : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i) => recf a Ds2)) (fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (_1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => BVVec n len (rec Ds2)) (fun (_1 : IRTSubsts As) => unit : Type) (fun (_1 : IRTSubsts As) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (i : SAWCoreScaffolding.Nat) (_1 : IRTSubsts As) => listSortGet As i) Dl Ds1 -> IRT As Ds1 Dl) (Dr : IRTDesc As) (recr : forall (Ds1 : IRTSubsts As), SAWCorePrelude.IRTDesc_rect As (fun (_1 : IRTDesc As) => IRTSubsts As -> Type) (fun (i : SAWCoreScaffolding.Nat) (Ds2 : IRTSubsts As) => IRT As (dropIRTs As Ds2 (SAWCoreScaffolding.Succ i)) (atIRTs As Ds2 i)) (fun (D1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => rec (IRTs_Cons As (IRT_mu As D1) Ds2)) (fun (_1 : IRTDesc As) (recl1 : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => Either (recl1 Ds2) (recr Ds2)) (fun (_1 : IRTDesc As) (recl1 : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => prod (recl1 Ds2) (recr Ds2)) (fun (i : SAWCoreScaffolding.Nat) (_1 : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i -> IRTDesc As) (recf : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i -> IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => @sigT (listSortGet As i) (fun (a : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i) => recf a Ds2)) (fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (_1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => BVVec n len (rec Ds2)) (fun (_1 : IRTSubsts As) => unit : Type) (fun (_1 : IRTSubsts As) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (i : SAWCoreScaffolding.Nat) (_1 : IRTSubsts As) => listSortGet As i) Dr Ds1 -> IRT As Ds1 Dr) (Ds1 : IRTSubsts As) (x : prod (SAWCorePrelude.IRTDesc_rect As (fun (_1 : IRTDesc As) => IRTSubsts As -> Type) (fun (i : SAWCoreScaffolding.Nat) (Ds2 : IRTSubsts As) => IRT As (dropIRTs As Ds2 (SAWCoreScaffolding.Succ i)) (atIRTs As Ds2 i)) (fun (D1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => rec (IRTs_Cons As (IRT_mu As D1) Ds2)) (fun (_1 : IRTDesc As) (recl1 : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr1 : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => Either (recl1 Ds2) (recr1 Ds2)) (fun (_1 : IRTDesc As) (recl1 : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr1 : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => prod (recl1 Ds2) (recr1 Ds2)) (fun (i : SAWCoreScaffolding.Nat) (_1 : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i -> IRTDesc As) (recf : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i -> IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => @sigT (listSortGet As i) (fun (a : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i) => recf a Ds2)) (fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (_1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => BVVec n len (rec Ds2)) (fun (_1 : IRTSubsts As) => unit : Type) (fun (_1 : IRTSubsts As) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (i : SAWCoreScaffolding.Nat) (_1 : IRTSubsts As) => listSortGet As i) Dl Ds1) (SAWCorePrelude.IRTDesc_rect As (fun (_1 : IRTDesc As) => IRTSubsts As -> Type) (fun (i : SAWCoreScaffolding.Nat) (Ds2 : IRTSubsts As) => IRT As (dropIRTs As Ds2 (SAWCoreScaffolding.Succ i)) (atIRTs As Ds2 i)) (fun (D1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => rec (IRTs_Cons As (IRT_mu As D1) Ds2)) (fun (_1 : IRTDesc As) (recl1 : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr1 : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => Either (recl1 Ds2) (recr1 Ds2)) (fun (_1 : IRTDesc As) (recl1 : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr1 : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => prod (recl1 Ds2) (recr1 Ds2)) (fun (i : SAWCoreScaffolding.Nat) (_1 : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i -> IRTDesc As) (recf : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i -> IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => @sigT (listSortGet As i) (fun (a : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i) => recf a Ds2)) (fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (_1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => BVVec n len (rec Ds2)) (fun (_1 : IRTSubsts As) => unit : Type) (fun (_1 : IRTSubsts As) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (i : SAWCoreScaffolding.Nat) (_1 : IRTSubsts As) => listSortGet As i) Dr Ds1)) => let var__2   := IRTDesc As in
  let var__3   := IRTSubsts As in
  uncurry (UnfoldedIRT As Ds1 Dl) (UnfoldedIRT As Ds1 Dr) (IRT As Ds1 (IRT_prod As Dl Dr)) (fun (xl : SAWCorePrelude.IRTDesc_rect As (fun (_1 : var__2) => IRTSubsts As -> Type) (fun (i : SAWCoreScaffolding.Nat) (Ds2 : IRTSubsts As) => IRT As (dropIRTs As Ds2 (SAWCoreScaffolding.Succ i)) (atIRTs As Ds2 i)) (fun (D1 : var__2) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => rec (IRTs_Cons As (IRT_mu As D1) Ds2)) (fun (_1 : var__2) (recl1 : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr1 : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => Either (recl1 Ds2) (recr1 Ds2)) (fun (_1 : var__2) (recl1 : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr1 : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => prod (recl1 Ds2) (recr1 Ds2)) (fun (i : SAWCoreScaffolding.Nat) (_1 : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i -> IRTDesc As) (recf : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i -> IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => @sigT (listSortGet As i) (fun (a : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i) => recf a Ds2)) (fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (_1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => BVVec n len (rec Ds2)) (fun (_1 : var__3) => unit : Type) (fun (_1 : var__3) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (i : SAWCoreScaffolding.Nat) (_1 : IRTSubsts As) => listSortGet As i) Dl Ds1) (xr : SAWCorePrelude.IRTDesc_rect As (fun (_1 : IRTDesc As) => IRTSubsts As -> Type) (fun (i : SAWCoreScaffolding.Nat) (Ds2 : IRTSubsts As) => IRT As (dropIRTs As Ds2 (SAWCoreScaffolding.Succ i)) (atIRTs As Ds2 i)) (fun (D1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => rec (IRTs_Cons As (IRT_mu As D1) Ds2)) (fun (_1 : IRTDesc As) (recl1 : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr1 : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => Either (recl1 Ds2) (recr1 Ds2)) (fun (_1 : IRTDesc As) (recl1 : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr1 : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => prod (recl1 Ds2) (recr1 Ds2)) (fun (i : SAWCoreScaffolding.Nat) (_1 : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i -> IRTDesc As) (recf : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i -> IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => @sigT (listSortGet As i) (fun (a : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i) => recf a Ds2)) (fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (_1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => BVVec n len (rec Ds2)) (fun (_1 : IRTSubsts As) => unit : Type) (fun (_1 : IRTSubsts As) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (i : SAWCoreScaffolding.Nat) (_1 : IRTSubsts As) => listSortGet As i) Dr Ds1) => IRT_pair As Ds1 Dl Dr (recl Ds1 xl) (recr Ds1 xr)) x) (fun (i : SAWCoreScaffolding.Nat) (Df : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i -> IRTDesc As) (recf : forall (a : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i), forall (Ds1 : IRTSubsts As), SAWCorePrelude.IRTDesc_rect As (fun (_1 : IRTDesc As) => IRTSubsts As -> Type) (fun (i1 : SAWCoreScaffolding.Nat) (Ds2 : IRTSubsts As) => IRT As (dropIRTs As Ds2 (SAWCoreScaffolding.Succ i1)) (atIRTs As Ds2 i1)) (fun (D1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => rec (IRTs_Cons As (IRT_mu As D1) Ds2)) (fun (_1 : IRTDesc As) (recl : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => Either (recl Ds2) (recr Ds2)) (fun (_1 : IRTDesc As) (recl : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => prod (recl Ds2) (recr Ds2)) (fun (i1 : SAWCoreScaffolding.Nat) (_1 : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i1 -> IRTDesc As) (recf : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i1 -> IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => @sigT (listSortGet As i1) (fun (a1 : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i1) => recf a1 Ds2)) (fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (_1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => BVVec n len (rec Ds2)) (fun (_1 : IRTSubsts As) => unit : Type) (fun (_1 : IRTSubsts As) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (i1 : SAWCoreScaffolding.Nat) (_1 : IRTSubsts As) => listSortGet As i1) (Df a) Ds1 -> IRT As Ds1 (Df a)) (Ds1 : IRTSubsts As) (x : @sigT (SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i) (fun (a : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i) => UnfoldedIRT As Ds1 (Df a))) => let var__2   := SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i in
  uncurrySigma (listSortGet As i) (fun (a : var__2) => UnfoldedIRT As Ds1 (Df a)) (IRT As Ds1 (IRT_sigT As i Df)) (fun (a : var__2) (xf : SAWCorePrelude.IRTDesc_rect As (fun (_1 : IRTDesc As) => IRTSubsts As -> Type) (fun (i1 : SAWCoreScaffolding.Nat) (Ds2 : IRTSubsts As) => IRT As (dropIRTs As Ds2 (SAWCoreScaffolding.Succ i1)) (atIRTs As Ds2 i1)) (fun (D1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => rec (IRTs_Cons As (IRT_mu As D1) Ds2)) (fun (_1 : IRTDesc As) (recl : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => Either (recl Ds2) (recr Ds2)) (fun (_1 : IRTDesc As) (recl : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => prod (recl Ds2) (recr Ds2)) (fun (i1 : SAWCoreScaffolding.Nat) (_1 : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i1 -> IRTDesc As) (recf1 : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i1 -> IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => @sigT (listSortGet As i1) (fun (a1 : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_3 : Type) => rec n)) As i1) => recf1 a1 Ds2)) (fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (_1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => BVVec n len (rec Ds2)) (fun (_1 : IRTSubsts As) => unit : Type) (fun (_1 : IRTSubsts As) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (i1 : SAWCoreScaffolding.Nat) (_1 : IRTSubsts As) => listSortGet As i1) (Df a) Ds1) => IRT_existT As Ds1 i Df a (recf a Ds1 xf)) x) (fun (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (D1 : IRTDesc As) (recg : forall (Ds1 : IRTSubsts As), SAWCorePrelude.IRTDesc_rect As (fun (_1 : IRTDesc As) => IRTSubsts As -> Type) (fun (i : SAWCoreScaffolding.Nat) (Ds2 : IRTSubsts As) => IRT As (dropIRTs As Ds2 (SAWCoreScaffolding.Succ i)) (atIRTs As Ds2 i)) (fun (D2 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => rec (IRTs_Cons As (IRT_mu As D2) Ds2)) (fun (_1 : IRTDesc As) (recl : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => Either (recl Ds2) (recr Ds2)) (fun (_1 : IRTDesc As) (recl : IRTSubsts As -> Type) (_2 : IRTDesc As) (recr : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => prod (recl Ds2) (recr Ds2)) (fun (i : SAWCoreScaffolding.Nat) (_1 : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n1 : SAWCoreScaffolding.Nat) (_2 : Type) => rec n1)) As i -> IRTDesc As) (recf : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n1 : SAWCoreScaffolding.Nat) (_3 : Type) => rec n1)) As i -> IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => @sigT (listSortGet As i) (fun (a : SAWCorePrelude.ListSort_rect (fun (_2 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_2 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_2 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n1 : SAWCoreScaffolding.Nat) (_3 : Type) => rec n1)) As i) => recf a Ds2)) (fun (n1 : SAWCoreScaffolding.Nat) (len1 : SAWCoreVectorsAsCoqVectors.Vec n1 SAWCoreScaffolding.Bool) (_1 : IRTDesc As) (rec : IRTSubsts As -> Type) (Ds2 : IRTSubsts As) => BVVec n1 len1 (rec Ds2)) (fun (_1 : IRTSubsts As) => unit : Type) (fun (_1 : IRTSubsts As) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (i : SAWCoreScaffolding.Nat) (_1 : IRTSubsts As) => listSortGet As i) D1 Ds1 -> IRT As Ds1 D1) (Ds1 : IRTSubsts As) (x : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreVectorsAsCoqVectors.bvToNat n len) (UnfoldedIRT As Ds1 D1)) => IRT_genBVVec As Ds1 n len D1 (fun (i : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (pf : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool (SAWCoreVectorsAsCoqVectors.bvult n i len) SAWCoreScaffolding.true) => recg Ds1 (atBVVec n len (UnfoldedIRT As Ds1 D1) x i pf))) (fun (Ds1 : var__1) (x : unit : Type) => IRT_tt As Ds1) (fun (Ds1 : var__1) (x : SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) => efq (IRT As Ds1 (IRT_empty As)) x) (fun (i : SAWCoreScaffolding.Nat) (Ds1 : IRTSubsts As) (x : SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => SAWCoreScaffolding.Nat -> Type) (fun (_1 : SAWCoreScaffolding.Nat) => SAWCoreScaffolding.Eq SAWCoreScaffolding.Bool SAWCoreScaffolding.true SAWCoreScaffolding.false) (fun (A : Type) (_1 : ListSort) (rec : SAWCoreScaffolding.Nat -> Type) => Nat_cases Type A (fun (n : SAWCoreScaffolding.Nat) (_2 : Type) => rec n)) As i) => IRT_elemT As Ds1 i x) D Ds.

(* Prelude.CompM was skipped *)

(* Prelude.returnM was skipped *)

(* Prelude.bindM was skipped *)

(* Prelude.existsM was skipped *)

(* Prelude.errorM was skipped *)

Definition fmapM : forall (a : Type), forall (b : Type), (a -> b) -> CompM a -> CompM b :=
  fun (a : Type) (b : Type) (f : a -> b) (m : CompM a) => @bindM CompM _ a b m (fun (x : a) => @returnM CompM _ b (f x)).

Definition applyM : forall (a : Type), forall (b : Type), CompM (a -> b) -> CompM a -> CompM b :=
  fun (a : Type) (b : Type) (f : CompM (a -> b)) (m : CompM a) => let var__0   := a -> b in
  @bindM CompM _ var__0 b f (fun (f1 : var__0) => @bindM CompM _ a b m (fun (x : a) => @returnM CompM _ b (f1 x))).

Definition fmapM2 : forall (a : Type), forall (b : Type), forall (c : Type), (a -> b -> c) -> CompM a -> CompM b -> CompM c :=
  fun (a : Type) (b : Type) (c : Type) (f : a -> b -> c) (m1 : CompM a) (m2 : CompM b) => applyM b c (fmapM a (b -> c) f m1) m2.

Definition fmapM3 : forall (a : Type), forall (b : Type), forall (c : Type), forall (d : Type), (a -> b -> c -> d) -> CompM a -> CompM b -> CompM c -> CompM d :=
  fun (a : Type) (b : Type) (c : Type) (d : Type) (f : a -> b -> c -> d) (m1 : CompM a) (m2 : CompM b) (m3 : CompM c) => applyM c d (fmapM2 a b (c -> d) f m1 m2) m3.

Definition composeM : forall (a : Type), forall (b : Type), forall (c : Type), (a -> CompM b) -> (b -> CompM c) -> a -> CompM c :=
  fun (a : Type) (b : Type) (c : Type) (f : a -> CompM b) (g : b -> CompM c) (x : a) => @bindM CompM _ b c (f x) g.

Definition tupleCompMFunBoth : forall (a : Type), forall (b : Type), forall (c : Type), (a -> CompM b) -> prod c a -> CompM (prod c b) :=
  fun (a : Type) (b : Type) (c : Type) (f : a -> CompM b) (x : prod c a) => @bindM CompM _ b (prod c b) (f (SAWCoreScaffolding.snd x)) (fun (y : b) => @returnM CompM _ (prod c b) (pair (SAWCoreScaffolding.fst x) y)).

Definition tupleCompMFunOut : forall (a : Type), forall (b : Type), forall (c : Type), c -> (a -> CompM b) -> a -> CompM (prod c b) :=
  fun (a : Type) (b : Type) (c : Type) (x : c) (f : a -> CompM b) (y : a) => @bindM CompM _ b (prod c b) (f y) (fun (z : b) => @returnM CompM _ (prod c b) (pair x z)).

Definition mapM : forall (a : Type), forall (b : Type), forall {Inh_b : SAWCoreScaffolding.Inhabited b}, (a -> CompM b) -> forall (n : SAWCoreScaffolding.Nat), SAWCoreVectorsAsCoqVectors.Vec n a -> CompM (SAWCoreVectorsAsCoqVectors.Vec n b) :=
  fun (a : Type) (b : Type) {Inh_b : SAWCoreScaffolding.Inhabited b} (f : a -> CompM b) => Nat__rec (fun (n : SAWCoreScaffolding.Nat) => SAWCoreVectorsAsCoqVectors.Vec n a -> CompM (SAWCoreVectorsAsCoqVectors.Vec n b)) (fun (_1 : SAWCoreVectorsAsCoqVectors.Vec 0 a) => @returnM CompM _ (SAWCoreVectorsAsCoqVectors.Vec 0 b) (SAWCoreVectorsAsCoqVectors.EmptyVec b)) (fun (n : SAWCoreScaffolding.Nat) (rec_f : SAWCoreVectorsAsCoqVectors.Vec n a -> CompM (SAWCoreVectorsAsCoqVectors.Vec n b)) (v : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) a) => fmapM2 b (SAWCoreVectorsAsCoqVectors.Vec n b) (SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) b) (fun (hd : b) (tl : SAWCoreVectorsAsCoqVectors.Vec n b) => ConsVec b hd n tl) (f (head n a v)) (rec_f (tail n a v))).

Definition mapBVVecM : forall (a : Type), forall (b : Type), forall {Inh_b : SAWCoreScaffolding.Inhabited b}, (a -> CompM b) -> forall (n : SAWCoreScaffolding.Nat), forall (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), BVVec n len a -> CompM (BVVec n len b) :=
  fun (a : Type) (b : Type) {Inh_b : SAWCoreScaffolding.Inhabited b} (f : a -> CompM b) (n : SAWCoreScaffolding.Nat) (len : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) => mapM a b f (SAWCoreVectorsAsCoqVectors.bvToNat n len).

Definition appendCastBVVecM : forall (n : SAWCoreScaffolding.Nat), forall (len1 : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (len2 : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (len3 : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool), forall (a : Type), BVVec n len1 a -> BVVec n len2 a -> CompM (BVVec n len3 a) :=
  fun (n : SAWCoreScaffolding.Nat) (len1 : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (len2 : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (len3 : SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) (a : Type) (v1 : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreVectorsAsCoqVectors.bvToNat n len1) a) (v2 : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreVectorsAsCoqVectors.bvToNat n len2) a) => let var__0   := SAWCoreVectorsAsCoqVectors.bvAdd n len1 len2 in
  let var__1   := BVVec n len3 a in
  let var__2   := SAWCoreScaffolding.Eq (SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) var__0 len3 in
  maybe var__2 (CompM var__1) (@errorM CompM _ var__1 "Could not cast BVVec"%string) (fun (pf : var__2) => let var__3   := SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool in
  let var__4   := SAWCoreVectorsAsCoqVectors.bvAdd n len1 len2 in
  let var__5   := BVVec n len3 a in
  @returnM CompM _ var__5 (SAWCoreScaffolding.coerce (BVVec n var__4 a) var__5 (eq_cong var__3 var__4 len3 pf Type (fun (l : var__3) => BVVec n l a)) (appendBVVec n len1 len2 a v1 v2))) (bvEqWithProof n var__0 len3).

(* Prelude.fixM was skipped *)

(* Prelude.LetRecType was skipped *)

(* Prelude.lrtToType was skipped *)

(* Prelude.LetRecTypes was skipped *)

(* Prelude.lrtPi was skipped *)

(* Prelude.lrtTupleType was skipped *)

(* Prelude.multiFixM was skipped *)

(* Prelude.letRecM was skipped *)

Definition letRecM1 : forall (a : Type), forall (b : Type), forall (c : Type), ((a -> CompM b) -> a -> CompM b) -> ((a -> CompM b) -> CompM c) -> CompM c :=
  fun (a : Type) (b : Type) (c : Type) (fn : (a -> CompM b) -> a -> CompM b) (body : (a -> CompM b) -> CompM c) => let var__0   := a -> CompM b in
  @CompM.letRecM (CompM.LRT_Cons (CompM.LRT_Fun a (fun (_1 : a) => CompM.LRT_Ret b)) CompM.LRT_Nil) c (fun (f : var__0) => pair (fn f) tt) (fun (f : var__0) => body f).

(* Prelude.test_fun0 was skipped *)

(* Prelude.test_fun1 was skipped *)

(* Prelude.test_fun2 was skipped *)

(* Prelude.test_fun3 was skipped *)

(* Prelude.test_fun4 was skipped *)

(* Prelude.test_fun5 was skipped *)

(* Prelude.test_fun6 was skipped *)

Axiom Array : Type -> Type -> Type .

Axiom arrayConstant : forall (a : Type), forall (b : Type), b -> Array a b .

Axiom arrayLookup : forall (a : Type), forall (b : Type), Array a b -> a -> b .

Axiom arrayUpdate : forall (a : Type), forall (b : Type), Array a b -> a -> b -> Array a b .

Axiom arrayCopy : forall (n : SAWCoreScaffolding.Nat), forall (a : Type), Array (SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) a -> SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> Array (SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) a -> SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> Array (SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) a .

Axiom arraySet : forall (n : SAWCoreScaffolding.Nat), forall (a : Type), Array (SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) a -> SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> a -> SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> Array (SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) a .

Axiom arrayRangeEq : forall (n : SAWCoreScaffolding.Nat), forall (a : Type), Array (SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) a -> SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> Array (SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool) a -> SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> SAWCoreVectorsAsCoqVectors.Vec n SAWCoreScaffolding.Bool -> SAWCoreScaffolding.Bool .

Axiom arrayEq : forall (a : Type), forall (b : Type), Array a b -> Array a b -> SAWCoreScaffolding.Bool .

(* Prelude.bveq_sameL was skipped *)

(* Prelude.bveq_sameR was skipped *)

(* Prelude.bveq_same2 was skipped *)

(* Prelude.bvNat_bvToNat was skipped *)

(* Prelude.ite_split_cong was skipped *)

(* Prelude.ite_join_cong was skipped *)

(* Prelude.map_map was skipped *)

End SAWCorePrelude.
